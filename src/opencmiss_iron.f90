!> \file
!> \author Chris Bradley
!> \brief The top level OpenCMISS Iron module.
!>
!> \mainpage OpenCMISS Iron Documentation
!>
!> An open source interactive computer program for Continuum Mechanics, Image analysis, Signal processing and System
!> Identification. Target usage: Bioengineering application of finite element analysis, boundary element and collocation
!> techniques.
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand, the University of Oxford, Oxford, United
!> Kingdom and King's College, London, United Kingdom. Portions created
!> by the University of Auckland, the University of Oxford and King's
!> College, London are Copyright (C) 2007-2010 by the University of
!> Auckland, the University of Oxford and King's College, London.
!> All Rights Reserved.
!>
!> Contributor(s):
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>
!>
!> The top level OpenCMISS Iron module. This module is the buffer Fortran module between the OpenCMISS Iron library and user code.
MODULE OpenCMISS_Iron

  USE ANALYTIC_ANALYSIS_ROUTINES
  USE BASE_ROUTINES
  USE BASIS_ROUTINES
  USE BIOELECTRIC_FINITE_ELASTICITY_ROUTINES
  USE BOUNDARY_CONDITIONS_ROUTINES
  USE Cmiss
  USE CMISS_CELLML
  USE COMP_ENVIRONMENT
  USE CONSTANTS
  USE CONTROL_LOOP_ROUTINES
  USE COORDINATE_ROUTINES
  USE DATA_POINT_ROUTINES
  USE DATA_PROJECTION_ROUTINES
  USE DISTRIBUTED_MATRIX_VECTOR
  USE EQUATIONS_ROUTINES
  USE EQUATIONS_SET_CONSTANTS
  USE EQUATIONS_SET_ROUTINES
  USE FIELD_ROUTINES
#ifdef USEFIELDML
  USE FIELDML_TYPES
  USE FIELDML_INPUT_ROUTINES
  USE FIELDML_OUTPUT_ROUTINES
  USE FIELDML_UTIL_ROUTINES
#endif
  USE FIELD_IO_ROUTINES
  USE FINITE_ELASTICITY_ROUTINES
  USE GENERATED_MESH_ROUTINES
  USE HAMILTON_JACOBI_EQUATIONS_ROUTINES
  USE HISTORY_ROUTINES
  USE INPUT_OUTPUT
  USE INTERFACE_ROUTINES
  USE INTERFACE_CONDITIONS_CONSTANTS
  USE INTERFACE_CONDITIONS_ROUTINES
  USE INTERFACE_EQUATIONS_ROUTINES
  USE INTERFACE_MATRICES_CONSTANTS
  USE INTERFACE_MATRICES_ROUTINES
  USE ISO_C_BINDING
  USE ISO_VARYING_STRING
  USE KINDS
  USE MESH_ROUTINES
  USE NODE_ROUTINES
  USE PROBLEM_CONSTANTS
  USE PROBLEM_ROUTINES
  USE REGION_ROUTINES
  USE SOLVER_ROUTINES
  USE STRINGS
  USE TYPES

#include "macros.h"  

  IMPLICIT NONE

  PRIVATE

  !Module parameters

  !Module types

  !>Contains information about a basis function.
  TYPE cmfe_BasisType
    PRIVATE
    TYPE(BASIS_TYPE), POINTER :: basis
  END TYPE cmfe_BasisType

  !>Contains information on the boundary conditions for the equations set.
  TYPE cmfe_BoundaryConditionsType
    PRIVATE
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: boundaryConditions
  END TYPE cmfe_BoundaryConditionsType

  !>Contains information on a CellML environment.
  TYPE cmfe_CellMLType
    PRIVATE
    TYPE(CELLML_TYPE), POINTER :: cellml
  END TYPE cmfe_CellMLType

  !>Contains information about the CellML equations for a solver.
  TYPE cmfe_CellMLEquationsType
    PRIVATE
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: cellmlEquations
  END TYPE cmfe_CellMLEquationsType

  !>Contains information on a control loop.
  TYPE cmfe_ControlLoopType
    PRIVATE
    TYPE(CONTROL_LOOP_TYPE), POINTER :: controlLoop
  END TYPE cmfe_ControlLoopType

  !>Contains information on a coordinate system.
  TYPE cmfe_CoordinateSystemType
    PRIVATE
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: coordinateSystem
  END TYPE cmfe_CoordinateSystemType

  !>Contains information on the data points defined on a region.
  TYPE cmfe_DataPointsType
    PRIVATE
    TYPE(DATA_POINTS_TYPE), POINTER :: dataPoints
  END TYPE cmfe_DataPointsType

  !>Contains information about a data projection.
  TYPE cmfe_DataProjectionType
    PRIVATE
    TYPE(DATA_PROJECTION_TYPE), POINTER :: dataProjection
  END TYPE cmfe_DataProjectionType

  !>Contains information on the mesh decomposition.
  TYPE cmfe_DecompositionType
    PRIVATE
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
  END TYPE cmfe_DecompositionType

  !>Contains information about the equations in an equations set.
  TYPE cmfe_EquationsType
    PRIVATE
    TYPE(EQUATIONS_TYPE), POINTER :: equations
  END TYPE cmfe_EquationsType

  !>Contains information on an equations set defined on a region.
  TYPE cmfe_EquationsSetType
    PRIVATE
    TYPE(EQUATIONS_SET_TYPE), POINTER :: equationsSet
  END TYPE cmfe_EquationsSetType

  !>Contains information for a field defined on a region.
  TYPE cmfe_FieldType
    PRIVATE
    TYPE(FIELD_TYPE), POINTER :: field
  END TYPE cmfe_FieldType

  !>Contains information for a fields defined on a region.
  TYPE cmfe_FieldsType
    !PRIVATE
    TYPE(FIELDS_TYPE), POINTER :: fields
  END TYPE cmfe_FieldsType

  !>Contains information on a generated mesh.
  TYPE cmfe_GeneratedMeshType
    PRIVATE
    TYPE(GENERATED_MESH_TYPE), POINTER :: generatedMesh
  END TYPE cmfe_GeneratedMeshType

  !>Contains information about a history file for a control loop.
  TYPE cmfe_HistoryType
    PRIVATE
    TYPE(HISTORY_TYPE), POINTER :: history
  END TYPE cmfe_HistoryType

  !>Contains information about an interface.
  TYPE cmfe_InterfaceType
    PRIVATE
    TYPE(INTERFACE_TYPE), POINTER :: interface
  END TYPE cmfe_InterfaceType

  !>Contains information about an interface condition.
  TYPE cmfe_InterfaceConditionType
    PRIVATE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: interfaceCondition
  END TYPE cmfe_InterfaceConditionType

  !>Contains information about an interface condition.
  TYPE cmfe_InterfaceEquationsType
    PRIVATE
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: interfaceEquations
  END TYPE cmfe_InterfaceEquationsType

   !>Contains information on an interfaces meshes connectivity.
  TYPE cmfe_InterfaceMeshConnectivityType
    PRIVATE
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: meshConnectivity
  END TYPE cmfe_InterfaceMeshConnectivityType
  
  !>Contains information on an interfaces points connectivity.
  TYPE cmfe_InterfacePointsConnectivityType
    PRIVATE
    TYPE(InterfacePointsConnectivityType), POINTER :: pointsConnectivity
  END TYPE cmfe_InterfacePointsConnectivityType

  !>A matrix that may be distributed across multiple computational nodes
  !>and may use sparse or full storage.
  TYPE cmfe_DistributedMatrixType
    PRIVATE
    TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: distributedMatrix
  END TYPE cmfe_DistributedMatrixType

  !>A vector that may be distributed across multiple computational nodes
  TYPE cmfe_DistributedVectorType
    PRIVATE
    TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: distributedVector
  END TYPE cmfe_DistributedVectorType

  !>Contains information on a mesh defined on a region.
  TYPE cmfe_MeshType
    PRIVATE
    TYPE(MESH_TYPE), POINTER :: mesh
  END TYPE cmfe_MeshType

  !>Contains information on a mesh elements defined in a mesh
  TYPE cmfe_MeshElementsType
    PRIVATE
    TYPE(MeshElementsType), POINTER :: meshElements
  END TYPE cmfe_MeshElementsType

  !>Contains information on an embedded mesh
  TYPE cmfe_MeshEmbeddingType
    PRIVATE
    TYPE(MESH_EMBEDDING_TYPE), POINTER :: meshEmbedding
  END TYPE cmfe_MeshEmbeddingType

  !>Contains information on a mesh nodes defined in a mesh
  TYPE cmfe_MeshNodesType
    PRIVATE
    TYPE(MeshNodesType), POINTER :: meshNodes
  END TYPE cmfe_MeshNodesType

  !>Contains information on the nodes defined on a region.
  TYPE cmfe_NodesType
    PRIVATE
    TYPE(NODES_TYPE), POINTER :: nodes
  END TYPE cmfe_NodesType

  !>Contains information for a problem.
  TYPE cmfe_ProblemType
    PRIVATE
    TYPE(PROBLEM_TYPE), POINTER :: problem
  END TYPE cmfe_ProblemType

  !>Contains information for a particular quadrature scheme for a basis.
  TYPE cmfe_QuadratureType
    PRIVATE
    TYPE(QUADRATURE_TYPE), POINTER :: quadrature
  END TYPE cmfe_QuadratureType

 !>Contains information for a region.
  TYPE cmfe_RegionType
    PRIVATE
    TYPE(REGION_TYPE), POINTER :: region
  END TYPE cmfe_RegionType

  !>Contains information about a solver.
  TYPE cmfe_SolverType
    PRIVATE
    TYPE(SOLVER_TYPE), POINTER :: solver
  END TYPE cmfe_SolverType

  !>Contains information about the solver equations for a solver.
  TYPE cmfe_SolverEquationsType
    PRIVATE
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: solverEquations
  END TYPE cmfe_SolverEquationsType

  !>Contains information on a computational work group
  TYPE cmfe_ComputationalWorkGroupType
    PRIVATE
    TYPE(COMPUTATIONAL_WORK_GROUP_TYPE), POINTER :: computationalWorkGroup
  END TYPE cmfe_ComputationalWorkGroupType

  !Module variables

  TYPE(VARYING_STRING) :: error

  !INTERFACE cmfe_Finalise_
  !  MODULE PROCEDURE cmfe_Finalise
  !END INTERFACE cmfe_Finalise_

  INTERFACE cmfe_Initialise
    MODULE PROCEDURE cmfe_InitialiseNumber
    MODULE PROCEDURE cmfe_InitialiseObj
  END INTERFACE cmfe_Initialise

  INTERFACE cmfe_Fields_Create
    MODULE PROCEDURE cmfe_Fields_CreateInterface
    MODULE PROCEDURE cmfe_Fields_CreateRegion
  END INTERFACE cmfe_Fields_Create

  !PUBLIC cmfe_Finalise,cmfe_Initialise
  PUBLIC cmfe_Finalise,cmfe_Initialise

  PUBLIC cmfe_BasisType,cmfe_BasisTypesCopy,cmfe_Basis_Finalise,cmfe_Basis_Initialise

  PUBLIC cmfe_BoundaryConditionsType,cmfe_BoundaryConditions_Finalise,cmfe_BoundaryConditions_Initialise

  PUBLIC cmfe_CellMLType,cmfe_CellML_Finalise,cmfe_CellML_Initialise

  PUBLIC cmfe_CellMLEquationsType,cmfe_CellMLEquations_Finalise,cmfe_CellMLEquations_Initialise

  PUBLIC cmfe_ComputationalWorkGroupType,cmfe_ComputationalWorkGroup_Initialise

  PUBLIC cmfe_ControlLoopType,cmfe_ControlLoop_Finalise,cmfe_ControlLoop_Initialise,cmfe_ControlLoop_LoadOutputSet

  PUBLIC cmfe_CoordinateSystemType,cmfe_CoordinateSystem_Finalise,cmfe_CoordinateSystem_Initialise

  PUBLIC cmfe_DataPointsType,cmfe_DataPoints_Finalise,cmfe_DataPoints_Initialise

  PUBLIC cmfe_DataProjectionType,cmfe_DataProjection_Finalise,cmfe_DataProjection_Initialise

  PUBLIC cmfe_DecompositionType,cmfe_Decomposition_Finalise,cmfe_Decomposition_Initialise

  PUBLIC cmfe_Decomposition_CalculateFacesSet,cmfe_Decomposition_CalculateLinesSet

  PUBLIC cmfe_EquationsType,cmfe_Equations_Finalise,cmfe_Equations_Initialise

  PUBLIC cmfe_EquationsSetType,cmfe_EquationsSet_Finalise,cmfe_EquationsSet_Initialise

  PUBLIC cmfe_FieldType,cmfe_Field_Finalise,cmfe_Field_Initialise

  PUBLIC cmfe_FieldsType,cmfe_Fields_Create,cmfe_Fields_Finalise,cmfe_Fields_Initialise

  PUBLIC cmfe_GeneratedMeshType,cmfe_GeneratedMesh_Finalise,cmfe_GeneratedMesh_Initialise

  PUBLIC cmfe_HistoryType,cmfe_History_Finalise,cmfe_History_Initialise

  PUBLIC cmfe_InterfaceType,cmfe_Interface_Finalise,cmfe_Interface_Initialise

  PUBLIC cmfe_InterfaceConditionType,cmfe_InterfaceCondition_Finalise,cmfe_InterfaceCondition_Initialise

  PUBLIC cmfe_InterfaceEquationsType,cmfe_InterfaceEquations_Finalise,cmfe_InterfaceEquations_Initialise

  PUBLIC cmfe_InterfaceMeshConnectivityType,cmfe_InterfaceMeshConnectivity_Finalise, &
    & cmfe_InterfaceMeshConnectivity_Initialise
  
  PUBLIC cmfe_InterfacePointsConnectivityType,cmfe_InterfacePointsConnectivity_Initialise, &
    & cmfe_InterfacePointsConnectivity_Finalise

  PUBLIC cmfe_DistributedMatrixType,cmfe_DistributedVectorType

  PUBLIC cmfe_DistributedMatrix_Initialise,cmfe_DistributedVector_Initialise

  PUBLIC cmfe_MeshType,cmfe_Mesh_Finalise,cmfe_Mesh_Initialise

  PUBLIC cmfe_MeshElementsType,cmfe_MeshElements_Finalise,cmfe_MeshElements_Initialise

  PUBLIC cmfe_MeshNodesType,cmfe_MeshNodes_Finalise,cmfe_MeshNodes_Initialise

  PUBLIC cmfe_NodesType,cmfe_Nodes_Finalise,cmfe_Nodes_Initialise

  PUBLIC cmfe_ProblemType,cmfe_Problem_Finalise,cmfe_Problem_Initialise

  PUBLIC cmfe_QuadratureType,cmfe_Quadrature_Finalise,cmfe_Quadrature_Initialise

  PUBLIC cmfe_RegionType,cmfe_Region_Finalise,cmfe_Region_Initialise

  PUBLIC cmfe_SolverType,cmfe_Solver_Finalise,cmfe_Solver_Initialise

  PUBLIC cmfe_SolverEquationsType,cmfe_SolverEquations_Finalise,cmfe_SolverEquations_Initialise

!!==================================================================================================================================
!!
!! ANALYTIC_ANALYSIS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Output the analytic error analysis for a field compared to the analytic values parameter set.
  INTERFACE cmfe_AnalyticAnalysis_Output
    MODULE PROCEDURE cmfe_AnalyticAnalysis_OutputNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_OutputObj
  END INTERFACE

  !>Get the absolute error of the node.
  INTERFACE cmfe_AnalyticAnalysis_AbsoluteErrorGetNode
    MODULE PROCEDURE cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeObj
  END INTERFACE cmfe_AnalyticAnalysis_AbsoluteErrorGetNode

  !>Get the percentage error of the node.
  INTERFACE cmfe_AnalyticAnalysis_PercentageErrorGetNode
    MODULE PROCEDURE cmfe_AnalyticAnalysis_PercentageErrorGetNodeNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_PercentageErrorGetNodeObj
  END INTERFACE cmfe_AnalyticAnalysis_PercentageErrorGetNode

  !>Get the relative error of the node.
  INTERFACE cmfe_AnalyticAnalysis_RelativeErrorGetNode
    MODULE PROCEDURE cmfe_AnalyticAnalysis_RelativeErrorGetNodeNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_RelativeErrorGetNodeObj
  END INTERFACE cmfe_AnalyticAnalysis_RelativeErrorGetNode

  !>Get the absolute error of the element.
  INTERFACE cmfe_AnalyticAnalysis_AbsoluteErrorGetElement
    MODULE PROCEDURE cmfe_AnalyticAnalysis_AbsoluteErrorGetElementNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_AbsoluteErrorGetElementObj
  END INTERFACE cmfe_AnalyticAnalysis_AbsoluteErrorGetElement

  !>Get the percentage error of the element.
  INTERFACE cmfe_AnalyticAnalysis_PercentageErrorGetElement
    MODULE PROCEDURE cmfe_AnalyticAnalysis_PercentageErrorGetElementNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_PercentageErrorGetElementObj
  END INTERFACE cmfe_AnalyticAnalysis_PercentageErrorGetElement

  !>Get the relative error of the element.
  INTERFACE cmfe_AnalyticAnalysis_RelativeErrorGetElement
    MODULE PROCEDURE cmfe_AnalyticAnalysis_RelativeErrorGetElementNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_RelativeErrorGetElementObj
  END INTERFACE cmfe_AnalyticAnalysis_RelativeErrorGetElement

  !>Get the absolute error of the constant.
  INTERFACE cmfe_AnalyticAnalysis_AbsoluteErrorGetConstant
    MODULE PROCEDURE cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantObj
  END INTERFACE cmfe_AnalyticAnalysis_AbsoluteErrorGetConstant

  !>Get the percentage error of the constant.
  INTERFACE cmfe_AnalyticAnalysis_PercentageErrorGetConstant
    MODULE PROCEDURE cmfe_AnalyticAnalysis_PercentageErrorGetConstantNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_PercentageErrorGetConstantObj
  END INTERFACE cmfe_AnalyticAnalysis_PercentageErrorGetConstant

  !>Get the relative error of the constant.
  INTERFACE cmfe_AnalyticAnalysis_RelativeErrorGetConstant
    MODULE PROCEDURE cmfe_AnalyticAnalysis_RelativeErrorGetConstantNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_RelativeErrorGetConstantObj
  END INTERFACE cmfe_AnalyticAnalysis_RelativeErrorGetConstant

  !>Get the RMS error of nodes.
  INTERFACE cmfe_AnalyticAnalysis_RMSErrorGetNode
    MODULE PROCEDURE cmfe_AnalyticAnalysis_RMSErrorGetNodeNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_RMSErrorGetNodeObj
  END INTERFACE cmfe_AnalyticAnalysis_RMSErrorGetNode

  !>Get the RMS error of elements.
  INTERFACE cmfe_AnalyticAnalysis_RMSErrorGetElement
    MODULE PROCEDURE cmfe_AnalyticAnalysis_RMSErrorGetElementNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_RMSErrorGetElementObj
  END INTERFACE cmfe_AnalyticAnalysis_RMSErrorGetElement

  !>Get integral of numerical values.
  INTERFACE cmfe_AnalyticAnalysis_IntegralNumericalValueGet
    MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralNumericalValueGetNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralNumericalValueGetObj
  END INTERFACE cmfe_AnalyticAnalysis_IntegralNumericalValueGet
  
  !>Get integral of analytical values.
  INTERFACE cmfe_AnalyticAnalysis_IntegralAnalyticValueGet
    MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralAnalyticValueGetNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralAnalyticValueGetObj
  END INTERFACE cmfe_AnalyticAnalysis_IntegralAnalyticValueGet

  !>Get integral of percentage errors.
  INTERFACE cmfe_AnalyticAnalysis_IntegralPercentageErrorGet
    MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralPercentageErrorGetNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralPercentageErrorGetObj
  END INTERFACE cmfe_AnalyticAnalysis_IntegralPercentageErrorGet

  !>Get integral of absolute errors.
  INTERFACE cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGet
    MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetObj
  END INTERFACE cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGet

  !>Get integral of relative errors.
  INTERFACE cmfe_AnalyticAnalysis_IntegralRelativeErrorGet
    MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralRelativeErrorGetNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralRelativeErrorGetObj
  END INTERFACE cmfe_AnalyticAnalysis_IntegralRelativeErrorGet

  !>Get integral of NID numerical errors.
  INTERFACE cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGet
    MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetObj
  END INTERFACE cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGet

  !>Get integral of NID errors.
  INTERFACE cmfe_AnalyticAnalysis_IntegralNIDErrorGet
    MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralNIDErrorGetNumber
    MODULE PROCEDURE cmfe_AnalyticAnalysis_IntegralNIDErrorGetObj
  END INTERFACE cmfe_AnalyticAnalysis_IntegralNIDErrorGet

  PUBLIC cmfe_AnalyticAnalysis_Output

  PUBLIC cmfe_AnalyticAnalysis_AbsoluteErrorGetNode,cmfe_AnalyticAnalysis_PercentageErrorGetNode, &
    & cmfe_AnalyticAnalysis_RelativeErrorGetNode

  PUBLIC cmfe_AnalyticAnalysis_AbsoluteErrorGetElement,cmfe_AnalyticAnalysis_PercentageErrorGetElement, &
    & cmfe_AnalyticAnalysis_RelativeErrorGetElement

  PUBLIC cmfe_AnalyticAnalysis_AbsoluteErrorGetConstant,cmfe_AnalyticAnalysis_PercentageErrorGetConstant, &
    & cmfe_AnalyticAnalysis_RelativeErrorGetConstant

  PUBLIC cmfe_AnalyticAnalysis_RMSErrorGetNode,cmfe_AnalyticAnalysis_RMSErrorGetElement

  PUBLIC cmfe_AnalyticAnalysis_IntegralNumericalValueGet,cmfe_AnalyticAnalysis_IntegralAnalyticValueGet, &
    & cmfe_AnalyticAnalysis_IntegralPercentageErrorGet,cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGet, &
    & cmfe_AnalyticAnalysis_IntegralRelativeErrorGet,cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGet, &
    & cmfe_AnalyticAnalysis_IntegralNIDErrorGet

!!==================================================================================================================================
!!
!! BASE_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_DiagnosticAndTimingConstants OPENCMISS::DiagnosticAndTiming::Constants
  !> \brief Diagnostic and Timing constants.
  !>@{
  !> \addtogroup OPENCMISS_DiagnosticTypes OPENCMISS::DiagnosticAndTiming::DiagnosticTypes
  !> \brief Diganostic constants.
  !> \see OPENCMISS::DiagnosticTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_ALL_DIAG_TYPE = ALL_DIAG_TYPE !<Type for setting diagnostic output in all routines \see OPENCMISS_DiagnosticTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_IN_DIAG_TYPE = IN_DIAG_TYPE !<Type for setting diagnostic output in one routine \see OPENCMISS_DiagnosticTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FROM_DIAG_TYPE = FROM_DIAG_TYPE !<Type for setting diagnostic output in one routine downwards \see OPENCMISS_DiagnosticTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_TimingTypes OPENCMISS::DiagnosticAndTiming::TimingTypes
  !> \brief Timing constants.
  !> \see OPENCMISS::TimingTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_ALL_TIMING_TYPE = ALL_TIMING_TYPE !<Type for setting timing output in all routines \see OPENCMISS_TimingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_IN_TIMING_TYPE = IN_TIMING_TYPE !<Type for setting timing output in one routine \see OPENCMISS_TimingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FROM_TIMING_TYPE = FROM_TIMING_TYPE !<Type for setting timing output from one routine downwards \see OPENCMISS_TimingTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMFE_ALL_DIAG_TYPE,CMFE_IN_DIAG_TYPE,CMFE_FROM_DIAG_TYPE

  PUBLIC CMFE_ALL_TIMING_TYPE,CMFE_IN_TIMING_TYPE,CMFE_FROM_TIMING_TYPE

  PUBLIC cmfe_DiagnosticsSetOff,cmfe_DiagnosticsSetOn

  PUBLIC cmfe_OutputSetOff,cmfe_OutputSetOn

  PUBLIC cmfe_TimingSetOff,cmfe_TimingSetOn,cmfe_TimingSummaryOutput

!!==================================================================================================================================
!!
!! BASIS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_BasisConstants OPENCMISS::Basis::Constants
  !> \brief Basis function constants.
  !>@{
  !> \addtogroup OPENCMISS_BasisTypes OPENCMISS::Basis::BasisTypes
  !> \brief Basis definition type parameters.
  !> \see OPENCMISS::BasisConstants,OPENCMISS
  !>@{ symbol 'nodenumber' at (1) has no IMPLICIT type.
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_LAGRANGE_HERMITE_TP_TYPE = BASIS_LAGRANGE_HERMITE_TP_TYPE !<Lagrange-Hermite tensor product basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_SIMPLEX_TYPE = BASIS_SIMPLEX_TYPE !<Simplex basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_SERENDIPITY_TYPE = BASIS_SERENDIPITY_TYPE !<Serendipity basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_AUXILLIARY_TYPE = BASIS_AUXILLIARY_TYPE !<Auxillary basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_B_SPLINE_TP_TYPE = BASIS_B_SPLINE_TP_TYPE !<B-spline basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE = BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE !<Fourier-Lagrange tensor product basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_EXTENDED_LAGRANGE_TP_TYPE = BASIS_EXTENDED_LAGRANGE_TP_TYPE !< Extendend Lagrange tensor product basis type \see OPENCMISS_BasisTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_BasisInterpolationSpecifications OPENCMISS::Basis::InterpolationSpecifications
  !> \brief Interpolation specification parameters
  !> \see OPENCMISS::BasisConstants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_LINEAR_LAGRANGE_INTERPOLATION = BASIS_LINEAR_LAGRANGE_INTERPOLATION !<Linear Lagrange interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_QUADRATIC_LAGRANGE_INTERPOLATION = BASIS_QUADRATIC_LAGRANGE_INTERPOLATION !<Quadratic Lagrange interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_CUBIC_LAGRANGE_INTERPOLATION = BASIS_CUBIC_LAGRANGE_INTERPOLATION !<Cubic Lagrange interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_CUBIC_HERMITE_INTERPOLATION = BASIS_CUBIC_HERMITE_INTERPOLATION !<Cubic Hermite interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_QUADRATIC1_HERMITE_INTERPOLATION = BASIS_QUADRATIC1_HERMITE_INTERPOLATION !<Quadratic Hermite (no derivative at xi=0) interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_QUADRATIC2_HERMITE_INTERPOLATION = BASIS_QUADRATIC2_HERMITE_INTERPOLATION !<Quadratic Hermite (no derivative at xi=1) interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_LINEAR_SIMPLEX_INTERPOLATION = BASIS_LINEAR_SIMPLEX_INTERPOLATION !<Linear Simplex interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_QUADRATIC_SIMPLEX_INTERPOLATION = BASIS_QUADRATIC_SIMPLEX_INTERPOLATION !<Quadratic Simplex interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_CUBIC_SIMPLEX_INTERPOLATION = BASIS_CUBIC_SIMPLEX_INTERPOLATION !<Cubic Simplex interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_BasisQuadratureSchemes OPENCMISS::Basis::QuadratureSchemes
  !> \brief Quadrature scheme parameters
  !> \see OPENCMISS::BasisConstants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_DEFAULT_QUADRATURE_SCHEME = BASIS_DEFAULT_QUADRATURE_SCHEME !<Identifier for the default quadrature scheme \see OPENCMISS_BasisQuadratureSchemes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_LOW_QUADRATURE_SCHEME = BASIS_LOW_QUADRATURE_SCHEME !<Identifier for a low order quadrature scheme \see OPENCMISS_BasisQuadratureSchemes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_MID_QUADRATURE_SCHEME = BASIS_MID_QUADRATURE_SCHEME !<Identifier for a mid order quadrature scheme \see OPENCMISS_BasisQuadratureSchemes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_HIGH_QUADRATURE_SCHEME = BASIS_HIGH_QUADRATURE_SCHEME !<Identifier for a high order quadrature scheme \see OPENCMISS_BasisQuadratureSchemes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_BasisQuadratureTypes OPENCMISS::Basis::QuadratureTypes
  !> \brief Basis quadrature type parameters.
  !> \see OPENCMISS::BasisConstants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_GAUSS_LEGENDRE_QUADRATURE = BASIS_GAUSS_LEGENDRE_QUADRATURE !<Gauss-Legendre quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_GAUSS_LAGUERRE_QUADRATURE = BASIS_GAUSS_LAGUERRE_QUADRATURE !<Gauss-Laguerre quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_GUASS_HERMITE_QUADRATURE = BASIS_GUASS_HERMITE_QUADRATURE !<Gauss-Hermite quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_ADAPTIVE_GAUSS_LEGENDRE_QUADRATURE = BASIS_ADAPTIVE_GAUSS_LEGENDRE_QUADRATURE !<Adaptive Gauss-Legendre quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_GAUSS_SIMPLEX_QUADRATURE = BASIS_GAUSS_SIMPLEX_QUADRATURE !<Gauss-Legendre for Simplex elements quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_BasisXiCollapse OPENCMISS::Basis::XiCollapse
  !> \brief Basis Xi collapse parameters.
  !> \see OPENCMISS::Basis,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_XI_COLLAPSED = BASIS_XI_COLLAPSED !<The Xi direction is collapsed \see OPENCMISS_BasisXiCollapse,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_COLLAPSED_AT_XI0 = BASIS_COLLAPSED_AT_XI0 !<The Xi direction at the xi=0 end of this Xi direction is collapsed \see OPENCMISS_BasisXiCollapse,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_COLLAPSED_AT_XI1 = BASIS_COLLAPSED_AT_XI1 !<The Xi direction at the xi=1 end of this Xi direction is collapsed \see OPENCMISS_BasisXiCollapse,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_BASIS_NOT_COLLAPSED = BASIS_NOT_COLLAPSED !<The Xi direction is not collapsed \see OPENCMISS_BasisXiCollapse,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the collapsed Xi flags for a basis.
  INTERFACE cmfe_Basis_CollapsedXiGet
    MODULE PROCEDURE cmfe_Basis_CollapsedXiGetNumber
    MODULE PROCEDURE cmfe_Basis_CollapsedXiGetObj
  END INTERFACE cmfe_Basis_CollapsedXiGet

  !>Sets/changes the collapsed Xi flags for a basis.
  INTERFACE cmfe_Basis_CollapsedXiSet
    MODULE PROCEDURE cmfe_Basis_CollapsedXiSetNumber
    MODULE PROCEDURE cmfe_Basis_CollapsedXiSetObj
  END INTERFACE cmfe_Basis_CollapsedXiSet

  !>Finishes the creation of a new basis. \see OpenCMISS::Iron::cmfe_Basis_CreateStart
  INTERFACE cmfe_Basis_CreateFinish
    MODULE PROCEDURE cmfe_Basis_CreateFinishNumber
    MODULE PROCEDURE cmfe_Basis_CreateFinishObj
  END INTERFACE cmfe_Basis_CreateFinish

  !>Starts the creation of a new basis. \see OpenCMISS::Iron::cmfe_Basis_CreateFinish
  INTERFACE cmfe_Basis_CreateStart
    MODULE PROCEDURE cmfe_Basis_CreateStartNumber
    MODULE PROCEDURE cmfe_Basis_CreateStartObj
  END INTERFACE cmfe_Basis_CreateStart

  !>Destroys a basis.
  INTERFACE cmfe_Basis_Destroy
    MODULE PROCEDURE cmfe_Basis_DestroyNumber
    MODULE PROCEDURE cmfe_Basis_DestroyObj
  END INTERFACE cmfe_Basis_Destroy

  !>Get the interpolation type in each Xi directions for a basis.
  INTERFACE cmfe_Basis_InterpolationXiGet
    MODULE PROCEDURE cmfe_Basis_InterpolationXiGetNumber
    MODULE PROCEDURE cmfe_Basis_InterpolationXiGetObj
  END INTERFACE cmfe_Basis_InterpolationXiGet

  !>Sets/changes the interpolation type in each Xi directions for a basis.
  INTERFACE cmfe_Basis_InterpolationXiSet
    MODULE PROCEDURE cmfe_Basis_InterpolationXiSetNumber
    MODULE PROCEDURE cmfe_Basis_InterpolationXiSetObj
  END INTERFACE cmfe_Basis_InterpolationXiSet

  !>Returns the number of local nodes in a basis.
  INTERFACE cmfe_Basis_NumberOfLocalNodesGet
    MODULE PROCEDURE cmfe_Basis_NumberOfLocalNodesGetNumber
    MODULE PROCEDURE cmfe_Basis_NumberOfLocalNodesGetObj
  END INTERFACE cmfe_Basis_NumberOfLocalNodesGet

  !>Returns the number of Xi directions in a basis.
  INTERFACE cmfe_Basis_NumberOfXiGet
    MODULE PROCEDURE cmfe_Basis_NumberOfXiGetNumber
    MODULE PROCEDURE cmfe_Basis_NumberOfXiGetObj
  END INTERFACE cmfe_Basis_NumberOfXiGet

  !>Sets/changes the number of Xi directions in a basis.
  INTERFACE cmfe_Basis_NumberOfXiSet
    MODULE PROCEDURE cmfe_Basis_NumberOfXiSetNumber
    MODULE PROCEDURE cmfe_Basis_NumberOfXiSetObj
  END INTERFACE cmfe_Basis_NumberOfXiSet

  !>Returns the number of Gauss points in each Xi direction on a basis quadrature.
  INTERFACE cmfe_Basis_QuadratureNumberOfGaussXiGet
    MODULE PROCEDURE cmfe_Basis_QuadratureNumberOfGaussXiGetNumber
    MODULE PROCEDURE cmfe_Basis_QuadratureNumberOfGaussXiGetObj
  END INTERFACE cmfe_Basis_QuadratureNumberOfGaussXiGet

  !>Sets/changes the number of Gauss points in each Xi direction on a basis quadrature.
  INTERFACE cmfe_Basis_QuadratureNumberOfGaussXiSet
    MODULE PROCEDURE cmfe_Basis_QuadratureNumberOfGaussXiSetNumber
    MODULE PROCEDURE cmfe_Basis_QuadratureNumberOfGaussXiSetObj
  END INTERFACE cmfe_Basis_QuadratureNumberOfGaussXiSet

  !>Returns the xi positions of Gauss points on a basis quadrature.
  INTERFACE cmfe_Basis_QuadratureGaussXiGet
    MODULE PROCEDURE cmfe_Basis_QuadratureSingleGaussXiGetNumber
    MODULE PROCEDURE cmfe_Basis_QuadratureSingleGaussXiGetObj
    MODULE PROCEDURE cmfe_Basis_QuadratureMultipleGaussXiGetNumber
    MODULE PROCEDURE cmfe_Basis_QuadratureMultipleGaussXiGetObj
  END INTERFACE cmfe_Basis_QuadratureGaussXiGet

  !>Returns the order of quadrature for a basis quadrature.
  INTERFACE cmfe_Basis_QuadratureOrderGet
    MODULE PROCEDURE cmfe_Basis_QuadratureOrderGetNumber
    MODULE PROCEDURE cmfe_Basis_QuadratureOrderGetObj
  END INTERFACE cmfe_Basis_QuadratureOrderGet

  !>Sets/changes the order of quadrature for a basis quadrature.
  INTERFACE cmfe_Basis_QuadratureOrderSet
    MODULE PROCEDURE cmfe_Basis_QuadratureOrderSetNumber
    MODULE PROCEDURE cmfe_Basis_QuadratureOrderSetObj
  END INTERFACE cmfe_Basis_QuadratureOrderSet

  !>Returns the quadrature type for a basis quadrature.
  INTERFACE cmfe_Basis_QuadratureTypeGet
    MODULE PROCEDURE cmfe_Basis_QuadratureTypeGetNumber
    MODULE PROCEDURE cmfe_Basis_QuadratureTypeGetObj
  END INTERFACE cmfe_Basis_QuadratureTypeGet

  !>Sets/changes the quadrature type for a basis quadrature.
  INTERFACE cmfe_Basis_QuadratureTypeSet
    MODULE PROCEDURE cmfe_Basis_QuadratureTypeSetNumber
    MODULE PROCEDURE cmfe_Basis_QuadratureTypeSetObj
  END INTERFACE cmfe_Basis_QuadratureTypeSet

  !>Sets/changes the local face gauss evaluatoin flag for a basis quadrature.
  INTERFACE cmfe_Basis_QuadratureLocalFaceGaussEvaluateSet
    MODULE PROCEDURE cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetNumber
    MODULE PROCEDURE cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetObj
  END INTERFACE cmfe_Basis_QuadratureLocalFaceGaussEvaluateSet

  !>Returns the type of a basis.
  INTERFACE cmfe_Basis_TypeGet
    MODULE PROCEDURE cmfe_Basis_TypeGetNumber
    MODULE PROCEDURE cmfe_Basis_TypeGetObj
  END INTERFACE cmfe_Basis_TypeGet

  !>Sets/changes the type of a basis.
  INTERFACE cmfe_Basis_TypeSet
    MODULE PROCEDURE cmfe_Basis_TypeSetNumber
    MODULE PROCEDURE cmfe_Basis_TypeSetObj
  END INTERFACE cmfe_Basis_TypeSet

  PUBLIC CMFE_BASIS_LAGRANGE_HERMITE_TP_TYPE,CMFE_BASIS_SIMPLEX_TYPE,CMFE_BASIS_SERENDIPITY_TYPE,CMFE_BASIS_AUXILLIARY_TYPE, &
    & CMFE_BASIS_B_SPLINE_TP_TYPE,CMFE_BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE,CMFE_BASIS_EXTENDED_LAGRANGE_TP_TYPE

  PUBLIC CMFE_BASIS_LINEAR_LAGRANGE_INTERPOLATION,CMFE_BASIS_QUADRATIC_LAGRANGE_INTERPOLATION, &
    & CMFE_BASIS_CUBIC_LAGRANGE_INTERPOLATION, &
    & CMFE_BASIS_CUBIC_HERMITE_INTERPOLATION,CMFE_BASIS_QUADRATIC1_HERMITE_INTERPOLATION, &
    & CMFE_BASIS_QUADRATIC2_HERMITE_INTERPOLATION, &
    & CMFE_BASIS_LINEAR_SIMPLEX_INTERPOLATION,CMFE_BASIS_QUADRATIC_SIMPLEX_INTERPOLATION,CMFE_BASIS_CUBIC_SIMPLEX_INTERPOLATION

  PUBLIC CMFE_BASIS_DEFAULT_QUADRATURE_SCHEME,CMFE_BASIS_LOW_QUADRATURE_SCHEME,CMFE_BASIS_MID_QUADRATURE_SCHEME, &
    & CMFE_BASIS_HIGH_QUADRATURE_SCHEME

  PUBLIC CMFE_BASIS_GAUSS_LEGENDRE_QUADRATURE,CMFE_BASIS_GAUSS_LAGUERRE_QUADRATURE,CMFE_BASIS_GUASS_HERMITE_QUADRATURE, &
    & CMFE_BASIS_ADAPTIVE_GAUSS_LEGENDRE_QUADRATURE,CMFE_BASIS_GAUSS_SIMPLEX_QUADRATURE

  PUBLIC CMFE_BASIS_XI_COLLAPSED,CMFE_BASIS_COLLAPSED_AT_XI0,CMFE_BASIS_COLLAPSED_AT_XI1,CMFE_BASIS_NOT_COLLAPSED

  PUBLIC cmfe_Basis_CollapsedXiGet,cmfe_Basis_CollapsedXiSet

  PUBLIC cmfe_Basis_CreateFinish,cmfe_Basis_CreateStart,cmfe_Basis_Destroy

  PUBLIC cmfe_Basis_InterpolationXiGet,cmfe_Basis_InterpolationXiSet

  PUBLIC cmfe_Basis_NumberOfLocalNodesGet

  PUBLIC cmfe_Basis_NumberOfXiGet,cmfe_Basis_NumberOfXiSet

  PUBLIC cmfe_Basis_QuadratureNumberOfGaussXiGet,cmfe_Basis_QuadratureNumberOfGaussXiSet

  PUBLIC cmfe_Basis_QuadratureGaussXiGet

  PUBLIC cmfe_Basis_QuadratureOrderGet,cmfe_Basis_QuadratureOrderSet

  PUBLIC cmfe_Basis_QuadratureTypeGet,cmfe_Basis_QuadratureTypeSet,cmfe_Basis_QuadratureLocalFaceGaussEvaluateSet

  PUBLIC cmfe_Basis_TypeGet,cmfe_Basis_TypeSet

!!==================================================================================================================================
!!
!! BOUNDARY_CONDITIONS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters


  !> \addtogroup OPENCMISS_BoundaryConditionsConstants OPENCMISS::BoundaryConditions::Constants
  !> \brief Boundary conditions constants.
  !>@{
  !> \addtogroup OPENCMISS_BoundaryConditionsTypes OPENCMISS::BoundaryConditions::Types
  !> \brief Specific boundary condition types, which might only be applicable to certain equation sets.
  !> \see OPENCMISS::BoundaryConditions,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FREE = BOUNDARY_CONDITION_FREE !<The dof is free.
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED = BOUNDARY_CONDITION_FIXED !<The dof is fixed as a boundary condition.
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED_WALL = BOUNDARY_CONDITION_FIXED_WALL
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED_INLET = BOUNDARY_CONDITION_FIXED_INLET
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED_OUTLET = BOUNDARY_CONDITION_FIXED_OUTLET
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_MOVED_WALL = BOUNDARY_CONDITION_MOVED_WALL
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED = BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FREE_WALL = BOUNDARY_CONDITION_FREE_WALL

  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_NEUMANN_POINT = BOUNDARY_CONDITION_NEUMANN_POINT !<Specify the normal derivative at a node, which is then integrated to find the nodal load term
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_NEUMANN_POINT_INCREMENTED = BOUNDARY_CONDITION_NEUMANN_POINT_INCREMENTED !<Specify the normal derivative at a node, which is then integrated to find the nodal load term. The value is incremented inside a load incremented control loop.
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_NEUMANN_INTEGRATED = BOUNDARY_CONDITION_NEUMANN_INTEGRATED !<Set the integrated right hand side load value directly
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_DIRICHLET = BOUNDARY_CONDITION_DIRICHLET
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_CAUCHY = BOUNDARY_CONDITION_CAUCHY
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_ROBIN = BOUNDARY_CONDITION_ROBIN

  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED_INCREMENTED = BOUNDARY_CONDITION_FIXED_INCREMENTED
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_PRESSURE = BOUNDARY_CONDITION_PRESSURE
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_PRESSURE_INCREMENTED = BOUNDARY_CONDITION_PRESSURE_INCREMENTED

  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_CORRECTION_MASS_INCREASE = BOUNDARY_CONDITION_CORRECTION_MASS_INCREASE
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_IMPERMEABLE_WALL = BOUNDARY_CONDITION_IMPERMEABLE_WALL
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_NEUMANN_INTEGRATED_ONLY = BOUNDARY_CONDITION_NEUMANN_INTEGRATED_ONLY !<A Neumann integrated boundary condition, and no point values will be integrated over a face or line that includes this dof

  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED_FITTED = BOUNDARY_CONDITION_FIXED_FITTED
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED_NONREFLECTING = BOUNDARY_CONDITION_FIXED_NONREFLECTING
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FIXED_CELLML = BOUNDARY_CONDITION_FIXED_CELLML
  !>@}
  !> \addtogroup OPENCMISS_BoundaryConditionSparsityTypes OPENCMISS::BoundaryConditions::SparsityTypes
  !> \brief Storage type for matrices used by boundary conditions.
  !> \see OPENCMISS::BoundaryConditions,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_SPARSE_MATRICES = BOUNDARY_CONDITION_SPARSE_MATRICES
  INTEGER(INTG), PARAMETER :: CMFE_BOUNDARY_CONDITION_FULL_MATRICES = BOUNDARY_CONDITION_FULL_MATRICES
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Destroys boundary conditions.
  INTERFACE cmfe_BoundaryConditions_Destroy
    MODULE PROCEDURE cmfe_BoundaryConditions_DestroyNumber0
    MODULE PROCEDURE cmfe_BoundaryConditions_DestroyNumber1
    MODULE PROCEDURE cmfe_BoundaryConditions_DestroyObj
  END INTERFACE cmfe_BoundaryConditions_Destroy

  !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant.
  INTERFACE cmfe_BoundaryConditions_AddConstant
    MODULE PROCEDURE cmfe_BoundaryConditions_AddConstantNumber
    MODULE PROCEDURE cmfe_BoundaryConditions_AddConstantObj
  END INTERFACE cmfe_BoundaryConditions_AddConstant

  !>Sets the value of the specified constant as a boundary condition on the specified constant.
  INTERFACE cmfe_BoundaryConditions_SetConstant
    MODULE PROCEDURE cmfe_BoundaryConditions_SetConstantNumber
    MODULE PROCEDURE cmfe_BoundaryConditions_SetConstantObj
  END INTERFACE cmfe_BoundaryConditions_SetConstant

  !>Adds to the value of the element constant and sets this as a boundary condition on the specified element.
  INTERFACE cmfe_BoundaryConditions_AddElement
    MODULE PROCEDURE cmfe_BoundaryConditions_AddElementNumber
    MODULE PROCEDURE cmfe_BoundaryConditions_AddElementObj
  END INTERFACE cmfe_BoundaryConditions_AddElement

  !>Sets the value of the specified element as a boundary condition on the specified element.
  INTERFACE cmfe_BoundaryConditions_SetElement
    MODULE PROCEDURE cmfe_BoundaryConditions_SetElementNumber
    MODULE PROCEDURE cmfe_BoundaryConditions_SetElementObj
  END INTERFACE cmfe_BoundaryConditions_SetElement

  !>Adds to the value of the node constant and sets this as a boundary condition on the specified node.
  INTERFACE cmfe_BoundaryConditions_AddNode
    MODULE PROCEDURE cmfe_BoundaryConditions_AddNodeNumber
    MODULE PROCEDURE cmfe_BoundaryConditions_AddNodeObj
  END INTERFACE cmfe_BoundaryConditions_AddNode

  !>Sets the value of the specified node as a boundary condition on the specified node.
  INTERFACE cmfe_BoundaryConditions_SetNode
    MODULE PROCEDURE cmfe_BoundaryConditions_SetNodeNumber0
    MODULE PROCEDURE cmfe_BoundaryConditions_SetNodeNumber1
    MODULE PROCEDURE cmfe_BoundaryConditions_SetNodeObj
  END INTERFACE cmfe_BoundaryConditions_SetNode

  !>Sets the matrix sparsity type for Neumann integration matrices, used when integrating Neumann point values.
  INTERFACE cmfe_BoundaryConditions_NeumannSparsityTypeSet
    MODULE PROCEDURE cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber0
    MODULE PROCEDURE cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber1
    MODULE PROCEDURE cmfe_BoundaryConditions_NeumannSparsityTypeSetObj
  END INTERFACE cmfe_BoundaryConditions_NeumannSparsityTypeSet

  !>Constrain multiple nodal equations dependent field DOFs to be a single solver DOF in the solver equations
  INTERFACE cmfe_BoundaryConditions_ConstrainNodeDofsEqual
    MODULE PROCEDURE cmfe_BoundaryConditions_ConstrainNodeDofsEqualNumber
    MODULE PROCEDURE cmfe_BoundaryConditions_ConstrainNodeDofsEqualObj
  END INTERFACE cmfe_BoundaryConditions_ConstrainNodeDofsEqual

  PUBLIC CMFE_BOUNDARY_CONDITION_FREE,CMFE_BOUNDARY_CONDITION_FIXED, &
    & CMFE_BOUNDARY_CONDITION_FIXED_WALL,CMFE_BOUNDARY_CONDITION_FIXED_INLET,CMFE_BOUNDARY_CONDITION_MOVED_WALL, &
    & CMFE_BOUNDARY_CONDITION_FREE_WALL,CMFE_BOUNDARY_CONDITION_FIXED_OUTLET,CMFE_BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED, &
    & CMFE_BOUNDARY_CONDITION_CORRECTION_MASS_INCREASE,CMFE_BOUNDARY_CONDITION_IMPERMEABLE_WALL, &
    & CMFE_BOUNDARY_CONDITION_NEUMANN_INTEGRATED_ONLY,CMFE_BOUNDARY_CONDITION_FIXED_FITTED, &
    & CMFE_BOUNDARY_CONDITION_FIXED_NONREFLECTING,CMFE_BOUNDARY_CONDITION_FIXED_CELLML

  PUBLIC CMFE_BOUNDARY_CONDITION_NEUMANN_POINT,CMFE_BOUNDARY_CONDITION_NEUMANN_INTEGRATED,CMFE_BOUNDARY_CONDITION_DIRICHLET
  PUBLIC CMFE_BOUNDARY_CONDITION_CAUCHY,CMFE_BOUNDARY_CONDITION_ROBIN,CMFE_BOUNDARY_CONDITION_FIXED_INCREMENTED
  PUBLIC CMFE_BOUNDARY_CONDITION_PRESSURE,CMFE_BOUNDARY_CONDITION_PRESSURE_INCREMENTED
  PUBLIC CMFE_BOUNDARY_CONDITION_NEUMANN_POINT_INCREMENTED

  PUBLIC CMFE_BOUNDARY_CONDITION_SPARSE_MATRICES,CMFE_BOUNDARY_CONDITION_FULL_MATRICES

  PUBLIC cmfe_BoundaryConditions_Destroy

  PUBLIC cmfe_BoundaryConditions_AddConstant,cmfe_BoundaryConditions_SetConstant

  PUBLIC cmfe_BoundaryConditions_AddElement,cmfe_BoundaryConditions_SetElement

  PUBLIC cmfe_BoundaryConditions_AddNode,cmfe_BoundaryConditions_SetNode

  PUBLIC cmfe_BoundaryConditions_NeumannSparsityTypeSet

  PUBLIC cmfe_BoundaryConditions_ConstrainNodeDofsEqual

!!==================================================================================================================================
!!
!! CMISS
!!
!!==================================================================================================================================

  !Module parameters
  !> \addtogroup OPENCMISS_CMISSConstants OpenCMISS::Iron::cmfe_::Constants
  !> \brief CMISS constants.
  !>@{
  !> \addtogroup OPENCMISS_CMISSErrorHandlingModes OpenCMISS::Iron::cmfe_::ErrorHandlingModes
  !> \brief CMISS error handling mode parameters
  !> \see OpenCMISS::Iron::cmfe_,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_ERRORS_RETURN_ERROR_CODE = CMFE_RETURN_ERROR_CODE !<Just return the error code \see OPENCMISS_CMISSErrorHandlingModes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_ERRORS_OUTPUT_ERROR = CMFE_OUTPUT_ERROR !<Output the error traceback and return the error code \see OPENCMISS_CMISSErrorHandlingModes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_ERRORS_TRAP_ERROR = CMFE_TRAP_ERROR!<Trap the error by outputing the error traceback and stopping the program \see OPENCMISS_CMISSErrorHandlingModes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Extracts the OpenCMISS error message.
  INTERFACE cmfe_ExtractErrorMessage
    MODULE PROCEDURE cmfe_ExtractErrorMessageC
    MODULE PROCEDURE cmfe_ExtractErrorMessageVS
  END INTERFACE cmfe_ExtractErrorMessage

  !>Gets the random seeds for OpenCMISS.
  INTERFACE cmfe_RandomSeedsGet
    MODULE PROCEDURE cmfe_RandomSeedsGet0
    MODULE PROCEDURE cmfe_RandomSeedsGet1
  END INTERFACE cmfe_RandomSeedsGet

  !>Sets the random seeds for OpenCMISS.
  INTERFACE cmfe_RandomSeedsSet
    MODULE PROCEDURE cmfe_RandomSeedsSet0
    MODULE PROCEDURE cmfe_RandomSeedsSet1
  END INTERFACE cmfe_RandomSeedsSet

  PUBLIC CMFE_ERRORS_RETURN_ERROR_CODE,CMFE_ERRORS_OUTPUT_ERROR,CMFE_ERRORS_TRAP_ERROR

  PUBLIC cmfe_ErrorHandlingModeGet,cmfe_ErrorHandlingModeSet

  PUBLIC cmfe_ExtractErrorMessage

  PUBLIC cmfe_RandomSeedsGet,cmfe_RandomSeedsSizeGet,cmfe_RandomSeedsSet

!!==================================================================================================================================
!!
!! CMISS_CELLML
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_CellMLConstants OPENCMISS::CellML::Constants
  !> \brief CellML constants.
  !>@{
  !> \addtogroup OPENCMISS_CellMLFieldTypes OPENCMISS::CellML::FieldTypes
  !> \brief CellML field type parameters.
  !> \see OPENCMISS::CellML,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_CELLML_MODELS_FIELD = CELLML_MODELS_FIELD !<CellML models field type \see OPENCMISS_CellMLFieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_CELLML_STATE_FIELD = CELLML_STATE_FIELD !<CellML state field type \see OPENCMISS_CellMLFieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_CELLML_INTERMEDIATE_FIELD = CELLML_INTERMEDIATE_FIELD !<CellML intermediate field type \see OPENCMISS_CellMLFieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_CELLML_PARAMETERS_FIELD = CELLML_PARAMETERS_FIELD !<CellML parameters field type \see OPENCMISS_CellMLFieldTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Set a CellML model variable as being known (the value will be set from an OpenCMISS field)
  INTERFACE cmfe_CellML_VariableSetAsKnown
    MODULE PROCEDURE cmfe_CellML_VariableSetAsKnownNumberC
    MODULE PROCEDURE cmfe_CellML_VariableSetAsKnownObjC
    MODULE PROCEDURE cmfe_CellML_VariableSetAsKnownNumberVS
    MODULE PROCEDURE cmfe_CellML_VariableSetAsKnownObjVS
  END INTERFACE cmfe_CellML_VariableSetAsKnown

  !>Set a CellML model variable as being wanted (the value will be extracted from the model to an OpenCMISS field)
  INTERFACE cmfe_CellML_VariableSetAsWanted
    MODULE PROCEDURE cmfe_CellML_VariableSetAsWantedNumberC
    MODULE PROCEDURE cmfe_CellML_VariableSetAsWantedObjC
    MODULE PROCEDURE cmfe_CellML_VariableSetAsWantedNumberVS
    MODULE PROCEDURE cmfe_CellML_VariableSetAsWantedObjVS
  END INTERFACE cmfe_CellML_VariableSetAsWanted

  !>Map a CellML model variable to a field variable component in this CellML environment.
  INTERFACE cmfe_CellML_CreateCellMLToFieldMap
    MODULE PROCEDURE cmfe_CellML_CreateCellMLToFieldMapNumberC
    MODULE PROCEDURE cmfe_CellML_CreateCellMLToFieldMapObjC
    MODULE PROCEDURE cmfe_CellML_CreateCellMLToFieldMapNumberVS
    MODULE PROCEDURE cmfe_CellML_CreateCellMLToFieldMapObjVS
  END INTERFACE cmfe_CellML_CreateCellMLToFieldMap

  !>Map a field variable component to a CellML model variable in this CellML environment.
  INTERFACE cmfe_CellML_CreateFieldToCellMLMap
    MODULE PROCEDURE cmfe_CellML_CreateFieldToCellMLMapNumberC
    MODULE PROCEDURE cmfe_CellML_CreateFieldToCellMLMapObjC
    MODULE PROCEDURE cmfe_CellML_CreateFieldToCellMLMapNumberVS
    MODULE PROCEDURE cmfe_CellML_CreateFieldToCellMLMapObjVS
  END INTERFACE cmfe_CellML_CreateFieldToCellMLMap

  !>Finishes the creation of a CellML environment. \see OpenCMISS::Iron::cmfe_CellML_CreateStart
  INTERFACE cmfe_CellML_CreateFinish
    MODULE PROCEDURE cmfe_CellML_CreateFinishNumber
    MODULE PROCEDURE cmfe_CellML_CreateFinishObj
  END INTERFACE cmfe_CellML_CreateFinish

  !>Starts the creation of a CellML environment. \see OpenCMISS::Iron::cmfe_CellML_CreateFinish
  INTERFACE cmfe_CellML_CreateStart
    MODULE PROCEDURE cmfe_CellML_CreateStartNumber
    MODULE PROCEDURE cmfe_CellML_CreateStartObj
  END INTERFACE cmfe_CellML_CreateStart

  !>Destroys a CellML environment.
  INTERFACE cmfe_CellML_Destroy
    MODULE PROCEDURE cmfe_CellML_DestroyNumber
    MODULE PROCEDURE cmfe_CellML_DestroyObj
  END INTERFACE cmfe_CellML_Destroy

  !>Finishes the creation of field maps for a CellML environment. \see OpenCMISS::Iron::cmfe_CellML_FieldMapsCreateStart
  INTERFACE cmfe_CellML_FieldMapsCreateFinish
    MODULE PROCEDURE cmfe_CellML_FieldMapsCreateFinishNumber
    MODULE PROCEDURE cmfe_CellML_FieldMapsCreateFinishObj
  END INTERFACE cmfe_CellML_FieldMapsCreateFinish

  !>Starts the creation of field maps for a CellML environment. \see OpenCMISS::Iron::cmfe_CellML_FieldMapsCreateFinish
  INTERFACE cmfe_CellML_FieldMapsCreateStart
    MODULE PROCEDURE cmfe_CellML_FieldMapsCreateStartNumber
    MODULE PROCEDURE cmfe_CellML_FieldMapsCreateStartObj
  END INTERFACE cmfe_CellML_FieldMapsCreateStart

  !>Imports the specified CellML model into a CellML models environment.
  INTERFACE cmfe_CellML_ModelImport
    MODULE PROCEDURE cmfe_CellML_ModelImportNumberC
    MODULE PROCEDURE cmfe_CellML_ModelImportObjC
    MODULE PROCEDURE cmfe_CellML_ModelImportNumberVS
    MODULE PROCEDURE cmfe_CellML_ModelImportObjVS
  END INTERFACE cmfe_CellML_ModelImport

  !>Finishes the creation of CellML models field. \see OpenCMISS::Iron::cmfe_CellML_ModelsFieldCreateStart
  INTERFACE cmfe_CellML_ModelsFieldCreateFinish
    MODULE PROCEDURE cmfe_CellML_ModelsFieldCreateFinishNumber
    MODULE PROCEDURE cmfe_CellML_ModelsFieldCreateFinishObj
  END INTERFACE cmfe_CellML_ModelsFieldCreateFinish

  !>Starts the creation of CellML models field. \see OpenCMISS::Iron::cmfe_CellML_ModelsFieldCreateFinish
  INTERFACE cmfe_CellML_ModelsFieldCreateStart
    MODULE PROCEDURE cmfe_CellML_ModelsFieldCreateStartNumber
    MODULE PROCEDURE cmfe_CellML_ModelsFieldCreateStartObj
  END INTERFACE cmfe_CellML_ModelsFieldCreateStart

  !>Returns the CellML models field for a CellML environment.
  INTERFACE cmfe_CellML_ModelsFieldGet
    MODULE PROCEDURE cmfe_CellML_ModelsFieldGetNumber
    MODULE PROCEDURE cmfe_CellML_ModelsFieldGetObj
  END INTERFACE cmfe_CellML_ModelsFieldGet

  !>Finishes the creation of CellML state field. \see OpenCMISS::Iron::cmfe_CellML_StateFieldCreateStart
  INTERFACE cmfe_CellML_StateFieldCreateFinish
    MODULE PROCEDURE cmfe_CellML_StateFieldCreateFinishNumber
    MODULE PROCEDURE cmfe_CellML_StateFieldCreateFinishObj
  END INTERFACE cmfe_CellML_StateFieldCreateFinish

  !>Starts the creation of CellML state field. \see OpenCMISS::Iron::cmfe_CellML_StateFieldCreateFinish
  INTERFACE cmfe_CellML_StateFieldCreateStart
    MODULE PROCEDURE cmfe_CellML_StateFieldCreateStartNumber
    MODULE PROCEDURE cmfe_CellML_StateFieldCreateStartObj
  END INTERFACE cmfe_CellML_StateFieldCreateStart

  !>Returns the CellML state field for a CellML environment.
  INTERFACE cmfe_CellML_StateFieldGet
    MODULE PROCEDURE cmfe_CellML_StateFieldGetNumber
    MODULE PROCEDURE cmfe_CellML_StateFieldGetObj
  END INTERFACE cmfe_CellML_StateFieldGet

  !>Returns the component for a given CellML field that corresponds to the specified CellML variable ID.
  INTERFACE cmfe_CellML_FieldComponentGet
    MODULE PROCEDURE cmfe_CellML_FieldComponentGetNumberC
    MODULE PROCEDURE cmfe_CellML_FieldComponentGetObjC
    MODULE PROCEDURE cmfe_CellML_FieldComponentGetNumberVS
    MODULE PROCEDURE cmfe_CellML_FieldComponentGetObjVS
  END INTERFACE cmfe_CellML_FieldComponentGet

  !>Finishes the creation of CellML intermediate field. \see OpenCMISS::Iron::cmfe_CellML_IntermediateFieldCreateStart
  INTERFACE cmfe_CellML_IntermediateFieldCreateFinish
    MODULE PROCEDURE cmfe_CellML_IntermediateFieldCreateFinishNumber
    MODULE PROCEDURE cmfe_CellML_IntermediateFieldCreateFinishObj
  END INTERFACE cmfe_CellML_IntermediateFieldCreateFinish

  !>Starts the creation of CellML intermediate field. \see OpenCMISS::Iron::cmfe_CellML_IntermediateFieldCreateFinish
  INTERFACE cmfe_CellML_IntermediateFieldCreateStart
    MODULE PROCEDURE cmfe_CellML_IntermediateFieldCreateStartNumber
    MODULE PROCEDURE cmfe_CellML_IntermediateFieldCreateStartObj
  END INTERFACE cmfe_CellML_IntermediateFieldCreateStart

  !>Returns the CellML intermediate field for a CellML environment.
  INTERFACE cmfe_CellML_IntermediateFieldGet
    MODULE PROCEDURE cmfe_CellML_IntermediateFieldGetNumber
    MODULE PROCEDURE cmfe_CellML_IntermediateFieldGetObj
  END INTERFACE cmfe_CellML_IntermediateFieldGet

  !>Finishes the creation of CellML parameters field. \see OpenCMISS::Iron::cmfe_CellML_ParametersFieldCreateStart
  INTERFACE cmfe_CellML_ParametersFieldCreateFinish
    MODULE PROCEDURE cmfe_CellML_ParametersFieldCreateFinishNumber
    MODULE PROCEDURE cmfe_CellML_ParametersFieldCreateFinishObj
  END INTERFACE cmfe_CellML_ParametersFieldCreateFinish

  !>Starts the creation of CellML parameters field. \see OpenCMISS::Iron::cmfe_CellML_ParametersFieldCreateFinish
  INTERFACE cmfe_CellML_ParametersFieldCreateStart
    MODULE PROCEDURE cmfe_CellML_ParametersFieldCreateStartNumber
    MODULE PROCEDURE cmfe_CellML_ParametersFieldCreateStartObj
  END INTERFACE cmfe_CellML_ParametersFieldCreateStart

  !>Returns the CellML parameters field for a CellML environment.
  INTERFACE cmfe_CellML_ParametersFieldGet
    MODULE PROCEDURE cmfe_CellML_ParametersFieldGetNumber
    MODULE PROCEDURE cmfe_CellML_ParametersFieldGetObj
  END INTERFACE cmfe_CellML_ParametersFieldGet

  !>Validate and instantiate the specified CellML environment.
  INTERFACE cmfe_CellML_Generate
    MODULE PROCEDURE cmfe_CellML_GenerateNumber
    MODULE PROCEDURE cmfe_CellML_GenerateObj
  END INTERFACE cmfe_CellML_Generate

  PUBLIC CMFE_CELLML_MODELS_FIELD,CMFE_CELLML_STATE_FIELD,CMFE_CELLML_INTERMEDIATE_FIELD,CMFE_CELLML_PARAMETERS_FIELD

  PUBLIC cmfe_CellML_VariableSetAsKnown,cmfe_CellML_VariableSetAsWanted

  PUBLIC cmfe_CellML_CreateCellMLToFieldMap,cmfe_CellML_CreateFieldToCellMLMap

  PUBLIC cmfe_CellML_CreateFinish,cmfe_CellML_CreateStart

  PUBLIC cmfe_CellML_Destroy

  PUBLIC cmfe_CellML_FieldMapsCreateStart,cmfe_CellML_FieldMapsCreateFinish

  PUBLIC cmfe_CellML_ModelImport

  PUBLIC cmfe_CellML_ModelsFieldCreateFinish,cmfe_CellML_ModelsFieldCreateStart,cmfe_CellML_ModelsFieldGet

  PUBLIC cmfe_CellML_StateFieldCreateFinish,cmfe_CellML_StateFieldCreateStart,cmfe_CellML_StateFieldGet

  PUBLIC cmfe_CellML_FieldComponentGet

  PUBLIC cmfe_CellML_IntermediateFieldCreateFinish,cmfe_CellML_IntermediateFieldCreateStart

  PUBLIC cmfe_CellML_IntermediateFieldGet

  PUBLIC cmfe_CellML_ParametersFieldCreateFinish,cmfe_CellML_ParametersFieldCreateStart,cmfe_CellML_ParametersFieldGet

  PUBLIC cmfe_CellML_Generate

!!==================================================================================================================================
!!
!! COMP_ENVIRONMENT
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  PUBLIC cmfe_ComputationalNodeNumberGet

  PUBLIC cmfe_ComputationalNumberOfNodesGet

  PUBLIC cmfe_ComputationalWorkGroup_CreateStart

  PUBLIC cmfe_ComputationalWorkGroup_CreateFinish

  PUBLIC cmfe_ComputationalWorkGroup_SubgroupAdd

  PUBLIC cmfe_Decomposition_WorldWorkGroupSet
!!==================================================================================================================================
!!
!! CONSTANTS
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_Constants OPENCMISS::Constants
  !> \brief Control loops constants.
  !>@{
  !> \addtogroup OPENCMISS_GlobalDerivativeConstants OPENCMISS::Constants::GlobalDerivativeConstants
  !> \brief Global derivative constant identifiers
  !> \see OPENCMISS_CONSTANTS,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_NO_GLOBAL_DERIV = NO_GLOBAL_DERIV !<No global derivative i.e., u \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GLOBAL_DERIV_S1 = GLOBAL_DERIV_S1 !<First global derivative in the s1 direction i.e., du/ds1 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GLOBAL_DERIV_S2 = GLOBAL_DERIV_S2 !<First global derivative in the s2 direction i.e., du/ds2 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GLOBAL_DERIV_S1_S2 = GLOBAL_DERIV_S1_S2 !<Global Cross derivative in the s1 and s2 direction i.e., d^2u/ds1ds2 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GLOBAL_DERIV_S3 = GLOBAL_DERIV_S3 !<First global derivative in the s3 direction i.e., du/ds3 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GLOBAL_DERIV_S1_S3 = GLOBAL_DERIV_S1_S3 !<Global Cross derivative in the s1 and s3 direction i.e., d^2u/ds1ds3 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GLOBAL_DERIV_S2_S3 = GLOBAL_DERIV_S2_S3 !<Global Cross derivative in the s2 and s3 direction i.e., d^2u/ds2ds3 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GLOBAL_DERIV_S1_S2_S3 = GLOBAL_DERIV_S1_S2_S3 !<Cross derivative in the s1, s2 and s3 direction i.e., d^3u/ds1ds2ds3 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMFE_NO_GLOBAL_DERIV,CMFE_GLOBAL_DERIV_S1,CMFE_GLOBAL_DERIV_S2,CMFE_GLOBAL_DERIV_S1_S2, &
    & CMFE_GLOBAL_DERIV_S3,CMFE_GLOBAL_DERIV_S1_S3,CMFE_GLOBAL_DERIV_S2_S3,CMFE_GLOBAL_DERIV_S1_S2_S3

!!==================================================================================================================================
!!
!! CONTROL_LOOP_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_ControlLoopConstants OPENCMISS::ControlLoop::Constants
  !> \brief Control loops constants.
  !>@{
  !> \addtogroup OPENCMISS_ControlLoopIdentifiers OPENCMISS::ControlLoop::Identifiers
  !> \brief The control loop identification parameters.
  !> \see OPENCMISS::ControlLoop,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_CONTROL_LOOP_NODE = CONTROL_LOOP_NODE !<The identifier for a each "leaf" node in a control loop. \see OPENCMISS_ControlLoopIdentifiers,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_ControlLoopOutputTypes OPENCMISS::ControlLoop::OutputTypes
  !> \brief The control loop output types.
  !> \see OPENCMISS::ControlLoop,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_CONTROL_LOOP_NO_OUTPUT = CONTROL_LOOP_NO_OUTPUT !<No output from the control loop. \see OPENCMISS_ControlLoopOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_CONTROL_LOOP_PROGRESS_OUTPUT = CONTROL_LOOP_PROGRESS_OUTPUT !<Progress output from the control loop. \see OPENCMISS_ControlLoopOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_CONTROL_LOOP_TIMING_OUTPUT = CONTROL_LOOP_TIMING_OUTPUT !<Timing output from the control loop. \see OPENCMISS_ControlLoopOutputTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the current time parameters for a time control loop.
  INTERFACE cmfe_ControlLoop_CurrentTimesGet
    MODULE PROCEDURE cmfe_ControlLoop_CurrentTimesGetNumber0
    MODULE PROCEDURE cmfe_ControlLoop_CurrentTimesGetNumber1
    MODULE PROCEDURE cmfe_ControlLoop_CurrentTimesGetObj
  END INTERFACE cmfe_ControlLoop_CurrentTimesGet

  !>Destroy a control loop.
  INTERFACE cmfe_ControlLoop_Destroy
    MODULE PROCEDURE cmfe_ControlLoop_DestroyNumber0
    MODULE PROCEDURE cmfe_ControlLoop_DestroyNumber1
    MODULE PROCEDURE cmfe_ControlLoop_DestroyObj
  END INTERFACE cmfe_ControlLoop_Destroy

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root.
  INTERFACE cmfe_ControlLoop_ControlLoopGet
    MODULE PROCEDURE cmfe_ControlLoop_ControlLoopGetNumber00
    MODULE PROCEDURE cmfe_ControlLoop_ControlLoopGetNumber10
    MODULE PROCEDURE cmfe_ControlLoop_ControlLoopGetNumber01
    MODULE PROCEDURE cmfe_ControlLoop_ControlLoopGetNumber11
    MODULE PROCEDURE cmfe_ControlLoop_ControlLoopGetObj0
    MODULE PROCEDURE cmfe_ControlLoop_ControlLoopGetObj1
  END INTERFACE cmfe_ControlLoop_ControlLoopGet

  !>Sets/changes the iteration parameters for a fixed control loop. \todo need a get metod
  INTERFACE cmfe_ControlLoop_IterationsSet
    MODULE PROCEDURE cmfe_ControlLoop_IterationsSetNumber0
    MODULE PROCEDURE cmfe_ControlLoop_IterationsSetNumber1
    MODULE PROCEDURE cmfe_ControlLoop_IterationsSetObj
  END INTERFACE cmfe_ControlLoop_IterationsSet

  !>Returns the label of a control loop.
  INTERFACE cmfe_ControlLoop_LabelGet
    MODULE PROCEDURE cmfe_ControlLoop_LabelGetCNumber0
    MODULE PROCEDURE cmfe_ControlLoop_LabelGetCNumber1
    MODULE PROCEDURE cmfe_ControlLoop_LabelGetCObj
    MODULE PROCEDURE cmfe_ControlLoop_LabelGetVSNumber0
    MODULE PROCEDURE cmfe_ControlLoop_LabelGetVSNumber1
    MODULE PROCEDURE cmfe_ControlLoop_LabelGetVSObj
  END INTERFACE cmfe_ControlLoop_LabelGet

  !>Sets/changes the label of a control loop.
  INTERFACE cmfe_ControlLoop_LabelSet
    MODULE PROCEDURE cmfe_ControlLoop_LabelSetCNumber0
    MODULE PROCEDURE cmfe_ControlLoop_LabelSetCNumber1
    MODULE PROCEDURE cmfe_ControlLoop_LabelSetCObj
    MODULE PROCEDURE cmfe_ControlLoop_LabelSetVSNumber0
    MODULE PROCEDURE cmfe_ControlLoop_LabelSetVSNumber1
    MODULE PROCEDURE cmfe_ControlLoop_LabelSetVSObj
  END INTERFACE cmfe_ControlLoop_LabelSet

  !>Sets/changes the maximum iterations for a while control loop. \todo need a get method
  INTERFACE cmfe_ControlLoop_MaximumIterationsSet
    MODULE PROCEDURE cmfe_ControlLoop_MaximumIterationsSetNumber0
    MODULE PROCEDURE cmfe_ControlLoop_MaximumIterationsSetNumber1
    MODULE PROCEDURE cmfe_ControlLoop_MaximumIterationsSetObj
  END INTERFACE cmfe_ControlLoop_MaximumIterationsSet

  !>Sets/changes the convergence tolerance for a while control loop. \todo need a get method
  INTERFACE cmfe_ControlLoop_AbsoluteToleranceSet
    MODULE PROCEDURE cmfe_ControlLoop_AbsoluteToleranceSetNumber0
    MODULE PROCEDURE cmfe_ControlLoop_AbsoluteToleranceSetNumber1
    MODULE PROCEDURE cmfe_ControlLoop_AbsoluteToleranceSetObj
  END INTERFACE cmfe_ControlLoop_AbsoluteToleranceSet

  !>Returns the number of sub loops for a control loop.
  INTERFACE cmfe_ControlLoop_NumberOfSubLoopsGet
    MODULE PROCEDURE cmfe_ControlLoop_NumberOfSubLoopsGetNumber0
    MODULE PROCEDURE cmfe_ControlLoop_NumberOfSubLoopsGetNumber1
    MODULE PROCEDURE cmfe_ControlLoop_NumberOfSubLoopsGetObj
  END INTERFACE cmfe_ControlLoop_NumberOfSubLoopsGet

  !>Sets/changes the number of sub loops for a control loop. \todo is this really a public method???
  INTERFACE cmfe_ControlLoop_NumberOfSubLoopsSet
    MODULE PROCEDURE cmfe_ControlLoop_NumberOfSubLoopsSetNumber0
    MODULE PROCEDURE cmfe_ControlLoop_NumberOfSubLoopsSetNumber1
    MODULE PROCEDURE cmfe_ControlLoop_NumberOfSubLoopsSetObj
  END INTERFACE cmfe_ControlLoop_NumberOfSubLoopsSet

  !>Sets/changes the output parameters for a time control loop.
  INTERFACE cmfe_ControlLoop_TimeOutputSet
    MODULE PROCEDURE cmfe_ControlLoop_TimeOutputSetNumber0
    MODULE PROCEDURE cmfe_ControlLoop_TimeOutputSetNumber1
    MODULE PROCEDURE cmfe_ControlLoop_TimeOutputSetObj
  END INTERFACE cmfe_ControlLoop_TimeOutputSet

  !>Returns the output type for a control loop.
  INTERFACE cmfe_ControlLoop_OutputTypeGet
    MODULE PROCEDURE cmfe_ControlLoop_OutputTypeGetNumber0
    MODULE PROCEDURE cmfe_ControlLoop_OutputTypeGetNumber1
    MODULE PROCEDURE cmfe_ControlLoop_OutputTypeGetObj
  END INTERFACE cmfe_ControlLoop_OutputTypeGet

  !>Sets/changes the output type for a control loop.
  INTERFACE cmfe_ControlLoop_OutputTypeSet
    MODULE PROCEDURE cmfe_ControlLoop_OutputTypeSetNumber0
    MODULE PROCEDURE cmfe_ControlLoop_OutputTypeSetNumber1
    MODULE PROCEDURE cmfe_ControlLoop_OutputTypeSetObj
  END INTERFACE cmfe_ControlLoop_OutputTypeSet

  !>Sets/changes the input parameters for a time control loop.
  INTERFACE cmfe_ControlLoop_TimeInputSet
    MODULE PROCEDURE cmfe_ControlLoop_TimeInputSetNumber0
    MODULE PROCEDURE cmfe_ControlLoop_TimeInputSetNumber1
    MODULE PROCEDURE cmfe_ControlLoop_TimeInputSetObj
  END INTERFACE cmfe_ControlLoop_TimeInputSet

  !>Returns the time parameters for a time control loop.
  INTERFACE cmfe_ControlLoop_TimesGet
    MODULE PROCEDURE cmfe_ControlLoop_TimesGetNumber0
    MODULE PROCEDURE cmfe_ControlLoop_TimesGetNumber1
    MODULE PROCEDURE cmfe_ControlLoop_TimesGetObj
  END INTERFACE cmfe_ControlLoop_TimesGet

  !>Sets/Changes the time parameters for a time control loop.
  INTERFACE cmfe_ControlLoop_TimesSet
    MODULE PROCEDURE cmfe_ControlLoop_TimesSetNumber0
    MODULE PROCEDURE cmfe_ControlLoop_TimesSetNumber1
    MODULE PROCEDURE cmfe_ControlLoop_TimesSetObj
  END INTERFACE cmfe_ControlLoop_TimesSet

  !>Sets/Changes the loop type for a control loop. \todo Is this really a public       method? \todo need a get method
  INTERFACE cmfe_ControlLoop_TypeSet
    MODULE PROCEDURE cmfe_ControlLoop_TypeSetNumber0
    MODULE PROCEDURE cmfe_ControlLoop_TypeSetNumber1
    MODULE PROCEDURE cmfe_ControlLoop_TypeSetObj
  END INTERFACE cmfe_ControlLoop_TypeSet

  PUBLIC CMFE_CONTROL_LOOP_NODE

  PUBLIC CMFE_CONTROL_LOOP_NO_OUTPUT,CMFE_CONTROL_LOOP_PROGRESS_OUTPUT,CMFE_CONTROL_LOOP_TIMING_OUTPUT

  PUBLIC cmfe_ControlLoop_CurrentTimesGet

  PUBLIC cmfe_ControlLoop_Destroy

  PUBLIC cmfe_ControlLoop_ControlLoopGet

  PUBLIC cmfe_ControlLoop_IterationsSet

  PUBLIC cmfe_ControlLoop_LabelGet,cmfe_ControlLoop_LabelSet

  PUBLIC cmfe_ControlLoop_MaximumIterationsSet

  PUBLIC cmfe_ControlLoop_AbsoluteToleranceSet

  PUBLIC cmfe_ControlLoop_NumberOfSubLoopsGet,cmfe_ControlLoop_NumberOfSubLoopsSet

  PUBLIC cmfe_ControlLoop_OutputTypeGet,cmfe_ControlLoop_OutputTypeSet

  PUBLIC cmfe_ControlLoop_TimeOutputSet,cmfe_ControlLoop_TimeInputSet

  PUBLIC cmfe_ControlLoop_TimesGet,cmfe_ControlLoop_TimesSet

  PUBLIC cmfe_ControlLoop_TypeSet


!!==================================================================================================================================
!!
!! COORDINATE_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_CoordinateConstants OPENCMISS::Coordinate::Constants
  !> \brief Coordinate constants.
  !>@{
  !> \addtogroup OPENCMISS_CoordinateSystemTypes OPENCMISS::Coordinate::SystemTypes
  !> \brief Coordinate system type parameters.
  !> \see OPENCMISS::Coordinate,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_RECTANGULAR_CARTESIAN_TYPE = COORDINATE_RECTANGULAR_CARTESIAN_TYPE !<Rectangular Cartesian coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_CYLINDRICAL_POLAR_TYPE = COORDINATE_CYLINDRICAL_POLAR_TYPE !<Cylindrical polar coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_SPHERICAL_POLAR_TYPE = COORDINATE_SPHERICAL_POLAR_TYPE !<Spherical polar coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_PROLATE_SPHEROIDAL_TYPE = COORDINATE_PROLATE_SPHEROIDAL_TYPE !<Prolate spheroidal coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_OBLATE_SPHEROIDAL_TYPE = COORDINATE_OBLATE_SPHEROIDAL_TYPE !<Oblate spheroidal coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_CoordinateRadialInterpolations OPENCMISS::Coordinate::RadialInterpolations
  !> \brief The type of radial interpolation for polar coordinate systems
  !> \see OPENCMISS::Coordinate,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_NO_RADIAL_INTERPOLATION_TYPE = COORDINATE_NO_RADIAL_INTERPOLATION_TYPE !<No radial interpolation \see OPENCMISS_CoordinateRadialInterpolations,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_RADIAL_INTERPOLATION_TYPE = COORDINATE_RADIAL_INTERPOLATION_TYPE !<r radial interpolation \see OPENCMISS_CoordinateRadialInterpolations,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_RADIAL_SQUARED_INTERPOLATION_TYPE = COORDINATE_RADIAL_SQUARED_INTERPOLATION_TYPE !<r^2 radial interpolation \see OPENCMISS_CoordinateRadialInterpolations,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_COORDINATE_RADIAL_CUBED_INTERPOLATION_TYPE = COORDINATE_RADIAL_CUBED_INTERPOLATION_TYPE !<r^3 radial interpolation \see OPENCMISS_CoordinateRadialInterpolations,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the creation of a coordinate system. \see OpenCMISS::Iron::cmfe_CoordinateSystem_CreateStart
  INTERFACE cmfe_CoordinateSystem_CreateFinish
    MODULE PROCEDURE cmfe_CoordinateSystem_CreateFinishNumber
    MODULE PROCEDURE cmfe_CoordinateSystem_CreateFinishObj
  END INTERFACE cmfe_CoordinateSystem_CreateFinish

  !>Starts the creation of a coordinate system. \see OpenCMISS::Iron::cmfe_CoordinateSystem_CreateFinish
  INTERFACE cmfe_CoordinateSystem_CreateStart
    MODULE PROCEDURE cmfe_CoordinateSystem_CreateStartNumber
    MODULE PROCEDURE cmfe_CoordinateSystem_CreateStartObj
  END INTERFACE cmfe_CoordinateSystem_CreateStart

  !>Destorys a coordinate system.
  INTERFACE cmfe_CoordinateSystem_Destroy
    MODULE PROCEDURE cmfe_CoordinateSystem_DestroyNumber
    MODULE PROCEDURE cmfe_CoordinateSystem_DestroyObj
  END INTERFACE cmfe_CoordinateSystem_Destroy

  !>Returns the coordinate system dimension. \todo user number method \todo fix pointers
  INTERFACE cmfe_CoordinateSystem_DimensionGet
    MODULE PROCEDURE cmfe_CoordinateSystem_DimensionGetNumber
    MODULE PROCEDURE cmfe_CoordinateSystem_DimensionGetObj
  END INTERFACE cmfe_CoordinateSystem_DimensionGet

  !>Sets/changes the coordinate system dimension. \todo fix pointers
  INTERFACE cmfe_CoordinateSystem_DimensionSet
    MODULE PROCEDURE cmfe_CoordinateSystem_DimensionSetNumber
    MODULE PROCEDURE cmfe_CoordinateSystem_DimensionSetObj
  END INTERFACE cmfe_CoordinateSystem_DimensionSet

  !>Returns the coordinate system focus. \todo user number method \todo fix pointers
  INTERFACE cmfe_CoordinateSystem_FocusGet
    MODULE PROCEDURE cmfe_CoordinateSystem_FocusGetNumber
    MODULE PROCEDURE cmfe_CoordinateSystem_FocusGetObj
  END INTERFACE cmfe_CoordinateSystem_FocusGet

  !>Sets/changes the coordinate system focus. \todo user number method \todo fix pointers
  INTERFACE cmfe_CoordinateSystem_FocusSet
    MODULE PROCEDURE cmfe_CoordinateSystem_FocusSetNumber
    MODULE PROCEDURE cmfe_CoordinateSystem_FocusSetObj
  END INTERFACE cmfe_CoordinateSystem_FocusSet

  !>Returns the coordinate system radial interpolation type. \todo user number method \todo fix pointers
  INTERFACE cmfe_CoordinateSystem_RadialInterpolationGet
    MODULE PROCEDURE cmfe_CoordinateSystem_RadialInterpolationGetNumber
    MODULE PROCEDURE cmfe_CoordinateSystem_RadialInterpolationGetObj
  END INTERFACE cmfe_CoordinateSystem_RadialInterpolationGet

  !>Sets/changes the coordinate system radial interpolation type. \todo user number method \todo fix pointers
  INTERFACE cmfe_CoordinateSystem_RadialInterpolationSet
    MODULE PROCEDURE cmfe_CoordinateSystem_RadialInterpolationSetNumber
    MODULE PROCEDURE cmfe_CoordinateSystem_RadialInterpolationSetObj
  END INTERFACE cmfe_CoordinateSystem_RadialInterpolationSet

  !>Returns the coordinate system type. \todo user number method \todo fix pointers
  INTERFACE cmfe_CoordinateSystem_TypeGet
    MODULE PROCEDURE cmfe_CoordinateSystem_TypeGetNumber
    MODULE PROCEDURE cmfe_CoordinateSystem_TypeGetObj
  END INTERFACE cmfe_CoordinateSystem_TypeGet

  !>Sets/changes the coordinate system type. \todo user number method \todo fix pointers
  INTERFACE cmfe_CoordinateSystem_TypeSet
    MODULE PROCEDURE cmfe_CoordinateSystem_TypeSetNumber
    MODULE PROCEDURE cmfe_CoordinateSystem_TypeSetObj
  END INTERFACE cmfe_CoordinateSystem_TypeSet

  !>Returns the coordinate system orign.
  INTERFACE cmfe_CoordinateSystem_OriginGet
    MODULE PROCEDURE cmfe_CoordinateSystem_OriginGetNumber
    MODULE PROCEDURE cmfe_CoordinateSystem_OriginGetObj
  END INTERFACE cmfe_CoordinateSystem_OriginGet

  !>Sets/changes the coordinate system orign.
  INTERFACE cmfe_CoordinateSystem_OriginSet
    MODULE PROCEDURE cmfe_CoordinateSystem_OriginSetNumber
    MODULE PROCEDURE cmfe_CoordinateSystem_OriginSetObj
  END INTERFACE cmfe_CoordinateSystem_OriginSet

  !>Returns the coordinate system orientation.
  INTERFACE cmfe_CoordinateSystem_OrientationGet
    MODULE PROCEDURE cmfe_CoordinateSystem_OrientationGetNumber
    MODULE PROCEDURE cmfe_CoordinateSystem_OrientationGetObj
  END INTERFACE cmfe_CoordinateSystem_OrientationGet

  !>Sets/changes the coordinate system orientation.
  INTERFACE cmfe_CoordinateSystem_OrientationSet
    MODULE PROCEDURE cmfe_CoordinateSystem_OrientationSetNumber
    MODULE PROCEDURE cmfe_CoordinateSystem_OrientationSetObj
  END INTERFACE cmfe_CoordinateSystem_OrientationSet

  PUBLIC CMFE_COORDINATE_RECTANGULAR_CARTESIAN_TYPE,CMFE_COORDINATE_CYLINDRICAL_POLAR_TYPE, &
    & CMFE_COORDINATE_SPHERICAL_POLAR_TYPE, &
    & CMFE_COORDINATE_PROLATE_SPHEROIDAL_TYPE,CMFE_COORDINATE_OBLATE_SPHEROIDAL_TYPE

  PUBLIC CMFE_COORDINATE_NO_RADIAL_INTERPOLATION_TYPE,CMFE_COORDINATE_RADIAL_INTERPOLATION_TYPE, &
    & CMFE_COORDINATE_RADIAL_SQUARED_INTERPOLATION_TYPE,CMFE_COORDINATE_RADIAL_CUBED_INTERPOLATION_TYPE

  PUBLIC cmfe_CoordinateSystem_CreateFinish,cmfe_CoordinateSystem_CreateStart

  PUBLIC cmfe_CoordinateSystem_Destroy

  PUBLIC cmfe_CoordinateSystem_DimensionGet,cmfe_CoordinateSystem_DimensionSet

  PUBLIC cmfe_CoordinateSystem_FocusGet,cmfe_CoordinateSystem_FocusSet

  PUBLIC cmfe_CoordinateSystem_RadialInterpolationGet,cmfe_CoordinateSystem_RadialInterpolationSet

  PUBLIC cmfe_CoordinateSystem_TypeGet,cmfe_CoordinateSystem_TypeSet

  PUBLIC cmfe_CoordinateSystem_OriginGet,cmfe_CoordinateSystem_OriginSet

  PUBLIC cmfe_CoordinateSystem_OrientationGet,cmfe_CoordinateSystem_OrientationSet

!!==================================================================================================================================
!!
!! DATA_POINT_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the process of creating data points in a region. \see OpenCMISS::Iron::cmfe_DataPoints_CreateStart
  INTERFACE cmfe_DataPoints_CreateFinish
    MODULE PROCEDURE cmfe_DataPoints_CreateFinishNumber
    MODULE PROCEDURE cmfe_DataPoints_CreateFinishObj
  END INTERFACE cmfe_DataPoints_CreateFinish

  !>Starts the process of creating data points in a region. \see OpenCMISS::Iron::cmfe_DataPoints_CreateFinish
  INTERFACE cmfe_DataPoints_CreateStart
    MODULE PROCEDURE cmfe_DataPoints_CreateStartNumber
    MODULE PROCEDURE cmfe_DataPoints_CreateStartObj
    MODULE PROCEDURE cmfe_DataPoints_CreateStartInterfaceObj
  END INTERFACE cmfe_DataPoints_CreateStart

  !>Destroys data points.
  INTERFACE cmfe_DataPoints_Destroy
    MODULE PROCEDURE cmfe_DataPoints_DestroyNumber
    MODULE PROCEDURE cmfe_DataPoints_DestroyObj
  END INTERFACE cmfe_DataPoints_Destroy

  !>Returns the number of data points
  INTERFACE cmfe_DataPoints_NumberOfDataPointsGet
    MODULE PROCEDURE cmfe_DataPoints_NumberOfDataPointsGetNumber
    MODULE PROCEDURE cmfe_DataPoints_NumberOfDataPointsGetObj
  END INTERFACE cmfe_DataPoints_NumberOfDataPointsGet

  !>Returns the label for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE cmfe_DataPoints_LabelGet
    MODULE PROCEDURE cmfe_DataPoints_LabelGetCNumber
    MODULE PROCEDURE cmfe_DataPoints_LabelGetCObj
    MODULE PROCEDURE cmfe_DataPoints_LabelGetVSNumber
    MODULE PROCEDURE cmfe_DataPoints_LabelGetVSObj
  END INTERFACE cmfe_DataPoints_LabelGet

  !>Sets/changes the label for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE cmfe_DataPoints_LabelSet
    MODULE PROCEDURE cmfe_DataPoints_LabelSetCNumber
    MODULE PROCEDURE cmfe_DataPoints_LabelSetCObj
    MODULE PROCEDURE cmfe_DataPoints_LabelSetVSNumber
    MODULE PROCEDURE cmfe_DataPoints_LabelSetVSObj
  END INTERFACE cmfe_DataPoints_LabelSet

  !>Returns the user number for a data point identified by a given global number.
  INTERFACE cmfe_DataPoints_UserNumberGet
    MODULE PROCEDURE cmfe_DataPoints_UserNumberGetNumber
    MODULE PROCEDURE cmfe_DataPoints_UserNumberGetObj
  END INTERFACE cmfe_DataPoints_UserNumberGet

  !>Sets/changes the user number for a data point identified by a given global number.
  INTERFACE cmfe_DataPoints_UserNumberSet
    MODULE PROCEDURE cmfe_DataPoints_UserNumberSetNumber
    MODULE PROCEDURE cmfe_DataPoints_UserNumberSetObj
  END INTERFACE cmfe_DataPoints_UserNumberSet

  !>Returns the values for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE cmfe_DataPoints_ValuesGet
    MODULE PROCEDURE cmfe_DataPoints_ValuesGetNumber
    MODULE PROCEDURE cmfe_DataPoints_ValuesGetObj
  END INTERFACE cmfe_DataPoints_ValuesGet

  !>Sets/changes the values for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE cmfe_DataPoints_ValuesSet
    MODULE PROCEDURE cmfe_DataPoints_ValuesSetNumber
    MODULE PROCEDURE cmfe_DataPoints_ValuesSetObj
  END INTERFACE cmfe_DataPoints_ValuesSet

  !>Returns the weights for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE cmfe_DataPoints_WeightsGet
    MODULE PROCEDURE cmfe_DataPoints_WeightsGetNumber
    MODULE PROCEDURE cmfe_DataPoints_WeightsGetObj
  END INTERFACE cmfe_DataPoints_WeightsGet

  !>Sets/changes the weights for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE cmfe_DataPoints_WeightsSet
    MODULE PROCEDURE cmfe_DataPoints_WeightsSetNumber
    MODULE PROCEDURE cmfe_DataPoints_WeightsSetObj
  END INTERFACE cmfe_DataPoints_WeightsSet

  PUBLIC cmfe_DataPoints_CreateFinish,cmfe_DataPoints_CreateStart

  PUBLIC cmfe_DataPoints_Destroy

  PUBLIC cmfe_DataPoints_NumberOfDataPointsGet

  PUBLIC cmfe_DataPoints_LabelGet,cmfe_DataPoints_LabelSet

  PUBLIC cmfe_DataPoints_UserNumberGet,cmfe_DataPoints_UserNumberSet

  PUBLIC cmfe_DataPoints_ValuesGet,cmfe_DataPoints_ValuesSet

  PUBLIC cmfe_DataPoints_WeightsGet,cmfe_DataPoints_WeightsSet

!!==================================================================================================================================
!!
!! DATA_PROJECTION_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_DataProjectionConstants OPENCMISS::DataProjection::Constants
  !> \brief DataProjection  constants.
  !>@{
  !> \addtogroup OPENCMISS_DataProjectionProjectionTypes OPENCMISS::DataProjection::ProjectionTypes
  !> \brief Data Projection types
  !> \see OPENCMISS::DataProjection,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_DATA_PROJECTION_BOUNDARY_LINES_PROJECTION_TYPE = DATA_PROJECTION_BOUNDARY_LINES_PROJECTION_TYPE!<The boundary line projection type for data projection, only projects to boundary lines of the mesh. \see OPENCMISS_DataProjectionProjectionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_DATA_PROJECTION_BOUNDARY_FACES_PROJECTION_TYPE = DATA_PROJECTION_BOUNDARY_FACES_PROJECTION_TYPE!<The boundary face projection type for data projection, only projects to boundary faces of the mesh. \see OPENCMISS_DataProjectionProjectionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_DATA_PROJECTION_ALL_ELEMENTS_PROJECTION_TYPE = DATA_PROJECTION_ALL_ELEMENTS_PROJECTION_TYPE !<The element projection type for data projection, projects to all elements in mesh. \see OPENCMISS_DataProjectionProjectionTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the absolute tolerance for a data projection.
  INTERFACE cmfe_DataProjection_AbsoluteToleranceGet
    MODULE PROCEDURE cmfe_DataProjection_AbsoluteToleranceGetNumber
    MODULE PROCEDURE cmfe_DataProjection_AbsoluteToleranceGetObj
  END INTERFACE cmfe_DataProjection_AbsoluteToleranceGet

  !>Sets/changes the absolute tolerance for a data projection.
  INTERFACE cmfe_DataProjection_AbsoluteToleranceSet
    MODULE PROCEDURE cmfe_DataProjection_AbsoluteToleranceSetNumber
    MODULE PROCEDURE cmfe_DataProjection_AbsoluteToleranceSetObj
  END INTERFACE cmfe_DataProjection_AbsoluteToleranceSet

  !>Finishes the creation of a new data projection. \see OpenCMISS::Iron::cmfe_DataProjection_CreateStart
  INTERFACE cmfe_DataProjection_CreateFinish
    MODULE PROCEDURE cmfe_DataProjection_CreateFinishNumber
    MODULE PROCEDURE cmfe_DataProjection_CreateFinishObj
  END INTERFACE cmfe_DataProjection_CreateFinish

  !>Starts the creation of a new data projection. \see OpenCMISS::Iron::cmfe_DataProjection_CreateFinish
  INTERFACE cmfe_DataProjection_CreateStart
    MODULE PROCEDURE cmfe_DataProjection_CreateStartNumber
    MODULE PROCEDURE cmfe_DataProjection_CreateStartObj
  END INTERFACE cmfe_DataProjection_CreateStart

  !>Destroy a data projection.
  INTERFACE cmfe_DataProjection_Destroy
    MODULE PROCEDURE cmfe_DataProjection_DestroyNumber
    MODULE PROCEDURE cmfe_DataProjection_DestroyObj
  END INTERFACE cmfe_DataProjection_Destroy
  
  !>Evaluate the data points position in a field based on data projection
  INTERFACE cmfe_DataProjection_DataPointsPositionEvaluate
    MODULE PROCEDURE cmfe_DataProjection_DataPointsPositionEvaluateRegionNumber
    MODULE PROCEDURE cmfe_DataProjection_DataPointsPositionEvaluateInterfaceNumber
    MODULE PROCEDURE cmfe_DataProjection_DataPointsPositionEvaluateObj
  END INTERFACE cmfe_DataProjection_DataPointsPositionEvaluate

  !>Starts the evluation of data projection on the geometric field.
  INTERFACE cmfe_DataProjection_DataPointsProjectionEvaluate
    MODULE PROCEDURE cmfe_DataProjection_DataPointsProjectionEvaluateNumber
    MODULE PROCEDURE cmfe_DataProjection_DataPointsProjectionEvaluateObj
  END INTERFACE cmfe_DataProjection_DataPointsProjectionEvaluate

  !>Returns the maximum iteration update for a data projection.
  INTERFACE cmfe_DataProjection_MaximumIterationUpdateGet
    MODULE PROCEDURE cmfe_DataProjection_MaximumIterationUpdateGetNumber
    MODULE PROCEDURE cmfe_DataProjection_MaximumIterationUpdateGetObj
  END INTERFACE cmfe_DataProjection_MaximumIterationUpdateGet

  !>Sets/changes the maximum iteration update for a data projection.
  INTERFACE cmfe_DataProjection_MaximumIterationUpdateSet
    MODULE PROCEDURE cmfe_DataProjection_MaximumIterationUpdateSetNumber
    MODULE PROCEDURE cmfe_DataProjection_MaximumIterationUpdateSetObj
  END INTERFACE cmfe_DataProjection_MaximumIterationUpdateSet

  !>Returns the maximum number of iterations for a data projection.
  INTERFACE cmfe_DataProjection_MaximumNumberOfIterationsGet
    MODULE PROCEDURE cmfe_DataProjection_MaximumNumberOfIterationsGetNumber
    MODULE PROCEDURE cmfe_DataProjection_MaximumNumberOfIterationsGetObj
  END INTERFACE cmfe_DataProjection_MaximumNumberOfIterationsGet

  !>Sets/changes the maximum number of iterations for a data projection.
  INTERFACE cmfe_DataProjection_MaximumNumberOfIterationsSet
    MODULE PROCEDURE cmfe_DataProjection_MaximumNumberOfIterationsSetNumber
    MODULE PROCEDURE cmfe_DataProjection_MaximumNumberOfIterationsSetObj
  END INTERFACE cmfe_DataProjection_MaximumNumberOfIterationsSet

  !>Returns the number of closest elements for a data projection.
  INTERFACE cmfe_DataProjection_NumberOfClosestElementsGet
    MODULE PROCEDURE cmfe_DataProjection_NumberOfClosestElementsGetNumber
    MODULE PROCEDURE cmfe_DataProjection_NumberOfClosestElementsGetObj
  END INTERFACE cmfe_DataProjection_NumberOfClosestElementsGet

  !>Sets/changes the number of closest elements for a data projection.
  INTERFACE cmfe_DataProjection_NumberOfClosestElementsSet
    MODULE PROCEDURE cmfe_DataProjection_NumberOfClosestElementsSetNumber
    MODULE PROCEDURE cmfe_DataProjection_NumberOfClosestElementsSetObj
  END INTERFACE cmfe_DataProjection_NumberOfClosestElementsSet
  
  !>Set the candidate element numbers and their local face/line numbers
  INTERFACE cmfe_DataProjection_ProjectionCandidatesSet
    MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidatesSetRegionNumber
    MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidatesSetInterfaceNumber
    MODULE PROCEDURE cmfe_DataProjection_ProjectionCandidatesSetObj
  END INTERFACE cmfe_DataProjection_ProjectionCandidatesSet

  !>Returns the projection type for a data projection.
  INTERFACE cmfe_DataProjection_ProjectionTypeGet
    MODULE PROCEDURE cmfe_DataProjection_ProjectionTypeGetNumber
    MODULE PROCEDURE cmfe_DataProjection_ProjectionTypeGetObj
  END INTERFACE cmfe_DataProjection_ProjectionTypeGet

  !>Sets/changes the projection type for a data projection.
  INTERFACE cmfe_DataProjection_ProjectionTypeSet
    MODULE PROCEDURE cmfe_DataProjection_ProjectionTypeSetNumber
    MODULE PROCEDURE cmfe_DataProjection_ProjectionTypeSetObj
  END INTERFACE cmfe_DataProjection_ProjectionTypeSet

  !>Returns the relative tolerance for a data projection.
  INTERFACE cmfe_DataProjection_RelativeToleranceGet
    MODULE PROCEDURE cmfe_DataProjection_RelativeToleranceGetNumber
    MODULE PROCEDURE cmfe_DataProjection_RelativeToleranceGetObj
  END INTERFACE cmfe_DataProjection_RelativeToleranceGet

  !>Sets/changes the relative tolerance for a data projection.
  INTERFACE cmfe_DataProjection_RelativeToleranceSet
    MODULE PROCEDURE cmfe_DataProjection_RelativeToleranceSetNumber
    MODULE PROCEDURE cmfe_DataProjection_RelativeToleranceSetObj
  END INTERFACE cmfe_DataProjection_RelativeToleranceSet

  !>Returns the starting xi for a data projection.
  INTERFACE cmfe_DataProjection_StartingXiGet
    MODULE PROCEDURE cmfe_DataProjection_StartingXiGetNumber
    MODULE PROCEDURE cmfe_DataProjection_StartingXiGetObj
  END INTERFACE cmfe_DataProjection_StartingXiGet

  !>Sets/changes the starting xi for a data projection.
  INTERFACE cmfe_DataProjection_StartingXiSet
    MODULE PROCEDURE cmfe_DataProjection_StartingXiSetNumber
    MODULE PROCEDURE cmfe_DataProjection_StartingXiSetObj
  END INTERFACE cmfe_DataProjection_StartingXiSet

  !>Sets/changes the element number for a data point projection.
  INTERFACE cmfe_DataProjection_ElementSet
    MODULE PROCEDURE cmfe_DataProjection_ElementSetRegionNumber
    MODULE PROCEDURE cmfe_DataProjection_ElementSetInterfaceNumber
    MODULE PROCEDURE cmfe_DataProjection_ElementSetObj
  END INTERFACE cmfe_DataProjection_ElementSet

  !>Gets the label for a data point projection.
  INTERFACE cmfe_DataProjection_LabelGet
    MODULE PROCEDURE cmfe_DataProjection_LabelGetCRegionNumber
    MODULE PROCEDURE cmfe_DataProjection_LabelGetCInterfaceNumber
    MODULE PROCEDURE cmfe_DataProjection_LabelGetCObj
    MODULE PROCEDURE cmfe_DataProjection_LabelGetVSRegionNumber
    MODULE PROCEDURE cmfe_DataProjection_LabelGetVSInterfaceNumber
    MODULE PROCEDURE cmfe_DataProjection_LabelGetVSObj
  END INTERFACE cmfe_DataProjection_LabelGet

  !>Sets/changes the label for a data point projection.
  INTERFACE cmfe_DataProjection_LabelSet
    MODULE PROCEDURE cmfe_DataProjection_LabelSetCRegionNumber
    MODULE PROCEDURE cmfe_DataProjection_LabelSetCInterfaceNumber
    MODULE PROCEDURE cmfe_DataProjection_LabelSetCObj
    MODULE PROCEDURE cmfe_DataProjection_LabelSetVSRegionNumber
    MODULE PROCEDURE cmfe_DataProjection_LabelSetVSInterfaceNumber
    MODULE PROCEDURE cmfe_DataProjection_LabelSetVSObj
  END INTERFACE cmfe_DataProjection_LabelSet

  !>Returns the projection distance for a data point identified by a given user number.
  INTERFACE cmfe_DataProjection_ResultDistanceGet
    MODULE PROCEDURE cmfe_DataProjection_ResultDistanceGetNumber
    MODULE PROCEDURE cmfe_DataProjection_ResultDistanceGetObj
  END INTERFACE cmfe_DataProjection_ResultDistanceGet

  !>Returns the projection element number for a data point identified by a given user number.
  INTERFACE cmfe_DataProjection_ResultElementNumberGet
    MODULE PROCEDURE cmfe_DataProjection_ResultElementNumberGetNumber
    MODULE PROCEDURE cmfe_DataProjection_ResultElementNumberGetObj
  END INTERFACE cmfe_DataProjection_ResultElementNumberGet

  !>Returns the projection element face number for a data point identified by a given user number.
  INTERFACE cmfe_DataProjection_ResultElementFaceNumberGet
    MODULE PROCEDURE cmfe_DataProjection_ResultElementFaceNumberGetNumber
    MODULE PROCEDURE cmfe_DataProjection_ResultElementFaceNumberGetObj
  END INTERFACE cmfe_DataProjection_ResultElementFaceNumberGet

  !>Returns the projection element line number for a data point identified by a given user number.
  INTERFACE cmfe_DataProjection_ResultElementLineNumberGet
    MODULE PROCEDURE cmfe_DataProjection_ResultElementLineNumberGetNumber
    MODULE PROCEDURE cmfe_DataProjection_ResultElementLineNumberGetObj
  END INTERFACE cmfe_DataProjection_ResultElementLineNumberGet

  !>Returns the projection exit tag for a data point identified by a given user number.
  INTERFACE cmfe_DataProjection_ResultExitTagGet
    MODULE PROCEDURE cmfe_DataProjection_ResultExitTagGetNumber
    MODULE PROCEDURE cmfe_DataProjection_ResultExitTagGetObj
  END INTERFACE cmfe_DataProjection_ResultExitTagGet

  !>Returns the projection xi for a data point identified by a given user number.
  INTERFACE cmfe_DataProjection_ResultXiGet
    MODULE PROCEDURE cmfe_DataProjection_ResultXiGetNumber
    MODULE PROCEDURE cmfe_DataProjection_ResultXiGetObj
  END INTERFACE cmfe_DataProjection_ResultXiGet

  !>Sets the projection xi for a data point identified by a given user number.
  INTERFACE cmfe_DataProjection_ResultXiSet
    MODULE PROCEDURE cmfe_DataProjection_ResultXiSetNumber
    MODULE PROCEDURE cmfe_DataProjection_ResultXiSetObj
  END INTERFACE cmfe_DataProjection_ResultXiSet

  PUBLIC CMFE_DATA_PROJECTION_BOUNDARY_LINES_PROJECTION_TYPE,CMFE_DATA_PROJECTION_BOUNDARY_FACES_PROJECTION_TYPE

  PUBLIC CMFE_DATA_PROJECTION_ALL_ELEMENTS_PROJECTION_TYPE

  PUBLIC cmfe_DataProjection_AbsoluteToleranceGet,cmfe_DataProjection_AbsoluteToleranceSet

  PUBLIC cmfe_DataProjection_CreateFinish,cmfe_DataProjection_CreateStart

  PUBLIC cmfe_DataProjection_Destroy
  
  PUBLIC cmfe_DataProjection_DataPointsPositionEvaluate
  
  PUBLIC cmfe_DataProjection_ProjectionCandidatesSet

  PUBLIC cmfe_DataProjection_DataPointsProjectionEvaluate

  PUBLIC cmfe_DataProjection_MaximumIterationUpdateGet,cmfe_DataProjection_MaximumIterationUpdateSet

  PUBLIC cmfe_DataProjection_MaximumNumberOfIterationsGet,cmfe_DataProjection_MaximumNumberOfIterationsSet

  PUBLIC cmfe_DataProjection_NumberOfClosestElementsGet,cmfe_DataProjection_NumberOfClosestElementsSet

  PUBLIC cmfe_DataProjection_ProjectionTypeGet,cmfe_DataProjection_ProjectionTypeSet

  PUBLIC cmfe_DataProjection_RelativeToleranceGet,cmfe_DataProjection_RelativeToleranceSet

  PUBLIC cmfe_DataProjection_StartingXiGet,cmfe_DataProjection_StartingXiSet

  PUBLIC cmfe_DataProjection_ElementSet

  PUBLIC cmfe_DataProjection_LabelGet,cmfe_DataProjection_LabelSet

  PUBLIC cmfe_DataProjection_ResultDistanceGet,cmfe_DataProjection_ResultElementNumberGet

  PUBLIC cmfe_DataProjection_ResultElementFaceNumberGet,cmfe_DataProjection_ResultElementLineNumberGet

  PUBLIC cmfe_DataProjection_ResultExitTagGet

  PUBLIC cmfe_DataProjection_ResultXiGet,cmfe_DataProjection_ResultXiSet

!!==================================================================================================================================
!!
!! EQUATIONS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_EquationsConstants OPENCMISS::Equations::Constants
  !> \brief Equations  constants.
  !>@{
  !> \addtogroup OPENCMISS_EquationsOutputTypes OPENCMISS::Equations::OutputTypes
  !> \brief Equations output types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_NO_OUTPUT = EQUATIONS_NO_OUTPUT!<No output from the equations \see OPENCMISS_EquationsOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_TIMING_OUTPUT = EQUATIONS_TIMING_OUTPUT !<Timing information output. \see OPENCMISS_EquationsOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_MATRIX_OUTPUT = EQUATIONS_MATRIX_OUTPUT !<All below and equation matrices output. \see OPENCMISS_EquationsOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_ELEMENT_MATRIX_OUTPUT = EQUATIONS_ELEMENT_MATRIX_OUTPUT !<All below and element matrices output. \see OPENCMISS_EquationsOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_NODAL_MATRIX_OUTPUT = EQUATIONS_NODAL_MATRIX_OUTPUT !<All below and nodal matrices output. \see OPENCMISS_EquationsOutputTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsSparsityTypes OPENCMISS::Equations::SparsityTypes
  !> \brief Equations sparsity types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SPARSE_MATRICES = EQUATIONS_SPARSE_MATRICES !<Use sparse matrices for the equations. \see OPENCMISS_EquationsSparsityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_FULL_MATRICES = EQUATIONS_FULL_MATRICES !<Use fully populated matrices for the equations. \see OPENCMISS_EquationsSparsityTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsLumpingTypes OPENCMISS::Equations::LumpingTypes
  !> \brief Equations lumping types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_UNLUMPED_MATRICES = EQUATIONS_UNLUMPED_MATRICES !<The equations matrices are not lumped. \see OPENCMISS_EquationsLumpingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_LUMPED_MATRICES = EQUATIONS_LUMPED_MATRICES !<The equations matrices are "mass" lumped. \see OPENCMISS_EquationsLumpingTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsLinearityTypes OPENCMISS::Equations::LinearityTypes
  !> \brief The equations linearity types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_LINEAR = EQUATIONS_LINEAR !<The equations are linear. \see OPENCMISS_EquationsLinearityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_NONLINEAR = EQUATIONS_NONLINEAR !<The equations are non-linear. \see \see OPENCMISS_EquationsLinearityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_NONLINEAR_BCS = EQUATIONS_NONLINEAR_BCS !<The equations have non-linear boundary conditions. \see \see OPENCMISS_EquationsLinearityTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsTimeDependenceTypes OPENCMISS::Equations::TimeDependenceTypes
  !> \brief The equations time dependence types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_STATIC = EQUATIONS_STATIC !<The equations are static and have no time dependence. \see OPENCMISS_EquationsTimeDependenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_QUASISTATIC = EQUATIONS_QUASISTATIC !<The equations are quasi-static. \see OPENCMISS_EquationsTimeDependenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_FIRST_ORDER_DYNAMIC = EQUATIONS_FIRST_ORDER_DYNAMIC !<The equations are first order dynamic. \see OPENCMISS_EquationsTimeDependenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SECOND_ORDER_DYNAMIC = EQUATIONS_SECOND_ORDER_DYNAMIC !<The equations are a second order dynamic. \see OPENCMISS_EquationsTimeDependenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_TIME_STEPPING = EQUATIONS_TIME_STEPPING !<The equations are for time stepping. \see OPENCMISS_EquationsTimeDependenceTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Destroys equations for an equations set.
  INTERFACE cmfe_Equations_Destroy
    MODULE PROCEDURE cmfe_Equations_DestroyNumber
    MODULE PROCEDURE cmfe_Equations_DestroyObj
  END INTERFACE cmfe_Equations_Destroy

  !>Gets the linearity type for equations.
  INTERFACE cmfe_Equations_LinearityTypeGet
    MODULE PROCEDURE cmfe_Equations_LinearityTypeGetNumber
    MODULE PROCEDURE cmfe_Equations_LinearityTypeGetObj
  END INTERFACE cmfe_Equations_LinearityTypeGet

  !>Gets the lumping type for equations.
  INTERFACE cmfe_Equations_LumpingTypeGet
    MODULE PROCEDURE cmfe_Equations_LumpingTypeGetNumber
    MODULE PROCEDURE cmfe_Equations_LumpingTypeGetObj
  END INTERFACE cmfe_Equations_LumpingTypeGet

  !>Sets/changes the lumping type for equations.
  INTERFACE cmfe_Equations_LumpingTypeSet
    MODULE PROCEDURE cmfe_Equations_LumpingTypeSetNumber
    MODULE PROCEDURE cmfe_Equations_LumpingTypeSetObj
  END INTERFACE cmfe_Equations_LumpingTypeSet

  !>Gets the output type for equations.
  INTERFACE cmfe_Equations_OutputTypeGet
    MODULE PROCEDURE cmfe_Equations_OutputTypeGetNumber
    MODULE PROCEDURE cmfe_Equations_OutputTypeGetObj
  END INTERFACE cmfe_Equations_OutputTypeGet

  !>Sets/changes the output type for equations.
  INTERFACE cmfe_Equations_OutputTypeSet
    MODULE PROCEDURE cmfe_Equations_OutputTypeSetNumber
    MODULE PROCEDURE cmfe_Equations_OutputTypeSetObj
  END INTERFACE cmfe_Equations_OutputTypeSet

 !>Gets the sparsity type for equations.
  INTERFACE cmfe_Equations_SparsityTypeGet
    MODULE PROCEDURE cmfe_Equations_SparsityTypeGetNumber
    MODULE PROCEDURE cmfe_Equations_SparsityTypeGetObj
  END INTERFACE cmfe_Equations_SparsityTypeGet

  !>Sets/changes the sparsity type for equations.
  INTERFACE cmfe_Equations_SparsityTypeSet
    MODULE PROCEDURE cmfe_Equations_SparsityTypeSetNumber
    MODULE PROCEDURE cmfe_Equations_SparsityTypeSetObj
  END INTERFACE cmfe_Equations_SparsityTypeSet

  !>Gets the time dependence type for equations.
  INTERFACE cmfe_Equations_TimeDependenceTypeGet
    MODULE PROCEDURE cmfe_Equations_TimeDependenceTypeGetNumber
    MODULE PROCEDURE cmfe_Equations_TimeDependenceTypeGetObj
  END INTERFACE cmfe_Equations_TimeDependenceTypeGet

  PUBLIC CMFE_EQUATIONS_NO_OUTPUT,CMFE_EQUATIONS_TIMING_OUTPUT,CMFE_EQUATIONS_MATRIX_OUTPUT

  PUBLIC CMFE_EQUATIONS_ELEMENT_MATRIX_OUTPUT,CMFE_EQUATIONS_NODAL_MATRIX_OUTPUT

  PUBLIC CMFE_EQUATIONS_SPARSE_MATRICES,CMFE_EQUATIONS_FULL_MATRICES

  PUBLIC CMFE_EQUATIONS_UNLUMPED_MATRICES,CMFE_EQUATIONS_LUMPED_MATRICES

  PUBLIC CMFE_EQUATIONS_LINEAR,CMFE_EQUATIONS_NONLINEAR,CMFE_EQUATIONS_NONLINEAR_BCS

  PUBLIC CMFE_EQUATIONS_STATIC,CMFE_EQUATIONS_QUASISTATIC,CMFE_EQUATIONS_FIRST_ORDER_DYNAMIC, &
    & CMFE_EQUATIONS_SECOND_ORDER_DYNAMIC, &
    & CMFE_EQUATIONS_TIME_STEPPING

  PUBLIC cmfe_Equations_Destroy

  PUBLIC cmfe_Equations_LinearityTypeGet

  PUBLIC cmfe_Equations_LumpingTypeGet,cmfe_Equations_LumpingTypeSet

  PUBLIC cmfe_Equations_OutputTypeGet,cmfe_Equations_OutputTypeSet

  PUBLIC cmfe_Equations_SparsityTypeGet,cmfe_Equations_SparsityTypeSet

  PUBLIC cmfe_Equations_TimeDependenceTypeGet

  PUBLIC cmfe_Equations_NumberOfLinearMatricesGet

  PUBLIC cmfe_Equations_NumberOfJacobianMatricesGet

  PUBLIC cmfe_Equations_NumberOfDynamicMatricesGet

  PUBLIC cmfe_Equations_LinearMatrixGet
  
  PUBLIC cmfe_Equations_JacobianMatrixGet

  PUBLIC cmfe_Equations_DynamicMatrixGet

  PUBLIC cmfe_Equations_DynamicMatrixGetByType

  PUBLIC cmfe_Equations_DynamicMatrixTypeGet

  PUBLIC cmfe_Equations_RhsVectorGet

  PUBLIC cmfe_Equations_ResidualVectorGet

  PUBLIC cmfe_Equations_ResidualNumberOfVariablesGet

  PUBLIC cmfe_Equations_ResidualVariablesGet

  PUBLIC cmfe_Equations_SourceVectorGet

!!==================================================================================================================================
!!
!! EQUATIONS_SET_CONSTANTS
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_EquationsSetConstants OPENCMISS::EquationsSet::Constants
  !> \brief Equations set constants.
  !>@{
  !> \addtogroup OPENCMISS_EquationsSetClasses OPENCMISS::EquationsSet::Classes
  !> \brief Equations set classes.
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NO_CLASS = EQUATIONS_SET_NO_CLASS !<No equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ELASTICITY_CLASS = EQUATIONS_SET_ELASTICITY_CLASS !<Elasticity equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FLUID_MECHANICS_CLASS = EQUATIONS_SET_FLUID_MECHANICS_CLASS !<Fluid Mechanics equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ELECTROMAGNETICS_CLASS = EQUATIONS_SET_ELECTROMAGNETICS_CLASS !<Electromagnetics equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CLASSICAL_FIELD_CLASS = EQUATIONS_SET_CLASSICAL_FIELD_CLASS !<Classical Field equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_BIOELECTRICS_CLASS = EQUATIONS_SET_BIOELECTRICS_CLASS !<Bioelectrics equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MODAL_CLASS = EQUATIONS_SET_MODAL_CLASS !<Modal equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FITTING_CLASS = EQUATIONS_SET_FITTING_CLASS !<Fitting equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_OPTIMISATION_CLASS = EQUATIONS_SET_OPTIMISATION_CLASS !<Optimisation equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTI_PHYSICS_CLASS = EQUATIONS_SET_MULTI_PHYSICS_CLASS !<Multi Physics equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsSetTypes OPENCMISS::EquationsSet::Types
  !> \brief Equations set Types.
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NO_TYPE = EQUATIONS_SET_NO_TYPE !<No equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_TYPE = EQUATIONS_SET_LINEAR_ELASTICITY_TYPE !<Linear elasticity equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FINITE_ELASTICITY_TYPE = EQUATIONS_SET_FINITE_ELASTICITY_TYPE !<Finite elasticity equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_TYPE = EQUATIONS_SET_STOKES_EQUATION_TYPE !<Stokes equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TYPE = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TYPE !<Navier-Stokes equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DARCY_EQUATION_TYPE = EQUATIONS_SET_DARCY_EQUATION_TYPE !<Darcy equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DARCY_PRESSURE_EQUATION_TYPE = EQUATIONS_SET_DARCY_PRESSURE_EQUATION_TYPE !<Darcy pressure equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_POISEUILLE_EQUATION_TYPE = EQUATIONS_SET_POISEUILLE_EQUATION_TYPE !<Poiseuille equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_BURGERS_EQUATION_TYPE = EQUATIONS_SET_BURGERS_EQUATION_TYPE !<Burgers equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CHARACTERISTIC_EQUATION_TYPE = EQUATIONS_SET_CHARACTERISTIC_EQUATION_TYPE !<Characteristic equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ELECTROSTATIC_TYPE = EQUATIONS_SET_ELECTROSTATIC_TYPE !<Electrostatic equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MAGNETOSTATIC_TYPE = EQUATIONS_SET_MAGNETOSTATIC_TYPE !<Magnetostatic equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MAXWELLS_EQUATIONS_TYPE = EQUATIONS_SET_MAXWELLS_EQUATIONS_TYPE !<Maxwells equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LAPLACE_EQUATION_TYPE = EQUATIONS_SET_LAPLACE_EQUATION_TYPE !<Laplace equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_POISSON_EQUATION_TYPE = EQUATIONS_SET_POISSON_EQUATION_TYPE !<Poisson equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_HELMHOLTZ_EQUATION_TYPE = EQUATIONS_SET_HELMHOLTZ_EQUATION_TYPE !<Helmholtz equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_WAVE_EQUATION_TYPE = EQUATIONS_SET_WAVE_EQUATION_TYPE !<Wave equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DIFFUSION_EQUATION_TYPE = EQUATIONS_SET_DIFFUSION_EQUATION_TYPE !<Diffusion equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ADVECTION_EQUATION_TYPE = EQUATIONS_SET_ADVECTION_EQUATION_TYPE !<Advection-Diffusion equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TYPE = &
    & EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TYPE !<Advection-Diffusion equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_TYPE = EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_TYPE !<Reaction-Diffusion equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_BIHARMONIC_EQUATION_TYPE = EQUATIONS_SET_BIHARMONIC_EQUATION_TYPE !<Biharmonic equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MONODOMAIN_EQUATION_TYPE = EQUATIONS_SET_MONODOMAIN_EQUATION_TYPE !<Monodomain equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_BIDOMAIN_EQUATION_TYPE = EQUATIONS_SET_BIDOMAIN_EQUATION_TYPE !<Bidomain equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_ELASTIC_MODAL_TYPE = EQUATIONS_SET_LINEAR_ELASTIC_MODAL_TYPE !<Linear elasticity modal equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DATA_FITTING_EQUATION_TYPE = EQUATIONS_SET_DATA_FITTING_EQUATION_TYPE !<Galerkin projection equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FINITE_ELASTICITY_DARCY_TYPE = EQUATIONS_SET_FINITE_ELASTICITY_DARCY_TYPE !<Finite Elasticity Darcy equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FINITE_ELASTICITY_STOKES_TYPE = EQUATIONS_SET_FINITE_ELASTICITY_STOKES_TYPE !<Finite Elasticity Stokes equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_TYPE = &
    & EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_TYPE !<Finite Elasticity Navier Stokes equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DIFFUSION_DIFFUSION_TYPE = EQUATIONS_SET_DIFFUSION_DIFFUSION_TYPE !<Diffusion Diffusion equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DIFFUSION_ADVECTION_DIFFUSION_TYPE = &
    & EQUATIONS_SET_DIFFUSION_ADVECTION_DIFFUSION_TYPE !<Diffusion Advection Diffusion equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE = &
    & EQUATIONS_SET_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE !<Monodomain equation equations Strang Splitting set type \see OPENCMISS_EquationsSetTypes,OPENCMISS

  !>@}
  !> \addtogroup OPENCMISS_EquationsSetSubtypes OPENCMISS::EquationsSet::Subtypes
  !> \brief Equations set subtypes.
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NO_SUBTYPE = EQUATIONS_SET_NO_SUBTYPE !<No equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE = EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE !<Three dimensional linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE = &
    & EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE !<Plane stress linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE = &
    & EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE !<Plane strain linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE = EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE !<One dimensional linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_PLATE_SUBTYPE = EQUATIONS_SET_PLATE_SUBTYPE !<Plate linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_SHELL_SUBTYPE = EQUATIONS_SET_SHELL_SUBTYPE !<Shell linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE = EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE !< Mooney-Rivlin constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE = &
  & EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE !< Incompressible Mooney-Rivlin constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE = &
  & EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE !< Nearly Incompressible Mooney-Rivlin constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE = & 
    & EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE !< Mooney-Rivlin constitutive law with steady-state active contraction for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE = & 
    & EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE !< St Venant Kirchoff constitutive law with steady-state active contraction for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE =&
    & EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE !< Active contraction/costa-based law with quasistatic time loop for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE = EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE !< Isotropic exponential constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE = &
    & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE !< Transverse isotropic exponential constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE = &
    & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE !< Transverse isotropic, active-contraction constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE = &
    & EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE !< Transverse isotropic, active-contraction material-transition constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE = &
    & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE !< Orthotropic Costa constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE= &
    & EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE !<Compressible version for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE= &
    & EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE !<Compressible version for finite elasticity equations set with active contraction subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE = &
    & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE !< Transverse isotropic Guccione constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE = &
    & EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE !< Transverse isotropic Guccione constitutive law with active contraction subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_INCOMPRESS_FINITE_ELASTICITY_DARCY_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE !<Incompressible version for finite elasticity coupled with Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE= &
    & EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE !<INRIA Model for finite elasticity coupled with Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ELASTICITY_MULTI_COMP_DARCY_INRIA_SUBTYPE= &
    & EQUATIONS_SET_ELASTICITY_MULTI_COMPARTMENT_DARCY_INRIA_SUBTYPE !<Multi Compartment Darcy INRIA Model coupled with finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_INCOMPRESS_ELASTICITY_DRIVEN_DARCY_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE !< Incompressible finite elasticity with Darcy flow driven by solid hydrostatic pressure \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_MR_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_MR_SUBTYPE !< Incompressible finite elasticity with Darcy flow driven by solid hydrostatic pressure, formulated in terms of modified invariants. \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_INCOMPRESS_ELAST_MULTI_COMP_DARCY_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MEMBRANE_SUBTYPE = EQUATIONS_SET_MEMBRANE_SUBTYPE !<Compressible version for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ORTHOTROPIC_HOLZAPFEL_OGDEN_SUBTYPE = &
    & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_HOLZAPFEL_OGDEN_SUBTYPE !< Orthotropic Holzapfel-Ogden constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE = &
    & EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE &
    & !< Orthotropic Holzapfel-Ogden constitutive law with active contraction for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ELASTICITY_FLUID_PRES_STATIC_INRIA_SUBTYPE = &
    & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE !< Static finite elasticity coupled with fluid pressure set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_SUBTYPE= &
    & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE !<Holmes and Mow's poroelastic constitutive relation subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE = &
    & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE !<Transverse isotropic constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE = &
    & EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE !<Anisotropic polynomial constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE = &
    & EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE !<Anisotropic polynomial active constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE= &
    & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE !<Humphrey and Yin transversely isotropic constitutive relation subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STATIC_STOKES_SUBTYPE = EQUATIONS_SET_STATIC_STOKES_SUBTYPE !<Static Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LAPLACE_STOKES_SUBTYPE = EQUATIONS_SET_LAPLACE_STOKES_SUBTYPE !<Laplace type Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSIENT_STOKES_SUBTYPE = EQUATIONS_SET_TRANSIENT_STOKES_SUBTYPE !<Transient Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ALE_STOKES_SUBTYPE = EQUATIONS_SET_ALE_STOKES_SUBTYPE !<ALE Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_PGM_STOKES_SUBTYPE = EQUATIONS_SET_PGM_STOKES_SUBTYPE !<PGM Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_OPTIMISED_STOKES_SUBTYPE = EQUATIONS_SET_OPTIMISED_STOKES_SUBTYPE !<Optimised Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STATIC_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_STATIC_NAVIER_STOKES_SUBTYPE !<Static Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LAPLACE_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_LAPLACE_NAVIER_STOKES_SUBTYPE !<Laplace type Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSIENT_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_TRANSIENT_NAVIER_STOKES_SUBTYPE !<Transient Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE = & 
    & EQUATIONS_SET_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE !<Transient residual-based stabilisation Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STATIC_RBS_NAVIER_STOKES_SUBTYPE =  &
    & EQUATIONS_SET_STATIC_RBS_NAVIER_STOKES_SUBTYPE !<Transient residual-based stabilisation Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTISCALE3D_NAVIER_STOKES_SUBTYPE = & 
    & EQUATIONS_SET_MULTISCALE3D_NAVIER_STOKES_SUBTYPE !<Transient stabilised 3D Navier-Stokes equations set with coupled multiscale boundaries subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTITUTIVE_MU_NAVIER_STOKES_SUBTYPE = & 
    & EQUATIONS_SET_CONSTITUTIVE_MU_NAVIER_STOKES_SUBTYPE !<Transient stabilised 3D Navier-Stokes equations set with coupled constitutive model for non-Newtonian viscosity \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSIENT1D_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_TRANSIENT1D_NAVIER_STOKES_SUBTYPE !<TRANSIENT1D Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE !<TRANSIENT1D Navier-Stokes equations set subtype with coupled Advection \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CHARACTERISTIC_SUBTYPE = &
    & EQUATIONS_SET_CHARACTERISTIC_SUBTYPE !<Static Characteristics equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_COUPLED1D0D_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_COUPLED1D0D_NAVIER_STOKES_SUBTYPE !<Coupled 1D-0D Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE !<Coupled 1D-0D Navier-Stokes equations set subtype with coupled Advection \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STREE1D0D_SUBTYPE = &
    & EQUATIONS_SET_STREE1D0D_SUBTYPE !<Coupled 1D-0D Navier-Stokes equations set subtype with coupled Advection \see
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STREE1D0D_ADV_SUBTYPE = &
    & EQUATIONS_SET_STREE1D0D_ADV_SUBTYPE !<Coupled 1D-0D Navier-Stokes equations set subtype with coupled Advection \see
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ALE_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_ALE_NAVIER_STOKES_SUBTYPE !<ALE Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_PGM_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_PGM_NAVIER_STOKES_SUBTYPE !<PGM Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_OPTIMISED_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_OPTIMISED_NAVIER_STOKES_SUBTYPE !<Optimised Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STANDARD_DARCY_SUBTYPE = EQUATIONS_SET_STANDARD_DARCY_SUBTYPE !<Standard Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUASISTATIC_DARCY_SUBTYPE = EQUATIONS_SET_QUASISTATIC_DARCY_SUBTYPE !<Quasistatic Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ALE_DARCY_SUBTYPE = EQUATIONS_SET_ALE_DARCY_SUBTYPE !<ALE Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSIENT_DARCY_SUBTYPE = EQUATIONS_SET_TRANSIENT_DARCY_SUBTYPE !<Transient Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_TRANSIENT_ALE_DARCY_SUBTYPE = EQUATIONS_SET_TRANSIENT_ALE_DARCY_SUBTYPE !<Transient ALE Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTI_COMPARTMENT_DARCY_SUBTYPE = EQUATIONS_SET_MULTI_COMPARTMENT_DARCY_SUBTYPE !<Multi Compartment Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_BURGERS_SUBTYPE = EQUATIONS_SET_BURGERS_SUBTYPE !<Burgers equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_BURGERS_SUBTYPE = EQUATIONS_SET_GENERALISED_BURGERS_SUBTYPE !<Generalised Burgers equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STATIC_BURGERS_SUBTYPE = EQUATIONS_SET_STATIC_BURGERS_SUBTYPE !<Static Burgers equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_INVISCID_BURGERS_SUBTYPE = EQUATIONS_SET_INVISCID_BURGERS_SUBTYPE !<Inviscid Burgers equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STANDARD_LAPLACE_SUBTYPE = EQUATIONS_SET_STANDARD_LAPLACE_SUBTYPE !<Standard Laplace equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_LAPLACE_SUBTYPE = EQUATIONS_SET_GENERALISED_LAPLACE_SUBTYPE !<Generalised Laplace equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MOVING_MESH_LAPLACE_SUBTYPE = EQUATIONS_SET_MOVING_MESH_LAPLACE_SUBTYPE !<Moving mesh Laplace equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STATIC_POISEUILLE_SUBTYPE = EQUATIONS_SET_STATIC_POISEUILLE_SUBTYPE !<Static Poiseuille equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DYNAMIC_POISEUILLE_SUBTYPE = EQUATIONS_SET_DYNAMIC_POISEUILLE_SUBTYPE !<Dynamic Poiseuille equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_PRESSURE_POISSON_SUBTYPE = EQUATIONS_SET_LINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NONLINEAR_PRESSURE_POISSON_SUBTYPE = &
    & EQUATIONS_SET_NONLINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ALE_PRESSURE_POISSON_SUBTYPE = EQUATIONS_SET_ALE_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FITTED_PRESSURE_POISSON_SUBTYPE = EQUATIONS_SET_FITTED_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTANT_SOURCE_POISSON_SUBTYPE = EQUATIONS_SET_CONSTANT_SOURCE_POISSON_SUBTYPE !<Constant source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE = &
    & EQUATIONS_SET_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE !<Poisson equations set subtype, that is the extracellular bidomain equation \see OPENCMISS_EquationsSetSubtypes,OPENCMISS  
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_POISSON_SUBTYPE = EQUATIONS_SET_LINEAR_SOURCE_POISSON_SUBTYPE !<Linear source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_POISSON_SUBTYPE = EQUATIONS_SET_QUADRATIC_SOURCE_POISSON_SUBTYPE !<Quadratic source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_POISSON_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_POISSON_SUBTYPE !<Exponential source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STANDARD_HELMHOLTZ_SUBTYPE = EQUATIONS_SET_STANDARD_HELMHOLTZ_SUBTYPE !<No source Helmholtz equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_HELMHOLTZ_SUBTYPE = EQUATIONS_SET_GENERALISED_HELMHOLTZ_SUBTYPE !<No source Helmholtz equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NO_SOURCE_DIFFUSION_SUBTYPE = EQUATIONS_SET_NO_SOURCE_DIFFUSION_SUBTYPE !<No source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTANT_SOURCE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_DIFFUSION_SUBTYPE !<Constant source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_SUBTYPE = EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_SUBTYPE !<Linear source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_SUBTYPE !<Quadratic source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_SUBTYPE !<Exponential source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NO_SOURCE_ALE_DIFFUSION_SUBTYPE = EQUATIONS_SET_NO_SOURCE_ALE_DIFFUSION_SUBTYPE !<No source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTANT_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_ALE_DIFFUSION_SUBTYPE !<Constant source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE !<Linear source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ALE_DIFFUSION_SUBTYPE !<Quadratic source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_ALE_DIFFUSION_SUBTYPE !<Exponential source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTI_COMP_TRANSPORT_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_MULTI_COMP_TRANSPORT_DIFFUSION_SUBTYPE !<Multi-compartment transport diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ADVECTION_SUBTYPE = &
    & EQUATIONS_SET_ADVECTION_SUBTYPE !<advection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Quadratic source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Exponential source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE = &
    & EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE !<In CellML evaluated incompressible material law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTIT_AND_GROWTH_LAW_IN_CELLML_SUBTYPE = &
    & EQUATIONS_SET_CONSTITUTIVE_AND_GROWTH_LAW_IN_CELLML_SUBTYPE !<CellML evaluated growth and constituative material law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Quadratic source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Exponential source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTANT_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUAD_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_QUAD_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE !<Quadratic source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXP_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_EXP_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE !<Exponential source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUAD_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_QUAD_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE !<Quadratic source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE !<Exponential source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONST_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LIN_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE !<Coupled source diffusion & advection-diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUBTYPE !<Multi-component transport advection-diffusion equations set \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULT_COMP_TRANSPORT_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUPG_SUBTYPE !<Multi-component transport advection-diffusion equations set using SUPG scheme \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CELLML_REAC_SPLIT_REAC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CELLML_REAC_SPLIT_REAC_DIFF_SUBTYPE !CellML Reaction Diffusion with order splitting \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CELLML_REAC_NO_SPLIT_REAC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CELLML_REAC_NO_SPLIT_REAC_DIFF_SUBTYPE !CellML Reaction Diffusion without order splitting \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_CONSTANT_REAC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_REAC_DIFF_SUBTYPE !Standard Reaction Diffusion without order splitting, and constant source \see OPENCMISS_EquationsSetSubtypes,OPENCMISS


  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MONODOMAIN_BUENOOROVIO_SUBTYPE= EQUATIONS_SET_MONODOMAIN_BUENOOROVIO_SUBTYPE !<First monodomain equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MONODOMAIN_TENTUSSCHER06_SUBTYPE= EQUATIONS_SET_MONODOMAIN_TENTUSSCHER06_SUBTYPE !<First monodomain equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FIRST_BIDOMAIN_SUBTYPE = EQUATIONS_SET_FIRST_BIDOMAIN_SUBTYPE !<First bidomain equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_SECOND_BIDOMAIN_SUBTYPE = EQUATIONS_SET_SECOND_BIDOMAIN_SUBTYPE !<Second bidomain equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STANDARD_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_STANDARD_DATA_FITTING_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_DATA_FITTING_SUBTYPE !<Generalised Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MAT_PROPERTIES_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_MAT_PROPERTIES_DATA_FITTING_SUBTYPE !<Material Properties Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MAT_PROP_INRIA_MODEL_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_MAT_PROPERTIES_INRIA_MODEL_DATA_FITTING_SUBTYPE !<Material Properties INRIA Model Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_VECTOR_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_VECTOR_DATA_FITTING_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DIVFREE_VECTOR_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_DIVFREE_VECTOR_DATA_FITTING_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DATA_POINT_VECTOR_STATIC_FITTING_SUBTYPE = &
    & EquationsSet_DataPointVectorStaticFittingSubtype !<Standard static Galerkin Projection using data points subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DATA_PT_VECTOR_QUASISTATIC_FITTING_SUBTYPE = &
    & EquationsSet_DataPointVectorQuasistaticFittingSubtype !<Standard quasistatic Galerkin Projection using data points subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_VECTOR_DATA_PRE_FITTING_SUBTYPE = &
    & EQUATIONS_SET_VECTOR_DATA_PRE_FITTING_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DIVFREE_VECTOR_DATA_PRE_FITTING_SUBTYPE = &
    & EQUATIONS_SET_DIVFREE_VECTOR_DATA_PRE_FITTING_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS


  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STANDARD_ELASTICITY_DARCY_SUBTYPE = EQUATIONS_SET_STANDARD_ELASTICITY_DARCY_SUBTYPE !<Standard Elasticity Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE !<Coupled source diffusion-diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE =  &
    & EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE !<Standard Monodomain Elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE =  &
    & EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE !<Coupled 1D Monodomain 3D Elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE =  &
    & EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE !<Coupled 1D Monodomain 3D Elasticity equations set subtype with titin \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE =  &
    & EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE !<Coupled 1D Monodomain 3D Elasticity equations set subtype with force-velocity relation \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE = &
    & EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE !<Finite Elasticity Navier Stokes ALE equations set subtype \see OPENCMISS_EquationsSetSubtype,OPENCMISS

  !>@}
  !> \addtogroup OPENCMISS_EquationsSetSolutionMethods OPENCMISS::EquationsSet::SolutionMethods
  !> \brief The solution method parameters
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FEM_SOLUTION_METHOD = EQUATIONS_SET_FEM_SOLUTION_METHOD !<Finite Element Method solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_BEM_SOLUTION_METHOD = EQUATIONS_SET_BEM_SOLUTION_METHOD !<Boundary Element Method solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FD_SOLUTION_METHOD = EQUATIONS_SET_FD_SOLUTION_METHOD !<Finite Difference solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FV_SOLUTION_METHOD = EQUATIONS_SET_FV_SOLUTION_METHOD !<Finite Volume solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GFEM_SOLUTION_METHOD = EQUATIONS_SET_GFEM_SOLUTION_METHOD !<Grid-based Finite Element Method solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GFD_SOLUTION_METHOD = EQUATIONS_SET_GFD_SOLUTION_METHOD !<Grid-based Finite Difference solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GFV_SOLUTION_METHOD = EQUATIONS_SET_GFV_SOLUTION_METHOD !<Grid-based Finite Volume solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  !>@}

  !> \addtogroup OPENCMISS_EquationsSetDerivedTypes OPENCMISS::EquationsSet::OutputTypes
  !> \brief Field values to output
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DERIVED_STRAIN = EQUATIONS_SET_DERIVED_STRAIN !<Strain tensor field output. \see OPENCMISS_EquationsSetDerivedTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DERIVED_STRESS = EQUATIONS_SET_DERIVED_STRESS !<Stress tensor field output. \see OPENCMISS_EquationsSetDerivedTypes,OPENCMISS
  !>@}

  !> \addtogroup OPENCMISS_EquationsSetDynamicMatrixTypes OPENCMISS::EquationsSet::DynamicMatrixTypes
  !> \brief Type of matrix in a dynamic equations set
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_MATRIX_STIFFNESS=EQUATIONS_MATRIX_STIFFNESS !<A stiffness matrix (multiplies displacement values)
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_MATRIX_DAMPING=EQUATIONS_MATRIX_DAMPING !<A damping matrix (multiplies velocity values)
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_MATRIX_MASS=EQUATIONS_MATRIX_MASS !<A mass matrix (multiplies acceleration values)
  !>@}

  !> \addtogroup OPENCMISS_EquationsSetAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes
  !> \brief The analytic function types.
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  !> \addtogroup OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Laplace
  !> \brief The analytic function types for a Laplace equation
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_1 = EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_1 !<u=x**2+2*x*y-y**2 \see OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_2 = EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_2 !<u=cos(x)cosh(y) \see OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_1 = EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_1 !<u=x**2-2*y**2+z**2 \see OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_2 = EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_2 !<u=cos(x)*cosh(y)*z \see OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsSetHelmholtzAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Helmholtz
  !> \brief The analytic function types for a Helmholtz equation
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_HELMHOLTZ_EQUATION_TWO_DIM_1 = EQUATIONS_SET_HELMHOLTZ_EQUATION_TWO_DIM_1 !<u=cos(sqrt(2)*k*x)*sin(sqrt(2)*k*y) \see OPENCMISS_EquationsSetHelmholtzAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_PoiseuilleAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Poiseuille
  !> \brief The analytic function types for a Poiseuille equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_POISEUILLE_EQUATION_TWO_DIM_1 = EQUATIONS_SET_POISEUILLE_EQUATION_TWO_DIM_1 !<u=ln(4/(x+y+1^2)) \see OPENCMISS_EquationsSetPoiseuilleAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_PoissonAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Poisson
  !> \brief The analytic function types for a Poisson equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_1 = EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_1 !<u=ln(4/(x+y+1^2)) \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_2 = EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_3 = EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_1 = EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_1 !<u=ln(6/(x+y+z+1^2)) \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_2 = EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_3 = EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_1 = EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_2 = EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DiffusionAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Diffusion
  !> \brief The analytic function types for a diffusion equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DIFFUSION_EQUATION_ONE_DIM_1 = EQUATIONS_SET_DIFFUSION_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DIFFUSION_EQUATION_TWO_DIM_1 = EQUATIONS_SET_DIFFUSION_EQUATION_TWO_DIM_1 !<u=exp(-kt)*sin(sqrt(k)*(x*cos(phi)+y*sin(phi))) \see OPENCMISS_EquationsSetDiffusionAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DIFFUSION_EQUATION_THREE_DIM_1 = EQUATIONS_SET_DIFFUSION_EQUATION_THREE_DIM_1 !<
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_THREE_DIM_1 = &
    & EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_EQUATION_THREE_DIM_1
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_ONE_DIM_1 = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_ONE_DIM_1 = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_EQUATION_ONE_DIM_1

  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_TWO_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_TWO_DIM !<Prescribed solution, using a source term to correct for error - 2D with 2 compartments
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_THREE_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_THREE_DIM !<Prescribed solution, using a source term to correct for error - 3D with 2 compartments
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTI_COMP_DIFFUSION_THREE_COMP_THREE_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_THREE_COMP_THREE_DIM !<Prescribed solution, using a source term to correct for error - 3D with 3 compartments
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_MULTI_COMP_DIFFUSION_FOUR_COMP_THREE_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_FOUR_COMP_THREE_DIM !<Prescribed solution, using a source term to correct for error - 3D with 3 compartments
  !>@}
  !> \addtogroup OPENCMISS_AdvectionDiffusionAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::AdvectionDiffusion
  !> \brief The analytic function types for an advection-diffusion equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TWO_DIM_1 = &
    & EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TWO_DIM_1 !<u=exp(-kt)*sin(sqrt(k)*(x*cos(phi)+y*sin(phi))) \see OPENCMISS_EquationsSetDiffusionAnalyticFunctionTypes,OPENCMISS
  !> \addtogroup OPENCMISS_StokesAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Stokes
  !> \brief The analytic function types for a Stokes equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_1 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_2 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_3 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_4 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_4 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_5 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_5 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_1 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_2 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_3 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_4 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_4 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_5 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_5 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_NavierStokesAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::NavierStokes
  !> \brief The analytic function types for a Navier-Stokes equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_POISEUILLE= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_POISEUILLE !< fully developed 2D channel flow (parabolic) \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_TAYLOR_GREEN= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_TAYLOR_GREEN !< 2D dynamic nonlinear Taylor-Green vortex decay \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_FLOWRATE_AORTA= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_FLOWRATE_AORTA !< A fourier decomposed flow waveform for boundary conditions
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_SINUSOID= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_SINUSOID !< A sinusoidal flow waveform
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_SPLINT_FROM_FILE= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_SPLINT_FROM_FILE !< Spline integration of dependent values specified in a file
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_1 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_2 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_3 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_4 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_4 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_5 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_5 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_1 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_2 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_3 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_4 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_4 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_5 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_5 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DarcyAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Darcy
  !> \brief The analytic function types for a Darcy equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_1 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_2 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_3 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_1 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_2 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_3 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_INCOMP_ELAST_DARCY_ANALYTIC_DARCY = &
    & EQUATIONS_SET_INCOMP_ELAST_DARCY_ANALYTIC_DARCY !<this is a solution where the finite elasticity solve is skipped to allow easy analytic testing of the mass increase & velocity solve step of incompressible poromechanical model
  !>@}
  !> \addtogroup OPENCMISS_BurgersAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Burgers
  !> \brief The analytic function types for a Burgers equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_BURGERS_EQUATION_ONE_DIM_1 = EQUATIONS_SET_BURGERS_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_1 = &
    & EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_2 = &
    & EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_2
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_STATIC_BURGERS_EQUATION_ONE_DIM_1 = &
    & EQUATIONS_SET_STATIC_BURGERS_EQUATION_ONE_DIM_1
  !>@}

  !> \addtogroup OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::LinearElasticity
  !> \brief The analytic function types for a LinearElasticity equation
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1 = EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1 = EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_2 = EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1 = EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2 = EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsSetFiniteElasticityAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::FiniteElasticity
  !> \brief The analytic function types for a FiniteElasticity equation
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER = EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  !>@}
  !>@}
  !>@}

  !> \addtogroup OPENCMISS_AnalyticParamIndices OPENCMISS::FiniteElasticity::AnalyticParamIndices
  !> \brief Indices for EQUATIONS_SET_ANALYTIC_TYPE%ANALYTIC_USER_PARAMS
  !> \see OPENCMISS::FiniteElasticity::AnalyticParamIndices,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX !<Inner pressure parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX !<Outer pressure parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX !<Lambda parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX !<Tsi parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX !<Inner radius parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX !<Outer radius parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX !<c1 parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX !<c2 parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMFE_EQUATIONS_SET_NO_CLASS,CMFE_EQUATIONS_SET_ELASTICITY_CLASS,CMFE_EQUATIONS_SET_FLUID_MECHANICS_CLASS, &
    & CMFE_EQUATIONS_SET_ELECTROMAGNETICS_CLASS,CMFE_EQUATIONS_SET_CLASSICAL_FIELD_CLASS,CMFE_EQUATIONS_SET_BIOELECTRICS_CLASS, &
    & CMFE_EQUATIONS_SET_MODAL_CLASS,CMFE_EQUATIONS_SET_FITTING_CLASS,CMFE_EQUATIONS_SET_OPTIMISATION_CLASS, &
    & CMFE_EQUATIONS_SET_MULTI_PHYSICS_CLASS

  PUBLIC CMFE_EQUATIONS_SET_NO_TYPE,CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_TYPE,CMFE_EQUATIONS_SET_FINITE_ELASTICITY_TYPE, &
    & CMFE_EQUATIONS_SET_STOKES_EQUATION_TYPE,CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_DARCY_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_DARCY_PRESSURE_EQUATION_TYPE,CMFE_EQUATIONS_SET_BURGERS_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_STATIC_POISEUILLE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_DYNAMIC_POISEUILLE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_CHARACTERISTIC_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_ELECTROSTATIC_TYPE,CMFE_EQUATIONS_SET_MAGNETOSTATIC_TYPE,CMFE_EQUATIONS_SET_MAXWELLS_EQUATIONS_TYPE, &
    & CMFE_EQUATIONS_SET_LAPLACE_EQUATION_TYPE,CMFE_EQUATIONS_SET_POISEUILLE_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_POISSON_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_HELMHOLTZ_EQUATION_TYPE,CMFE_EQUATIONS_SET_WAVE_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_DIFFUSION_EQUATION_TYPE,CMFE_EQUATIONS_SET_ADVECTION_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TYPE,CMFE_EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_BIHARMONIC_EQUATION_TYPE,CMFE_EQUATIONS_SET_MONODOMAIN_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_BIDOMAIN_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_ELASTIC_MODAL_TYPE,CMFE_EQUATIONS_SET_DATA_FITTING_EQUATION_TYPE, &
    & CMFE_EQUATIONS_SET_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE

  PUBLIC CMFE_EQUATIONS_SET_FINITE_ELASTICITY_DARCY_TYPE, &
    & CMFE_EQUATIONS_SET_FINITE_ELASTICITY_STOKES_TYPE, CMFE_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_TYPE, &
    & CMFE_EQUATIONS_SET_DIFFUSION_DIFFUSION_TYPE, CMFE_EQUATIONS_SET_DIFFUSION_ADVECTION_DIFFUSION_TYPE

  PUBLIC CMFE_EQUATIONS_SET_NO_SUBTYPE,CMFE_EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE,CMFE_EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE, &
    & CMFE_EQUATIONS_SET_PLATE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_SHELL_SUBTYPE, &
    & CMFE_EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE,CMFE_EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE,CMFE_EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE,CMFE_EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE,CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE,CMFE_EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_SUBTYPE,CMFE_EQUATIONS_SET_ANISOTROPIC_POLYNOMIAL_ACTIVE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE,CMFE_EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE, &
    & CMFE_EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE,CMFE_EQUATIONS_SET_INCOMPRESS_FINITE_ELASTICITY_DARCY_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE,CMFE_EQUATIONS_SET_ELASTICITY_MULTI_COMP_DARCY_INRIA_SUBTYPE, &
    & CMFE_EQUATIONS_SET_INCOMPRESS_ELASTICITY_DRIVEN_DARCY_SUBTYPE, &
    & CMFE_EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_MR_SUBTYPE, &
    & CMFE_EQUATIONS_SET_INCOMPRESS_ELAST_MULTI_COMP_DARCY_SUBTYPE,CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MEMBRANE_SUBTYPE, CMFE_EQUATIONS_SET_ORTHOTROPIC_HOLZAPFEL_OGDEN_SUBTYPE, &
    & CMFE_EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE,  &
    & CMFE_EQUATIONS_SET_ELASTICITY_FLUID_PRES_STATIC_INRIA_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_SUBTYPE,&
    & CMFE_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE,&
    & CMFE_EQUATIONS_SET_STATIC_STOKES_SUBTYPE, CMFE_EQUATIONS_SET_LAPLACE_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TRANSIENT_STOKES_SUBTYPE,CMFE_EQUATIONS_SET_ALE_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ALE_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_OPTIMISED_STOKES_SUBTYPE,CMFE_EQUATIONS_SET_STATIC_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LAPLACE_NAVIER_STOKES_SUBTYPE,CMFE_EQUATIONS_SET_TRANSIENT_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TRANSIENT1D_NAVIER_STOKES_SUBTYPE, CMFE_EQUATIONS_SET_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_STATIC_RBS_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_CHARACTERISTIC_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE, CMFE_EQUATIONS_SET_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_STREE1D0D_SUBTYPE, CMFE_EQUATIONS_SET_STREE1D0D_ADV_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MULTISCALE3D_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_CONSTITUTIVE_MU_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_COUPLED1D0D_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_OPTIMISED_NAVIER_STOKES_SUBTYPE,CMFE_EQUATIONS_SET_STANDARD_DARCY_SUBTYPE, &
    & CMFE_EQUATIONS_SET_QUASISTATIC_DARCY_SUBTYPE,CMFE_EQUATIONS_SET_ALE_DARCY_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TRANSIENT_DARCY_SUBTYPE, &
    & CMFE_EQUATIONS_SET_TRANSIENT_ALE_DARCY_SUBTYPE,CMFE_EQUATIONS_SET_MULTI_COMPARTMENT_DARCY_SUBTYPE, &
    & CMFE_EQUATIONS_SET_STANDARD_LAPLACE_SUBTYPE,CMFE_EQUATIONS_SET_MOVING_MESH_LAPLACE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GENERALISED_LAPLACE_SUBTYPE,CMFE_EQUATIONS_SET_CONSTANT_SOURCE_POISSON_SUBTYPE, &
    & CMFE_EQUATIONS_SET_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_PRESSURE_POISSON_SUBTYPE, CMFE_EQUATIONS_SET_NONLINEAR_PRESSURE_POISSON_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ALE_PRESSURE_POISSON_SUBTYPE, CMFE_EQUATIONS_SET_FITTED_PRESSURE_POISSON_SUBTYPE,&
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_POISSON_SUBTYPE,CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_POISSON_SUBTYPE, &
    & CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_POISSON_SUBTYPE,CMFE_EQUATIONS_SET_STANDARD_HELMHOLTZ_SUBTYPE, &
    & CMFE_EQUATIONS_SET_GENERALISED_HELMHOLTZ_SUBTYPE, &
    & CMFE_EQUATIONS_SET_NO_SOURCE_DIFFUSION_SUBTYPE,CMFE_EQUATIONS_SET_CONSTANT_SOURCE_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_SUBTYPE,CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_SUBTYPE,CMFE_EQUATIONS_SET_MULTI_COMP_TRANSPORT_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_NO_SOURCE_ALE_DIFFUSION_SUBTYPE,CMFE_EQUATIONS_SET_CONSTANT_SOURCE_ALE_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE,CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_ALE_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_ADVECTION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUBTYPE,CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_ADVEC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVEC_DIFF_SUBTYPE,CMFE_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUBTYPE,CMFE_EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE, CMFE_EQUATIONS_SET_CONSTANT_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE, CMFE_EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE, CMFE_EQUATIONS_SET_QUAD_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_EXP_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_QUAD_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_CONST_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_LIN_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUBTYPE,CMFE_EQUATIONS_SET_MULT_COMP_TRANSPORT_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMFE_EQUATIONS_SET_PGM_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_FIRST_BIDOMAIN_SUBTYPE,CMFE_EQUATIONS_SET_SECOND_BIDOMAIN_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MONODOMAIN_BUENOOROVIO_SUBTYPE,&
    & CMFE_EQUATIONS_SET_MONODOMAIN_TENTUSSCHER06_SUBTYPE  ,&
    & CMFE_EQUATIONS_SET_STANDARD_DATA_FITTING_SUBTYPE,CMFE_EQUATIONS_SET_GENERALISED_DATA_FITTING_SUBTYPE, &
    & CMFE_EQUATIONS_SET_VECTOR_DATA_FITTING_SUBTYPE,CMFE_EQUATIONS_SET_DIVFREE_VECTOR_DATA_FITTING_SUBTYPE, &
    & CMFE_EQUATIONS_SET_VECTOR_DATA_PRE_FITTING_SUBTYPE,CMFE_EQUATIONS_SET_DIVFREE_VECTOR_DATA_PRE_FITTING_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MAT_PROPERTIES_DATA_FITTING_SUBTYPE,CMFE_EQUATIONS_SET_MAT_PROP_INRIA_MODEL_DATA_FITTING_SUBTYPE, &
    & CMFE_EQUATIONS_SET_DATA_POINT_VECTOR_STATIC_FITTING_SUBTYPE, &
    & CMFE_EQUATIONS_SET_DATA_PT_VECTOR_QUASISTATIC_FITTING_SUBTYPE, &
    & CMFE_EQUATIONS_SET_PGM_NAVIER_STOKES_SUBTYPE, &
    & CMFE_EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE, &
    & CMFE_EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE, &
    & CMFE_EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_BURGERS_SUBTYPE,CMFE_EQUATIONS_SET_GENERALISED_BURGERS_SUBTYPE, &
    & CMFE_EQUATIONS_SET_STATIC_BURGERS_SUBTYPE, &
    & CMFE_EQUATIONS_SET_INVISCID_BURGERS_SUBTYPE,CMFE_EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE, &
    & CMFE_EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE,CMFE_EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE, &
    & CMFE_EQUATIONS_SET_CONSTIT_AND_GROWTH_LAW_IN_CELLML_SUBTYPE, &
    & CMFE_EQUATIONS_SET_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE, &
    & CMFE_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE

  PUBLIC CMFE_EQUATIONS_SET_CELLML_REAC_SPLIT_REAC_DIFF_SUBTYPE, CMFE_EQUATIONS_SET_CELLML_REAC_NO_SPLIT_REAC_DIFF_SUBTYPE, &
    & CMFE_EQUATIONS_SET_CONSTANT_REAC_DIFF_SUBTYPE

  PUBLIC CMFE_EQUATIONS_SET_FEM_SOLUTION_METHOD,CMFE_EQUATIONS_SET_BEM_SOLUTION_METHOD,CMFE_EQUATIONS_SET_FD_SOLUTION_METHOD, &
    & CMFE_EQUATIONS_SET_FV_SOLUTION_METHOD,CMFE_EQUATIONS_SET_GFEM_SOLUTION_METHOD,CMFE_EQUATIONS_SET_GFD_SOLUTION_METHOD, &
    & CMFE_EQUATIONS_SET_GFV_SOLUTION_METHOD

  PUBLIC CMFE_EQUATIONS_SET_DERIVED_STRAIN,CMFE_EQUATIONS_SET_DERIVED_STRESS
  PUBLIC CMFE_EQUATIONS_MATRIX_STIFFNESS,CMFE_EQUATIONS_MATRIX_DAMPING,CMFE_EQUATIONS_MATRIX_MASS

  PUBLIC CMFE_EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_1,CMFE_EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_2, &
    & CMFE_EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_1,CMFE_EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_2

  PUBLIC CMFE_EQUATIONS_SET_HELMHOLTZ_EQUATION_TWO_DIM_1

  PUBLIC CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1,CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1, &
    & CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_2,CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1, &
    & CMFE_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2

  PUBLIC CMFE_EQUATIONS_SET_DIFFUSION_EQUATION_ONE_DIM_1,CMFE_EQUATIONS_SET_DIFFUSION_EQUATION_TWO_DIM_1, &
    & CMFE_EQUATIONS_SET_DIFFUSION_EQUATION_THREE_DIM_1, &
    & CMFE_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_THREE_DIM_1,CMFE_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_ONE_DIM_1, &
    & CMFE_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_ONE_DIM_1,CMFE_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_TWO_DIM, &
    & CMFE_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_THREE_DIM,CMFE_EQUATIONS_SET_MULTI_COMP_DIFFUSION_THREE_COMP_THREE_DIM, &
    & CMFE_EQUATIONS_SET_MULTI_COMP_DIFFUSION_FOUR_COMP_THREE_DIM


  PUBLIC CMFE_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TWO_DIM_1

  PUBLIC CMFE_EQUATIONS_SET_POISEUILLE_EQUATION_TWO_DIM_1

  PUBLIC CMFE_EQUATIONS_SET_BURGERS_EQUATION_ONE_DIM_1,CMFE_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_1, &
    & CMFE_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_2, &
    & CMFE_EQUATIONS_SET_STATIC_BURGERS_EQUATION_ONE_DIM_1

  PUBLIC CMFE_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_1,CMFE_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_2, &
    & CMFE_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_3
  PUBLIC CMFE_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_1,CMFE_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_2, &
    & CMFE_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_3
  PUBLIC CMFE_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_1, &
    & CMFE_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_2

  PUBLIC CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_1,CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_2, &
    & CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_3
  PUBLIC CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_4,CMFE_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_5
  PUBLIC CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_1,CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_2, &
    & CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_3
  PUBLIC CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_4,CMFE_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_5

  PUBLIC CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_POISEUILLE, &
    & CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_TAYLOR_GREEN
  PUBLIC CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_FLOWRATE_AORTA, &
    &    CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_SINUSOID, &
    &    CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_SPLINT_FROM_FILE
  PUBLIC CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_1,CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_2, &
    & CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_3
  PUBLIC CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_4,CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_5
  PUBLIC CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_1,CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_2, &
    & CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_3
  PUBLIC CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_4,CMFE_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_5

  PUBLIC CMFE_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_1,CMFE_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_2, &
    & CMFE_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_3
  PUBLIC CMFE_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_1,CMFE_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_2, &
    & CMFE_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_3
  PUBLIC CMFE_EQUATIONS_SET_INCOMP_ELAST_DARCY_ANALYTIC_DARCY

  PUBLIC CMFE_EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER
  PUBLIC CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX,CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX
  PUBLIC CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX,CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX
  PUBLIC CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX,CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX
  PUBLIC CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX,CMFE_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX

!!==================================================================================================================================
!!
!! EQUATIONS_SET_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finish the creation of a analytic solution for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_AnalyticCreateStart
  INTERFACE cmfe_EquationsSet_AnalyticCreateFinish
    MODULE PROCEDURE cmfe_EquationsSet_AnalyticCreateFinishNumber
    MODULE PROCEDURE cmfe_EquationsSet_AnalyticCreateFinishObj
  END INTERFACE cmfe_EquationsSet_AnalyticCreateFinish

  !>Start the creation of a analytic solution for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_AnalyticCreateFinish
  INTERFACE cmfe_EquationsSet_AnalyticCreateStart
    MODULE PROCEDURE cmfe_EquationsSet_AnalyticCreateStartNumber
    MODULE PROCEDURE cmfe_EquationsSet_AnalyticCreateStartObj
  END INTERFACE cmfe_EquationsSet_AnalyticCreateStart

  !>Destroy the analytic solution for an equations set.
  INTERFACE cmfe_EquationsSet_AnalyticDestroy
    MODULE PROCEDURE cmfe_EquationsSet_AnalyticDestroyNumber
    MODULE PROCEDURE cmfe_EquationsSet_AnalyticDestroyObj
  END INTERFACE cmfe_EquationsSet_AnalyticDestroy

  !>Evaluates the current analytic solution for an equations set.
  INTERFACE cmfe_EquationsSet_AnalyticEvaluate
    MODULE PROCEDURE cmfe_EquationsSet_AnalyticEvaluateNumber
    MODULE PROCEDURE cmfe_EquationsSet_AnalyticEvaluateObj
  END INTERFACE cmfe_EquationsSet_AnalyticEvaluate

  !>Returns the analytic time for an equations set.
  INTERFACE cmfe_EquationsSet_AnalyticTimeGet
    MODULE PROCEDURE cmfe_EquationsSet_AnalyticTimeGetNumber
    MODULE PROCEDURE cmfe_EquationsSet_AnalyticTimeGetObj
  END INTERFACE cmfe_EquationsSet_AnalyticTimeGet

  !>Sets/changes the analytic time for an equations set.
  INTERFACE cmfe_EquationsSet_AnalyticTimeSet
    MODULE PROCEDURE cmfe_EquationsSet_AnalyticTimeSetNumber
    MODULE PROCEDURE cmfe_EquationsSet_AnalyticTimeSetObj
  END INTERFACE cmfe_EquationsSet_AnalyticTimeSet

  !>Finish the creation of an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_CreateStart
  INTERFACE cmfe_EquationsSet_CreateFinish
    MODULE PROCEDURE cmfe_EquationsSet_CreateFinishNumber
    MODULE PROCEDURE cmfe_EquationsSet_CreateFinishObj
  END INTERFACE cmfe_EquationsSet_CreateFinish

  !>Start the creation of an equations set on a region. \see OpenCMISS::Iron::cmfe_EquationsSet_CreateFinish
  INTERFACE cmfe_EquationsSet_CreateStart
    MODULE PROCEDURE cmfe_EquationsSet_CreateStartNumber
    MODULE PROCEDURE cmfe_EquationsSet_CreateStartObj
  END INTERFACE cmfe_EquationsSet_CreateStart

  !>Destroy an equations set.
  INTERFACE cmfe_EquationsSet_Destroy
    MODULE PROCEDURE cmfe_EquationsSet_DestroyNumber
    MODULE PROCEDURE cmfe_EquationsSet_DestroyObj
  END INTERFACE cmfe_EquationsSet_Destroy

  !>Finish the creation of dependent variables for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_DependentCreateStart
  INTERFACE cmfe_EquationsSet_DependentCreateFinish
    MODULE PROCEDURE cmfe_EquationsSet_DependentCreateFinishNumber
    MODULE PROCEDURE cmfe_EquationsSet_DependentCreateFinishObj
  END INTERFACE cmfe_EquationsSet_DependentCreateFinish

  !>Start the creation of dependent variables for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_DependentCreateFinish
  INTERFACE cmfe_EquationsSet_DependentCreateStart
    MODULE PROCEDURE cmfe_EquationsSet_DependentCreateStartNumber
    MODULE PROCEDURE cmfe_EquationsSet_DependentCreateStartObj
  END INTERFACE cmfe_EquationsSet_DependentCreateStart

  !>Destroy the dependent variables for an equations set.
  INTERFACE cmfe_EquationsSet_DependentDestroy
    MODULE PROCEDURE cmfe_EquationsSet_DependentDestroyNumber
    MODULE PROCEDURE cmfe_EquationsSet_DependentDestroyObj
  END INTERFACE cmfe_EquationsSet_DependentDestroy

  !>Finish the creation of derived variables for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_DerivedCreateStart
  INTERFACE cmfe_EquationsSet_DerivedCreateFinish
    MODULE PROCEDURE cmfe_EquationsSet_DerivedCreateFinishNumber
    MODULE PROCEDURE cmfe_EquationsSet_DerivedCreateFinishObj
  END INTERFACE cmfe_EquationsSet_DerivedCreateFinish

  !>Start the creation of derived variables for an equations set. These are used to store any intermediate
  !>calculated values, for example stress and strain fields in an elasticity problem. \see OpenCMISS::Iron::cmfe_EquationsSet_DerivedCreateFinish
  INTERFACE cmfe_EquationsSet_DerivedCreateStart
    MODULE PROCEDURE cmfe_EquationsSet_DerivedCreateStartNumber
    MODULE PROCEDURE cmfe_EquationsSet_DerivedCreateStartObj
  END INTERFACE cmfe_EquationsSet_DerivedCreateStart

  !>Destroy the derived variables for an equations set.
  INTERFACE cmfe_EquationsSet_DerivedDestroy
    MODULE PROCEDURE cmfe_EquationsSet_DerivedDestroyNumber
    MODULE PROCEDURE cmfe_EquationsSet_DerivedDestroyObj
  END INTERFACE cmfe_EquationsSet_DerivedDestroy

  !>Finish the creation of equations for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_EquationsCreateStart
  INTERFACE cmfe_EquationsSet_EquationsCreateFinish
    MODULE PROCEDURE cmfe_EquationsSet_EquationsCreateFinishNumber
    MODULE PROCEDURE cmfe_EquationsSet_EquationsCreateFinishObj
  END INTERFACE cmfe_EquationsSet_EquationsCreateFinish

  !>Start the creation of equations for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_EquationsCreateFinish
  INTERFACE cmfe_EquationsSet_EquationsCreateStart
    MODULE PROCEDURE cmfe_EquationsSet_EquationsCreateStartNumber
    MODULE PROCEDURE cmfe_EquationsSet_EquationsCreateStartObj
  END INTERFACE cmfe_EquationsSet_EquationsCreateStart

  !>Destroy the equations for an equations set.
  INTERFACE cmfe_EquationsSet_EquationsDestroy
    MODULE PROCEDURE cmfe_EquationsSet_EquationsDestroyNumber
    MODULE PROCEDURE cmfe_EquationsSet_EquationsDestroyObj
  END INTERFACE cmfe_EquationsSet_EquationsDestroy

  !>Finish the creation of independent fields for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_IndependentCreateStart
  INTERFACE cmfe_EquationsSet_IndependentCreateFinish
    MODULE PROCEDURE cmfe_EquationsSet_IndependentCreateFinishNumber
    MODULE PROCEDURE cmfe_EquationsSet_IndependentCreateFinishObj
  END INTERFACE cmfe_EquationsSet_IndependentCreateFinish

  !>Start the creation of independent fields for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_MaterialsCreateFinish
  INTERFACE cmfe_EquationsSet_IndependentCreateStart
    MODULE PROCEDURE cmfe_EquationsSet_IndependentCreateStartNumber
    MODULE PROCEDURE cmfe_EquationsSet_IndependentCreateStartObj
  END INTERFACE cmfe_EquationsSet_IndependentCreateStart

  !>Destroy the independent fields for an equations set.
  INTERFACE cmfe_EquationsSet_IndependentDestroy
    MODULE PROCEDURE cmfe_EquationsSet_IndependentDestroyNumber
    MODULE PROCEDURE cmfe_EquationsSet_IndependentDestroyObj
  END INTERFACE cmfe_EquationsSet_IndependentDestroy

  !>Finish the creation of materials for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_MaterialsCreateStart
  INTERFACE cmfe_EquationsSet_MaterialsCreateFinish
    MODULE PROCEDURE cmfe_EquationsSet_MaterialsCreateFinishNumber
    MODULE PROCEDURE cmfe_EquationsSet_MaterialsCreateFinishObj
  END INTERFACE cmfe_EquationsSet_MaterialsCreateFinish

  !>Start the creation of materials for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_MaterialsCreateFinish
  INTERFACE cmfe_EquationsSet_MaterialsCreateStart
    MODULE PROCEDURE cmfe_EquationsSet_MaterialsCreateStartNumber
    MODULE PROCEDURE cmfe_EquationsSet_MaterialsCreateStartObj
  END INTERFACE cmfe_EquationsSet_MaterialsCreateStart

  !>Destroy the materials for an equations set.
  INTERFACE cmfe_EquationsSet_MaterialsDestroy
    MODULE PROCEDURE cmfe_EquationsSet_MaterialsDestroyNumber
    MODULE PROCEDURE cmfe_EquationsSet_MaterialsDestroyObj
  END INTERFACE cmfe_EquationsSet_MaterialsDestroy

  !>Returns the solution method for an equations set.
  INTERFACE cmfe_EquationsSet_SolutionMethodGet
    MODULE PROCEDURE cmfe_EquationsSet_SolutionMethodGetNumber
    MODULE PROCEDURE cmfe_EquationsSet_SolutionMethodGetObj
  END INTERFACE cmfe_EquationsSet_SolutionMethodGet

  !>Sets/changes the solution method for an equations set.
  INTERFACE cmfe_EquationsSet_SolutionMethodSet
    MODULE PROCEDURE cmfe_EquationsSet_SolutionMethodSetNumber
    MODULE PROCEDURE cmfe_EquationsSet_SolutionMethodSetObj
  END INTERFACE cmfe_EquationsSet_SolutionMethodSet

  !>Finish the creation of a source for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_SourceCreateStart
  INTERFACE cmfe_EquationsSet_SourceCreateFinish
    MODULE PROCEDURE cmfe_EquationsSet_SourceCreateFinishNumber
    MODULE PROCEDURE cmfe_EquationsSet_SourceCreateFinishObj
  END INTERFACE cmfe_EquationsSet_SourceCreateFinish

  !>Start the creation of a source for an equations set. \see OpenCMISS::Iron::cmfe_EquationsSet_SourceCreateFinish
  INTERFACE cmfe_EquationsSet_SourceCreateStart
    MODULE PROCEDURE cmfe_EquationsSet_SourceCreateStartNumber
    MODULE PROCEDURE cmfe_EquationsSet_SourceCreateStartObj
  END INTERFACE cmfe_EquationsSet_SourceCreateStart

  !>Destroy the source for an equations set.
  INTERFACE cmfe_EquationsSet_SourceDestroy
    MODULE PROCEDURE cmfe_EquationsSet_SourceDestroyNumber
    MODULE PROCEDURE cmfe_EquationsSet_SourceDestroyObj
  END INTERFACE cmfe_EquationsSet_SourceDestroy

  !>Returns the equations set specification array
  INTERFACE cmfe_EquationsSet_SpecificationGet
    MODULE PROCEDURE cmfe_EquationsSet_SpecificationGetNumber
    MODULE PROCEDURE cmfe_EquationsSet_SpecificationGetObj
  END INTERFACE cmfe_EquationsSet_SpecificationGet

  !>Returns the size of the equations set specification array.
  INTERFACE cmfe_EquationsSet_SpecificationSizeGet
    MODULE PROCEDURE cmfe_EquationsSet_SpecificationSizeGetNumber
    MODULE PROCEDURE cmfe_EquationsSet_SpecificationSizeGetObj
  END INTERFACE cmfe_EquationsSet_SpecificationSizeGet

  !>Calculates an output field for the equations set.
  INTERFACE cmfe_EquationsSet_DerivedVariableCalculate
    MODULE PROCEDURE cmfe_EquationsSet_DerivedVariableCalculateNumber
    MODULE PROCEDURE cmfe_EquationsSet_DerivedVariableCalculateObj
  END INTERFACE cmfe_EquationsSet_DerivedVariableCalculate

  !>Set the derived field variable type to be used by a derived variable
  INTERFACE cmfe_EquationsSet_DerivedVariableSet
    MODULE PROCEDURE cmfe_EquationsSet_DerivedVariableSetNumber
    MODULE PROCEDURE cmfe_EquationsSet_DerivedVariableSetObj
  END INTERFACE cmfe_EquationsSet_DerivedVariableSet
  
  !>Calculate the strain tensor at a given element xi location.
  INTERFACE cmfe_EquationsSet_StrainInterpolateXi
    MODULE PROCEDURE cmfe_EquationsSet_StrainInterpolateXiNumber
    MODULE PROCEDURE cmfe_EquationsSet_StrainInterpolateXiObj
  END INTERFACE cmfe_EquationsSet_StrainInterpolateXi

  !>Gets the equations set analytic user parameter
  INTERFACE cmfe_EquationsSet_AnalyticUserParamGet
    MODULE PROCEDURE cmfe_EquationsSet_AnalyticUserParamGetNumber
    MODULE PROCEDURE cmfe_EquationsSet_AnalyticUserParamGetObj
  END INTERFACE cmfe_EquationsSet_AnalyticUserParamGet

  !>Sets/changes the equations set analytic user parameter
  INTERFACE cmfe_EquationsSet_AnalyticUserParamSet
    MODULE PROCEDURE cmfe_EquationsSet_AnalyticUserParamSetNumber
    MODULE PROCEDURE cmfe_EquationsSet_AnalyticUserParamSetObj
  END INTERFACE cmfe_EquationsSet_AnalyticUserParamSet

  PUBLIC cmfe_EquationsSet_AnalyticCreateFinish,cmfe_EquationsSet_AnalyticCreateStart

  PUBLIC cmfe_EquationsSet_AnalyticDestroy

  PUBLIC cmfe_EquationsSet_AnalyticEvaluate

  PUBLIC cmfe_EquationsSet_AnalyticTimeGet,cmfe_EquationsSet_AnalyticTimeSet

  PUBLIC cmfe_EquationsSet_CreateFinish,cmfe_EquationsSet_CreateStart

  PUBLIC cmfe_EquationsSet_Destroy

  PUBLIC cmfe_EquationsSet_DependentCreateFinish,cmfe_EquationsSet_DependentCreateStart

  PUBLIC cmfe_EquationsSet_DependentDestroy

  PUBLIC cmfe_EquationsSet_DerivedCreateFinish,cmfe_EquationsSet_DerivedCreateStart

  PUBLIC cmfe_EquationsSet_DerivedDestroy

  PUBLIC cmfe_EquationsSet_DerivedVariableCalculate,cmfe_EquationsSet_DerivedVariableSet

  PUBLIC cmfe_EquationsSet_EquationsCreateFinish,cmfe_EquationsSet_EquationsCreateStart

  PUBLIC cmfe_EquationsSet_EquationsDestroy

  PUBLIC cmfe_EquationsSet_IndependentCreateFinish,cmfe_EquationsSet_IndependentCreateStart

  PUBLIC cmfe_EquationsSet_IndependentDestroy

  PUBLIC cmfe_EquationsSet_MaterialsCreateFinish,cmfe_EquationsSet_MaterialsCreateStart

  PUBLIC cmfe_EquationsSet_MaterialsDestroy

  PUBLIC cmfe_EquationsSet_SolutionMethodGet,cmfe_EquationsSet_SolutionMethodSet

  PUBLIC cmfe_EquationsSet_SourceCreateFinish,cmfe_EquationsSet_SourceCreateStart

  PUBLIC cmfe_EquationsSet_SourceDestroy

  PUBLIC cmfe_EquationsSet_SpecificationGet,cmfe_EquationsSet_SpecificationSizeGet

  PUBLIC cmfe_EquationsSet_StrainInterpolateXi

  PUBLIC cmfe_EquationsSet_AnalyticUserParamSet,cmfe_EquationsSet_AnalyticUserParamGet

!!==================================================================================================================================
!!
!! FIELD_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_FieldConstants OPENCMISS::Field::Constants
  !> \brief Field constants.
  !>@{
  !> \addtogroup OPENCMISS_FieldDependentTypes OPENCMISS::Field::DependentTypes
  !> \brief Depedent field parameter types.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_INDEPENDENT_TYPE = FIELD_INDEPENDENT_TYPE !<Independent field type \see OPENCMISS_FieldDependentTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEPENDENT_TYPE = FIELD_DEPENDENT_TYPE !<Dependent field type \see OPENCMISS_FieldDependentTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldDimensionTypes OPENCMISS::Field::DimensionTypes
  !> \brief Field dimension parameter types.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_SCALAR_DIMENSION_TYPE = FIELD_SCALAR_DIMENSION_TYPE !<Scalar field \see OPENCMISS_FieldDimensionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_VECTOR_DIMENSION_TYPE = FIELD_VECTOR_DIMENSION_TYPE !<Vector field \see OPENCMISS_FieldDimensionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_TENSOR_DIMENSION_TYPE = FIELD_TENSOR_DIMENSION_TYPE !<Tensor field \see OPENCMISS_FieldDimensionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldTypes OPENCMISS::Field::Types
  !> \brief Field type parameters.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_GEOMETRIC_TYPE = FIELD_GEOMETRIC_TYPE !<Geometric field \see OPENCMISS_FieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_FIBRE_TYPE = FIELD_FIBRE_TYPE !<Fibre field \see OPENCMISS_FieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_GENERAL_TYPE = FIELD_GENERAL_TYPE !<General field \see OPENCMISS_FieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_MATERIAL_TYPE = FIELD_MATERIAL_TYPE !<Material field \see OPENCMISS_FieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_GEOMETRIC_GENERAL_TYPE = FIELD_GEOMETRIC_GENERAL_TYPE !<Geometric general field \see OPENCMISS_FieldTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldInterpolationTypes OPENCMISS::Field::InterpolationTypes
  !> \brief Field interpolation parameters.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_CONSTANT_INTERPOLATION = FIELD_CONSTANT_INTERPOLATION !<Constant interpolation. One parameter for the field \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_ELEMENT_BASED_INTERPOLATION = FIELD_ELEMENT_BASED_INTERPOLATION !<Element based interpolation. Parameters are different in each element \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_NODE_BASED_INTERPOLATION = FIELD_NODE_BASED_INTERPOLATION !<Node based interpolation. Parameters are nodal based and a basis function is used \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_GRID_POINT_BASED_INTERPOLATION = FIELD_GRID_POINT_BASED_INTERPOLATION !<Grid point based interpolation. Parameters are different at each grid point \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_GAUSS_POINT_BASED_INTERPOLATION = FIELD_GAUSS_POINT_BASED_INTERPOLATION !<Gauss point based interpolation. Parameters are different at each Gauss point \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DATA_POINT_BASED_INTERPOLATION = FIELD_DATA_POINT_BASED_INTERPOLATION !<Data point based interpolation. Parameters are different at each data point \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldVariableTypes OPENCMISS::Field::VariableTypes
  !> \brief Field variable type parameters.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_NUMBER_OF_VARIABLE_SUBTYPES = FIELD_NUMBER_OF_VARIABLE_SUBTYPES !<The number of subtypes of a variable - i.e., u, du/dn, du/dt, d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_U_VARIABLE_TYPE = FIELD_U_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELUDELN_VARIABLE_TYPE = FIELD_DELUDELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELUDELT_VARIABLE_TYPE = FIELD_DELUDELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2UDELT2_VARIABLE_TYPE = FIELD_DEL2UDELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_V_VARIABLE_TYPE = FIELD_V_VARIABLE_TYPE !<Second standard variable type i.e., v \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELVDELN_VARIABLE_TYPE = FIELD_DELVDELN_VARIABLE_TYPE !<Second normal derivative variable type i.e., dv/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELVDELT_VARIABLE_TYPE = FIELD_DELVDELT_VARIABLE_TYPE !<Second first time derivative variable type i.e., dv/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2VDELT2_VARIABLE_TYPE = FIELD_DEL2VDELT2_VARIABLE_TYPE !<Second second time derivative variable type i.e., d^2v/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_U1_VARIABLE_TYPE = FIELD_U1_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU1DELN_VARIABLE_TYPE = FIELD_DELU1DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU1DELT_VARIABLE_TYPE = FIELD_DELU1DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U1DELT2_VARIABLE_TYPE = FIELD_DEL2U1DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_U2_VARIABLE_TYPE = FIELD_U2_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU2DELN_VARIABLE_TYPE = FIELD_DELU2DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU2DELT_VARIABLE_TYPE = FIELD_DELU2DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U2DELT2_VARIABLE_TYPE = FIELD_DEL2U2DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_U3_VARIABLE_TYPE = FIELD_U3_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU3DELN_VARIABLE_TYPE = FIELD_DELU3DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU3DELT_VARIABLE_TYPE = FIELD_DELU3DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U3DELT2_VARIABLE_TYPE = FIELD_DEL2U3DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_U4_VARIABLE_TYPE = FIELD_U4_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU4DELN_VARIABLE_TYPE = FIELD_DELU4DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU4DELT_VARIABLE_TYPE = FIELD_DELU4DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U4DELT2_VARIABLE_TYPE = FIELD_DEL2U4DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_U5_VARIABLE_TYPE = FIELD_U5_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU5DELN_VARIABLE_TYPE = FIELD_DELU5DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU5DELT_VARIABLE_TYPE = FIELD_DELU5DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U5DELT2_VARIABLE_TYPE = FIELD_DEL2U5DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_U6_VARIABLE_TYPE = FIELD_U6_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU6DELN_VARIABLE_TYPE = FIELD_DELU6DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU6DELT_VARIABLE_TYPE = FIELD_DELU6DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U6DELT2_VARIABLE_TYPE = FIELD_DEL2U6DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_U7_VARIABLE_TYPE = FIELD_U7_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU7DELN_VARIABLE_TYPE = FIELD_DELU7DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU7DELT_VARIABLE_TYPE = FIELD_DELU7DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U7DELT2_VARIABLE_TYPE = FIELD_DEL2U7DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_U8_VARIABLE_TYPE = FIELD_U8_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU8DELN_VARIABLE_TYPE = FIELD_DELU8DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU8DELT_VARIABLE_TYPE = FIELD_DELU8DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U8DELT2_VARIABLE_TYPE = FIELD_DEL2U8DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_U9_VARIABLE_TYPE = FIELD_U9_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU9DELN_VARIABLE_TYPE = FIELD_DELU9DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU9DELT_VARIABLE_TYPE = FIELD_DELU9DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U9DELT2_VARIABLE_TYPE = FIELD_DEL2U9DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_U10_VARIABLE_TYPE = FIELD_U10_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU10DELN_VARIABLE_TYPE = FIELD_DELU10DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DELU10DELT_VARIABLE_TYPE = FIELD_DELU10DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DEL2U10DELT2_VARIABLE_TYPE = FIELD_DEL2U10DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldDataTypes OPENCMISS::Field::DataTypes
  !> \brief Field data types
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_INTG_TYPE = FIELD_INTG_TYPE !<Integer field data type \see OPENCMISS_FieldDataTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_SP_TYPE = FIELD_SP_TYPE !<Single precision real field data type \see OPENCMISS_FieldDataTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_DP_TYPE = FIELD_DP_TYPE !<Double precision real field data type \see OPENCMISS_FieldDataTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_L_TYPE = FIELD_L_TYPE !<Logical field data type \see OPENCMISS_FieldDataTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldDOFOrderTypes OPENCMISS::Field::DOFOrderTypes
  !> \brief Field DOF order types
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_SEPARATED_COMPONENT_DOF_ORDER = FIELD_SEPARATED_COMPONENT_DOF_ORDER !<Field variable component dofs are not contiguous \see OPENCMISS_FieldDOFOrderTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER = FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER !<Field variable component dofs are contiguous \see OPENCMISS_FieldDOFOrderTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldParameterSetTypes OPENCMISS::Field::ParameterSetTypes
  !> \brief Field parameter set type parameters
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_VALUES_SET_TYPE = FIELD_VALUES_SET_TYPE !<The parameter set corresponding to the field values (at time T+DT for dynamic problems) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_BOUNDARY_CONDITIONS_SET_TYPE = FIELD_BOUNDARY_CONDITIONS_SET_TYPE !<The parameter set corresponding to the field boundary condition values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_INITIAL_VALUES_SET_TYPE = FIELD_INITIAL_VALUES_SET_TYPE !<The parameter set corresponding to the field initial values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_INCREMENTAL_VALUES_SET_TYPE = FIELD_INCREMENTAL_VALUES_SET_TYPE !<The parameter set corresponding to the field incremental values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_ANALYTIC_VALUES_SET_TYPE = FIELD_ANALYTIC_VALUES_SET_TYPE !<The parameter set corresponding to the analytic field values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_PREVIOUS_VALUES_SET_TYPE = FIELD_PREVIOUS_VALUES_SET_TYPE !<The parameter set corresponding to the previous field values (at time T) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE = FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE !<The parameter set corresponding to the mean predicited avalues (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_VELOCITY_VALUES_SET_TYPE = FIELD_VELOCITY_VALUES_SET_TYPE !<The parameter set corresponding to the velocity values (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_INITIAL_VELOCITY_SET_TYPE = FIELD_INITIAL_VELOCITY_SET_TYPE !<The parameter set corresponding to the initial velocity values for dynamic problems. This is also the previous velocity values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_PREVIOUS_VELOCITY_SET_TYPE = FIELD_PREVIOUS_VELOCITY_SET_TYPE !<The parameter set corresponding to the previous velocity values (at time T). This is also the initial velocity values for dynamic problems. \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE = FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE !<The parameter set corresponding to the mean predicited velocity values (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_ACCELERATION_VALUES_SET_TYPE = FIELD_ACCELERATION_VALUES_SET_TYPE !<The parameter set corresponding to the acceleration values (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_INITIAL_ACCELERATION_SET_TYPE = FIELD_INITIAL_ACCELERATION_SET_TYPE !<The parameter set corresponding to the initial acceleration values for dynamic problems. This is also the previous accelearation values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_PREVIOUS_ACCELERATION_SET_TYPE = FIELD_PREVIOUS_ACCELERATION_SET_TYPE !<The parameter set corresponding to the previous acceleration values (at time T).This is also the initial acceleration values for dynamic problems. \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE = FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE !<The parameter set corresponding to the mean predicited acceleration values (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_PRESSURE_VALUES_SET_TYPE = FIELD_PRESSURE_VALUES_SET_TYPE !<The parameter set corresponding to the surface pressure values. \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_PREVIOUS_PRESSURE_SET_TYPE = FIELD_PREVIOUS_PRESSURE_SET_TYPE !<The parameter set corresponding to the previous surface pressure values (at time T). \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE = FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE !<The parameter set corresponding to the impermeable flag values. \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_INTEGRATED_NEUMANN_SET_TYPE = FIELD_INTEGRATED_NEUMANN_SET_TYPE !<Stores integrated Neumann values calculated from Neumann point values. \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldScalingTypes OPENCMISS::Field::ScalingTypes
  !> \brief Field scaling type parameters
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_NO_SCALING = FIELD_NO_SCALING !<The field is not scaled \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_UNIT_SCALING = FIELD_UNIT_SCALING !<The field has unit scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_ARC_LENGTH_SCALING = FIELD_ARC_LENGTH_SCALING !<The field has arc length scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_ARITHMETIC_MEAN_SCALING = FIELD_ARITHMETIC_MEAN_SCALING !<The field has arithmetic mean of the arc length scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_GEOMETRIC_MEAN_SCALING = FIELD_GEOMETRIC_MEAN_SCALING !<The field has geometric mean of the arc length scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_FIELD_HARMONIC_MEAN_SCALING = FIELD_HARMONIC_MEAN_SCALING !<The field has geometric mean of the arc length scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the interpolation type for a field variable component.
  INTERFACE cmfe_Field_ComponentInterpolationGet
    MODULE PROCEDURE cmfe_Field_ComponentInterpolationGetNumber
    MODULE PROCEDURE cmfe_Field_ComponentInterpolationGetObj
  END INTERFACE cmfe_Field_ComponentInterpolationGet

  !>Sets/changes the interpolation type for a field variable component.
  INTERFACE cmfe_Field_ComponentInterpolationSet
    MODULE PROCEDURE cmfe_Field_ComponentInterpolationSetNumber
    MODULE PROCEDURE cmfe_Field_ComponentInterpolationSetObj
  END INTERFACE cmfe_Field_ComponentInterpolationSet

  !>Returns the label for a field variable component.
  INTERFACE cmfe_Field_ComponentLabelGet
    MODULE PROCEDURE cmfe_Field_ComponentLabelGetCNumber
    MODULE PROCEDURE cmfe_Field_ComponentLabelGetCObj
    MODULE PROCEDURE cmfe_Field_ComponentLabelGetVSNumber
    MODULE PROCEDURE cmfe_Field_ComponentLabelGetVSObj
  END INTERFACE cmfe_Field_ComponentLabelGet

  !>Sets/changes the label for a field variable component.
  INTERFACE cmfe_Field_ComponentLabelSet
    MODULE PROCEDURE cmfe_Field_ComponentLabelSetCNumber
    MODULE PROCEDURE cmfe_Field_ComponentLabelSetCObj
    MODULE PROCEDURE cmfe_Field_ComponentLabelSetVSNumber
    MODULE PROCEDURE cmfe_Field_ComponentLabelSetVSObj
  END INTERFACE cmfe_Field_ComponentLabelSet

  !>Returns the mesh component number for a field variable component.
  INTERFACE cmfe_Field_ComponentMeshComponentGet
    MODULE PROCEDURE cmfe_Field_ComponentMeshComponentGetNumber
    MODULE PROCEDURE cmfe_Field_ComponentMeshComponentGetObj
  END INTERFACE cmfe_Field_ComponentMeshComponentGet

  !>Sets/changes the mesh component number for a field variable component.
  INTERFACE cmfe_Field_ComponentMeshComponentSet
    MODULE PROCEDURE cmfe_Field_ComponentMeshComponentSetNumber
    MODULE PROCEDURE cmfe_Field_ComponentMeshComponentSetObj
  END INTERFACE cmfe_Field_ComponentMeshComponentSet

  !>Initialises the values of a parameter set of a field variable component to a constant value.
  INTERFACE cmfe_Field_ComponentValuesInitialise
    MODULE PROCEDURE cmfe_Field_ComponentValuesInitialiseIntgNumber
    MODULE PROCEDURE cmfe_Field_ComponentValuesInitialiseIntgObj
    MODULE PROCEDURE cmfe_Field_ComponentValuesInitialiseSPNumber
    MODULE PROCEDURE cmfe_Field_ComponentValuesInitialiseSPObj
    MODULE PROCEDURE cmfe_Field_ComponentValuesInitialiseDPNumber
    MODULE PROCEDURE cmfe_Field_ComponentValuesInitialiseDPObj
    MODULE PROCEDURE cmfe_Field_ComponentValuesInitialiseLNumber
    MODULE PROCEDURE cmfe_Field_ComponentValuesInitialiseLObj
  END INTERFACE cmfe_Field_ComponentValuesInitialise

  !>Returns the data type for a field variable.
  INTERFACE cmfe_Field_DataTypeGet
    MODULE PROCEDURE cmfe_Field_DataTypeGetNumber
    MODULE PROCEDURE cmfe_Field_DataTypeGetObj
  END INTERFACE cmfe_Field_DataTypeGet

  !>Sets/changes the data type for a field variable.
  INTERFACE cmfe_Field_DataTypeSet
    MODULE PROCEDURE cmfe_Field_DataTypeSetNumber
    MODULE PROCEDURE cmfe_Field_DataTypeSetObj
  END INTERFACE cmfe_Field_DataTypeSet

  !>Returns the DOF order type for a field variable.
  INTERFACE cmfe_Field_DOFOrderTypeGet
    MODULE PROCEDURE cmfe_Field_DOFOrderTypeGetNumber
    MODULE PROCEDURE cmfe_Field_DOFOrderTypeGetObj
  END INTERFACE cmfe_Field_DOFOrderTypeGet

  !>Sets/changes the DOF order type for a field variable. Note: for contiguous coponent DOF ordering all the components of the field variable must have the same interpolation type.
  INTERFACE cmfe_Field_DOFOrderTypeSet
    MODULE PROCEDURE cmfe_Field_DOFOrderTypeSetNumber
    MODULE PROCEDURE cmfe_Field_DOFOrderTypeSetObj
  END INTERFACE cmfe_Field_DOFOrderTypeSet

  !>Finishes the creation of a field. \see OpenCMISS::Iron::cmfe_Field_CreateStart
  INTERFACE cmfe_Field_CreateFinish
    MODULE PROCEDURE cmfe_Field_CreateFinishNumber
    MODULE PROCEDURE cmfe_Field_CreateFinishObj
  END INTERFACE cmfe_Field_CreateFinish

  !>Starts the creation of a field. \see OpenCMISS::Iron::cmfe_Field_CreateFinish
  INTERFACE cmfe_Field_CreateStart
    MODULE PROCEDURE cmfe_Field_CreateStartNumber
    MODULE PROCEDURE cmfe_Field_CreateStartInterfaceObj
    MODULE PROCEDURE cmfe_Field_CreateStartRegionObj
  END INTERFACE cmfe_Field_CreateStart

  !>Returns the dependent type for a field.
  INTERFACE cmfe_Field_DependentTypeGet
    MODULE PROCEDURE cmfe_Field_DependentTypeGetNumber
    MODULE PROCEDURE cmfe_Field_DependentTypeGetObj
  END INTERFACE cmfe_Field_DependentTypeGet

  !>Sets/changes the dependent type for a field.
  INTERFACE cmfe_Field_DependentTypeSet
    MODULE PROCEDURE cmfe_Field_DependentTypeSetNumber
    MODULE PROCEDURE cmfe_Field_DependentTypeSetObj
  END INTERFACE cmfe_Field_DependentTypeSet

  !>Destroys a field.
  INTERFACE cmfe_Field_Destroy
    MODULE PROCEDURE cmfe_Field_DestroyNumber
    MODULE PROCEDURE cmfe_Field_DestroyObj
  END INTERFACE cmfe_Field_Destroy

  !>Returns the field dimension for a field variable.
  INTERFACE cmfe_Field_DimensionGet
    MODULE PROCEDURE cmfe_Field_DimensionGetNumber
    MODULE PROCEDURE cmfe_Field_DimensionGetObj
  END INTERFACE cmfe_Field_DimensionGet

  !>Sets/changes the field dimension for a field variable.
  INTERFACE cmfe_Field_DimensionSet
    MODULE PROCEDURE cmfe_Field_DimensionSetNumber
    MODULE PROCEDURE cmfe_Field_DimensionSetObj
  END INTERFACE cmfe_Field_DimensionSet

  !>Returns the geometric field for a field.
  INTERFACE cmfe_Field_GeometricFieldGet
    MODULE PROCEDURE cmfe_Field_GeometricFieldGetNumber
    MODULE PROCEDURE cmfe_Field_GeometricFieldGetObj
  END INTERFACE cmfe_Field_GeometricFieldGet

  !>Sets/changes the geometric field for a field.
  INTERFACE cmfe_Field_GeometricFieldSet
    MODULE PROCEDURE cmfe_Field_GeometricFieldSetNumber
    MODULE PROCEDURE cmfe_Field_GeometricFieldSetObj
  END INTERFACE cmfe_Field_GeometricFieldSet

  !>Gets line lengths from a geometric field given an element number and element basis line number.
  INTERFACE cmfe_Field_GeometricParametersElementLineLengthGet
    MODULE PROCEDURE cmfe_Field_GeometricParametersElementLineLengthGetNumber
    MODULE PROCEDURE cmfe_Field_GeometricParametersElementLineLengthGetObj
  END INTERFACE cmfe_Field_GeometricParametersElementLineLengthGet

 !>Returns the label for a field.
  INTERFACE cmfe_Field_LabelGet
    MODULE PROCEDURE cmfe_Field_LabelGetCNumber
    MODULE PROCEDURE cmfe_Field_LabelGetCObj
    MODULE PROCEDURE cmfe_Field_LabelGetVSNumber
    MODULE PROCEDURE cmfe_Field_LabelGetVSObj
  END INTERFACE cmfe_Field_LabelGet

  !>Sets/changes the label for a field.
  INTERFACE cmfe_Field_LabelSet
    MODULE PROCEDURE cmfe_Field_LabelSetCNumber
    MODULE PROCEDURE cmfe_Field_LabelSetCObj
    MODULE PROCEDURE cmfe_Field_LabelSetVSNumber
    MODULE PROCEDURE cmfe_Field_LabelSetVSObj
  END INTERFACE cmfe_Field_LabelSet

  INTERFACE cmfe_Field_PositionNormalTangentCalculateNode
    MODULE PROCEDURE cmfe_Field_PositionNormalTangentCalculateNodeNumber
    MODULE PROCEDURE cmfe_Field_PositionNormalTangentCalculateNodeObj
  END INTERFACE

  !>Returns the mesh decomposition for a field.
  INTERFACE cmfe_Field_MeshDecompositionGet
    MODULE PROCEDURE cmfe_Field_MeshDecompositionGetNumber
    MODULE PROCEDURE cmfe_Field_MeshDecompositionGetObj
  END INTERFACE cmfe_Field_MeshDecompositionGet

  !>Sets/changes the mesh decomposition for a field. \todo remove when fields take decomposition argument on creation???
  INTERFACE cmfe_Field_MeshDecompositionSet
    MODULE PROCEDURE cmfe_Field_MeshDecompositionSetNumber
    MODULE PROCEDURE cmfe_Field_MeshDecompositionSetObj
  END INTERFACE cmfe_Field_MeshDecompositionSet

  !>Sets/changes the data projection for a field.
  INTERFACE cmfe_Field_DataProjectionSet
    MODULE PROCEDURE cmfe_Field_DataProjectionSetNumber
    MODULE PROCEDURE cmfe_Field_DataProjectionSetObj
  END INTERFACE cmfe_Field_DataProjectionSet

  !>Returns the number of field components for a field variable.
  INTERFACE cmfe_Field_NumberOfComponentsGet
    MODULE PROCEDURE cmfe_Field_NumberOfComponentsGetNumber
    MODULE PROCEDURE cmfe_Field_NumberOfComponentsGetObj
  END INTERFACE cmfe_Field_NumberOfComponentsGet

  !>Sets/changes the number of field components for a field variable.
  INTERFACE cmfe_Field_NumberOfComponentsSet
    MODULE PROCEDURE cmfe_Field_NumberOfComponentsSetNumber
    MODULE PROCEDURE cmfe_Field_NumberOfComponentsSetObj
  END INTERFACE cmfe_Field_NumberOfComponentsSet

  !>Returns the number of field variables for a field.
  INTERFACE cmfe_Field_NumberOfVariablesGet
    MODULE PROCEDURE cmfe_Field_NumberOfVariablesGetNumber
    MODULE PROCEDURE cmfe_Field_NumberOfVariablesGetObj
  END INTERFACE cmfe_Field_NumberOfVariablesGet

  !>Sets/changes the number of field variables for a field.
  INTERFACE cmfe_Field_NumberOfVariablesSet
    MODULE PROCEDURE cmfe_Field_NumberOfVariablesSetNumber
    MODULE PROCEDURE cmfe_Field_NumberOfVariablesSetObj
  END INTERFACE cmfe_Field_NumberOfVariablesSet

  !>Adds the given value to the given parameter set for the constant of the field variable component.
  INTERFACE cmfe_Field_ParameterSetAddConstant
    MODULE PROCEDURE cmfe_Field_ParameterSetAddConstantIntgNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetAddConstantIntgObj
    MODULE PROCEDURE cmfe_Field_ParameterSetAddConstantSPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetAddConstantSPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetAddConstantDPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetAddConstantDPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetAddConstantLNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetAddConstantLObj
  END INTERFACE cmfe_Field_ParameterSetAddConstant

  !>Adds the given value to the given parameter set for a particular user element of the field variable component.
  INTERFACE cmfe_Field_ParameterSetAddElement
    MODULE PROCEDURE cmfe_Field_ParameterSetAddElementIntgNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetAddElementIntgObj
    MODULE PROCEDURE cmfe_Field_ParameterSetAddElementSPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetAddElementSPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetAddElementDPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetAddElementDPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetAddElementLNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetAddElementLObj
  END INTERFACE cmfe_Field_ParameterSetAddElement

  !>Adds the given value to the given parameter set for a particular user node of the field variable component.
  INTERFACE cmfe_Field_ParameterSetAddNode
    MODULE PROCEDURE cmfe_Field_ParameterSetAddNodeIntgNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetAddNodeIntgObj
    MODULE PROCEDURE cmfe_Field_ParameterSetAddNodeSPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetAddNodeSPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetAddNodeDPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetAddNodeDPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetAddNodeLNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetAddNodeLObj
  END INTERFACE cmfe_Field_ParameterSetAddNode

  !>Creates a new parameter set of type set type for a field variable.
  INTERFACE cmfe_Field_ParameterSetCreate
    MODULE PROCEDURE cmfe_Field_ParameterSetCreateNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetCreateObj
  END INTERFACE cmfe_Field_ParameterSetCreate

  !>Destroy a parameter set of type set type for a field variable.
  INTERFACE cmfe_Field_ParameterSetDestroy
    MODULE PROCEDURE cmfe_Field_ParameterSetDestroyNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetDestroyObj
  END INTERFACE cmfe_Field_ParameterSetDestroy

  !>Returns a pointer to the specified field parameter set local data array. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  INTERFACE cmfe_Field_ParameterSetDataGet
    MODULE PROCEDURE cmfe_Field_ParameterSetDataGetIntgNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetDataGetIntgObj
    MODULE PROCEDURE cmfe_Field_ParameterSetDataGetSPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetDataGetSPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetDataGetDPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetDataGetDPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetDataGetLNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetDataGetLObj
  END INTERFACE cmfe_Field_ParameterSetDataGet

  !>Restores the specified field variable parameter set local array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call.
  INTERFACE cmfe_Field_ParameterSetDataRestore
    MODULE PROCEDURE cmfe_Field_ParameterSetDataRestoreIntgNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetDataRestoreIntgObj
    MODULE PROCEDURE cmfe_Field_ParameterSetDataRestoreSPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetDataRestoreSPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetDataRestoreDPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetDataRestoreDPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetDataRestoreLNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetDataRestoreLObj
  END INTERFACE cmfe_Field_ParameterSetDataRestore

  !>Returns from the given parameter set a value for the specified constant of a field variable component.
  INTERFACE cmfe_Field_ParameterSetGetConstant
    MODULE PROCEDURE cmfe_Field_ParameterSetGetConstantIntgNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetGetConstantIntgObj
    MODULE PROCEDURE cmfe_Field_ParameterSetGetConstantSPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetGetConstantSPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetGetConstantDPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetGetConstantDPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetGetConstantLNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetGetConstantLObj
  END INTERFACE cmfe_Field_ParameterSetGetConstant
  
  !>Returns from the given parameter set a value for the specified data pont of a field variable component.
  INTERFACE cmfe_Field_ParameterSetGetDataPoint
    MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointIntgNumberI !Interface
    MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointIntgNumberR !Region
    MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointIntgObj
    MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointSPNumberI !Interface
    MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointSPNumberR !Region
    MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointSPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointDPNumberI !Interface
    MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointDPNumberR !Region
    MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointDPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointLNumberI !Interface
    MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointLNumberR !Region
    MODULE PROCEDURE cmfe_Field_ParameterSetGetDataPointLObj
  END INTERFACE cmfe_Field_ParameterSetGetDataPoint

  !>Returns from the given parameter set a value for the specified element of a field variable component.
  INTERFACE cmfe_Field_ParameterSetGetElement
    MODULE PROCEDURE cmfe_Field_ParameterSetGetElementIntgNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetGetElementIntgObj
    MODULE PROCEDURE cmfe_Field_ParameterSetGetElementSPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetGetElementSPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetGetElementDPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetGetElementDPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetGetElementLNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetGetElementLObj
  END INTERFACE cmfe_Field_ParameterSetGetElement

  !>Returns from the given parameter set a value for the specified node and derivative of a field variable component.
  INTERFACE cmfe_Field_ParameterSetGetNode
    MODULE PROCEDURE cmfe_Field_ParameterSetGetNodeIntgNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetGetNodeIntgObj
    MODULE PROCEDURE cmfe_Field_ParameterSetGetNodeSPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetGetNodeSPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetGetNodeDPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetGetNodeDPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetGetNodeLNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetGetNodeLObj
  END INTERFACE cmfe_Field_ParameterSetGetNode

  !>Returns from the given parameter set a value for the specified element and Gauss point of a field variable component.
  INTERFACE cmfe_Field_ParameterSetGetGaussPoint ! TODO: other versions
    MODULE PROCEDURE cmfe_Field_ParameterSetGetGaussPointDPObj
  END INTERFACE cmfe_Field_ParameterSetGetGaussPoint

  !>Updates the given parameter set with the given value for the constant of a field variable component.
  INTERFACE cmfe_Field_ParameterSetUpdateConstant
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateConstantIntgNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateConstantIntgObj
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateConstantSPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateConstantSPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateConstantDPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateConstantDPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateConstantLNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateConstantLObj
  END INTERFACE cmfe_Field_ParameterSetUpdateConstant
  
  !>Update the given parameter set a value for the specified data pont of a field variable component.
  INTERFACE cmfe_Field_ParameterSetUpdateDataPoint
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointIntgNumberI !Interface
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointIntgNumberR !Region
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointIntgObj
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointSPNumberI !Interface
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointSPNumberR !Region
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointSPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointDPNumberI !Interface
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointDPNumberR !Region
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointDPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointLNumberI !Interface
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointLNumberR !Region
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateDataPointLObj
  END INTERFACE cmfe_Field_ParameterSetUpdateDataPoint

  !>Updates the given parameter set with the given value for a particular user element of a field variable component.
  INTERFACE cmfe_Field_ParameterSetUpdateElement
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementIntgNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementIntgObj
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementSPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementSPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementDPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementDPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementLNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementLObj
  END INTERFACE cmfe_Field_ParameterSetUpdateElement

  !>Finishes the parameter set update for a field variable. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateStart
  INTERFACE cmfe_Field_ParameterSetUpdateFinish
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateFinishNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateFinishObj
  END INTERFACE cmfe_Field_ParameterSetUpdateFinish

  !>Updates the given parameter set with the given value for a particular user node of a field variable component.
  INTERFACE cmfe_Field_ParameterSetUpdateNode
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateNodeIntgNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateNodeIntgObj
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateNodeSPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateNodeSPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateNodeDPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateNodeDPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateNodeLNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateNodeLObj
  END INTERFACE cmfe_Field_ParameterSetUpdateNode

  !\todo: merge the two types of routines for getting scalefactors under the same interface declaration?
  !>Gets a scale factor for a particular node.
  INTERFACE cmfe_Field_ParameterSetNodeScaleFactorGet
    MODULE PROCEDURE cmfe_Field_ParameterSetNodeScaleFactorGetNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetNodeScaleFactorGetObj
  END INTERFACE cmfe_Field_ParameterSetNodeScaleFactorGet

  !>Gets the scale factors for all nodes
  INTERFACE cmfe_Field_ParameterSetNodeScaleFactorsGet
    MODULE PROCEDURE cmfe_Field_ParameterSetNodeScaleFactorsGetNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetNodeScaleFactorsGetObj
  END INTERFACE cmfe_Field_ParameterSetNodeScaleFactorsGet

  !>Sets a scale factor for a particular node.
  INTERFACE cmfe_Field_ParameterSetNodeScaleFactorSet
    MODULE PROCEDURE cmfe_Field_ParameterSetNodeScaleFactorSetNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetNodeScaleFactorSetObj
  END INTERFACE cmfe_Field_ParameterSetNodeScaleFactorSet

  !>Sets the scale factors for all nodes
  INTERFACE cmfe_Field_ParameterSetNodeScaleFactorsSet
    MODULE PROCEDURE cmfe_Field_ParameterSetNodeScaleFactorsSetNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetNodeScaleFactorsSetObj
  END INTERFACE cmfe_Field_ParameterSetNodeScaleFactorsSet

  !>Gets the number of scalefactor dofs
  INTERFACE cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGet
    MODULE PROCEDURE cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj
  END INTERFACE cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGet

  !>Updates the given parameter set with the given values for all local dofs of the field variable.  
  INTERFACE cmfe_Field_ParameterSetUpdateLocalDofs
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateLocalDofsDPObj
    !\todo: add Intg/SP/L routines, both indexed by Number and Obj
  END INTERFACE cmfe_Field_ParameterSetUpdateLocalDofs

  !>Updates the given parameter set with the given value for a particular Gauss point of a field variable component.
  INTERFACE cmfe_Field_ParameterSetUpdateGaussPoint
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateGaussPointIntgNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateGaussPointIntgObj
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateGaussPointSPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateGaussPointSPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateGaussPointDPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateGaussPointDPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateGaussPointLNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateGaussPointLObj
  END INTERFACE cmfe_Field_ParameterSetUpdateGaussPoint

  !>Interpolates the given parameter set at a specified xi/set of xi locations for specified element and derviative.
  INTERFACE cmfe_Field_ParameterSetInterpolateXi
    MODULE PROCEDURE cmfe_Field_ParameterSetInterpolateSingleXiDPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetInterpolateSingleXiDPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetInterpolateMultipleXiDPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetInterpolateMultipleXiDPObj
  END INTERFACE cmfe_Field_ParameterSetInterpolateXi

  !>Interpolates the given parameter set at a specified set of Gauss points for specified element and derviative. When interpolating at multiple Gauss points, if no Gauss points are specified then all Gauss points are interpolated.
  INTERFACE cmfe_Field_ParameterSetInterpolateGauss
    MODULE PROCEDURE cmfe_Field_ParameterSetInterpolateSingleGaussDPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetInterpolateSingleGaussDPObj
    MODULE PROCEDURE cmfe_Field_ParameterSetInterpolateMultipleGaussDPNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetInterpolateMultipleGaussDPObj
  END INTERFACE CMFE_FIELD_PARAMETERSETINTERPOLATEGAUSS

  !>Updates the given parameter set with the given value for a particular data point of a field variable component.
  INTERFACE cmfe_Field_ParameterSetUpdateElementDataPoint
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateElementDataPointDPObj
  END INTERFACE cmfe_Field_ParameterSetUpdateElementDataPoint

  !>Starts the parameter set update for a field variable. \see OpenCMISS::Iron::cmfe_Field_ParameterSetUpdateFinish
  INTERFACE cmfe_Field_ParameterSetUpdateStart
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateStartNumber
    MODULE PROCEDURE cmfe_Field_ParameterSetUpdateStartObj
  END INTERFACE cmfe_Field_ParameterSetUpdateStart

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable.
  INTERFACE cmfe_Field_ParametersToFieldParametersComponentCopy
    MODULE PROCEDURE cmfe_Field_ParametersToFieldParametersComponentCopyNumber
    MODULE PROCEDURE cmfe_Field_ParametersToFieldParametersComponentCopyObj
  END INTERFACE cmfe_Field_ParametersToFieldParametersComponentCopy

  !>Returns the scaling type for a field.
  INTERFACE cmfe_Field_ScalingTypeGet
    MODULE PROCEDURE cmfe_Field_ScalingTypeGetNumber
    MODULE PROCEDURE cmfe_Field_ScalingTypeGetObj
  END INTERFACE cmfe_Field_ScalingTypeGet

  !>Sets/changes the scaling type for a field.
  INTERFACE cmfe_Field_ScalingTypeSet
    MODULE PROCEDURE cmfe_Field_ScalingTypeSetNumber
    MODULE PROCEDURE cmfe_Field_ScalingTypeSetObj
  END INTERFACE cmfe_Field_ScalingTypeSet

  !>Returns the type for a field.
  INTERFACE cmfe_Field_TypeGet
    MODULE PROCEDURE cmfe_Field_TypeGetNumber
    MODULE PROCEDURE cmfe_Field_TypeGetObj
  END INTERFACE cmfe_Field_TypeGet

  !>Sets/changes the type for a field.
  INTERFACE cmfe_Field_TypeSet
    MODULE PROCEDURE cmfe_Field_TypeSetNumber
    MODULE PROCEDURE cmfe_Field_TypeSetObj
  END INTERFACE cmfe_Field_TypeSet

  !>Returns the label for a field variable.
  INTERFACE cmfe_Field_VariableLabelGet
    MODULE PROCEDURE cmfe_Field_VariableLabelGetCNumber
    MODULE PROCEDURE cmfe_Field_VariableLabelGetCObj
    MODULE PROCEDURE cmfe_Field_VariableLabelGetVSNumber
    MODULE PROCEDURE cmfe_Field_VariableLabelGetVSObj
  END INTERFACE cmfe_Field_VariableLabelGet

  !>Sets/changes the label for a field variable.
  INTERFACE cmfe_Field_VariableLabelSet
    MODULE PROCEDURE cmfe_Field_VariableLabelSetCNumber
    MODULE PROCEDURE cmfe_Field_VariableLabelSetCObj
    MODULE PROCEDURE cmfe_Field_VariableLabelSetVSNumber
    MODULE PROCEDURE cmfe_Field_VariableLabelSetVSObj
  END INTERFACE cmfe_Field_VariableLabelSet

  !>Returns the field variable types for a field.
  INTERFACE cmfe_Field_VariableTypesGet
    MODULE PROCEDURE cmfe_Field_VariableTypesGetNumber
    MODULE PROCEDURE cmfe_Field_VariableTypesGetObj
  END INTERFACE cmfe_Field_VariableTypesGet

  !>Sets/changes the field variable types for a field.
  INTERFACE cmfe_Field_VariableTypesSet
    MODULE PROCEDURE cmfe_Field_VariableTypesSetNumber
    MODULE PROCEDURE cmfe_Field_VariableTypesSetObj
  END INTERFACE cmfe_Field_VariableTypesSet


  PUBLIC CMFE_FIELD_DEPENDENT_TYPE,CMFE_FIELD_INDEPENDENT_TYPE

  PUBLIC CMFE_FIELD_SCALAR_DIMENSION_TYPE,CMFE_FIELD_VECTOR_DIMENSION_TYPE,CMFE_FIELD_TENSOR_DIMENSION_TYPE

  PUBLIC CMFE_FIELD_GEOMETRIC_TYPE,CMFE_FIELD_FIBRE_TYPE,CMFE_FIELD_GENERAL_TYPE,CMFE_FIELD_MATERIAL_TYPE, &
    & CMFE_FIELD_GEOMETRIC_GENERAL_TYPE

  PUBLIC CMFE_FIELD_CONSTANT_INTERPOLATION,CMFE_FIELD_ELEMENT_BASED_INTERPOLATION,CMFE_FIELD_NODE_BASED_INTERPOLATION, &
    & CMFE_FIELD_GRID_POINT_BASED_INTERPOLATION,CMFE_FIELD_GAUSS_POINT_BASED_INTERPOLATION, &
    & CMFE_FIELD_DATA_POINT_BASED_INTERPOLATION

  PUBLIC CMFE_FIELD_NUMBER_OF_VARIABLE_SUBTYPES

  PUBLIC CMFE_FIELD_U_VARIABLE_TYPE,CMFE_FIELD_DELUDELN_VARIABLE_TYPE,CMFE_FIELD_DELUDELT_VARIABLE_TYPE, &
    & CMFE_FIELD_DEL2UDELT2_VARIABLE_TYPE, &
    & CMFE_FIELD_V_VARIABLE_TYPE,CMFE_FIELD_DELVDELN_VARIABLE_TYPE,CMFE_FIELD_DELVDELT_VARIABLE_TYPE, &
    & CMFE_FIELD_DEL2VDELT2_VARIABLE_TYPE, &
    & CMFE_FIELD_U1_VARIABLE_TYPE,CMFE_FIELD_DELU1DELN_VARIABLE_TYPE,CMFE_FIELD_DELU1DELT_VARIABLE_TYPE, &
    & CMFE_FIELD_DEL2U1DELT2_VARIABLE_TYPE, &
    & CMFE_FIELD_U2_VARIABLE_TYPE,CMFE_FIELD_DELU2DELN_VARIABLE_TYPE,CMFE_FIELD_DELU2DELT_VARIABLE_TYPE, &
    & CMFE_FIELD_DEL2U2DELT2_VARIABLE_TYPE, &
    & CMFE_FIELD_U3_VARIABLE_TYPE,CMFE_FIELD_DELU3DELN_VARIABLE_TYPE,CMFE_FIELD_DELU3DELT_VARIABLE_TYPE, &
    & CMFE_FIELD_DEL2U3DELT2_VARIABLE_TYPE, &
    & CMFE_FIELD_U4_VARIABLE_TYPE,CMFE_FIELD_DELU4DELN_VARIABLE_TYPE,CMFE_FIELD_DELU4DELT_VARIABLE_TYPE, &
    & CMFE_FIELD_DEL2U4DELT2_VARIABLE_TYPE, &
    & CMFE_FIELD_U5_VARIABLE_TYPE,CMFE_FIELD_DELU5DELN_VARIABLE_TYPE,CMFE_FIELD_DELU5DELT_VARIABLE_TYPE, &
    & CMFE_FIELD_DEL2U5DELT2_VARIABLE_TYPE, &
    & CMFE_FIELD_U6_VARIABLE_TYPE,CMFE_FIELD_DELU6DELN_VARIABLE_TYPE,CMFE_FIELD_DELU6DELT_VARIABLE_TYPE, &
    & CMFE_FIELD_DEL2U6DELT2_VARIABLE_TYPE, &
    & CMFE_FIELD_U7_VARIABLE_TYPE,CMFE_FIELD_DELU7DELN_VARIABLE_TYPE,CMFE_FIELD_DELU7DELT_VARIABLE_TYPE, &
    & CMFE_FIELD_DEL2U7DELT2_VARIABLE_TYPE, &
    & CMFE_FIELD_U8_VARIABLE_TYPE,CMFE_FIELD_DELU8DELN_VARIABLE_TYPE,CMFE_FIELD_DELU8DELT_VARIABLE_TYPE, &
    & CMFE_FIELD_DEL2U8DELT2_VARIABLE_TYPE, &
    & CMFE_FIELD_U9_VARIABLE_TYPE,CMFE_FIELD_DELU9DELN_VARIABLE_TYPE,CMFE_FIELD_DELU9DELT_VARIABLE_TYPE, &
    & CMFE_FIELD_DEL2U9DELT2_VARIABLE_TYPE, &
    & CMFE_FIELD_U10_VARIABLE_TYPE,CMFE_FIELD_DELU10DELN_VARIABLE_TYPE,CMFE_FIELD_DELU10DELT_VARIABLE_TYPE, &
    & CMFE_FIELD_DEL2U10DELT2_VARIABLE_TYPE

  PUBLIC CMFE_FIELD_INTG_TYPE,CMFE_FIELD_SP_TYPE,CMFE_FIELD_DP_TYPE,CMFE_FIELD_L_TYPE

  PUBLIC CMFE_FIELD_SEPARATED_COMPONENT_DOF_ORDER,CMFE_FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER

  PUBLIC CMFE_FIELD_VALUES_SET_TYPE,CMFE_FIELD_INITIAL_VALUES_SET_TYPE,CMFE_FIELD_INCREMENTAL_VALUES_SET_TYPE, &
    & CMFE_FIELD_BOUNDARY_CONDITIONS_SET_TYPE, &
    & CMFE_FIELD_ANALYTIC_VALUES_SET_TYPE, &
    & CMFE_FIELD_PREVIOUS_VALUES_SET_TYPE,CMFE_FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE,CMFE_FIELD_VELOCITY_VALUES_SET_TYPE, &
    & CMFE_FIELD_INITIAL_VELOCITY_SET_TYPE,CMFE_FIELD_PREVIOUS_VELOCITY_SET_TYPE,CMFE_FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE, &
    & CMFE_FIELD_ACCELERATION_VALUES_SET_TYPE,CMFE_FIELD_INITIAL_ACCELERATION_SET_TYPE, &
    & CMFE_FIELD_PREVIOUS_ACCELERATION_SET_TYPE, &
    & CMFE_FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE, CMFE_FIELD_PRESSURE_VALUES_SET_TYPE, &
    & CMFE_FIELD_PREVIOUS_PRESSURE_SET_TYPE, &
    & CMFE_FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE,CMFE_FIELD_INTEGRATED_NEUMANN_SET_TYPE

  PUBLIC CMFE_FIELD_NO_SCALING,CMFE_FIELD_UNIT_SCALING,CMFE_FIELD_ARC_LENGTH_SCALING,CMFE_FIELD_ARITHMETIC_MEAN_SCALING, &
    & CMFE_FIELD_GEOMETRIC_MEAN_SCALING,CMFE_FIELD_HARMONIC_MEAN_SCALING

  PUBLIC cmfe_Field_ComponentInterpolationGet,cmfe_Field_ComponentInterpolationSet

  PUBLIC cmfe_Field_ComponentLabelGet,cmfe_Field_ComponentLabelSet

  PUBLIC cmfe_Field_ComponentMeshComponentGet,cmfe_Field_ComponentMeshComponentSet

  PUBLIC cmfe_Field_ComponentValuesInitialise

  PUBLIC cmfe_Field_DataTypeGet,cmfe_Field_DataTypeSet

  PUBLIC cmfe_Field_DOFOrderTypeGet,cmfe_Field_DOFOrderTypeSet

  PUBLIC cmfe_Field_CreateFinish,cmfe_Field_CreateStart

  PUBLIC cmfe_Field_DependentTypeGet,cmfe_Field_DependentTypeSet

  PUBLIC cmfe_Field_Destroy

  PUBLIC cmfe_Field_DimensionGet,cmfe_Field_DimensionSet

  PUBLIC cmfe_Field_GeometricFieldGet,cmfe_Field_GeometricFieldSet

  PUBLIC cmfe_Field_GeometricParametersElementLineLengthGet

  PUBLIC cmfe_Field_LabelGet,cmfe_Field_LabelSet

  PUBLIC cmfe_Field_MeshDecompositionGet,cmfe_Field_MeshDecompositionSet

  PUBLIC cmfe_Field_DataProjectionSet

  PUBLIC cmfe_Field_PositionNormalTangentCalculateNode

  PUBLIC cmfe_Field_NumberOfComponentsGet,cmfe_Field_NumberOfComponentsSet

  PUBLIC cmfe_Field_NumberOfVariablesGet,cmfe_Field_NumberOfVariablesSet

  PUBLIC cmfe_Field_ParameterSetAddConstant,cmfe_Field_ParameterSetAddElement,cmfe_Field_ParameterSetAddNode

  PUBLIC cmfe_Field_ParameterSetCreate

  PUBLIC cmfe_Field_ParameterSetDestroy

  PUBLIC cmfe_Field_ParameterSetDataGet,cmfe_Field_ParameterSetDataRestore

  PUBLIC cmfe_Field_ParameterSetGetConstant,cmfe_Field_ParameterSetGetElement,cmfe_Field_ParameterSetGetNode
  
  PUBLIC cmfe_Field_ParameterSetGetDataPoint,cmfe_Field_ParameterSetUpdateDataPoint

  PUBLIC cmfe_Field_ParameterSetUpdateConstant,cmfe_Field_ParameterSetUpdateElement,cmfe_Field_ParameterSetUpdateNode

  PUBLIC cmfe_Field_ParameterSetNodeScaleFactorGet,cmfe_Field_ParameterSetNodeScaleFactorSet

  PUBLIC cmfe_Field_ParameterSetNodeScaleFactorsGet,cmfe_Field_ParameterSetNodeScaleFactorsSet

  PUBLIC cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGet

  PUBLIC cmfe_Field_ParameterSetUpdateLocalDofs

  PUBLIC cmfe_Field_ParameterSetUpdateGaussPoint,cmfe_Field_ParameterSetGetGaussPoint

  PUBLIC cmfe_Field_ParameterSetInterpolateXi

  PUBLIC cmfe_Field_ParameterSetInterpolateGauss

  PUBLIC cmfe_Field_ParameterSetUpdateElementDataPoint

  PUBLIC cmfe_Field_ParameterSetUpdateFinish,cmfe_Field_ParameterSetUpdateStart

  PUBLIC cmfe_Field_ParametersToFieldParametersComponentCopy

  PUBLIC cmfe_Field_ScalingTypeGet,cmfe_Field_ScalingTypeSet

  PUBLIC cmfe_Field_TypeGet,cmfe_Field_TypeSet

  PUBLIC cmfe_Field_VariableLabelGet,cmfe_Field_VariableLabelSet

  PUBLIC cmfe_Field_VariableTypesGet,cmfe_Field_VariableTypesSet

!!==================================================================================================================================
!!
!! FIELD_IO_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  INTERFACE cmfe_Fields_ElementsExport
    MODULE PROCEDURE cmfe_Fields_ElementsExportCCObj
    MODULE PROCEDURE cmfe_Fields_ElementsExportVSCObj
    MODULE PROCEDURE cmfe_Fields_ElementsExportCVSObj
    MODULE PROCEDURE cmfe_Fields_ElementsExportVSVSObj
  END INTERFACE cmfe_Fields_ElementsExport

  INTERFACE cmfe_Fields_NodesExport
    MODULE PROCEDURE cmfe_Fields_NodesExportCCObj
    MODULE PROCEDURE cmfe_Fields_NodesExportVSCObj
    MODULE PROCEDURE cmfe_Fields_NodesExportCVSObj
    MODULE PROCEDURE cmfe_Fields_NodesExportVSVSObj
  END INTERFACE cmfe_Fields_NodesExport

  PUBLIC cmfe_Fields_ElementsExport,cmfe_Fields_NodesExport

!!==================================================================================================================================
!!
!! GENERATED_MESH_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_GeneratedMeshConstants OPENCMISS::GeneratedMesh::Constants
  !> \brief Generated mesh constants.
  !>@{
  !> \addtogroup OPENCMISS_GeneratedMeshTypes OPENCMISS::GeneratedMesh::Types
  !> \brief Generated mesh types.
  !> \see OPENCMISS::GeneratedMesh,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_REGULAR_MESH_TYPE = GENERATED_MESH_REGULAR_MESH_TYPE !<A regular generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_POLAR_MESH_TYPE = GENERATED_MESH_POLAR_MESH_TYPE !<A polar generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_FRACTAL_TREE_MESH_TYPE = GENERATED_MESH_FRACTAL_TREE_MESH_TYPE !<A fractal tree generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_CYLINDER_MESH_TYPE = GENERATED_MESH_CYLINDER_MESH_TYPE !<A cylinder generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_ELLIPSOID_MESH_TYPE = GENERATED_MESH_ELLIPSOID_MESH_TYPE !<An ellipsoid generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  !>@}
  !>@}

  !> \addtogroup OPENCMISS_GeneratedMeshConstants OPENCMISS::GeneratedMesh::Constants
  !> \brief Generated mesh constants.
  !>@{
  !> \addtogroup OPENCMISS_GeneratedMeshSurfaceTypes OPENCMISS::GeneratedMesh::SurfaceTypes
  !> \brief Generated mesh surface types.
  !> \see OPENCMISS::GeneratedMesh,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_CYLINDER_INNER_SURFACE = GENERATED_MESH_CYLINDER_INNER_SURFACE !<Cylinder inner surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_CYLINDER_OUTER_SURFACE = GENERATED_MESH_CYLINDER_OUTER_SURFACE !<Cylinder outer surface. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_CYLINDER_TOP_SURFACE = GENERATED_MESH_CYLINDER_TOP_SURFACE !<Cylinder top surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_CYLINDER_BOTTOM_SURFACE = GENERATED_MESH_CYLINDER_BOTTOM_SURFACE !<Cylinder bottom surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_ELLIPSOID_INNER_SURFACE = GENERATED_MESH_ELLIPSOID_INNER_SURFACE !<Ellipsoid inner surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_ELLIPSOID_OUTER_SURFACE = GENERATED_MESH_ELLIPSOID_OUTER_SURFACE !<Ellipsoid outer surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_ELLIPSOID_TOP_SURFACE = GENERATED_MESH_ELLIPSOID_TOP_SURFACE !<Ellipsoid top surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_REGULAR_LEFT_SURFACE = GENERATED_MESH_REGULAR_LEFT_SURFACE !<Regular left surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_REGULAR_RIGHT_SURFACE = GENERATED_MESH_REGULAR_RIGHT_SURFACE !<Regular right surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_REGULAR_TOP_SURFACE = GENERATED_MESH_REGULAR_TOP_SURFACE !<Regular top surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_REGULAR_BOTTOM_SURFACE = GENERATED_MESH_REGULAR_BOTTOM_SURFACE !<Regular bottom surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_REGULAR_FRONT_SURFACE = GENERATED_MESH_REGULAR_FRONT_SURFACE !<Regular front surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_GENERATED_MESH_REGULAR_BACK_SURFACE = GENERATED_MESH_REGULAR_BACK_SURFACE !<Regular back surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the basis for a generated mesh.
  INTERFACE cmfe_GeneratedMesh_BasisGet
    MODULE PROCEDURE cmfe_GeneratedMesh_BasisGetNumber
    MODULE PROCEDURE cmfe_GeneratedMesh_BasisGetObj
  END INTERFACE cmfe_GeneratedMesh_BasisGet

  !>Sets/changes the basis for a generated mesh.
  INTERFACE cmfe_GeneratedMesh_BasisSet
    MODULE PROCEDURE cmfe_GeneratedMesh_BasisSetNumber0
    MODULE PROCEDURE cmfe_GeneratedMesh_BasisSetNumber1
    MODULE PROCEDURE cmfe_GeneratedMesh_BasisSetObj0
    MODULE PROCEDURE cmfe_GeneratedMesh_BasisSetObj1
  END INTERFACE cmfe_GeneratedMesh_BasisSet

  !>Sets/changes the base vectors for a generated mesh.
  INTERFACE cmfe_GeneratedMesh_BaseVectorsSet
    MODULE PROCEDURE cmfe_GeneratedMesh_BaseVectorsSetNumber
    MODULE PROCEDURE cmfe_GeneratedMesh_BaseVectorsSetObj
  END INTERFACE cmfe_GeneratedMesh_BaseVectorsSet

  !>Finishes the creation of a generated mesh. \see OpenCMISS::Iron::cmfe_GeneratedMesh_CreateStart
  INTERFACE cmfe_GeneratedMesh_CreateFinish
    MODULE PROCEDURE cmfe_GeneratedMesh_CreateFinishNumber
    MODULE PROCEDURE cmfe_GeneratedMesh_CreateFinishObj
  END INTERFACE cmfe_GeneratedMesh_CreateFinish

  !>Starts the creation of a generated mesh. \see OpenCMISS::Iron::cmfe_GeneratedMesh_CreateFinish
  INTERFACE cmfe_GeneratedMesh_CreateStart
    MODULE PROCEDURE cmfe_GeneratedMesh_CreateStartNumber
    MODULE PROCEDURE cmfe_GeneratedMesh_CreateStartInterfaceObj
    MODULE PROCEDURE cmfe_GeneratedMesh_CreateStartRegionObj
  END INTERFACE cmfe_GeneratedMesh_CreateStart

  !>Destroys a generated mesh.
  INTERFACE cmfe_GeneratedMesh_Destroy
    MODULE PROCEDURE cmfe_GeneratedMesh_DestroyNumber
    MODULE PROCEDURE cmfe_GeneratedMesh_DestroyObj
  END INTERFACE cmfe_GeneratedMesh_Destroy

  !>Returns the extent of a generated mesh.
  INTERFACE cmfe_GeneratedMesh_ExtentGet
    MODULE PROCEDURE cmfe_GeneratedMesh_ExtentGetNumber
    MODULE PROCEDURE cmfe_GeneratedMesh_ExtentGetObj
  END INTERFACE cmfe_GeneratedMesh_ExtentGet

  !>Sets/changes the extent of a generated mesh.
  INTERFACE cmfe_GeneratedMesh_ExtentSet
    MODULE PROCEDURE cmfe_GeneratedMesh_ExtentSetNumber
    MODULE PROCEDURE cmfe_GeneratedMesh_ExtentSetObj
  END INTERFACE cmfe_GeneratedMesh_ExtentSet

  !>Returns the number of elements in a generated mesh.
  INTERFACE cmfe_GeneratedMesh_NumberOfElementsGet
    MODULE PROCEDURE cmfe_GeneratedMesh_NumberOfElementsGetNumber
    MODULE PROCEDURE cmfe_GeneratedMesh_NumberOfElementsGetObj
  END INTERFACE cmfe_GeneratedMesh_NumberOfElementsGet

  !>Sets/changes the number of elements in a generated mesh.
  INTERFACE cmfe_GeneratedMesh_NumberOfElementsSet
    MODULE PROCEDURE cmfe_GeneratedMesh_NumberOfElementsSetNumber
    MODULE PROCEDURE cmfe_GeneratedMesh_NumberOfElementsSetObj
  END INTERFACE cmfe_GeneratedMesh_NumberOfElementsSet

  !>Returns the origin of a generated mesh.
  INTERFACE cmfe_GeneratedMesh_OriginGet
    MODULE PROCEDURE cmfe_GeneratedMesh_OriginGetNumber
    MODULE PROCEDURE cmfe_GeneratedMesh_OriginGetObj
  END INTERFACE cmfe_GeneratedMesh_OriginGet

  !>Sets/changes the origin of a generated mesh.
  INTERFACE cmfe_GeneratedMesh_OriginSet
    MODULE PROCEDURE cmfe_GeneratedMesh_OriginSetNumber
    MODULE PROCEDURE cmfe_GeneratedMesh_OriginSetObj
  END INTERFACE cmfe_GeneratedMesh_OriginSet

  !>Returns the type of a generated mesh.
  INTERFACE cmfe_GeneratedMesh_TypeGet
    MODULE PROCEDURE cmfe_GeneratedMesh_TypeGetNumber
    MODULE PROCEDURE cmfe_GeneratedMesh_TypeGetObj
  END INTERFACE cmfe_GeneratedMesh_TypeGet

  !>Sets/changes the type of a generated mesh.
  INTERFACE cmfe_GeneratedMesh_TypeSet
    MODULE PROCEDURE cmfe_GeneratedMesh_TypeSetNumber
    MODULE PROCEDURE cmfe_GeneratedMesh_TypeSetObj
  END INTERFACE cmfe_GeneratedMesh_TypeSet

  !>Calculates and sets the geometric field parameters for a generated mesh
  INTERFACE cmfe_GeneratedMesh_GeometricParametersCalculate
    MODULE PROCEDURE cmfe_GeneratedMesh_GeometricParametersCalculateNumber
    MODULE PROCEDURE cmfe_GeneratedMesh_GeometricParametersCalculateObj
  END INTERFACE cmfe_GeneratedMesh_GeometricParametersCalculate

  !>Returns a list of nodes belonging to a surface of given type
  INTERFACE cmfe_GeneratedMesh_SurfaceGet
    MODULE PROCEDURE cmfe_GeneratedMesh_SurfaceGetNumber0
    MODULE PROCEDURE cmfe_GeneratedMesh_SurfaceGetNumber1
    MODULE PROCEDURE cmfe_GeneratedMesh_SurfaceGetObj0
    MODULE PROCEDURE cmfe_GeneratedMesh_SurfaceGetObj1
  END INTERFACE


  !>Creates an embedding of one mesh in another
  INTERFACE cmfe_MeshEmbedding_Create
    MODULE PROCEDURE cmfe_MeshEmbedding_CreateNumber
    MODULE PROCEDURE cmfe_MeshEmbedding_CreateObj
  END INTERFACE

  !>Sets the embedded nodes for one parent element
  INTERFACE cmfe_MeshEmbedding_SetChildNodePosition
    MODULE PROCEDURE cmfe_MeshEmbedding_SetChildNodePositionObj
  END INTERFACE


  !>Pushes data from the parent field to the child field
  INTERFACE cmfe_MeshEmbedding_PushData
    MODULE PROCEDURE cmfe_MeshEmbedding_PushDataObj
  END INTERFACE

  INTERFACE cmfe_MeshEmbedding_SetGaussPointData
   MODULE PROCEDURE cmfe_MeshEmbedding_SetGaussPointDataObj
  END INTERFACE

  INTERFACE cmfe_MeshEmbedding_PullGaussPointData
   MODULE PROCEDURE cmfe_MeshEmbedding_PullGaussPointDataObj
  END INTERFACE

   INTERFACE cmfe_MeshEmbedding_GetGaussPointCoord
    MODULE PROCEDURE cmfe_Field_ParameterSetGetGaussPointCoordObj
   END INTERFACE

  PUBLIC cmfe_MeshEmbedding_Create,cmfe_MeshEmbedding_SetChildNodePosition, cmfe_MeshEmbeddingType

  PUBLIC cmfe_MeshEmbedding_Initialise,cmfe_MeshEmbedding_SetGaussPointData

  PUBLIC cmfe_MeshEmbedding_PushData,cmfe_MeshEmbedding_PullGaussPointData

  PUBLIC cmfe_MeshEmbedding_GetGaussPointCoord

  PUBLIC CMFE_GENERATED_MESH_REGULAR_MESH_TYPE,CMFE_GENERATED_MESH_POLAR_MESH_TYPE,CMFE_GENERATED_MESH_FRACTAL_TREE_MESH_TYPE

  PUBLIC CMFE_GENERATED_MESH_CYLINDER_MESH_TYPE, CMFE_GENERATED_MESH_ELLIPSOID_MESH_TYPE

  PUBLIC CMFE_GENERATED_MESH_CYLINDER_INNER_SURFACE,CMFE_GENERATED_MESH_CYLINDER_OUTER_SURFACE

  PUBLIC CMFE_GENERATED_MESH_CYLINDER_TOP_SURFACE, CMFE_GENERATED_MESH_CYLINDER_BOTTOM_SURFACE

  PUBLIC CMFE_GENERATED_MESH_ELLIPSOID_INNER_SURFACE, CMFE_GENERATED_MESH_ELLIPSOID_OUTER_SURFACE

  PUBLIC CMFE_GENERATED_MESH_ELLIPSOID_TOP_SURFACE

  PUBLIC CMFE_GENERATED_MESH_REGULAR_LEFT_SURFACE, CMFE_GENERATED_MESH_REGULAR_RIGHT_SURFACE, &
    & CMFE_GENERATED_MESH_REGULAR_TOP_SURFACE

  PUBLIC CMFE_GENERATED_MESH_REGULAR_BOTTOM_SURFACE, CMFE_GENERATED_MESH_REGULAR_FRONT_SURFACE, &
    & CMFE_GENERATED_MESH_REGULAR_BACK_SURFACE

  PUBLIC cmfe_GeneratedMesh_BasisGet,cmfe_GeneratedMesh_BasisSet

  PUBLIC cmfe_GeneratedMesh_BaseVectorsSet

  PUBLIC cmfe_GeneratedMesh_CreateFinish,cmfe_GeneratedMesh_CreateStart

  PUBLIC cmfe_GeneratedMesh_Destroy

  PUBLIC cmfe_GeneratedMesh_ExtentGet,cmfe_GeneratedMesh_ExtentSet

  PUBLIC cmfe_GeneratedMesh_NumberOfElementsGet,cmfe_GeneratedMesh_NumberOfElementsSet

  PUBLIC cmfe_GeneratedMesh_OriginGet,cmfe_GeneratedMesh_OriginSet

  PUBLIC cmfe_GeneratedMesh_TypeGet,cmfe_GeneratedMesh_TypeSet

  PUBLIC cmfe_GeneratedMesh_GeometricParametersCalculate

  PUBLIC cmfe_GeneratedMesh_SurfaceGet


!!==================================================================================================================================
!!
!! INTERFACE_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Adds a mesh to an interface.
  INTERFACE cmfe_Interface_MeshAdd
    MODULE PROCEDURE cmfe_Interface_MeshAddNumber
    MODULE PROCEDURE cmfe_Interface_MeshAddObj
  END INTERFACE cmfe_Interface_MeshAdd

  !>Finishes the creation of an interface. \see OpenCMISS::Iron::cmfe_Interface_CreateStart
  INTERFACE cmfe_Interface_CreateFinish
    MODULE PROCEDURE cmfe_Interface_CreateFinishNumber
    MODULE PROCEDURE cmfe_Interface_CreateFinishObj
  END INTERFACE cmfe_Interface_CreateFinish

  !>Starts the creation of an interface. \see OpenCMISS::Iron::cmfe_Interface_CreateFinish
  INTERFACE cmfe_Interface_CreateStart
    MODULE PROCEDURE cmfe_Interface_CreateStartNumber
    MODULE PROCEDURE cmfe_Interface_CreateStartObj
  END INTERFACE cmfe_Interface_CreateStart
  
  !>Set the coordinate system of an inteface
  INTERFACE cmfe_Interface_CoordinateSystemSet
    MODULE PROCEDURE cmfe_Interface_CoordinateSystemSetNumber
    MODULE PROCEDURE cmfe_Interface_CoordinateSystemSetObj
  END INTERFACE cmfe_Interface_CoordinateSystemSet
  
  !>Get the coordinate system of an inteface
  INTERFACE cmfe_Interface_CoordinateSystemGet
    MODULE PROCEDURE cmfe_Interface_CoordinateSystemGetNumber
    MODULE PROCEDURE cmfe_Interface_CoordinateSystemGetObj
  END INTERFACE cmfe_Interface_CoordinateSystemGet

  !>Destroys an interface.
  INTERFACE cmfe_Interface_Destroy
    MODULE PROCEDURE cmfe_Interface_DestroyNumber
    MODULE PROCEDURE cmfe_Interface_DestroyObj
  END INTERFACE cmfe_Interface_Destroy

  !>Returns the label of an interface.
  INTERFACE cmfe_Interface_LabelGet
    MODULE PROCEDURE cmfe_Interface_LabelGetCNumber
    MODULE PROCEDURE cmfe_Interface_LabelGetCObj
    MODULE PROCEDURE cmfe_Interface_LabelGetVSNumber
    MODULE PROCEDURE cmfe_Interface_LabelGetVSObj
  END INTERFACE cmfe_Interface_LabelGet

  !>Sets/changes the label of an interface.
  INTERFACE cmfe_Interface_LabelSet
    MODULE PROCEDURE cmfe_Interface_LabelSetCNumber
    MODULE PROCEDURE cmfe_Interface_LabelSetCObj
    MODULE PROCEDURE cmfe_Interface_LabelSetVSNumber
    MODULE PROCEDURE cmfe_Interface_LabelSetVSObj
  END INTERFACE cmfe_Interface_LabelSet

  !>Returns the nodes for a interface.
  INTERFACE cmfe_Interface_NodesGet
    MODULE PROCEDURE cmfe_Interface_NodesGetObj
  END INTERFACE cmfe_Interface_NodesGet

  !>Finishes the creation of an interface meshes connectivity. \see OpenCMISS::Iron::cmfe_InterfaceMeshConnectivity_CreateStart
  INTERFACE cmfe_InterfaceMeshConnectivity_CreateFinish
    MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_CreateFinishNumber
    MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_CreateFinishObj
  END INTERFACE cmfe_InterfaceMeshConnectivity_CreateFinish

  !>Starts the creation of an interface meshes connectivity.
  INTERFACE cmfe_InterfaceMeshConnectivity_CreateStart
    MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_CreateStartNumber
    MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_CreateStartObj
  END INTERFACE cmfe_InterfaceMeshConnectivity_CreateStart

  !>Sets the element xi values for the mesh connectivity between an element in the interface mesh and an element in a region mesh
  INTERFACE cmfe_InterfaceMeshConnectivity_ElementXiSet
    MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_ElementXiSetNumber
    MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_ElementXiSetObj
  END INTERFACE cmfe_InterfaceMeshConnectivity_ElementXiSet

  !>Sets the number of elements coupled through a given interface mesh element
  INTERFACE cmfe_InterfaceMeshConnectivity_ElementNumberSet
    MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber
    MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_ElementNumberSetObj
  END INTERFACE cmfe_InterfaceMeshConnectivity_ElementNumberSet

  !>Sets the coupled node numbers
  INTERFACE cmfe_InterfaceMeshConnectivity_NodeNumberSet
    MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_NodeNumberSetNumber
    MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_NodeNumberSetObj
  END INTERFACE cmfe_InterfaceMeshConnectivity_NodeNumberSet

  !>Sets the number of elements coupled through a given interface mesh element
  INTERFACE cmfe_InterfaceMeshConnectivity_BasisSet
    MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_BasisSetNumber
    MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_BasisSetObj
  END INTERFACE cmfe_InterfaceMeshConnectivity_BasisSet

  !>Destroys an interface meshes connectivity.
  INTERFACE cmfe_InterfaceMeshConnectivity_Destroy
    MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_DestroyNumber
    MODULE PROCEDURE cmfe_InterfaceMeshConnectivity_DestroyObj
  END INTERFACE cmfe_InterfaceMeshConnectivity_Destroy
  
  !>Finishes the creation of an interface points connectivity.
  INTERFACE cmfe_InterfacePointsConnectivity_CreateFinish
    MODULE PROCEDURE cmfe_InterfacePointsConnectivity_CreateFinishNumber
    MODULE PROCEDURE cmfe_InterfacePointsConnectivity_CreateFinishObj
  END INTERFACE cmfe_InterfacePointsConnectivity_CreateFinish
  
  !>Starts the creation of an interface points connectivity.
  INTERFACE cmfe_InterfacePointsConnectivity_CreateStart
    MODULE PROCEDURE cmfe_InterfacePointsConnectivity_CreateStartNumber
    MODULE PROCEDURE cmfe_InterfacePointsConnectivity_CreateStartObj
  END INTERFACE cmfe_InterfacePointsConnectivity_CreateStart
  
  !>Destroys an interface points connectivity.
  INTERFACE cmfe_InterfacePointsConnectivity_Destroy
    MODULE PROCEDURE cmfe_InterfacePointsConnectivity_DestroyNumber
    MODULE PROCEDURE cmfe_InterfacePointsConnectivity_DestroyObj
  END INTERFACE cmfe_InterfacePointsConnectivity_Destroy
  
  !>Get the coupled mesh element number that defines points connectivity
  INTERFACE cmfe_InterfacePointsConnectivity_ElementNumberGet
    MODULE PROCEDURE cmfe_InterfacePointsConnectivity_ElementNumberGetNumber
    MODULE PROCEDURE cmfe_InterfacePointsConnectivity_ElementNumberGetObj
  END INTERFACE cmfe_InterfacePointsConnectivity_ElementNumberGet
  
  !>Gets the element xi values for the points connectivity between a data point in the interface mesh and an element in a region mesh
  INTERFACE cmfe_InterfacePointsConnectivity_PointXiGet
    MODULE PROCEDURE cmfe_InterfacePointsConnectivity_PointXiGetNumber
    MODULE PROCEDURE cmfe_InterfacePointsConnectivity_PointXiGetObj
  END INTERFACE cmfe_InterfacePointsConnectivity_PointXiGet
  
  !>Sets the coupled mesh element number that defines points connectivity
  INTERFACE cmfe_InterfacePointsConnectivity_ElementNumberSet
    MODULE PROCEDURE cmfe_InterfacePointsConnectivity_ElementNumberSetNumber
    MODULE PROCEDURE cmfe_InterfacePointsConnectivity_ElementNumberSetObj
  END INTERFACE cmfe_InterfacePointsConnectivity_ElementNumberSet
  
  !>Sets the element xi values for the points connectivity between a data point in the interface mesh and an element in a region mesh
  INTERFACE cmfe_InterfacePointsConnectivity_PointXiSet
    MODULE PROCEDURE cmfe_InterfacePointsConnectivity_PointXiSetNumber
    MODULE PROCEDURE cmfe_InterfacePointsConnectivity_PointXiSetObj
  END INTERFACE cmfe_InterfacePointsConnectivity_PointXiSet
  
  !>Update points connectivity information with projection results
  INTERFACE cmfe_InterfacePointsConnectivity_UpdateFromProjection
    MODULE PROCEDURE cmfe_InterfacePointsConnectivity_UpdateFromProjectionRNumber
    MODULE PROCEDURE cmfe_InterfacePointsConnectivity_UpdateFromProjectionINumber
    MODULE PROCEDURE cmfe_InterfacePointsConnectivity_UpdateFromProjectionObj
  END INTERFACE cmfe_InterfacePointsConnectivity_UpdateFromProjection

  PUBLIC cmfe_Interface_MeshAdd

  PUBLIC cmfe_Interface_CreateFinish,cmfe_Interface_CreateStart
  
  PUBLIC cmfe_Interface_CoordinateSystemSet,cmfe_Interface_CoordinateSystemGet

  PUBLIC cmfe_Interface_Destroy

  PUBLIC cmfe_Interface_LabelGet,cmfe_Interface_LabelSet

  PUBLIC cmfe_Interface_NodesGet

  PUBLIC cmfe_InterfaceMeshConnectivity_CreateFinish,cmfe_InterfaceMeshConnectivity_CreateStart

  PUBLIC cmfe_InterfaceMeshConnectivity_Destroy,cmfe_InterfaceMeshConnectivity_BasisSet

  PUBLIC cmfe_InterfaceMeshConnectivity_ElementNumberSet,cmfe_InterfaceMeshConnectivity_ElementXiSet

  PUBLIC cmfe_InterfaceMeshConnectivity_NodeNumberSet

  PUBLIC cmfe_InterfacePointsConnectivity_CreateFinish,cmfe_InterfacePointsConnectivity_CreateStart

  PUBLIC cmfe_InterfacePointsConnectivity_Destroy
  
  PUBLIC cmfe_InterfacePointsConnectivity_ElementNumberGet,cmfe_InterfacePointsConnectivity_PointXiGet
  
  PUBLIC cmfe_InterfacePointsConnectivity_ElementNumberSet,cmfe_InterfacePointsConnectivity_PointXiSet
  
  PUBLIC cmfe_InterfacePointsConnectivity_UpdateFromProjection

!!==================================================================================================================================
!!
!! INTERFACE_CONDITION_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_InterfaceConditionConstants OPENCMISS::InterfaceConditions::Constants
  !> \brief Interface conditions constants.
  !>@{
  !> \addtogroup OPENCMISS_InterfaceConditionMethods OPENCMISS::InterfaceConditions::Methods
  !> \brief Interface condition methods.
  !> \see OPENCMISS::InterfaceConditions,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD = &
    & INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD !<Lagrange multipliers interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD = INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD !<Augmented Lagrange multiplers interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_PENALTY_METHOD = INTERFACE_CONDITION_PENALTY_METHOD !<Penalty interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_POINT_TO_POINT_METHOD = INTERFACE_CONDITION_POINT_TO_POINT_METHOD !<Point to point interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_InterfaceConditionOperators OPENCMISS::InterfaceConditions::Operators
  !> \brief Interface condition operator types.
  !> \see OPENCMISS::InterfaceConditions,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR = &
    & INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR !<Continuous field operator, i.e., lambda.(u1_gauss-u2_gauss). \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR = &
    & INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR !<Continuous field normal operator, i.e., lambda(u_1.n_1-u_2.n_2). \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_FLS_CONTACT_OPERATOR= &
    & INTERFACE_CONDITION_FLS_CONTACT_OPERATOR !<Frictionless contact operator, i.e., lambda.(x_1.n-x_2.n). \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_FLS_CONTACT_REPROJECT_OPERATOR= &
    & INTERFACE_CONDITION_FLS_CONTACT_REPROJECT_OPERATOR !<Frictionless contact operator, reproject at each newton iteration and has geometric linearisation terms i.e., lambda.(x_1.n-x_2.n). \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_SOLID_FLUID_OPERATOR = INTERFACE_CONDITION_SOLID_FLUID_OPERATOR !<Solid fluid operator, i.e., lambda.(v_f-du_s/dt). \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR = &
    & INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR !<Solid fluid normal operator, i.e., lambda(v_f.n_f-du_s/dt.n_s). \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_InterfaceConditionIntegrationTypes OPENCMISS::InterfaceConditions::IntegrationTypes
  !> \brief Interface condition integration types.
  !> \see OPENCMISS::InterfaceConditions,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_GAUSS_INTEGRATION=INTERFACE_CONDITION_GAUSS_INTEGRATION !<Gauss points integration type, i.e. Loop over element Gauss points and sum up their contribution. \see OPENCMISS_InterfaceConditionIntegrationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_INTERFACE_CONDITION_DATA_POINTS_INTEGRATION=INTERFACE_CONDITION_DATA_POINTS_INTEGRATION !< Data points integration type i.e. Loop over data points and  sum up their contribution. \see OPENCMISS_InterfaceConditionIntegrationTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the creation of an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_CreateStart
  INTERFACE cmfe_InterfaceCondition_CreateFinish
    MODULE PROCEDURE cmfe_InterfaceCondition_CreateFinishNumber
    MODULE PROCEDURE cmfe_InterfaceCondition_CreateFinishObj
  END INTERFACE cmfe_InterfaceCondition_CreateFinish

  !>Starts the creation of an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_CreateFinish
  INTERFACE cmfe_InterfaceCondition_CreateStart
    MODULE PROCEDURE cmfe_InterfaceCondition_CreateStartNumber
    MODULE PROCEDURE cmfe_InterfaceCondition_CreateStartObj
  END INTERFACE cmfe_InterfaceCondition_CreateStart

  !>Adds in a dependent variable to an interface condition.
  INTERFACE cmfe_InterfaceCondition_DependentVariableAdd
    MODULE PROCEDURE cmfe_InterfaceCondition_DependentVariableAddNumber
    MODULE PROCEDURE cmfe_InterfaceCondition_DependentVariableAddObj
  END INTERFACE cmfe_InterfaceCondition_DependentVariableAdd

  !>Destroys an interface condition.
  INTERFACE cmfe_InterfaceCondition_Destroy
    MODULE PROCEDURE cmfe_InterfaceCondition_DestroyNumber
    MODULE PROCEDURE cmfe_InterfaceCondition_DestroyObj
  END INTERFACE cmfe_InterfaceCondition_Destroy

  !>Finishes the creation of equations for an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_EquationsCreateStart
  INTERFACE cmfe_InterfaceCondition_EquationsCreateFinish
    MODULE PROCEDURE cmfe_InterfaceCondition_EquationsCreateFinishNumber
    MODULE PROCEDURE cmfe_InterfaceCondition_EquationsCreateFinishObj
  END INTERFACE cmfe_InterfaceCondition_EquationsCreateFinish

  !>Starts the creation of equations for an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_EquationsCreateFinish
  INTERFACE cmfe_InterfaceCondition_EquationsCreateStart
    MODULE PROCEDURE cmfe_InterfaceCondition_EquationsCreateStartNumber
    MODULE PROCEDURE cmfe_InterfaceCondition_EquationsCreateStartObj
  END INTERFACE cmfe_InterfaceCondition_EquationsCreateStart

  !>Destroys the interface equations for an interface condition.
  INTERFACE cmfe_InterfaceCondition_EquationsDestroy
    MODULE PROCEDURE cmfe_InterfaceCondition_EquationsDestroyNumber
    MODULE PROCEDURE cmfe_InterfaceCondition_EquationsDestroyObj
  END INTERFACE cmfe_InterfaceCondition_EquationsDestroy
  
  !>Returns the integration type for an interface condition.
  INTERFACE cmfe_InterfaceCondition_IntegrationTypeGet
    MODULE PROCEDURE cmfe_InterfaceCondition_IntegrationTypeGetNumber
    MODULE PROCEDURE cmfe_InterfaceCondition_IntegrationTypeGetObj
  END INTERFACE cmfe_InterfaceCondition_IntegrationTypeGet
  
  !>Sets/changes the integration type for an interface condition.
  INTERFACE cmfe_InterfaceCondition_IntegrationTypeSet
    MODULE PROCEDURE cmfe_InterfaceCondition_IntegrationTypeSetNumber
    MODULE PROCEDURE cmfe_InterfaceCondition_IntegrationTypeSetObj
  END INTERFACE cmfe_InterfaceCondition_IntegrationTypeSet

  !>Finishes the creation of a Lagrange multipliers field for an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_LagrangeFieldCreateStart
  INTERFACE cmfe_InterfaceCondition_LagrangeFieldCreateFinish
    MODULE PROCEDURE cmfe_InterfaceCondition_LagrangeFieldCreateFinishNumber
    MODULE PROCEDURE cmfe_InterfaceCondition_LagrangeFieldCreateFinishObj
  END INTERFACE cmfe_InterfaceCondition_LagrangeFieldCreateFinish

  !>Starts the creation of a Lagrange multipliers field for an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_LagrangeFieldCreateFinish
  INTERFACE cmfe_InterfaceCondition_LagrangeFieldCreateStart
    MODULE PROCEDURE cmfe_InterfaceCondition_LagrangeFieldCreateStartNumber
    MODULE PROCEDURE cmfe_InterfaceCondition_LagrangeFieldCreateStartObj
  END INTERFACE cmfe_InterfaceCondition_LagrangeFieldCreateStart

  !>Finishes the creation of a Penalty field for an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_PenaltyFieldCreateStart
  INTERFACE cmfe_InterfaceCondition_PenaltyFieldCreateFinish
    MODULE PROCEDURE cmfe_InterfaceCondition_PenaltyFieldCreateFinishNumber
    MODULE PROCEDURE cmfe_InterfaceCondition_PenaltyFieldCreateFinishObj
  END INTERFACE cmfe_InterfaceCondition_PenaltyFieldCreateFinish

  !>Starts the creation of a Penalty field for an interface condition. \see OpenCMISS::Iron::cmfe_InterfaceCondition_PenaltyFieldCreateFinish
  INTERFACE cmfe_InterfaceCondition_PenaltyFieldCreateStart
    MODULE PROCEDURE cmfe_InterfaceCondition_PenaltyFieldCreateStartNumber
    MODULE PROCEDURE cmfe_InterfaceCondition_PenaltyFieldCreateStartObj
  END INTERFACE cmfe_InterfaceCondition_PenaltyFieldCreateStart

  !>Returns the method for an interface condition.
  INTERFACE cmfe_InterfaceCondition_MethodGet
    MODULE PROCEDURE cmfe_InterfaceCondition_MethodGetNumber
    MODULE PROCEDURE cmfe_InterfaceCondition_MethodGetObj
  END INTERFACE cmfe_InterfaceCondition_MethodGet

  !>Sets/changes the method for an interface condition.
  INTERFACE cmfe_InterfaceCondition_MethodSet
    MODULE PROCEDURE cmfe_InterfaceCondition_MethodSetNumber
    MODULE PROCEDURE cmfe_InterfaceCondition_MethodSetObj
  END INTERFACE cmfe_InterfaceCondition_MethodSet

  !>Returns the operator for an interface condition.
  INTERFACE cmfe_InterfaceCondition_OperatorGet
    MODULE PROCEDURE cmfe_InterfaceCondition_OperatorGetNumber
    MODULE PROCEDURE cmfe_InterfaceCondition_OperatorGetObj
  END INTERFACE cmfe_InterfaceCondition_OperatorGet

  !>Sets/changes the operator for an interface condition.
  INTERFACE cmfe_InterfaceCondition_OperatorSet
    MODULE PROCEDURE cmfe_InterfaceCondition_OperatorSetNumber
    MODULE PROCEDURE cmfe_InterfaceCondition_OperatorSetObj
  END INTERFACE cmfe_InterfaceCondition_OperatorSet

  !>Returns the sparsity for interface equations.
  INTERFACE cmfe_InterfaceEquations_SparsityGet
    MODULE PROCEDURE cmfe_InterfaceEquations_SparsityGetNumber
    MODULE PROCEDURE cmfe_InterfaceEquations_SparsityGetObj
  END INTERFACE cmfe_InterfaceEquations_SparsityGet

  !>Sets/changes the sparsity for interface equations.
  INTERFACE cmfe_InterfaceEquations_SparsitySet
    MODULE PROCEDURE cmfe_InterfaceEquations_SparsitySetNumber
    MODULE PROCEDURE cmfe_InterfaceEquations_SparsitySetObj
  END INTERFACE cmfe_InterfaceEquations_SparsitySet

  !>Returns the output type for interface equations.
  INTERFACE cmfe_InterfaceEquations_OutputTypeGet
    MODULE PROCEDURE cmfe_InterfaceEquations_OutputTypeGetNumber
    MODULE PROCEDURE cmfe_InterfaceEquations_OutputTypeGetObj
  END INTERFACE cmfe_InterfaceEquations_OutputTypeGet

  !>Sets/changes the output type for interface equations.
  INTERFACE cmfe_InterfaceEquations_OutputTypeSet
    MODULE PROCEDURE cmfe_InterfaceEquations_OutputTypeSetNumber
    MODULE PROCEDURE cmfe_InterfaceEquations_OutputTypeSetObj
  END INTERFACE cmfe_InterfaceEquations_OutputTypeSet

  PUBLIC CMFE_INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD,CMFE_INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD, &
    & CMFE_INTERFACE_CONDITION_PENALTY_METHOD,CMFE_INTERFACE_CONDITION_POINT_TO_POINT_METHOD

  PUBLIC CMFE_INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR,CMFE_INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR, &
    & CMFE_INTERFACE_CONDITION_FLS_CONTACT_OPERATOR,CMFE_INTERFACE_CONDITION_FLS_CONTACT_REPROJECT_OPERATOR, &
    & CMFE_INTERFACE_CONDITION_SOLID_FLUID_OPERATOR,CMFE_INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR
    
  PUBLIC CMFE_INTERFACE_CONDITION_GAUSS_INTEGRATION,CMFE_INTERFACE_CONDITION_DATA_POINTS_INTEGRATION

  PUBLIC cmfe_InterfaceCondition_CreateFinish,cmfe_InterfaceCondition_CreateStart

  PUBLIC cmfe_InterfaceCondition_DependentVariableAdd

  PUBLIC cmfe_InterfaceCondition_Destroy

  PUBLIC cmfe_InterfaceCondition_EquationsCreateFinish,cmfe_InterfaceCondition_EquationsCreateStart

  PUBLIC cmfe_InterfaceCondition_EquationsDestroy
  
  PUBLIC cmfe_InterfaceCondition_IntegrationTypeGet,cmfe_InterfaceCondition_IntegrationTypeSet

  PUBLIC cmfe_InterfaceCondition_LagrangeFieldCreateFinish,cmfe_InterfaceCondition_LagrangeFieldCreateStart

  PUBLIC cmfe_InterfaceCondition_PenaltyFieldCreateFinish,cmfe_InterfaceCondition_PenaltyFieldCreateStart

  PUBLIC cmfe_InterfaceCondition_MethodGet,cmfe_InterfaceCondition_MethodSet

  PUBLIC cmfe_InterfaceCondition_OperatorGet,cmfe_InterfaceCondition_OperatorSet

  PUBLIC cmfe_InterfaceEquations_SparsityGet,cmfe_InterfaceEquations_SparsitySet

  PUBLIC cmfe_InterfaceEquations_OutputTypeGet,cmfe_InterfaceEquations_OutputTypeSet

!!==================================================================================================================================
!!
!! INTERFACE MATRICES ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_InterfaceMatricesTimeDependenceTypes OPENCMISS::InterfaceMatrices::TimeDependenceTypes
  !> \brief Interface matrices time dependency types
  !>@{
  INTEGER, PARAMETER :: CMFE_NUMBER_OF_INTERFACE_MATRIX_TYPES=NUMBER_OF_INTERFACE_MATRIX_TYPES
  INTEGER, PARAMETER :: CMFE_INTERFACE_MATRIX_STATIC=INTERFACE_MATRIX_STATIC !<Interface matrix is of static type \see INTERFACE_MATRICES_ROUTINES_InterfaceMatricesTimeDependenceTypes,INTERFACE_MATRICES_ROUTINES
  INTEGER, PARAMETER :: CMFE_INTERFACE_MATRIX_QUASI_STATIC=INTERFACE_MATRIX_QUASI_STATIC !<Interface matrix is of quasi-static type \see INTERFACE_MATRICES_ROUTINES_InterfaceMatricesTimeDependenceTypes,INTERFACE_MATRICES_ROUTINES
  INTEGER, PARAMETER :: CMFE_INTERFACE_MATRIX_FIRST_ORDER_DYNAMIC=INTERFACE_MATRIX_FIRST_ORDER_DYNAMIC !<Interface matrix is of first order dynamic type \see INTERFACE_MATRICES_ROUTINES_InterfaceMatricesTimeDependenceTypes,INTERFACE_MATRICES_ROUTINES
  INTEGER, PARAMETER :: CMFE_INTERFACE_MATRIX_SECOND_ORDER_DYNAMIC=INTERFACE_MATRIX_SECOND_ORDER_DYNAMIC !<Interface matrix is of second order dynamic type \see INTERFACE_MATRICES_ROUTINES_InterfaceMatricesTimeDependenceTypes,INTERFACE_MATRICES_ROUTINES
  !>@}

  !Module types

  !Module variables

  !Interfaces
  PUBLIC CMFE_NUMBER_OF_INTERFACE_MATRIX_TYPES,CMFE_INTERFACE_MATRIX_STATIC,CMFE_INTERFACE_MATRIX_QUASI_STATIC, &
    & CMFE_INTERFACE_MATRIX_FIRST_ORDER_DYNAMIC,CMFE_INTERFACE_MATRIX_SECOND_ORDER_DYNAMIC

  PUBLIC cmfe_InterfaceMatrices_TimeDependenceTypeSet,cmfe_InterfaceMatrices_TimeDependenceTypeGet

!!==================================================================================================================================
!!
!! MESH_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_MeshConstants OPENCMISS::Mesh::Constants
  !> \brief Mesh constants.
  !>@{
  !> \addtogroup OPENCMISS_DecompositionTypes OPENCMISS::Mesh::DecompositionTypes
  !> \brief The Decomposition types parameters
  !> \see OPENCMISS::Mesh,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_DECOMPOSITION_ALL_TYPE = DECOMPOSITION_ALL_TYPE !<The decomposition contains all elements. \see OPENCMISS_DecompositionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_DECOMPOSITION_CALCULATED_TYPE = DECOMPOSITION_CALCULATED_TYPE !<The element decomposition is calculated by graph partitioning. \see OPENCMISS_DecompositionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_DECOMPOSITION_USER_DEFINED_TYPE = DECOMPOSITION_USER_DEFINED_TYPE !<The user will set the element decomposition. \see OPENCMISS_DecompositionTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the creation of a domain decomposition. \see OpenCMISS::Iron::cmfe_Decomposition_CreateStart
  INTERFACE cmfe_Decomposition_CreateFinish
    MODULE PROCEDURE cmfe_Decomposition_CreateFinishNumber
    MODULE PROCEDURE cmfe_Decomposition_CreateFinishObj
  END INTERFACE cmfe_Decomposition_CreateFinish

  !>Start the creation of a domain decomposition for a given mesh. \see OpenCMISS::Iron::cmfe_Decomposition_CreateStart
  INTERFACE cmfe_Decomposition_CreateStart
    MODULE PROCEDURE cmfe_Decomposition_CreateStartNumber
    MODULE PROCEDURE cmfe_Decomposition_CreateStartObj
  END INTERFACE cmfe_Decomposition_CreateStart

  !>Destroys a domain decomposition.
  INTERFACE cmfe_Decomposition_Destroy
    MODULE PROCEDURE cmfe_Decomposition_DestroyNumber
    MODULE PROCEDURE cmfe_Decomposition_DestroyObj
  END INTERFACE cmfe_Decomposition_Destroy

  !>Calculates the element domains for the decomposition of a mesh.
  INTERFACE cmfe_Decomposition_ElementDomainCalculate
    MODULE PROCEDURE cmfe_Decomposition_ElementDomainCalculateNumber
    MODULE PROCEDURE cmfe_Decomposition_ElementDomainCalculateObj
  END INTERFACE cmfe_Decomposition_ElementDomainCalculate

  !>Returns the domain for a given element in a decomposition of a mesh.
  INTERFACE cmfe_Decomposition_ElementDomainGet
    MODULE PROCEDURE cmfe_Decomposition_ElementDomainGetNumber
    MODULE PROCEDURE cmfe_Decomposition_ElementDomainGetObj
  END INTERFACE cmfe_Decomposition_ElementDomainGet

  !>Sets/changes the domain for a given element in a decomposition of a mesh.
  INTERFACE cmfe_Decomposition_ElementDomainSet
    MODULE PROCEDURE cmfe_Decomposition_ElementDomainSetNumber
    MODULE PROCEDURE cmfe_Decomposition_ElementDomainSetObj
  END INTERFACE cmfe_Decomposition_ElementDomainSet

  !>Returns the mesh component number used for the decomposition of a mesh.
  INTERFACE cmfe_Decomposition_MeshComponentGet
    MODULE PROCEDURE cmfe_Decomposition_MeshComponentGetNumber
    MODULE PROCEDURE cmfe_Decomposition_MeshComponentGetObj
  END INTERFACE cmfe_Decomposition_MeshComponentGet

  !>Sets/changes the mesh component number used for the decomposition of a mesh.
  INTERFACE cmfe_Decomposition_MeshComponentSet
    MODULE PROCEDURE cmfe_Decomposition_MeshComponentSetNumber
    MODULE PROCEDURE cmfe_Decomposition_MeshComponentSetObj
  END INTERFACE cmfe_Decomposition_MeshComponentSet

  !>Returns the number of domains used for the decomposition of a mesh.
  INTERFACE cmfe_Decomposition_NumberOfDomainsGet
    MODULE PROCEDURE cmfe_Decomposition_NumberOfDomainsGetNumber
    MODULE PROCEDURE cmfe_Decomposition_NumberOfDomainsGetObj
  END INTERFACE cmfe_Decomposition_NumberOfDomainsGet

  !>Sets/changes the number of domains used for the decomposition of a mesh.
  INTERFACE cmfe_Decomposition_NumberOfDomainsSet
    MODULE PROCEDURE cmfe_Decomposition_NumberOfDomainsSetNumber
    MODULE PROCEDURE cmfe_Decomposition_NumberOfDomainsSetObj
  END INTERFACE cmfe_Decomposition_NumberOfDomainsSet

  !>Returns the type of decomposition.
  INTERFACE cmfe_Decomposition_TypeGet
    MODULE PROCEDURE cmfe_Decomposition_TypeGetNumber
    MODULE PROCEDURE cmfe_Decomposition_TypeGetObj
  END INTERFACE cmfe_Decomposition_TypeGet

  !>Sets/changes the type of decomposition.
  INTERFACE cmfe_Decomposition_TypeSet
    MODULE PROCEDURE cmfe_Decomposition_TypeSetNumber
    MODULE PROCEDURE cmfe_Decomposition_TypeSetObj
  END INTERFACE cmfe_Decomposition_TypeSet

  !>Sets/changes whether lines should be calculated for the decomposition.
  INTERFACE cmfe_Decomposition_CalculateLinesSet
    MODULE PROCEDURE cmfe_Decomposition_CalculateLinesSetNumber
    MODULE PROCEDURE cmfe_Decomposition_CalculateLinesSetObj
  END INTERFACE cmfe_Decomposition_CalculateLinesSet

  !>Sets/changes whether faces should be calculated for the decomposition.
  INTERFACE cmfe_Decomposition_CalculateFacesSet
    MODULE PROCEDURE cmfe_Decomposition_CalculateFacesSetNumber
    MODULE PROCEDURE cmfe_Decomposition_CalculateFacesSetObj
  END INTERFACE cmfe_Decomposition_CalculateFacesSet

  !>Finishes the creation of a mesh. \see OpenCMISS::Iron::cmfe_Mesh_CreateStart
  INTERFACE cmfe_Mesh_CreateFinish
    MODULE PROCEDURE cmfe_Mesh_CreateFinishNumber
    MODULE PROCEDURE cmfe_Mesh_CreateFinishObj
  END INTERFACE cmfe_Mesh_CreateFinish

  !>Starts the creation of a mesh. \see OpenCMISS::Iron::cmfe_Mesh_CreateFinish
  INTERFACE cmfe_Mesh_CreateStart
    MODULE PROCEDURE cmfe_Mesh_CreateStartNumber
    MODULE PROCEDURE cmfe_Mesh_CreateStartObj
    MODULE PROCEDURE cmfe_Mesh_CreateStartInterfaceObj
  END INTERFACE cmfe_Mesh_CreateStart

  !>Destroys a mesh.
  INTERFACE cmfe_Mesh_Destroy
    MODULE PROCEDURE cmfe_Mesh_DestroyNumber
    MODULE PROCEDURE cmfe_Mesh_DestroyObj
  END INTERFACE cmfe_Mesh_Destroy

  !>Returns the number of mesh components in a mesh.
  INTERFACE cmfe_Mesh_NumberOfComponentsGet
    MODULE PROCEDURE cmfe_Mesh_NumberOfComponentsGetNumber
    MODULE PROCEDURE cmfe_Mesh_NumberOfComponentsGetObj
  END INTERFACE cmfe_Mesh_NumberOfComponentsGet

  !>Sets/changes the number of mesh components in a mesh.
  INTERFACE cmfe_Mesh_NumberOfComponentsSet
    MODULE PROCEDURE cmfe_Mesh_NumberOfComponentsSetNumber
    MODULE PROCEDURE cmfe_Mesh_NumberOfComponentsSetObj
  END INTERFACE cmfe_Mesh_NumberOfComponentsSet

  !>Returns the number of elements in a mesh.
  INTERFACE cmfe_Mesh_NumberOfElementsGet
    MODULE PROCEDURE cmfe_Mesh_NumberOfElementsGetNumber
    MODULE PROCEDURE cmfe_Mesh_NumberOfElementsGetObj
  END INTERFACE cmfe_Mesh_NumberOfElementsGet

  !>Sets/changes the number of elements in a mesh.
  INTERFACE cmfe_Mesh_NumberOfElementsSet
    MODULE PROCEDURE cmfe_Mesh_NumberOfElementsSetNumber
    MODULE PROCEDURE cmfe_Mesh_NumberOfElementsSetObj
  END INTERFACE cmfe_Mesh_NumberOfElementsSet

  !>Sets/changes the surrounding elements calculate flag for the mesh.
  INTERFACE cmfe_Mesh_SurroundingElementsCalculateSet
    MODULE PROCEDURE cmfe_Mesh_SurroundingElementsCalculateSetNumber
    MODULE PROCEDURE cmfe_Mesh_SurroundingElementsCalculateSetObj
  END INTERFACE cmfe_Mesh_SurroundingElementsCalculateSet
  
  !>Sets/changes whether data points topology should be calculated for the decomposition.
  INTERFACE cmfe_Mesh_TopologyDataPointsCalculateProjection
    MODULE PROCEDURE cmfe_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber
    MODULE PROCEDURE cmfe_Mesh_TopologyDataPointsCalculateProjectionRegionNumber
    MODULE PROCEDURE cmfe_Mesh_TopologyDataPointsCalculateProjectionObj
  END INTERFACE cmfe_Mesh_TopologyDataPointsCalculateProjection

  !>Returns the basis for an element in a mesh.
  INTERFACE cmfe_MeshElements_BasisGet
    MODULE PROCEDURE cmfe_MeshElements_BasisGetNumber
    MODULE PROCEDURE cmfe_MeshElements_BasisGetObj
  END INTERFACE cmfe_MeshElements_BasisGet

  !>Sets/changes the basis for an element in a mesh.
  INTERFACE cmfe_MeshElements_BasisSet
    MODULE PROCEDURE cmfe_MeshElements_BasisSetNumber
    MODULE PROCEDURE cmfe_MeshElements_BasisSetObj
  END INTERFACE cmfe_MeshElements_BasisSet

  !>Returns the adjacent elements for a given element and adjacent xi direction for an element in a mesh.
  INTERFACE cmfe_MeshElements_AdjacentElementGet
    MODULE PROCEDURE cmfe_MeshElements_AdjacentElementGetNumber
    MODULE PROCEDURE cmfe_MeshElements_AdjacentElementGetObj
  END INTERFACE cmfe_MeshElements_AdjacentElementGet

  !>Finishes the creation of a mesh elements for a mesh component. \see OpenCMISS::Iron::cmfe_MeshElements_CreateStart
  INTERFACE cmfe_MeshElements_CreateFinish
    MODULE PROCEDURE cmfe_MeshElements_CreateFinishNumber
    MODULE PROCEDURE cmfe_MeshElements_CreateFinishObj
  END INTERFACE cmfe_MeshElements_CreateFinish

  !>Starts the creation of a mesh elements for a mesh component. \see OpenCMISS::Iron::cmfe_MeshElements_CreateFinish
  INTERFACE cmfe_MeshElements_CreateStart
    MODULE PROCEDURE cmfe_MeshElements_CreateStartNumber
    MODULE PROCEDURE cmfe_MeshElements_CreateStartObj
  END INTERFACE cmfe_MeshElements_CreateStart

  !>Get the mesh elements belonging to a mesh component.
  INTERFACE cmfe_Mesh_ElementsGet
    MODULE PROCEDURE cmfe_Mesh_ElementsGetNumber
    MODULE PROCEDURE cmfe_Mesh_ElementsGetObj
  END INTERFACE cmfe_Mesh_ElementsGet

  !>Returns the element nodes for an element in a mesh.
  INTERFACE cmfe_MeshElements_NodesGet
    MODULE PROCEDURE cmfe_MeshElements_NodesGetNumber
    MODULE PROCEDURE cmfe_MeshElements_NodesGetObj
  END INTERFACE cmfe_MeshElements_NodesGet

  !>Sets/changes the element nodes for an element in a mesh.
  INTERFACE cmfe_MeshElements_NodesSet
    MODULE PROCEDURE cmfe_MeshElements_NodesSetNumber
    MODULE PROCEDURE cmfe_MeshElements_NodesSetObj
  END INTERFACE cmfe_MeshElements_NodesSet

  !>Sets/changes a user node's derivative version for an element in a mesh.
  INTERFACE cmfe_MeshElements_UserNodeVersionSet
    MODULE PROCEDURE cmfe_MeshElements_UserNodeVersionSetNumber
    MODULE PROCEDURE cmfe_MeshElements_UserNodeVersionSetObj
  END INTERFACE cmfe_MeshElements_UserNodeVersionSet

  !>Sets/changes a local element's node derivative version for an element in a mesh.
  INTERFACE cmfe_MeshElements_LocalElementNodeVersionSet
    MODULE PROCEDURE cmfe_MeshElements_LocalElementNodeVersionSetNumber
    MODULE PROCEDURE cmfe_MeshElements_LocalElementNodeVersionSetObj
  END INTERFACE cmfe_MeshElements_LocalElementNodeVersionSet

  !>Returns the element user number for an element in a mesh.
  INTERFACE cmfe_MeshElements_UserNumberGet
    MODULE PROCEDURE cmfe_MeshElements_UserNumberGetNumber
    MODULE PROCEDURE cmfe_MeshElements_UserNumberGetObj
  END INTERFACE cmfe_MeshElements_UserNumberGet

  !>Sets/changes the element user number for an element in a mesh.
  INTERFACE cmfe_MeshElements_UserNumberSet
    MODULE PROCEDURE cmfe_MeshElements_UserNumberSetNumber
    MODULE PROCEDURE cmfe_MeshElements_UserNumberSetObj
  END INTERFACE cmfe_MeshElements_UserNumberSet

  !>Sets/changes the element user numbers for all element in a mesh.
  INTERFACE cmfe_MeshElements_UserNumbersAllSet
    MODULE PROCEDURE cmfe_MeshElements_UserNumbersAllSetNumber
    MODULE PROCEDURE cmfe_MeshElements_UserNumbersAllSetObj
  END INTERFACE cmfe_MeshElements_UserNumbersAllSet

  !>Returns true if the given node is in the given mesh component.
  INTERFACE cmfe_Mesh_NodeExists
    MODULE PROCEDURE cmfe_Mesh_NodeExistsNumber
    MODULE PROCEDURE cmfe_Mesh_NodeExistsObj
  END INTERFACE cmfe_Mesh_NodeExists

  !>Returns true if the given element is in the given mesh component.
  INTERFACE cmfe_Mesh_ElementExists
    MODULE PROCEDURE cmfe_Mesh_ElementExistsNumber
    MODULE PROCEDURE cmfe_Mesh_ElementExistsObj
  END INTERFACE cmfe_Mesh_ElementExists

  !>Get the mesh nodes belonging to a mesh component.
  INTERFACE cmfe_Mesh_NodesGet
    MODULE PROCEDURE cmfe_Mesh_NodesGetNumber
    MODULE PROCEDURE cmfe_Mesh_NodesGetObj
  END INTERFACE cmfe_Mesh_NodesGet

  !>Returns the number of derivatives for a node in a mesh.
  INTERFACE cmfe_MeshNodes_NumberOfDerivativesGet
    MODULE PROCEDURE cmfe_MeshNodes_NumberOfDerivativesGetNumber
    MODULE PROCEDURE cmfe_MeshNodes_NumberOfDerivativesGetObj
  END INTERFACE cmfe_MeshNodes_NumberOfDerivativesGet

  !>Returns the derivatives for a node in a mesh.
  INTERFACE cmfe_MeshNodes_DerivativesGet
    MODULE PROCEDURE cmfe_MeshNodes_DerivativesGetNumber
    MODULE PROCEDURE cmfe_MeshNodes_DerivativesGetObj
  END INTERFACE cmfe_MeshNodes_DerivativesGet

  !>Returns the number of versions for a derivative at a node in a mesh.
  INTERFACE cmfe_MeshNodes_NumberOfVersionsGet
    MODULE PROCEDURE cmfe_MeshNodes_NumberOfVersionsGetNumber
    MODULE PROCEDURE cmfe_MeshNodes_NumberOfVersionsGetObj
  END INTERFACE cmfe_MeshNodes_NumberOfVersionsGet

  !>Returns the number of nodes in a mesh.
  INTERFACE cmfe_MeshNodes_NumberOfNodesGet
    MODULE PROCEDURE cmfe_MeshNodes_NumberOfNodesGetNumber
    MODULE PROCEDURE cmfe_MeshNodes_NumberOfNodesGetObj
  END INTERFACE cmfe_MeshNodes_NumberOfNodesGet

  !>Returns the domain for a given element in a decomposition of a mesh.
  INTERFACE cmfe_Decomposition_NodeDomainGet
    MODULE PROCEDURE cmfe_Decomposition_NodeDomainGetNumber
    MODULE PROCEDURE cmfe_Decomposition_NodeDomainGetObj
  END INTERFACE cmfe_Decomposition_NodeDomainGet

  !>Calculates the decomposition topology for data points .
  INTERFACE cmfe_Decomposition_TopologyDataProjectionCalculate
    MODULE PROCEDURE cmfe_Decomposition_TopologyDataProjectionCalculateObj
  END INTERFACE cmfe_Decomposition_TopologyDataProjectionCalculate

  !>Gets the local data point number for data points projected on an element
  INTERFACE cmfe_Decomposition_TopologyElementDataPointLocalNumberGet
    MODULE PROCEDURE cmfe_Decomposition_TopologyElementDataPointLocalNumberGetObj
  END INTERFACE cmfe_Decomposition_TopologyElementDataPointLocalNumberGet

  !>Gets the user data point number for data points projected on an element
  INTERFACE cmfe_Decomposition_TopologyElementDataPointUserNumberGet
    MODULE PROCEDURE cmfe_Decomposition_TopologyElementDataPointUserNumberGetObj
  END INTERFACE cmfe_Decomposition_TopologyElementDataPointUserNumberGet

  !>Gets the number of data points projected on an element
  INTERFACE cmfe_Decomposition_TopologyNumberOfElementDataPointsGet
    MODULE PROCEDURE cmfe_Decomposition_TopologyNumberOfElementDataPointsGetObj
  END INTERFACE cmfe_Decomposition_TopologyNumberOfElementDataPointsGet

  PUBLIC CMFE_DECOMPOSITION_ALL_TYPE,CMFE_DECOMPOSITION_CALCULATED_TYPE,CMFE_DECOMPOSITION_USER_DEFINED_TYPE

  PUBLIC cmfe_Decomposition_CreateFinish,cmfe_Decomposition_CreateStart

  PUBLIC cmfe_Decomposition_TopologyDataProjectionCalculate

  PUBLIC cmfe_Decomposition_TopologyElementDataPointLocalNumberGet

  PUBLIC cmfe_Decomposition_TopologyElementDataPointUserNumberGet

  PUBLIC cmfe_Decomposition_TopologyNumberOfElementDataPointsGet

  PUBLIC cmfe_Decomposition_Destroy

  PUBLIC cmfe_Decomposition_ElementDomainCalculate

  PUBLIC cmfe_Decomposition_ElementDomainGet,cmfe_Decomposition_ElementDomainSet

  PUBLIC cmfe_Decomposition_MeshComponentGet,cmfe_Decomposition_MeshComponentSet

  PUBLIC cmfe_Decomposition_NumberOfDomainsGet,cmfe_Decomposition_NumberOfDomainsSet

  PUBLIC cmfe_Decomposition_TypeGet,cmfe_Decomposition_TypeSet

  PUBLIC cmfe_Decomposition_NodeDomainGet

  PUBLIC cmfe_Mesh_CreateFinish,cmfe_Mesh_CreateStart

  PUBLIC cmfe_Mesh_Destroy

  PUBLIC cmfe_Mesh_NumberOfComponentsGet,cmfe_Mesh_NumberOfComponentsSet

  PUBLIC cmfe_Mesh_NumberOfElementsGet,cmfe_Mesh_NumberOfElementsSet

  PUBLIC cmfe_MeshElements_BasisGet,cmfe_MeshElements_BasisSet

  PUBLIC cmfe_MeshElements_AdjacentElementGet

  PUBLIC cmfe_MeshElements_UserNodeVersionSet,cmfe_MeshElements_LocalElementNodeVersionSet

  PUBLIC cmfe_MeshElements_CreateFinish,cmfe_MeshElements_CreateStart

  PUBLIC cmfe_MeshElements_NodesGet,cmfe_MeshElements_NodesSet

  PUBLIC cmfe_MeshElements_UserNumberGet,cmfe_MeshElements_UserNumberSet

  PUBLIC cmfe_MeshElements_UserNumbersAllSet
 
  PUBLIC cmfe_MeshNodes_NumberOfDerivativesGet,cmfe_MeshNodes_DerivativesGet

  PUBLIC cmfe_MeshNodes_NumberOfVersionsGet

  PUBLIC cmfe_MeshNodes_NumberOfNodesGet

  PUBLIC cmfe_Mesh_ElementsGet

  PUBLIC cmfe_Mesh_NodesGet

  PUBLIC cmfe_Mesh_NodeExists,cmfe_Mesh_ElementExists

  PUBLIC cmfe_Mesh_SurroundingElementsCalculateSet

  PUBLIC cmfe_Mesh_TopologyDataPointsCalculateProjection

!!==================================================================================================================================
!!
!! DISTRIBUTED_MATRIX_VECTOR
!!
!!==================================================================================================================================

  !> \addtogroup OPENCMISS_MatrixVectorConstants OPENCMISS::MatrixVector::Constants
  !> \brief Distributed matrix and vector function constants.
  !>@{
  !> \addtogroup OPENCMISS_MatrixStorageTypes OPENCMISS::MatrixVector::MatrixStorageTypes
  !> \brief Type of matrix storage.
  !> \see OPENCMISS::MatrixVectorConstants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_MATRIX_BLOCK_STORAGE_TYPE=DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE !<Distributed matrix block storage type \see OPENCMISS_MatrixStorageTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_MATRIX_DIAGONAL_STORAGE_TYPE=DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE !<Distributed matrix diagonal storage type \see OPENCMISS_MatrixStorageTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_MATRIX_COLUMN_MAJOR_STORAGE_TYPE=DISTRIBUTED_MATRIX_COLUMN_MAJOR_STORAGE_TYPE !<Distributed matrix column major storage type \see OPENCMISS_MatrixStorageTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_MATRIX_ROW_MAJOR_STORAGE_TYPE=DISTRIBUTED_MATRIX_ROW_MAJOR_STORAGE_TYPE !<Distributed matrix row major storage type \see OPENCMISS_MatrixStorageTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_MATRIX_COMPRESSED_ROW_STORAGE_TYPE=DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE !<Distributed matrix compressed row storage type \see OPENCMISS_MatrixStorageTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE=DISTRIBUTED_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE !<Distributed matrix compressed column storage type \see OPENCMISS_MatrixStorageTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_MATRIX_ROW_COLUMN_STORAGE_TYPE=DISTRIBUTED_MATRIX_ROW_COLUMN_STORAGE_TYPE !<Distributed matrix row-column storage type \see OPENCMISS_MatrixStorageTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_MatrixVectorDataTypes OPENCMISS::MatrixVector::DataTypes
  !> \brief Type of data stored in matrices and vectors.
  !> \see OPENCMISS::MatrixVectorConstants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_MATRIX_VECTOR_INTG_TYPE=DISTRIBUTED_MATRIX_VECTOR_INTG_TYPE
  INTEGER(INTG), PARAMETER :: CMFE_MATRIX_VECTOR_SP_TYPE=DISTRIBUTED_MATRIX_VECTOR_SP_TYPE !<Single precision real distributed matrix-vector data type \see OPENCMISS_MatrixVectorDataTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_MATRIX_VECTOR_DP_TYPE=DISTRIBUTED_MATRIX_VECTOR_DP_TYPE !<Double precision real distributed matrix-vector data type \see OPENCMISS_MatrixVectorDataTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_MATRIX_VECTOR_L_TYPE=DISTRIBUTED_MATRIX_VECTOR_L_TYPE !<Logical distributed matrix-vector data type \see OPENCMISS_MatrixVectorDataTypes,OPENCMISS
  !>@}
  !>@}

  PUBLIC CMFE_MATRIX_BLOCK_STORAGE_TYPE,CMFE_MATRIX_DIAGONAL_STORAGE_TYPE,CMFE_MATRIX_COLUMN_MAJOR_STORAGE_TYPE, &
    & CMFE_MATRIX_ROW_MAJOR_STORAGE_TYPE,CMFE_MATRIX_COMPRESSED_ROW_STORAGE_TYPE,CMFE_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE, &
    & CMFE_MATRIX_ROW_COLUMN_STORAGE_TYPE

  PUBLIC CMFE_MATRIX_VECTOR_INTG_TYPE,CMFE_MATRIX_VECTOR_SP_TYPE,CMFE_MATRIX_VECTOR_DP_TYPE,CMFE_MATRIX_VECTOR_L_TYPE

  !Note that currently we don't have any user number based routines for distributed matrices
  !as if we can't use a pointer to a CMISS object, a pointer to matrix data isn't going to
  !be much use either. It's also more awkward when matrices and vectors themselves don't have
  !user numbers and there are multiple ways to access them through user numbers, eg. solver equations
  !matrices or equations set matrices

  !>Get the storage type for a distributed matrix
  INTERFACE cmfe_DistributedMatrix_StorageTypeGet
    MODULE PROCEDURE cmfe_DistributedMatrix_StorageTypeGetObj
  END INTERFACE cmfe_DistributedMatrix_StorageTypeGet

  !>Get the data type for a distributed matrix
  INTERFACE cmfe_DistributedMatrix_DataTypeGet
    MODULE PROCEDURE cmfe_DistributedMatrix_DataTypeGetObj
  END INTERFACE cmfe_DistributedMatrix_DataTypeGet

  !>Get the dimensions for a distributed matrix on this computational node
  INTERFACE cmfe_DistributedMatrix_DimensionsGet
    MODULE PROCEDURE cmfe_DistributedMatrix_DimensionsGetObj
  END INTERFACE cmfe_DistributedMatrix_DimensionsGet

  !>Get the row indices and column indices for a sparse matrix
  INTERFACE cmfe_DistributedMatrix_StorageLocationsGet
    MODULE PROCEDURE cmfe_DistributedMatrix_StorageLocationsGetObj
  END INTERFACE cmfe_DistributedMatrix_StorageLocationsGet

  !>Get the data array for this matrix on this computational node
  INTERFACE cmfe_DistributedMatrix_DataGet
    MODULE PROCEDURE cmfe_DistributedMatrix_DataGetIntgObj
    MODULE PROCEDURE cmfe_DistributedMatrix_DataGetDPObj
    MODULE PROCEDURE cmfe_DistributedMatrix_DataGetSPObj
    MODULE PROCEDURE cmfe_DistributedMatrix_DataGetLObj
  END INTERFACE cmfe_DistributedMatrix_DataGet

  !>Restore the data array for this matrix once it has finished being used
  INTERFACE cmfe_DistributedMatrix_DataRestore
    MODULE PROCEDURE cmfe_DistributedMatrix_DataRestoreIntgObj
    MODULE PROCEDURE cmfe_DistributedMatrix_DataRestoreDPObj
    MODULE PROCEDURE cmfe_DistributedMatrix_DataRestoreSPObj
    MODULE PROCEDURE cmfe_DistributedMatrix_DataRestoreLObj
  END INTERFACE cmfe_DistributedMatrix_DataRestore

  !>Get the data type for a distributed vector
  INTERFACE cmfe_DistributedVector_DataTypeGet
    MODULE PROCEDURE cmfe_DistributedVector_DataTypeGetObj
  END INTERFACE cmfe_DistributedVector_DataTypeGet

  !>Get the data array for this vector on this computational node
  INTERFACE cmfe_DistributedVector_DataGet
    MODULE PROCEDURE cmfe_DistributedVector_DataGetIntgObj
    MODULE PROCEDURE cmfe_DistributedVector_DataGetDPObj
    MODULE PROCEDURE cmfe_DistributedVector_DataGetSPObj
    MODULE PROCEDURE cmfe_DistributedVector_DataGetLObj
  END INTERFACE cmfe_DistributedVector_DataGet

  !>Restore the data array for this vector once it has finished being used
  INTERFACE cmfe_DistributedVector_DataRestore
    MODULE PROCEDURE cmfe_DistributedVector_DataRestoreIntgObj
    MODULE PROCEDURE cmfe_DistributedVector_DataRestoreDPObj
    MODULE PROCEDURE cmfe_DistributedVector_DataRestoreSPObj
    MODULE PROCEDURE cmfe_DistributedVector_DataRestoreLObj
  END INTERFACE cmfe_DistributedVector_DataRestore

  PUBLIC cmfe_DistributedMatrix_StorageTypeGet,cmfe_DistributedMatrix_StorageLocationsGet
  PUBLIC cmfe_DistributedMatrix_DataTypeGet,cmfe_DistributedMatrix_DimensionsGet
  PUBLIC cmfe_DistributedMatrix_DataGet,cmfe_DistributedMatrix_DataRestore
  PUBLIC cmfe_DistributedVector_DataTypeGet
  PUBLIC cmfe_DistributedVector_DataGet,cmfe_DistributedVector_DataRestore

!!==================================================================================================================================
!!
!! NODE_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the process of creating nodes in a region. \see OpenCMISS::Iron::cmfe_Nodes_CreateStart
  INTERFACE cmfe_Nodes_CreateFinish
    MODULE PROCEDURE cmfe_Nodes_CreateFinishNumber
    MODULE PROCEDURE cmfe_Nodes_CreateFinishObj
  END INTERFACE cmfe_Nodes_CreateFinish

  !>Starts the process of creating nodes in a region. \see OpenCMISS::Iron::cmfe_Nodes_CreateFinish
  INTERFACE cmfe_Nodes_CreateStart
    MODULE PROCEDURE cmfe_Nodes_CreateStartNumber
    MODULE PROCEDURE cmfe_Nodes_CreateStartObj
    MODULE PROCEDURE cmfe_Nodes_CreateStartInterfaceObj
  END INTERFACE cmfe_Nodes_CreateStart

  !>Destroys nodes.
  INTERFACE cmfe_Nodes_Destroy
    MODULE PROCEDURE cmfe_Nodes_DestroyNumber
    MODULE PROCEDURE cmfe_Nodes_DestroyObj
  END INTERFACE cmfe_Nodes_Destroy

  !>Returns the number of nodes
  INTERFACE cmfe_Nodes_NumberOfNodesGet
    MODULE PROCEDURE cmfe_Nodes_NumberOfNodesGetNumber
    MODULE PROCEDURE cmfe_Nodes_NumberOfNodesGetObj
  END INTERFACE cmfe_Nodes_NumberOfNodesGet

  !>Returns the label for a node identified by a given global number. \todo should this be a user number?
  INTERFACE cmfe_Nodes_LabelGet
    MODULE PROCEDURE cmfe_Nodes_LabelGetCNumber
    MODULE PROCEDURE cmfe_Nodes_LabelGetCObj
    MODULE PROCEDURE cmfe_Nodes_LabelGetVSNumber
    MODULE PROCEDURE cmfe_Nodes_LabelGetVSObj
  END INTERFACE cmfe_Nodes_LabelGet

  !>Sets/changes the label for a node identified by a given global number. \todo should this be a user number?
  INTERFACE cmfe_Nodes_LabelSet
    MODULE PROCEDURE cmfe_Nodes_LabelSetCNumber
    MODULE PROCEDURE cmfe_Nodes_LabelSetCObj
    MODULE PROCEDURE cmfe_Nodes_LabelSetVSNumber
    MODULE PROCEDURE cmfe_Nodes_LabelSetVSObj
  END INTERFACE cmfe_Nodes_LabelSet

  !>Returns the user number for a node identified by a given global number.
  INTERFACE cmfe_Nodes_UserNumberGet
    MODULE PROCEDURE cmfe_Nodes_UserNumberGetNumber
    MODULE PROCEDURE cmfe_Nodes_UserNumberGetObj
  END INTERFACE cmfe_Nodes_UserNumberGet

  !>Sets/changes the user number for a node identified by a given global number.
  INTERFACE cmfe_Nodes_UserNumberSet
    MODULE PROCEDURE cmfe_Nodes_UserNumberSetNumber
    MODULE PROCEDURE cmfe_Nodes_UserNumberSetObj
  END INTERFACE cmfe_Nodes_UserNumberSet
  
  !>Sets/changes the all user number for nodes.
  INTERFACE cmfe_Nodes_UserNumbersAllSet
    MODULE PROCEDURE cmfe_Nodes_UserNumbersAllSetNumber
    MODULE PROCEDURE cmfe_Nodes_UserNumbersAllSetObj
  END INTERFACE cmfe_Nodes_UserNumbersAllSet

  PUBLIC cmfe_Nodes_CreateFinish,cmfe_Nodes_CreateStart

  PUBLIC cmfe_Nodes_Destroy

  PUBLIC cmfe_Nodes_NumberOfNodesGet

  PUBLIC cmfe_Nodes_LabelGet,cmfe_Nodes_LabelSet

  PUBLIC cmfe_Nodes_UserNumberGet,cmfe_Nodes_UserNumberSet,cmfe_Nodes_UserNumbersAllSet

!!==================================================================================================================================
!!
!! PROBLEM_CONSTANTS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_ProblemConstants OPENCMISS::Problem::Constants
  !> \brief Problem constants.
  !>@{
  !> \addtogroup OPENCMISS_ProblemClasses OPENCMISS::Problem::Classes
  !> \brief Problem classes.
  !> \see OPENCMISS::Problem,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NO_CLASS = PROBLEM_NO_CLASS !<No problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_ELASTICITY_CLASS = PROBLEM_ELASTICITY_CLASS !<Elasticity problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FLUID_MECHANICS_CLASS = PROBLEM_FLUID_MECHANICS_CLASS !<Fluid mechanics problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_ELECTROMAGNETICS_CLASS = PROBLEM_ELECTROMAGNETICS_CLASS !<Electromagnetics problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_CLASSICAL_FIELD_CLASS = PROBLEM_CLASSICAL_FIELD_CLASS !<Classical field problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_BIOELECTRICS_CLASS = PROBLEM_BIOELECTRICS_CLASS !<Bioelectrics problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MODAL_CLASS = PROBLEM_MODAL_CLASS !<Modal problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FITTING_CLASS = PROBLEM_FITTING_CLASS !<Fitting problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_OPTIMISATION_CLASS = PROBLEM_OPTIMISATION_CLASS !<Optimisation problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MULTI_PHYSICS_CLASS = PROBLEM_MULTI_PHYSICS_CLASS !<Multi physics problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_ProblemTypes OPENCMISS::Problem::Types
  !> \brief Problem Types.
  !> \see OPENCMISS::Problem,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NO_TYPE = PROBLEM_NO_TYPE !<No problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_ELASTICITY_TYPE = PROBLEM_LINEAR_ELASTICITY_TYPE !<Linear elasticity problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_TYPE = PROBLEM_FINITE_ELASTICITY_TYPE !<Finite elasticity problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_ELASTICITY_CONTACT_TYPE = PROBLEM_LINEAR_ELASTICITY_CONTACT_TYPE !<Linear elasticity problem subject to contact contstraint type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_CONTACT_TYPE = PROBLEM_FINITE_ELASTICITY_CONTACT_TYPE !<Finite elasticity problem subject to contact constraint type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STOKES_EQUATION_TYPE = PROBLEM_STOKES_EQUATION_TYPE !<Stokes equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NAVIER_STOKES_EQUATION_TYPE = PROBLEM_NAVIER_STOKES_EQUATION_TYPE !<Navier-Stokes problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DARCY_EQUATION_TYPE = PROBLEM_DARCY_EQUATION_TYPE !<Darcy equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_POISEUILLE_EQUATION_TYPE = PROBLEM_POISEUILLE_EQUATION_TYPE !<Poiseuille equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_BURGERS_EQUATION_TYPE = PROBLEM_BURGERS_EQUATION_TYPE !<Burgers equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_ELECTROSTATIC_TYPE = PROBLEM_ELECTROSTATIC_TYPE !<Electrostatic problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MAGNETOSTATIC_TYPE = PROBLEM_MAGNETOSTATIC_TYPE !<Magnetostatic problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MAXWELLS_EQUATIONS_TYPE = PROBLEM_MAXWELLS_EQUATIONS_TYPE !<Maxwell's equations problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LAPLACE_EQUATION_TYPE = PROBLEM_LAPLACE_EQUATION_TYPE !<Laplace problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_POISSON_EQUATION_TYPE = PROBLEM_POISSON_EQUATION_TYPE !<Poisson problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_HELMHOLTZ_EQUATION_TYPE = PROBLEM_HELMHOLTZ_EQUATION_TYPE !<Helmholtz problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_WAVE_EQUATION_TYPE = PROBLEM_WAVE_EQUATION_TYPE !<Wave equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DIFFUSION_EQUATION_TYPE = PROBLEM_DIFFUSION_EQUATION_TYPE !<Diffusion equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_ADVECTION_DIFFUSION_EQUATION_TYPE = PROBLEM_ADVECTION_DIFFUSION_EQUATION_TYPE !<Advection-Diffusion equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_REACTION_DIFFUSION_EQUATION_TYPE = PROBLEM_REACTION_DIFFUSION_EQUATION_TYPE !<Reaction-Diffusion equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_BIHARMONIC_EQUATION_TYPE = PROBLEM_BIHARMONIC_EQUATION_TYPE !<Bi-harmonic equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MONODOMAIN_EQUATION_TYPE = PROBLEM_MONODOMAIN_EQUATION_TYPE !<Monodomain equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_BIDOMAIN_EQUATION_TYPE = PROBLEM_BIDOMAIN_EQUATION_TYPE !<Bidomain equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_ELASTIC_MODAL_TYPE = PROBLEM_LINEAR_ELASTIC_MODAL_TYPE !<Linear elastic modal problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DATA_FITTING_TYPE = PROBLEM_DATA_FITTING_TYPE !<Galerkin projection problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_DARCY_TYPE = PROBLEM_FINITE_ELASTICITY_DARCY_TYPE !<Finite Elasticity Darcy problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_STOKES_TYPE = PROBLEM_FINITE_ELASTICITY_STOKES_TYPE !<Finite Elasticity Stokes problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_TYPE = PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_TYPE !<Finite Elasticity NavierStokes problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DIFFUSION_DIFFUSION_TYPE = PROBLEM_DIFFUSION_DIFFUSION_TYPE !<Diffusion Diffusion problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DIFFUSION_ADVECTION_DIFFUSION_TYPE = PROBLEM_DIFFUSION_ADVECTION_DIFFUSION_TYPE !<Diffusion Advection Diffusion problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MULTI_COMPARTMENT_TRANSPORT_TYPE = PROBLEM_MULTI_COMPARTMENT_TRANSPORT_TYPE !<Multi-compartment transport problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_FLUID_PRESSURE_TYPE = PROBLEM_FINITE_ELASTICITY_FLUID_PRESSURE_TYPE !<Finite elasticity fluid pressure problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_BIOELECTRIC_FINITE_ELASTICITY_TYPE = PROBLEM_BIOELECTRIC_FINITE_ELASTICITY_TYPE !<Monodomain finite elasticity problem type \see OPENCMISS_ProblemTypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE = &
    & PROBLEM_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE !<Monodomain equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_ProblemSubtypes OPENCMISS::Problem::Subtypes
  !> \brief Problem Subtypes.
  !> \see OPENCMISS::Problem,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NO_SUBTYPE = PROBLEM_NO_SUBTYPE !<No problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STATIC_STOKES_SUBTYPE = PROBLEM_STATIC_STOKES_SUBTYPE !<Static Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LAPLACE_STOKES_SUBTYPE = PROBLEM_LAPLACE_STOKES_SUBTYPE !<Laplace type Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_TRANSIENT_STOKES_SUBTYPE = PROBLEM_TRANSIENT_STOKES_SUBTYPE !<Transient Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_ALE_STOKES_SUBTYPE = PROBLEM_ALE_STOKES_SUBTYPE !<ALE Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_PGM_STOKES_SUBTYPE = PROBLEM_PGM_STOKES_SUBTYPE !<PGM Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_OPTIMISED_STOKES_SUBTYPE = PROBLEM_OPTIMISED_STOKES_SUBTYPE !<Optimised Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STATIC_NAVIER_STOKES_SUBTYPE = PROBLEM_STATIC_NAVIER_STOKES_SUBTYPE !<Static Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LAPLACE_NAVIER_STOKES_SUBTYPE = PROBLEM_LAPLACE_NAVIER_STOKES_SUBTYPE !<Laplace type Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_TRANSIENT_NAVIER_STOKES_SUBTYPE = PROBLEM_TRANSIENT_NAVIER_STOKES_SUBTYPE !<Transient Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE = PROBLEM_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE !<Transient stabilised Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MULTISCALE_NAVIER_STOKES_SUBTYPE = &
    & PROBLEM_MULTISCALE_NAVIER_STOKES_SUBTYPE !<Transient stabilised Navier-Stokes problem with multiscale boundary coupling subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_TRANSIENT1D_NAVIER_STOKES_SUBTYPE = PROBLEM_TRANSIENT1D_NAVIER_STOKES_SUBTYPE !<TRANSIENT1D Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_COUPLED1D0D_NAVIER_STOKES_SUBTYPE = PROBLEM_COUPLED1D0D_NAVIER_STOKES_SUBTYPE !<Coupled 1D-DAE Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE = PROBLEM_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE !<TRANSIENT1D Navier-Stokes problem subtype with Advection \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE = PROBLEM_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE !<Coupled 1D-DAE Navier-Stokes problem subtype with Advection \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STREE1D0D_SUBTYPE = PROBLEM_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE !<Coupled 1D-DAE Navier-Stokes problem subtype with Advection \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STREE1D0D_ADV_SUBTYPE = PROBLEM_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE !<Coupled 1D-DAE Navier-Stokes problem subtype with Advection \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_ALE_NAVIER_STOKES_SUBTYPE = PROBLEM_ALE_NAVIER_STOKES_SUBTYPE !<ALE Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_PGM_NAVIER_STOKES_SUBTYPE = PROBLEM_PGM_NAVIER_STOKES_SUBTYPE !<PGM Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_OPTIMISED_NAVIER_STOKES_SUBTYPE = PROBLEM_OPTIMISED_NAVIER_STOKES_SUBTYPE !<Optimised Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STANDARD_DARCY_SUBTYPE = PROBLEM_STANDARD_DARCY_SUBTYPE !<Standard Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_QUASISTATIC_DARCY_SUBTYPE = PROBLEM_QUASISTATIC_DARCY_SUBTYPE !<Quasistatic Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_ALE_DARCY_SUBTYPE = PROBLEM_ALE_DARCY_SUBTYPE !<ALE Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_TRANSIENT_DARCY_SUBTYPE = PROBLEM_TRANSIENT_DARCY_SUBTYPE !<Transient Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_PGM_DARCY_SUBTYPE = PROBLEM_PGM_DARCY_SUBTYPE !<PGM Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_PGM_TRANSIENT_DARCY_SUBTYPE = PROBLEM_PGM_TRANSIENT_DARCY_SUBTYPE !<PGM Transient Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STANDARD_LAPLACE_SUBTYPE = PROBLEM_STANDARD_LAPLACE_SUBTYPE !<Standard Laplace problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_GENERALISED_LAPLACE_SUBTYPE = PROBLEM_GENERALISED_LAPLACE_SUBTYPE !<Generalised Laplace problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STATIC_POISEUILLE_SUBTYPE = PROBLEM_STATIC_POISEUILLE_SUBTYPE !<Static Poiseuille problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DYNAMIC_POISEUILLE_SUBTYPE = PROBLEM_DYNAMIC_POISEUILLE_SUBTYPE !<Static Poiseuille problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE = PROBLEM_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE !<Linear source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_SOURCE_POISSON_SUBTYPE = PROBLEM_LINEAR_SOURCE_POISSON_SUBTYPE !<Linear source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_PRESSURE_POISSON_SUBTYPE = PROBLEM_LINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NONLINEAR_PRESSURE_POISSON_SUBTYPE = PROBLEM_NONLINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_ALE_PRESSURE_POISSON_SUBTYPE = PROBLEM_ALE_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FITTED_PRESSURE_POISSON_SUBTYPE = PROBLEM_FITTED_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NONLINEAR_SOURCE_POISSON_SUBTYPE = PROBLEM_NONLINEAR_SOURCE_POISSON_SUBTYPE !<Nonlinear source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STANDARD_HELMHOLTZ_SUBTYPE = PROBLEM_STANDARD_HELMHOLTZ_SUBTYPE !<No source Helmholtz problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_GENERALISED_HELMHOLTZ_SUBTYPE = PROBLEM_GENERALISED_HELMHOLTZ_SUBTYPE !<No source Helmholtz problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NO_SOURCE_DIFFUSION_SUBTYPE = PROBLEM_NO_SOURCE_DIFFUSION_SUBTYPE !<No source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_SOURCE_DIFFUSION_SUBTYPE = PROBLEM_LINEAR_SOURCE_DIFFUSION_SUBTYPE !<Linear source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NONLINEAR_SOURCE_DIFFUSION_SUBTYPE = PROBLEM_NONLINEAR_SOURCE_DIFFUSION_SUBTYPE !<Nonlinear source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NO_SOURCE_ALE_DIFFUSION_SUBTYPE = PROBLEM_NO_SOURCE_ALE_DIFFUSION_SUBTYPE !<No source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE = PROBLEM_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE !<Linear source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NONLINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & PROBLEM_NONLINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE !<Nonlinear source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<No source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Linear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NONLINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_NONLINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Nonlinear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<No source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_LINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Linear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NONLINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_NONLINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Nonlinear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = PROBLEM_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<No source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & PROBLEM_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Linear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_NONLINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & PROBLEM_NONLINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Nonlinear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STATIC_BURGERS_SUBTYPE = PROBLEM_STATIC_BURGERS_SUBTYPE !<static Burgers problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DYNAMIC_BURGERS_SUBTYPE = PROBLEM_DYNAMIC_BURGERS_SUBTYPE !<dynamic Burgers problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_CELLML_REAC_INTEG_REAC_DIFF_STRANG_SPLIT_SUBTYPE = &
    & PROBLEM_CELLML_REAC_INTEG_REAC_DIFF_STRANG_SPLIT_SUBTYPE !CellML reaction integrated strang-split subtype of reaction diffusion \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_CELLML_REAC_EVAL_REAC_DIFF_NO_SPLIT_SUBTYPE = &
    & PROBLEM_CELLML_REAC_EVAL_REAC_DIFF_NO_SPLIT_SUBTYPE !CellML reaction evaluated no-split subtype of reaction diffusion \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_CONSTANT_REAC_DIFF_NO_SPLIT_SUBTYPE = &
    & PROBLEM_CONSTANT_REAC_DIFF_NO_SPLIT_SUBTYPE !Standard constant reaction reaction diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STANDARD_DATA_FITTING_SUBTYPE = &
    & PROBLEM_STANDARD_DATA_FITTING_SUBTYPE !<Standard Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_VECTOR_DATA_FITTING_SUBTYPE = &
    & PROBLEM_VECTOR_DATA_FITTING_SUBTYPE !<Standard Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DIV_FREE_VECTOR_DATA_FITTING_SUBTYPE = &
    & PROBLEM_DIV_FREE_VECTOR_DATA_FITTING_SUBTYPE !<Standard Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DATA_POINT_VECTOR_STATIC_FITTING_SUBTYPE = &
    & Problem_DataPointVectorStaticFittingSubtype !<Standard static Galerkin projection problem using data points subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DATA_PT_VECTOR_QUASISTATIC_FITTING_SUBTYPE = &
    & Problem_DataPointVectorQuasistaticFittingSubtype !<Standard quasistatic Galerkin projection problem using data points subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_VECTOR_DATA_PRE_FITTING_SUBTYPE = &
    & PROBLEM_VECTOR_DATA_PRE_FITTING_SUBTYPE !<Standard Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_DIV_FREE_VECTOR_DATA_PRE_FITTING_SUBTYPE = &
    & PROBLEM_DIV_FREE_VECTOR_DATA_PRE_FITTING_SUBTYPE !<Standard Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_GENERALISED_DATA_FITTING_SUBTYPE = &
    & PROBLEM_GENERALISED_DATA_FITTING_SUBTYPE !<Generalised Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MAT_PROPERTIES_DATA_FITTING_SUBTYPE = &
    & PROBLEM_MAT_PROPERTIES_DATA_FITTING_SUBTYPE !<Material Properties Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE = PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE !<Standard Elasticity Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_PGM_ELASTICITY_DARCY_SUBTYPE = PROBLEM_PGM_ELASTICITY_DARCY_SUBTYPE !<PGM Elasticity Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE = &
    & PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE !<Quasistatic Elasticity Transient Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE = &
    & PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE !<Quasistatic Elasticity Transient Darcy Material Solve problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE = &
    & PROBLEM_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE !<Coupled source diffusion-diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE = &
    & PROBLEM_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE !<Coupled source diffusion & advection-diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STANDARD_MULTI_COMPARTMENT_TRANSPORT_SUBTYPE = &
    & PROBLEM_STANDARD_MULTI_COMPARTMENT_TRANSPORT_SUBTYPE !<Standard multi-compartment transport problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE = &
    & PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE !<Standard elasticity fluid pressure problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_GUDUNOV_MONODOMAIN_SIMPLE_ELASTICITY_SUBTYPE = &
    & PROBLEM_GUDUNOV_MONODOMAIN_SIMPLE_ELASTICITY_SUBTYPE !<Transient monodomain simple elasticity problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_GUDUNOV_MONODOMAIN_1D3D_ELASTICITY_SUBTYPE = & 
    & PROBLEM_GUDUNOV_MONODOMAIN_1D3D_ELASTICITY_SUBTYPE !<Transient monodomain simple elasticity problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE = & 
    & PROBLEM_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE !<Transient monodomain simple elasticity problem subtype with titin \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE = & 
    & PROBLEM_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE !<Transient monodomain simple elasticity problem subtype with force-velocity relation \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE = &
    & PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE !<Coupled Finite Elasticity Navier Stokes moving mesh subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE = PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE !<Quasistatic finite elasticity subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_CELLML_SUBTYPE = PROBLEM_FINITE_ELASTICITY_CELLML_SUBTYPE !<Quasistatic finite elasticity subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE =  &
    & PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE !<Quasistatic finite elasticity subtype \see OPENCMISS_QProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MONODOMAIN_GUDUNOV_SPLIT_SUBTYPE = PROBLEM_MONODOMAIN_GUDUNOV_SPLIT_SUBTYPE !<Monodomain Gudunov split problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MONODOMAIN_STRANG_SPLIT_SUBTYPE = PROBLEM_MONODOMAIN_STRANG_SPLIT_SUBTYPE !<Monodomain Gudunov split problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_BIDOMAIN_GUDUNOV_SPLIT_SUBTYPE = PROBLEM_BIDOMAIN_GUDUNOV_SPLIT_SUBTYPE !<Bidomain Gudunov split problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_BIDOMAIN_STRANG_SPLIT_SUBTYPE = PROBLEM_BIDOMAIN_STRANG_SPLIT_SUBTYPE !<Bidomain Gudunov split problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MONODOMAIN_BUENOOROVIO_SUBTYPE = PROBLEM_MONODOMAIN_BUENOOROVIO_SUBTYPE !<Generalised Laplace problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_MONODOMAIN_TENTUSSCHER06_SUBTYPE = PROBLEM_MONODOMAIN_TENTUSSCHER06_SUBTYPE !<Generalised Laplace problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE=PROBLEM_LE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE !<linear elasticity problem subject to contact constraint, transform field at load increments and reproject at Newton iterations \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LE_CONTACT_TRANSFORM_SUBTYPE=PROBLEM_LE_CONTACT_TRANSFORM_SUBTYPE !<linear elasticity problem subject to contact constraint, transform field at load increments \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_LE_CONTACT_REPROJECT_SUBTYPE=PROBLEM_LE_CONTACT_REPROJECT_SUBTYPE !<linear elasticity problem subject to contact constraint, reproject at Newton iterations \see OPENCMISS_ProblemSubtypes,OPENCMISS
    
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE=PROBLEM_FE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE !<linear elasticity problem subject to contact constraint, transform field at load increments and reproject at Newton iterations \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FE_CONTACT_TRANSFORM_SUBTYPE=PROBLEM_FE_CONTACT_TRANSFORM_SUBTYPE !<finear elasticity problem subject to contact constraint, transform field at load increments \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_FE_CONTACT_REPROJECT_SUBTYPE=PROBLEM_FE_CONTACT_REPROJECT_SUBTYPE !<finear elasticity problem subject to contact constraint, reproject at Newton iterations \see OPENCMISS_ProblemSubtypes,OPENCMISS

  !>@}
  !> \addtogroup OPENCMISS_ProblemControlLoopTypes OPENCMISS::Problem::ControlLoopTypes
  !> \brief Problem control loop type parameters
  !> \see OPENCMISS::Problem,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_CONTROL_SIMPLE_TYPE = PROBLEM_CONTROL_SIMPLE_TYPE !<Simple, one iteration control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_CONTROL_FIXED_LOOP_TYPE = PROBLEM_CONTROL_FIXED_LOOP_TYPE !<Fixed iteration control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_CONTROL_TIME_LOOP_TYPE = PROBLEM_CONTROL_TIME_LOOP_TYPE !<Time control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_CONTROL_WHILE_LOOP_TYPE = PROBLEM_CONTROL_WHILE_LOOP_TYPE !<While control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_PROBLEM_CONTROL_LOAD_INCREMENT_LOOP_TYPE = PROBLEM_CONTROL_LOAD_INCREMENT_LOOP_TYPE !<Load increment control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMFE_PROBLEM_NO_CLASS,CMFE_PROBLEM_ELASTICITY_CLASS,CMFE_PROBLEM_FLUID_MECHANICS_CLASS, &
    & CMFE_PROBLEM_ELECTROMAGNETICS_CLASS, &
    & CMFE_PROBLEM_CLASSICAL_FIELD_CLASS,CMFE_PROBLEM_BIOELECTRICS_CLASS,CMFE_PROBLEM_MODAL_CLASS,CMFE_PROBLEM_FITTING_CLASS, &
    & CMFE_PROBLEM_OPTIMISATION_CLASS,CMFE_PROBLEM_MULTI_PHYSICS_CLASS

  PUBLIC CMFE_PROBLEM_NO_TYPE

  PUBLIC CMFE_PROBLEM_LINEAR_ELASTICITY_TYPE,CMFE_PROBLEM_FINITE_ELASTICITY_TYPE
  
  PUBLIC CMFE_PROBLEM_LINEAR_ELASTICITY_CONTACT_TYPE, CMFE_PROBLEM_FINITE_ELASTICITY_CONTACT_TYPE

  PUBLIC CMFE_PROBLEM_STOKES_EQUATION_TYPE,CMFE_PROBLEM_NAVIER_STOKES_EQUATION_TYPE,CMFE_PROBLEM_DARCY_EQUATION_TYPE, &
    & CMFE_PROBLEM_POISEUILLE_EQUATION_TYPE,CMFE_PROBLEM_BURGERS_EQUATION_TYPE

  PUBLIC CMFE_PROBLEM_ELECTROSTATIC_TYPE,CMFE_PROBLEM_MAGNETOSTATIC_TYPE,CMFE_PROBLEM_MAXWELLS_EQUATIONS_TYPE

  PUBLIC CMFE_PROBLEM_LAPLACE_EQUATION_TYPE,CMFE_PROBLEM_POISSON_EQUATION_TYPE,CMFE_PROBLEM_HELMHOLTZ_EQUATION_TYPE, &
    & CMFE_PROBLEM_WAVE_EQUATION_TYPE,CMFE_PROBLEM_DIFFUSION_EQUATION_TYPE,CMFE_PROBLEM_ADVECTION_DIFFUSION_EQUATION_TYPE, &
    & CMFE_PROBLEM_REACTION_DIFFUSION_EQUATION_TYPE,CMFE_PROBLEM_BIHARMONIC_EQUATION_TYPE

  PUBLIC CMFE_PROBLEM_MONODOMAIN_EQUATION_TYPE,CMFE_PROBLEM_BIDOMAIN_EQUATION_TYPE

  PUBLIC CMFE_PROBLEM_LINEAR_ELASTIC_MODAL_TYPE

  PUBLIC CMFE_PROBLEM_DATA_FITTING_TYPE

  PUBLIC CMFE_PROBLEM_FINITE_ELASTICITY_DARCY_TYPE, &
    & CMFE_PROBLEM_FINITE_ELASTICITY_STOKES_TYPE, CMFE_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_TYPE, &
    & CMFE_PROBLEM_DIFFUSION_DIFFUSION_TYPE, CMFE_PROBLEM_DIFFUSION_ADVECTION_DIFFUSION_TYPE, &
    & CMFE_PROBLEM_MULTI_COMPARTMENT_TRANSPORT_TYPE,CMFE_PROBLEM_FINITE_ELASTICITY_FLUID_PRESSURE_TYPE, &
    & CMFE_PROBLEM_BIOELECTRIC_FINITE_ELASTICITY_TYPE

  PUBLIC CMFE_PROBLEM_NO_SUBTYPE
  
  PUBLIC CMFE_PROBLEM_LE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE, CMFE_PROBLEM_LE_CONTACT_TRANSFORM_SUBTYPE, &
    & CMFE_PROBLEM_LE_CONTACT_REPROJECT_SUBTYPE
    
  PUBLIC CMFE_PROBLEM_FE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE, CMFE_PROBLEM_FE_CONTACT_TRANSFORM_SUBTYPE, &
    & CMFE_PROBLEM_FE_CONTACT_REPROJECT_SUBTYPE

  PUBLIC CMFE_PROBLEM_STATIC_STOKES_SUBTYPE,CMFE_PROBLEM_LAPLACE_STOKES_SUBTYPE,CMFE_PROBLEM_TRANSIENT_STOKES_SUBTYPE, &
    & CMFE_PROBLEM_OPTIMISED_STOKES_SUBTYPE,CMFE_PROBLEM_ALE_STOKES_SUBTYPE,CMFE_PROBLEM_PGM_STOKES_SUBTYPE

  PUBLIC CMFE_PROBLEM_STATIC_NAVIER_STOKES_SUBTYPE,CMFE_PROBLEM_LAPLACE_NAVIER_STOKES_SUBTYPE, &
    & CMFE_PROBLEM_TRANSIENT_NAVIER_STOKES_SUBTYPE,CMFE_PROBLEM_TRANSIENT_RBS_NAVIER_STOKES_SUBTYPE, &
    & CMFE_PROBLEM_PGM_NAVIER_STOKES_SUBTYPE,CMFE_PROBLEM_OPTIMISED_NAVIER_STOKES_SUBTYPE, &
    & CMFE_PROBLEM_TRANSIENT1D_NAVIER_STOKES_SUBTYPE,CMFE_PROBLEM_COUPLED1D0D_NAVIER_STOKES_SUBTYPE, &
    & CMFE_PROBLEM_TRANSIENT1D_ADV_NAVIER_STOKES_SUBTYPE,CMFE_PROBLEM_COUPLED1D0D_ADV_NAVIER_STOKES_SUBTYPE, &
    & CMFE_PROBLEM_STREE1D0D_ADV_SUBTYPE,CMFE_PROBLEM_STREE1D0D_SUBTYPE, &
    & CMFE_PROBLEM_ALE_NAVIER_STOKES_SUBTYPE,CMFE_PROBLEM_MULTISCALE_NAVIER_STOKES_SUBTYPE

  PUBLIC CMFE_PROBLEM_STANDARD_DARCY_SUBTYPE,CMFE_PROBLEM_QUASISTATIC_DARCY_SUBTYPE,CMFE_PROBLEM_ALE_DARCY_SUBTYPE, &
    & CMFE_PROBLEM_TRANSIENT_DARCY_SUBTYPE,CMFE_PROBLEM_PGM_DARCY_SUBTYPE,CMFE_PROBLEM_PGM_TRANSIENT_DARCY_SUBTYPE

  PUBLIC CMFE_PROBLEM_STATIC_POISEUILLE_SUBTYPE,CMFE_PROBLEM_DYNAMIC_POISEUILLE_SUBTYPE

  PUBLIC CMFE_PROBLEM_STATIC_BURGERS_SUBTYPE,CMFE_PROBLEM_DYNAMIC_BURGERS_SUBTYPE

  PUBLIC CMFE_PROBLEM_STANDARD_LAPLACE_SUBTYPE,CMFE_PROBLEM_GENERALISED_LAPLACE_SUBTYPE, &
    & CMFE_PROBLEM_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE

  PUBLIC CMFE_PROBLEM_LINEAR_SOURCE_POISSON_SUBTYPE,CMFE_PROBLEM_NONLINEAR_SOURCE_POISSON_SUBTYPE, &
    & CMFE_PROBLEM_LINEAR_PRESSURE_POISSON_SUBTYPE,CMFE_PROBLEM_NONLINEAR_PRESSURE_POISSON_SUBTYPE, &
    & CMFE_PROBLEM_ALE_PRESSURE_POISSON_SUBTYPE, CMFE_PROBLEM_FITTED_PRESSURE_POISSON_SUBTYPE, &
    & CMFE_PROBLEM_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE

  PUBLIC CMFE_PROBLEM_STANDARD_HELMHOLTZ_SUBTYPE,CMFE_PROBLEM_GENERALISED_HELMHOLTZ_SUBTYPE

  PUBLIC CMFE_PROBLEM_NO_SOURCE_DIFFUSION_SUBTYPE,CMFE_PROBLEM_LINEAR_SOURCE_DIFFUSION_SUBTYPE, &
    & CMFE_PROBLEM_NONLINEAR_SOURCE_DIFFUSION_SUBTYPE

  PUBLIC CMFE_PROBLEM_NO_SOURCE_ALE_DIFFUSION_SUBTYPE,CMFE_PROBLEM_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE, &
    & CMFE_PROBLEM_NONLINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE

  PUBLIC CMFE_PROBLEM_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE,CMFE_PROBLEM_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMFE_PROBLEM_NONLINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE

  PUBLIC CMFE_PROBLEM_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE,CMFE_PROBLEM_LINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMFE_PROBLEM_NONLINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE

  PUBLIC CMFE_PROBLEM_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE,CMFE_PROBLEM_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE, &
    & CMFE_PROBLEM_NONLINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE

  PUBLIC CMFE_PROBLEM_CELLML_REAC_INTEG_REAC_DIFF_STRANG_SPLIT_SUBTYPE, &
    & CMFE_PROBLEM_CELLML_REAC_EVAL_REAC_DIFF_NO_SPLIT_SUBTYPE, &
    & CMFE_PROBLEM_CONSTANT_REAC_DIFF_NO_SPLIT_SUBTYPE


  PUBLIC CMFE_PROBLEM_STANDARD_DATA_FITTING_SUBTYPE,CMFE_PROBLEM_GENERALISED_DATA_FITTING_SUBTYPE, &
    & CMFE_PROBLEM_VECTOR_DATA_FITTING_SUBTYPE,CMFE_PROBLEM_DIV_FREE_VECTOR_DATA_FITTING_SUBTYPE, &
    & CMFE_PROBLEM_VECTOR_DATA_PRE_FITTING_SUBTYPE,CMFE_PROBLEM_DIV_FREE_VECTOR_DATA_PRE_FITTING_SUBTYPE, &
    & CMFE_PROBLEM_MAT_PROPERTIES_DATA_FITTING_SUBTYPE,CMFE_PROBLEM_DATA_POINT_VECTOR_STATIC_FITTING_SUBTYPE, &
    & CMFE_PROBLEM_DATA_PT_VECTOR_QUASISTATIC_FITTING_SUBTYPE

  PUBLIC CMFE_PROBLEM_MONODOMAIN_GUDUNOV_SPLIT_SUBTYPE,CMFE_PROBLEM_MONODOMAIN_STRANG_SPLIT_SUBTYPE, &
    & CMFE_PROBLEM_BIDOMAIN_GUDUNOV_SPLIT_SUBTYPE,CMFE_PROBLEM_BIDOMAIN_STRANG_SPLIT_SUBTYPE

  PUBLIC CMFE_PROBLEM_MONODOMAIN_BUENOOROVIO_SUBTYPE, CMFE_PROBLEM_MONODOMAIN_TENTUSSCHER06_SUBTYPE

  PUBLIC CMFE_PROBLEM_CONTROL_SIMPLE_TYPE,CMFE_PROBLEM_CONTROL_FIXED_LOOP_TYPE,CMFE_PROBLEM_CONTROL_TIME_LOOP_TYPE, &
    & CMFE_PROBLEM_CONTROL_WHILE_LOOP_TYPE,CMFE_PROBLEM_CONTROL_LOAD_INCREMENT_LOOP_TYPE

  PUBLIC CMFE_PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE, CMFE_PROBLEM_PGM_ELASTICITY_DARCY_SUBTYPE, &
   & CMFE_PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE,CMFE_PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE, &
   & CMFE_PROBLEM_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE, CMFE_PROBLEM_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE, &
   & CMFE_PROBLEM_STANDARD_MULTI_COMPARTMENT_TRANSPORT_SUBTYPE,CMFE_PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE, &
   & CMFE_PROBLEM_GUDUNOV_MONODOMAIN_SIMPLE_ELASTICITY_SUBTYPE,CMFE_PROBLEM_GUDUNOV_MONODOMAIN_1D3D_ELASTICITY_SUBTYPE, &
   & CMFE_PROBLEM_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE,CMFE_PROBLEM_MONODOMAIN_ELASTICITY_VELOCITY_SUBTYPE, &
   & CMFE_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE

  PUBLIC CMFE_PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE,CMFE_PROBLEM_FINITE_ELASTICITY_CELLML_SUBTYPE, &
    & CMFE_PROBLEM_FINITE_ELASTICITY_WITH_GROWTH_CELLML_SUBTYPE
  
!!==================================================================================================================================
!!
!! PROBLEM_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finish the creation of CellML equations for a problem. \see OpenCMISS::Iron::cmfe_Problem_CellMLEquationsCreateStart
  INTERFACE cmfe_Problem_CellMLEquationsCreateFinish
    MODULE PROCEDURE cmfe_Problem_CellMLEquationsCreateFinishNumber
    MODULE PROCEDURE cmfe_Problem_CellMLEquationsCreateFinishObj
  END INTERFACE cmfe_Problem_CellMLEquationsCreateFinish

  !>Start the creation of solver equations for a problem. \see OpenCMISS::Iron::cmfe_Problem_CellMLEquationsCreateFinish
  INTERFACE cmfe_Problem_CellMLEquationsCreateStart
    MODULE PROCEDURE cmfe_Problem_CellMLEquationsCreateStartNumber
    MODULE PROCEDURE cmfe_Problem_CellMLEquationsCreateStartObj
  END INTERFACE cmfe_Problem_CellMLEquationsCreateStart

  !>Returns the CellML equations for a problem.
  INTERFACE cmfe_Problem_CellMLEquationsGet
    MODULE PROCEDURE cmfe_Problem_CellMLEquationsGetNumber0
    MODULE PROCEDURE cmfe_Problem_CellMLEquationsGetNumber1
    MODULE PROCEDURE cmfe_Problem_CellMLEquationsGetObj0
    MODULE PROCEDURE cmfe_Problem_CellMLEquationsGetObj1
  END INTERFACE cmfe_Problem_CellMLEquationsGet

  !>Finishes the process of creating a problem. \see OpenCMISS::Iron::cmfe_Problem_CreateStart
  INTERFACE cmfe_Problem_CreateFinish
    MODULE PROCEDURE cmfe_Problem_CreateFinishNumber
    MODULE PROCEDURE cmfe_Problem_CreateFinishObj
  END INTERFACE cmfe_Problem_CreateFinish

  !>Start the process of creating a problem. \see OpenCMISS::Iron::cmfe_Problem_CreateFinish
  INTERFACE cmfe_Problem_CreateStart
    MODULE PROCEDURE cmfe_Problem_CreateStartNumber
    MODULE PROCEDURE cmfe_Problem_CreateStartObj
  END INTERFACE cmfe_Problem_CreateStart

  !>Finishes the process of creating a control loop on a problem. \see OpenCMISS::Iron::cmfe_Problem_ControlLoopCreateStart
  INTERFACE cmfe_Problem_ControlLoopCreateFinish
    MODULE PROCEDURE cmfe_Problem_ControlLoopCreateFinishNumber
    MODULE PROCEDURE cmfe_Problem_ControlLoopCreateFinishObj
  END INTERFACE cmfe_Problem_ControlLoopCreateFinish

  !>Starts the process of creating a control loop on a problem. \see OpenCMISS::Iron::cmfe_Problem_ControlLoopCreateFinish
  INTERFACE cmfe_Problem_ControlLoopCreateStart
    MODULE PROCEDURE cmfe_Problem_ControlLoopCreateStartNumber
    MODULE PROCEDURE cmfe_Problem_ControlLoopCreateStartObj
  END INTERFACE cmfe_Problem_ControlLoopCreateStart

  !>Destroys the control loop for a problem.
  INTERFACE cmfe_Problem_ControlLoopDestroy
    MODULE PROCEDURE cmfe_Problem_ControlLoopDestroyNumber
    MODULE PROCEDURE cmfe_Problem_ControlLoopDestroyObj
  END INTERFACE cmfe_Problem_ControlLoopDestroy

  !>Returns a control loop for a problem.
  INTERFACE cmfe_Problem_ControlLoopGet
    MODULE PROCEDURE cmfe_Problem_ControlLoopGetNumber0
    MODULE PROCEDURE cmfe_Problem_ControlLoopGetNumber1
    MODULE PROCEDURE cmfe_Problem_ControlLoopGetObj0
    MODULE PROCEDURE cmfe_Problem_ControlLoopGetObj1
  END INTERFACE cmfe_Problem_ControlLoopGet

  !>Destroys a problem.
  INTERFACE cmfe_Problem_Destroy
    MODULE PROCEDURE cmfe_Problem_DestroyNumber
    MODULE PROCEDURE cmfe_Problem_DestroyObj
  END INTERFACE cmfe_Problem_Destroy

  !>Solve a problem.
  INTERFACE cmfe_Problem_Solve
    MODULE PROCEDURE cmfe_Problem_SolveNumber
    MODULE PROCEDURE cmfe_Problem_SolveObj
  END INTERFACE cmfe_Problem_Solve

  !>Returns the solver for a problem control loop.
  INTERFACE cmfe_Problem_SolverGet
    MODULE PROCEDURE cmfe_Problem_SolverGetNumber0
    MODULE PROCEDURE cmfe_Problem_SolverGetNumber1
    MODULE PROCEDURE cmfe_Problem_SolverGetObj0
    MODULE PROCEDURE cmfe_Problem_SolverGetObj1
  END INTERFACE cmfe_Problem_SolverGet

  !>Set boundary conditions for solver equations according to the analytic equations.
  INTERFACE cmfe_SolverEquations_BoundaryConditionsAnalytic
    MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsAnalyticNumber0
    MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsAnalyticNumber1
    MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsAnalyticObj
  END INTERFACE cmfe_SolverEquations_BoundaryConditionsAnalytic

  !>Finish the creation of solver equations for a problem. \see OpenCMISS::Iron::cmfe_Problem_SolverEquationsCreateStart
  INTERFACE cmfe_Problem_SolverEquationsCreateFinish
    MODULE PROCEDURE cmfe_Problem_SolverEquationsCreateFinishNumber
    MODULE PROCEDURE cmfe_Problem_SolverEquationsCreateFinishObj
  END INTERFACE cmfe_Problem_SolverEquationsCreateFinish

  !>Start the creation of solver equations for a problem. \see OpenCMISS::Iron::cmfe_Problem_SolverEquationsCreateFinish
  INTERFACE cmfe_Problem_SolverEquationsCreateStart
    MODULE PROCEDURE cmfe_Problem_SolverEquationsCreateStartNumber
    MODULE PROCEDURE cmfe_Problem_SolverEquationsCreateStartObj
  END INTERFACE cmfe_Problem_SolverEquationsCreateStart

  !>Destroys the solver equations for a problem.
  INTERFACE cmfe_Problem_SolverEquationsDestroy
    MODULE PROCEDURE cmfe_Problem_SolverEquationsDestroyNumber
    MODULE PROCEDURE cmfe_Problem_SolverEquationsDestroyObj
  END INTERFACE cmfe_Problem_SolverEquationsDestroy

  !>Returns the solver equations for a problem.
  INTERFACE cmfe_Problem_SolverEquationsGet
    MODULE PROCEDURE cmfe_Problem_SolverEquationsGetNumber0
    MODULE PROCEDURE cmfe_Problem_SolverEquationsGetNumber1
    MODULE PROCEDURE cmfe_Problem_SolverEquationsGetObj0
    MODULE PROCEDURE cmfe_Problem_SolverEquationsGetObj1
  END INTERFACE cmfe_Problem_SolverEquationsGet

  !>Finish the creation of solvers for a problem. \see OpenCMISS::Iron::cmfe_Problem_SolversCreateStart
  INTERFACE cmfe_Problem_SolversCreateFinish
    MODULE PROCEDURE cmfe_Problem_SolversCreateFinishNumber
    MODULE PROCEDURE cmfe_Problem_SolversCreateFinishObj
  END INTERFACE cmfe_Problem_SolversCreateFinish

  !>Start the creation of solvers for a problem. \see OpenCMISS::Iron::cmfe_Problem_SolversCreateFinish
  INTERFACE cmfe_Problem_SolversCreateStart
    MODULE PROCEDURE cmfe_Problem_SolversCreateStartNumber
    MODULE PROCEDURE cmfe_Problem_SolversCreateStartObj
  END INTERFACE cmfe_Problem_SolversCreateStart

  !>Destroy the solvers for a problem.
  INTERFACE cmfe_Problem_SolversDestroy
    MODULE PROCEDURE cmfe_Problem_SolversDestroyNumber
    MODULE PROCEDURE cmfe_Problem_SolversDestroyObj
  END INTERFACE cmfe_Problem_SolversDestroy

  !>Returns the problem specification array for a problem.
  INTERFACE cmfe_Problem_SpecificationGet
    MODULE PROCEDURE cmfe_Problem_SpecificationGetNumber
    MODULE PROCEDURE cmfe_Problem_SpecificationGetObj
  END INTERFACE cmfe_Problem_SpecificationGet

  !>Returns the size of the problem specification array for a problem.
  INTERFACE cmfe_Problem_SpecificationSizeGet
    MODULE PROCEDURE cmfe_Problem_SpecificationSizeGetNumber
    MODULE PROCEDURE cmfe_Problem_SpecificationSizeGetObj
  END INTERFACE cmfe_Problem_SpecificationSizeGet 

  PUBLIC cmfe_Problem_CellMLEquationsCreateFinish,cmfe_Problem_CellMLEquationsCreateStart

  PUBLIC cmfe_Problem_CellMLEquationsGet

  PUBLIC cmfe_Problem_CreateFinish,cmfe_Problem_CreateStart

  PUBLIC cmfe_Problem_ControlLoopCreateFinish,cmfe_Problem_ControlLoopCreateStart

  PUBLIC cmfe_Problem_ControlLoopDestroy

  PUBLIC cmfe_Problem_ControlLoopGet

  PUBLIC cmfe_Problem_Destroy

  PUBLIC cmfe_Problem_Solve

  PUBLIC cmfe_Problem_SolverGet

  PUBLIC cmfe_SolverEquations_BoundaryConditionsAnalytic

  PUBLIC cmfe_Problem_SolverEquationsCreateFinish,cmfe_Problem_SolverEquationsCreateStart

  PUBLIC cmfe_Problem_SolverEquationsDestroy

  PUBLIC cmfe_Problem_SolverEquationsGet

  PUBLIC cmfe_Problem_SolversCreateFinish,cmfe_Problem_SolversCreateStart

  PUBLIC cmfe_Problem_SolversDestroy

  PUBLIC cmfe_Problem_SpecificationGet,cmfe_Problem_SpecificationSizeGet

!!==================================================================================================================================
!!
!! REGION_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Returns the coordinate system of region.
  INTERFACE cmfe_Region_CoordinateSystemGet
    MODULE PROCEDURE cmfe_Region_CoordinateSystemGetNumber
    MODULE PROCEDURE cmfe_Region_CoordinateSystemGetObj
  END INTERFACE cmfe_Region_CoordinateSystemGet

  !>Sets/changes the coordinate system of region.
  INTERFACE cmfe_Region_CoordinateSystemSet
    MODULE PROCEDURE cmfe_Region_CoordinateSystemSetNumber
    MODULE PROCEDURE cmfe_Region_CoordinateSystemSetObj
  END INTERFACE cmfe_Region_CoordinateSystemSet

  !>Finishes the creation of a region. \see OpenCMISS::Iron::cmfe_Region_CreateStart
  INTERFACE cmfe_Region_CreateFinish
    MODULE PROCEDURE cmfe_Region_CreateFinishNumber
    MODULE PROCEDURE cmfe_Region_CreateFinishObj
  END INTERFACE cmfe_Region_CreateFinish

  !>Starts the creation of a region. \see OpenCMISS::Iron::cmfe_Region_CreateFinish
  INTERFACE cmfe_Region_CreateStart
    MODULE PROCEDURE cmfe_Region_CreateStartNumber
    MODULE PROCEDURE cmfe_Region_CreateStartObj
  END INTERFACE cmfe_Region_CreateStart

  !>Returns the data points for a region.
  INTERFACE cmfe_Region_DataPointsGet
    MODULE PROCEDURE cmfe_Region_DataPointsGetObj
  END INTERFACE cmfe_Region_DataPointsGet

  !>Destroys a region.
  INTERFACE cmfe_Region_Destroy
    MODULE PROCEDURE cmfe_Region_DestroyNumber
    MODULE PROCEDURE cmfe_Region_DestroyObj
  END INTERFACE cmfe_Region_Destroy

  !>Returns the label of a region.
  INTERFACE cmfe_Region_LabelGet
    MODULE PROCEDURE cmfe_Region_LabelGetCNumber
    MODULE PROCEDURE cmfe_Region_LabelGetCObj
    MODULE PROCEDURE cmfe_Region_LabelGetVSNumber
    MODULE PROCEDURE cmfe_Region_LabelGetVSObj
  END INTERFACE cmfe_Region_LabelGet

  !>Sets/changes the label of a region.
  INTERFACE cmfe_Region_LabelSet
    MODULE PROCEDURE cmfe_Region_LabelSetCNumber
    MODULE PROCEDURE cmfe_Region_LabelSetCObj
    MODULE PROCEDURE cmfe_Region_LabelSetVSNumber
    MODULE PROCEDURE cmfe_Region_LabelSetVSObj
  END INTERFACE cmfe_Region_LabelSet

  !>Returns the nodes for a region.
  INTERFACE cmfe_Region_NodesGet
    MODULE PROCEDURE cmfe_Region_NodesGetObj
  END INTERFACE cmfe_Region_NodesGet

  PUBLIC cmfe_Region_CoordinateSystemGet,cmfe_Region_CoordinateSystemSet

  PUBLIC cmfe_Region_CreateFinish,cmfe_Region_CreateStart

  PUBLIC cmfe_Region_DataPointsGet

  PUBLIC cmfe_Region_Destroy

  PUBLIC cmfe_Region_LabelGet,cmfe_Region_LabelSet

  PUBLIC cmfe_Region_NodesGet

!!==================================================================================================================================
!!
!! SOLVER_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_SolverConstants OPENCMISS::Solver::Constants
  !> \brief Solver constants.
  !>@{
  !> \addtogroup OPENCMISS_SolverTypes OPENCMISS::Solver::SolverTypes
  !> \brief The types of solver
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_LINEAR_TYPE = SOLVER_LINEAR_TYPE !<A linear solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NONLINEAR_TYPE = SOLVER_NONLINEAR_TYPE !<A nonlinear solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_TYPE = SOLVER_DYNAMIC_TYPE !<A dynamic solver. \see  OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_TYPE = SOLVER_DAE_TYPE !<A differential-algebraic equation solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_EIGENPROBLEM_TYPE = SOLVER_EIGENPROBLEM_TYPE !<A eigenproblem solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_OPTIMISER_TYPE = SOLVER_OPTIMISER_TYPE !<An optimiser solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: cmfe_SolverCellMLEvaluatorType = SOLVER_CELLML_EVALUATOR_TYPE !<A CellML evaluator solver. \see OPENCMISS_SolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_SolverLibraries OPENCMISS::Solver::SolverLibraries
  !> \brief The types of solver libraries.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_CMISS_LIBRARY = SOLVER_CMISS_LIBRARY !<CMISS (internal) solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_PETSC_LIBRARY = SOLVER_PETSC_LIBRARY !<PETSc solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_MUMPS_LIBRARY = SOLVER_MUMPS_LIBRARY !<MUMPS solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_SUPERLU_LIBRARY = SOLVER_SUPERLU_LIBRARY !<SuperLU solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_SPOOLES_LIBRARY = SOLVER_SPOOLES_LIBRARY !<SPOOLES solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_UMFPACK_LIBRARY = SOLVER_UMFPACK_LIBRARY !<UMFPACK solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_LUSOL_LIBRARY = SOLVER_LUSOL_LIBRARY !<LUSOL solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ESSL_LIBRARY = SOLVER_ESSL_LIBRARY !<ESSL solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_LAPACK_LIBRARY = SOLVER_LAPACK_LIBRARY !<LAPACK solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_TAO_LIBRARY = SOLVER_TAO_LIBRARY !<TAO solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_HYPRE_LIBRARY = SOLVER_HYPRE_LIBRARY !<Hypre solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_PASTIX_LIBRARY = SOLVER_PASTIX_LIBRARY !<PaStiX solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_LinearSolverTypes OPENCMISS::Solver::LinearSolverTypes
  !> \brief The types of linear solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_LINEAR_DIRECT_SOLVE_TYPE = SOLVER_LINEAR_DIRECT_SOLVE_TYPE !<Direct linear solver type. \see OPENCMISS_LinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE = SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE !<Iterative linear solver type. \see OPENCMISS_LinearSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DirectLinearSolverTypes OPENCMISS::Solver::DirectLinearSolverTypes
  !> \brief The types of direct linear solvers. \todo Move libraries to a more appropriate place.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DIRECT_LU = SOLVER_DIRECT_LU !<LU direct linear solver. \see OPENCMISS_DirectLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DIRECT_CHOLESKY = SOLVER_DIRECT_CHOLESKY !<Cholesky direct linear solver. \see OPENCMISS_DirectLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DIRECT_SVD = SOLVER_DIRECT_SVD !<SVD direct linear solver. \see OPENCMISS_DirectLinearSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_IterativeLinearSolverTypes OPENCMISS::Solver::IterativeLinearSolverTypes
  !> \brief The types of iterative linear solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_RICHARDSON = SOLVER_ITERATIVE_RICHARDSON !<Richardson iterative solver type. \see  OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_CHEBYSHEV = SOLVER_ITERATIVE_CHEBYSHEV !<Chebychev iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_CONJUGATE_GRADIENT = SOLVER_ITERATIVE_CONJUGATE_GRADIENT !<Conjugate gradient iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_BICONJUGATE_GRADIENT = SOLVER_ITERATIVE_BICONJUGATE_GRADIENT !<Bi-conjugate gradient iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_GMRES = SOLVER_ITERATIVE_GMRES !<Generalised minimum residual iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_BiCGSTAB = SOLVER_ITERATIVE_BiCGSTAB !<Stabalised bi-conjugate gradient iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_CONJGRAD_SQUARED = SOLVER_ITERATIVE_CONJGRAD_SQUARED !<Conjugate gradient squared iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_IterativePreconditionerTypes OPENCMISS::Solver::IterativePreconditionerTypes
  !> \brief The types of iterative preconditioners.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_NO_PRECONDITIONER = SOLVER_ITERATIVE_NO_PRECONDITIONER !<No preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_JACOBI_PRECONDITIONER = SOLVER_ITERATIVE_JACOBI_PRECONDITIONER !<Jacobi preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER = SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER !<Iterative block Jacobi preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_SOR_PRECONDITIONER = SOLVER_ITERATIVE_SOR_PRECONDITIONER !<Successive over relaxation preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER = &
    & SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER !<Incomplete Cholesky preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER = SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER !<Incomplete LU preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER =  &
    & SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER !<Additive Schwrz preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_NonlinearSolverTypes OPENCMISS::Solver::NonlinearSolverTypes
  !> \brief The types of nonlinear solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NONLINEAR_NEWTON = SOLVER_NONLINEAR_NEWTON !<Newton nonlinear solver type. \see OPENCMISS_NonlinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NONLINEAR_BFGS_INVERSE = SOLVER_NONLINEAR_BFGS_INVERSE !<BFGS inverse nonlinear solver type. \see OPENCMISS_NonlinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NONLINEAR_SQP = SOLVER_NONLINEAR_SQP !<Sequential Quadratic Program nonlinear solver type. \see OPENCMISS_NonlinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NONLINEAR_QUASI_NEWTON = SOLVER_NONLINEAR_QUASI_NEWTON !<Quasi-Newton nonlinear solver type. \see OPENCMISS_NonlinearSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_QuasiNewtonSolverTypes OPENCMISS::Solver::QuasiNewtonSolverTypes
  !> \brief The types of nonlinear Quasi-Newton solvers
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_LINESEARCH=SOLVER_QUASI_NEWTON_LINESEARCH !<Quasi-Newton line search nonlinear solver type \see OPENCMISS_QuasiNewtonSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_TRUSTREGION=SOLVER_QUASI_NEWTON_TRUSTREGION !<Quasi-Newton trust region nonlinear solver type \see OPENCMISS_QuasiNewtonSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_QuasiNewtonTypes OPENCMISS::Solver::QuasiNewtonTypes
  !> \brief The nonlinear Quasi-Newton types
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_LBFGS=SOLVER_QUASI_NEWTON_LBFGS !<LBFGS Quasi-Newton type \see OPENCMISS_QuasiNewtonTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_GOODBROYDEN=SOLVER_QUASI_NEWTON_GOODBROYDEN !<"Good" Broyden Quasi-Newton type \see OPENCMISS_QuasiNewtonTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_BADBROYDEN=SOLVER_QUASI_NEWTON_BADBROYDEN !<"Bad" Broyden Quasi-Newton type \see OPENCMISS_QuasiNewtonTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_QuasiNewtonLineSearchTypes OPENCMISS::Solver::NonlinearQuasiNewtonLineSearchTypes
  !> \brief The types of line search techniques for Quasi-Newton line search nonlinear solvers
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_LINESEARCH_BASIC=SOLVER_QUASI_NEWTON_LINESEARCH_BASIC !<Simple damping line search. \see OPENCMISS_QuasiNewtonLineSearchTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_LINESEARCH_L2=SOLVER_QUASI_NEWTON_LINESEARCH_L2 !<Secant line search over the L2 norm of the function \see OPENCMISS_QuasiNewtonLineSearchTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_LINESEARCH_CP=SOLVER_QUASI_NEWTON_LINESEARCH_CP !<Critical point secant line search \see OPENCMISS_QuasiNewtonLineSearchTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_QuasiNewtonRestartTypes OPENCMISS::Solver::QuasiNewtonRestartTypes
  !> \brief The nonlinear Quasi-Newton restart types
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_RESTART_NONE=SOLVER_QUASI_NEWTON_RESTART_NONE !<Never restart \see OPENCMISS_QuasiNewtonRestartTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_RESTART_POWELL=SOLVER_QUASI_NEWTON_RESTART_POWELL !<Restart based upon descent criteria \see OPENCMISS_QuasiNewtonRestartTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_RESTART_PERIODIC=SOLVER_QUASI_NEWTON_RESTART_PERIODIC !<Restart after a fixed number of iterations \see OPENCMISS_QuasiNewtonRestartTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_QuasiNewtonScaleTypes OPENCMISS::Solver::QuasiNewtonScaleTypes
  !> \brief The nonlinear Quasi-Newton scale types
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_SCALE_NONE=SOLVER_QUASI_NEWTON_SCALE_NONE !<Don't scale the problem \see OPENCMISS_QuasiNewtonScaleTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_SCALE_SHANNO=SOLVER_QUASI_NEWTON_SCALE_SHANNO !<Use Shanno scaling \see OPENCMISS_QuasiNewtonScaleTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_SCALE_LINESEARCH=SOLVER_QUASI_NEWTON_SCALE_LINESEARCH !<Scale based upon line search lambda \see OPENCMISS_QuasiNewtonScaleTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_QUASI_NEWTON_SCALE_JACOBIAN=SOLVER_QUASI_NEWTON_SCALE_JACOBIAN !<Scale by inverting a previously computed Jacobian \see OPENCMISS_QuasiNewtonScaleTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_NewtonSolverTypes OPENCMISS::Solver::NewtonSolverTypes
  !> \brief The types of nonlinear Newton solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_LINESEARCH = SOLVER_NEWTON_LINESEARCH !<Newton line search nonlinear solver type. \see OPENCMISS_NewtonSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_TRUSTREGION = SOLVER_NEWTON_TRUSTREGION !<Newton trust region nonlinear solver type. \see OPENCMISS_NewtonSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_NewtonLineSearchTypes OPENCMISS::Solver::NewtonLineSearchTypes
  !> \brief The types line search techniques for Newton line search nonlinear solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_LINESEARCH_LINEAR = SOLVER_NEWTON_LINESEARCH_LINEAR !<Linear line search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_LINESEARCH_QUADRATIC = SOLVER_NEWTON_LINESEARCH_QUADRATIC !<Quadratic search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_LINESEARCH_CUBIC = SOLVER_NEWTON_LINESEARCH_CUBIC !<Cubic search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_JacobianCalculationTypes OPENCMISS::Solver::JacobianCalculationTypes
  !> \brief The Jacobian calculation types for a nonlinear solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED = SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED !<The Jacobian values will not be calculated for the nonlinear equations set. \see OPENCMISS_JacobianCalculationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED = SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED !<The Jacobian values will be calculated analytically for the nonlinear equations set. \see OPENCMISS_JacobianCalculationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_JACOBIAN_FD_CALCULATED = SOLVER_NEWTON_JACOBIAN_FD_CALCULATED !<The Jacobian values will be calcualted using finite differences for the nonlinear equations set. \see OPENCMISS_JacobianCalculationTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_NewtonConvergenceTypes OPENCMISS::Solver::NewtonConvergenceTypes
  !> \brief The convergence test types for a nonlinear newton solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT = SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT !<Newton solver Petsc default convergence test type. \see OPENCMISS_NewtonConvergenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM = SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM !<Newton solver energy norm convergence test type. \see OPENCMISS_NewtonConvergenceTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO = SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO !<Newton solver Sum of differentiated ratios of unconstrained to constrained residuals convergence test type. \see OPENCMISS_NewtonConvergenceTypes,OPENCMISS 
  !>@}
  !> \addtogroup OPENCMISS_DynamicOrderTypes OPENCMISS::Solver::DynamicOrderTypes
  !> \brief The order types for a dynamic solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_FIRST_ORDER = SOLVER_DYNAMIC_FIRST_ORDER !<Dynamic solver has first order terms. \see OPENCMISS_DynamicOrderTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_SECOND_ORDER = SOLVER_DYNAMIC_SECOND_ORDER !<Dynamic solver has second order terms. \see OPENCMISS_DynamicOrderTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DynamicLinearityTypes OPENCMISS::Solver::DynamicLinearityTypes
  !> \brief The time linearity types for a dynamic solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_LINEAR = SOLVER_DYNAMIC_LINEAR !<Dynamic solver has linear terms. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_NONLINEAR = SOLVER_DYNAMIC_NONLINEAR !<Dynamic solver has nonlinear terms. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DynamicDegreeTypes OPENCMISS::Solver::DynamicDegreeTypes
  !> \brief The time interpolation polynomial degree types for a dynamic solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_FIRST_DEGREE = SOLVER_DYNAMIC_FIRST_DEGREE !<Dynamic solver uses a first degree polynomial for time interpolation. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_SECOND_DEGREE = SOLVER_DYNAMIC_SECOND_DEGREE !<Dynamic solver uses a second degree polynomial for time interpolation. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_THIRD_DEGREE = SOLVER_DYNAMIC_THIRD_DEGREE !<Dynamic solver uses a third degree polynomial for time interpolation. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DynamicSchemeTypes OPENCMISS::Solver::DynamicSchemeTypes
  !> \brief The types of dynamic solver scheme.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_EULER_SCHEME = SOLVER_DYNAMIC_EULER_SCHEME !<Euler (explicit) dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME = SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME !<Backward Euler (implicit) dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME = SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME !<Crank-Nicolson dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_GALERKIN_SCHEME = SOLVER_DYNAMIC_GALERKIN_SCHEME !<Galerkin dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_ZLAMAL_SCHEME = SOLVER_DYNAMIC_ZLAMAL_SCHEME !<Zlamal dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME = SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME !<2nd degree Gear dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME = SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME !<1st 2nd degree Liniger dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME = SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME !<2nd 2nd degree Liniger dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_NEWMARK1_SCHEME = SOLVER_DYNAMIC_NEWMARK1_SCHEME !<1st Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_NEWMARK2_SCHEME = SOLVER_DYNAMIC_NEWMARK2_SCHEME !<2nd Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_NEWMARK3_SCHEME = SOLVER_DYNAMIC_NEWMARK3_SCHEME !<3rd Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME = SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME !<3rd degree Gear dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME = SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME !<1st 3rd degree Liniger dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME = SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME !<2nd 3rd degree Liniger dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_HOUBOLT_SCHEME = SOLVER_DYNAMIC_HOUBOLT_SCHEME !<Houbolt dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_WILSON_SCHEME = SOLVER_DYNAMIC_WILSON_SCHEME !<Wilson dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME = SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME !<1st Bossak-Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME = SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME !<2nd Bossak-Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME = SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME !<1st Hilbert-Hughes-Taylor dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME = SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME !<1st Hilbert-Hughes-Taylor dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DYNAMIC_USER_DEFINED_SCHEME = SOLVER_DYNAMIC_USER_DEFINED_SCHEME !<User specified degree and theta dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DAETypes OPENCMISS::Solver::DAETypes
  !> \brief The type of differential-algebraic equation.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_DIFFERENTIAL_ONLY = SOLVER_DAE_DIFFERENTIAL_ONLY !<Differential equations only. \see OPENCMISS_DAETypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_INDEX_1 = SOLVER_DAE_INDEX_1 !<Index 1 differential-algebraic equation. \see OPENCMISS_DAETypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_INDEX_2 = SOLVER_DAE_INDEX_2 !<Index 2 differential-algebraic equation. \see OPENCMISS_DAETypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_INDEX_3 = SOLVER_DAE_INDEX_3 !<Index 3 differential-algebraic equation. \see OPENCMISS_DAETypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DAESolverTypes OPENCMISS::Solver::DAESolverTypes
  !> \brief The differential-algebraic equation solver types for a differential-algebraic equation solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_EULER = SOLVER_DAE_EULER !<Euler differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_CRANK_NICOLSON = SOLVER_DAE_CRANK_NICOLSON !<Crank-Nicolson differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_RUNGE_KUTTA = SOLVER_DAE_RUNGE_KUTTA !<Runge-Kutta differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_ADAMS_MOULTON = SOLVER_DAE_ADAMS_MOULTON !<Adams-Moulton differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_BDF = SOLVER_DAE_BDF !<General BDF differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_RUSH_LARSON = SOLVER_DAE_RUSH_LARSON !<Rush-Larson differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_EXTERNAL = SOLVER_DAE_EXTERNAL !<External (e.g., CellML generated) differential-algebraic equation solver. \see
  !>@}
  !> \addtogroup OPENCMISS_EulerDAESolverTypes OPENCMISS::Solver::EulerDAESolverTypes
  !> \brief The Euler solver types for a differential-algebriac equation solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_EULER_FORWARD = SOLVER_DAE_EULER_FORWARD !<Forward Euler differential equation solver. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_EULER_BACKWARD = SOLVER_DAE_EULER_BACKWARD !<Backward Euler differential equation solver. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_DAE_EULER_IMPROVED = SOLVER_DAE_EULER_IMPROVED !<Improved Euler differential equation solver. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_SolutionInitialiseTypes OPENCMISS::Solver::SolutionInitialiseTypes
  !> \brief The types of solution initialisation.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_SOLUTION_INITIALISE_ZERO = SOLVER_SOLUTION_INITIALISE_ZERO !<Initialise the solution by zeroing it before a solve. \see OPENCMISS_SolutionInitialiseTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD = SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD !<Initialise the solution by copying in the current dependent field values. \see OPENCMISS_SolutionInitialiseTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_SOLUTION_INITIALISE_NO_CHANGE = SOLVER_SOLUTION_INITIALISE_NO_CHANGE !<Do not change the solution before a solve. \see OPENCMISS_SolutionInitialiseTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_SolverOutputTypes OPENCMISS::Solver::OutputTypes
  !> \brief The types of output.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_NO_OUTPUT = SOLVER_NO_OUTPUT !<No output from the solver routines. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_PROGRESS_OUTPUT = SOLVER_PROGRESS_OUTPUT !<Progress output from solver routines. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_TIMING_OUTPUT = SOLVER_TIMING_OUTPUT !<Timing output from the solver routines plus below. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_SOLVER_OUTPUT = SOLVER_SOLVER_OUTPUT !<Solver specific output from the solver routines plus below. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_MATRIX_OUTPUT = SOLVER_MATRIX_OUTPUT !<Solver matrices output from the solver routines plus below. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_SolverEquationsSparsityTypes OPENCMISS::SolverEquations::SparsityTypes
  !> \brief The types of sparse solver equations matrices.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_SPARSE_MATRICES = SOLVER_SPARSE_MATRICES !<Use sparse solver matrices. \see OPENCMISS_SolverEquationsSparsityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMFE_SOLVER_FULL_MATRICES = SOLVER_FULL_MATRICES !<Use fully populated solver matrices. \see OPENCMISS_SolverEquationsSparsityTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the CellML equations for a solver.
  INTERFACE cmfe_Solver_CellMLEquationsGet
    MODULE PROCEDURE cmfe_Solver_CellMLEquationsGetNumber0
    MODULE PROCEDURE cmfe_Solver_CellMLEquationsGetNumber1
    MODULE PROCEDURE cmfe_Solver_CellMLEquationsGetObj
  END INTERFACE cmfe_Solver_CellMLEquationsGet

  !>Adds CellML environments to CellML equations.
  INTERFACE cmfe_CellMLEquations_CellMLAdd
    MODULE PROCEDURE cmfe_CellMLEquations_CellMLAddNumber0
    MODULE PROCEDURE cmfe_CellMLEquations_CellMLAddNumber1
    MODULE PROCEDURE cmfe_CellMLEquations_CellMLAddObj
  END INTERFACE cmfe_CellMLEquations_CellMLAdd

  !>Returns the solver type for an Euler differential-algebraic equation solver. \todo should this be CMISSSolver_DAEEulerSolverTypeGet???
  INTERFACE cmfe_Solver_DAEEulerSolverTypeGet
    MODULE PROCEDURE cmfe_Solver_DAEEulerSolverTypeGetNumber0
    MODULE PROCEDURE cmfe_Solver_DAEEulerSolverTypeGetNumber1
    MODULE PROCEDURE cmfe_Solver_DAEEulerSolverTypeGetObj
  END INTERFACE cmfe_Solver_DAEEulerSolverTypeGet

  !>Sets/changes the solver type for an Euler differential-algebraic equation solver. \todo should this be CMISSSolver_DAEEulerSolverTypeSet???
  INTERFACE cmfe_Solver_DAEEulerSolverTypeSet
    MODULE PROCEDURE cmfe_Solver_DAEEulerSolverTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_DAEEulerSolverTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_DAEEulerSolverTypeSetObj
  END INTERFACE cmfe_Solver_DAEEulerSolverTypeSet

  !>Returns the solver type for an differential-algebraic equation solver.
  INTERFACE cmfe_Solver_DAESolverTypeGet
    MODULE PROCEDURE cmfe_Solver_DAESolverTypeGetNumber0
    MODULE PROCEDURE cmfe_Solver_DAESolverTypeGetNumber1
    MODULE PROCEDURE cmfe_Solver_DAESolverTypeGetObj
  END INTERFACE cmfe_Solver_DAESolverTypeGet

  !>Sets/changes the solver type for an differential-algebraic equation solver.
  INTERFACE cmfe_Solver_DAESolverTypeSet
    MODULE PROCEDURE cmfe_Solver_DAESolverTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_DAESolverTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_DAESolverTypeSetObj
  END INTERFACE cmfe_Solver_DAESolverTypeSet

  !>Sets/changes the times for a differential-algebraic equation solver.
  INTERFACE cmfe_Solver_DAETimesSet
    MODULE PROCEDURE cmfe_Solver_DAETimesSetNumber0
    MODULE PROCEDURE cmfe_Solver_DAETimesSetNumber1
    MODULE PROCEDURE cmfe_Solver_DAETimesSetObj
  END INTERFACE cmfe_Solver_DAETimesSet

  !>Sets/changes the (initial) time step for a differential-algebraic equation solver.
  INTERFACE cmfe_Solver_DAETimeStepSet
    MODULE PROCEDURE cmfe_Solver_DAETimeStepSetNumber0
    MODULE PROCEDURE cmfe_Solver_DAETimeStepSetNumber1
    MODULE PROCEDURE cmfe_Solver_DAETimeStepSetObj
  END INTERFACE cmfe_Solver_DAETimeStepSet

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver.
  INTERFACE cmfe_Solver_DynamicDegreeGet
    MODULE PROCEDURE cmfe_Solver_DynamicDegreeGetNumber0
    MODULE PROCEDURE cmfe_Solver_DynamicDegreeGetNumber1
    MODULE PROCEDURE cmfe_Solver_DynamicDegreeGetObj
  END INTERFACE cmfe_Solver_DynamicDegreeGet

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver.
  INTERFACE cmfe_Solver_DynamicDegreeSet
    MODULE PROCEDURE cmfe_Solver_DynamicDegreeSetNumber0
    MODULE PROCEDURE cmfe_Solver_DynamicDegreeSetNumber1
    MODULE PROCEDURE cmfe_Solver_DynamicDegreeSetObj
  END INTERFACE cmfe_Solver_DynamicDegreeSet

  !>Returns the linearity type for the dynamic solver.
  INTERFACE cmfe_Solver_DynamicLinearityTypeGet
    MODULE PROCEDURE cmfe_Solver_DynamicLinearityTypeGetNumber0
    MODULE PROCEDURE cmfe_Solver_DynamicLinearityTypeGetNumber1
    MODULE PROCEDURE cmfe_Solver_DynamicLinearityTypeGetObj
  END INTERFACE cmfe_Solver_DynamicLinearityTypeGet

  !>Returns the linear solver associated with a linear dynamic solver.
  INTERFACE cmfe_Solver_DynamicLinearSolverGet
    MODULE PROCEDURE cmfe_Solver_DynamicLinearSolverGetNumber0
    MODULE PROCEDURE cmfe_Solver_DynamicLinearSolverGetNumber1
    MODULE PROCEDURE cmfe_Solver_DynamicLinearSolverGetObj
  END INTERFACE cmfe_Solver_DynamicLinearSolverGet

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver.
  INTERFACE cmfe_Solver_DynamicNonlinearSolverGet
    MODULE PROCEDURE cmfe_Solver_DynamicNonlinearSolverGetNumber0
    MODULE PROCEDURE cmfe_Solver_DynamicNonlinearSolverGetNumber1
    MODULE PROCEDURE cmfe_Solver_DynamicNonlinearSolverGetObj
  END INTERFACE cmfe_Solver_DynamicNonlinearSolverGet

  !>Sets/changes the scheme for a dynamic solver.
  INTERFACE cmfe_Solver_DynamicSchemeSet
    MODULE PROCEDURE cmfe_Solver_DynamicSchemeSetNumber0
    MODULE PROCEDURE cmfe_Solver_DynamicSchemeSetNumber1
    MODULE PROCEDURE cmfe_Solver_DynamicSchemeSetObj
  END INTERFACE cmfe_Solver_DynamicSchemeSet

  !>Sets/changes the theta scheme values for a dynamic solver.
  INTERFACE cmfe_Solver_DynamicThetaSet
    MODULE PROCEDURE cmfe_Solver_DynamicThetaSetNumber00
    MODULE PROCEDURE cmfe_Solver_DynamicThetaSetNumber01
    MODULE PROCEDURE cmfe_Solver_DynamicThetaSetNumber10
    MODULE PROCEDURE cmfe_Solver_DynamicThetaSetNumber11
    MODULE PROCEDURE cmfe_Solver_DynamicThetaSetObj0
    MODULE PROCEDURE cmfe_Solver_DynamicThetaSetObj1
  END INTERFACE cmfe_Solver_DynamicThetaSet

  !>Sets/changes the dynamic times for a dynamic solver.
  INTERFACE cmfe_Solver_DynamicTimesSet
    MODULE PROCEDURE cmfe_Solver_DynamicTimesSetNumber0
    MODULE PROCEDURE cmfe_Solver_DynamicTimesSetNumber1
    MODULE PROCEDURE cmfe_Solver_DynamicTimesSetObj
  END INTERFACE cmfe_Solver_DynamicTimesSet
  
  !Sets the arbitrary path logical for the transformation
  INTERFACE cmfe_Solver_GeometricTransformationArbitraryPathSet
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationArbitraryPathSetNumber
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationArbitraryPathSetObj
  END INTERFACE cmfe_Solver_GeometricTransformationArbitraryPathSet
  
  !Clear transformation for a geometric transformation solver
  INTERFACE cmfe_Solver_GeometricTransformationClear
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationClearNumber
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationClearObj
  END INTERFACE cmfe_Solver_GeometricTransformationClear
  
  !Sets the field to transform
  INTERFACE cmfe_Solver_GeometricTransformationFieldSet
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationFieldSetNumber
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationFieldSetObj
  END INTERFACE cmfe_Solver_GeometricTransformationFieldSet
  
  !Sets the full transformation matrix for a geometric transformation
  INTERFACE cmfe_Solver_GeometricTransformationMatrixSet
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationMatrixSetNumber0
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationMatrixSetObj0
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationMatrixSetNumber1
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationMatrixSetObj1
  END INTERFACE cmfe_Solver_GeometricTransformationMatrixSet
  
  !Sets number of load increments for the transformation
  INTERFACE cmfe_Solver_GeometricTransformationNumberOfLoadIncrementsSet
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationNoLoadIncrementsSetNumber
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationNoLoadIncrementsSetObj
  END INTERFACE cmfe_Solver_GeometricTransformationNumberOfLoadIncrementsSet
  
  !Sets the rotation for a geometric transformation
  INTERFACE cmfe_Solver_GeometricTransformationRotationSet
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationRotationSetNumber0
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationRotationSetObj0
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationRotationSetNumber1
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationRotationSetObj1
  END INTERFACE cmfe_Solver_GeometricTransformationRotationSet
  
  !Sets the scalings for a uni-directional geometric transformation
  INTERFACE cmfe_Solver_GeometricTransformationScalingsSet
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationScalingsSetNumber
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationScalingsSetObj
  END INTERFACE cmfe_Solver_GeometricTransformationScalingsSet
  
  !Sets the translation for a geometric transformation
  INTERFACE cmfe_Solver_GeometricTransformationTranslationSet
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationTranslationSetNumber0
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationTranslationSetObj0
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationTranslationSetNumber1
    MODULE PROCEDURE cmfe_Solver_GeometricTransformationTranslationSetObj1
  END INTERFACE cmfe_Solver_GeometricTransformationTranslationSet

  !>Returns the label of a solver.
  INTERFACE cmfe_Solver_LabelGet
    MODULE PROCEDURE cmfe_Solver_LabelGetCNumber0
    MODULE PROCEDURE cmfe_Solver_LabelGetCNumber1
    MODULE PROCEDURE cmfe_Solver_LabelGetCObj
    MODULE PROCEDURE cmfe_Solver_LabelGetVSNumber0
    MODULE PROCEDURE cmfe_Solver_LabelGetVSNumber1
    MODULE PROCEDURE cmfe_Solver_LabelGetVSObj
  END INTERFACE cmfe_Solver_LabelGet

  !>Sets/changes the label of a control loop.
  INTERFACE cmfe_Solver_LabelSet
    MODULE PROCEDURE cmfe_Solver_LabelSetCNumber0
    MODULE PROCEDURE cmfe_Solver_LabelSetCNumber1
    MODULE PROCEDURE cmfe_Solver_LabelSetCObj
    MODULE PROCEDURE cmfe_Solver_LabelSetVSNumber0
    MODULE PROCEDURE cmfe_Solver_LabelSetVSNumber1
    MODULE PROCEDURE cmfe_Solver_LabelSetVSObj
  END INTERFACE cmfe_Solver_LabelSet

  !>Returns the type of library to use for the solver.
  INTERFACE cmfe_Solver_LibraryTypeGet
    MODULE PROCEDURE cmfe_Solver_LibraryTypeGetNumber0
    MODULE PROCEDURE cmfe_Solver_LibraryTypeGetNumber1
    MODULE PROCEDURE cmfe_Solver_LibraryTypeGetObj
  END INTERFACE cmfe_Solver_LibraryTypeGet

  !>Sets/changes the type of library to use for the solver.
  INTERFACE cmfe_Solver_LibraryTypeSet
    MODULE PROCEDURE cmfe_Solver_LibraryTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_LibraryTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_LibraryTypeSetObj
  END INTERFACE cmfe_Solver_LibraryTypeSet

  !>Sets/changes the type of direct linear solver.
  INTERFACE cmfe_Solver_LinearDirectTypeSet
    MODULE PROCEDURE cmfe_Solver_LinearDirectTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_LinearDirectTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_LinearDirectTypeSetObj
  END INTERFACE cmfe_Solver_LinearDirectTypeSet

  !>Sets/changes the absolute tolerance for an iterative linear solver.
  INTERFACE cmfe_Solver_LinearIterativeAbsoluteToleranceSet
    MODULE PROCEDURE cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber0
    MODULE PROCEDURE cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber1
    MODULE PROCEDURE cmfe_Solver_LinearIterativeAbsoluteToleranceSetObj
  END INTERFACE cmfe_Solver_LinearIterativeAbsoluteToleranceSet

  !>Sets/changes the divergence tolerance for an iterative linear solver.
  INTERFACE cmfe_Solver_LinearIterativeDivergenceToleranceSet
    MODULE PROCEDURE cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber0
    MODULE PROCEDURE cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber1
    MODULE PROCEDURE cmfe_Solver_LinearIterativeDivergenceToleranceSetObj
  END INTERFACE cmfe_Solver_LinearIterativeDivergenceToleranceSet

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver.
  INTERFACE cmfe_Solver_LinearIterativeGMRESRestartSet
    MODULE PROCEDURE cmfe_Solver_LinearIterativeGMRESRestartSetNumber0
    MODULE PROCEDURE cmfe_Solver_LinearIterativeGMRESRestartSetNumber1
    MODULE PROCEDURE cmfe_Solver_LinearIterativeGMRESRestartSetObj
  END INTERFACE cmfe_Solver_LinearIterativeGMRESRestartSet

  !>Sets/changes the maximum number of iterations for an iterative linear solver.
  INTERFACE cmfe_Solver_LinearIterativeMaximumIterationsSet
    MODULE PROCEDURE cmfe_Solver_LinearIterativeMaximumIterationsSetNumber0
    MODULE PROCEDURE cmfe_Solver_LinearIterativeMaximumIterationsSetNumber1
    MODULE PROCEDURE cmfe_Solver_LinearIterativeMaximumIterationsSetObj
  END INTERFACE cmfe_Solver_LinearIterativeMaximumIterationsSet

  !>Sets/changes the type of preconditioner for an iterative linear solver.
  INTERFACE cmfe_Solver_LinearIterativePreconditionerTypeSet
    MODULE PROCEDURE cmfe_Solver_LinearIterativePreconditionerTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_LinearIterativePreconditionerTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_LinearIterativePreconditionerTypeSetObj
  END INTERFACE cmfe_Solver_LinearIterativePreconditionerTypeSet

  !>Sets/changes the relative tolerance for an iterative linear solver.
  INTERFACE cmfe_Solver_LinearIterativeRelativeToleranceSet
    MODULE PROCEDURE cmfe_Solver_LinearIterativeRelativeToleranceSetNumber0
    MODULE PROCEDURE cmfe_Solver_LinearIterativeRelativeToleranceSetNumber1
    MODULE PROCEDURE cmfe_Solver_LinearIterativeRelativeToleranceSetObj
  END INTERFACE cmfe_Solver_LinearIterativeRelativeToleranceSet

  !>Sets/changes the type of iterative linear solver.
  INTERFACE cmfe_Solver_LinearIterativeTypeSet
    MODULE PROCEDURE cmfe_Solver_LinearIterativeTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_LinearIterativeTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_LinearIterativeTypeSetObj
  END INTERFACE cmfe_Solver_LinearIterativeTypeSet

  !>Sets/changes the type of linear solver.
  INTERFACE cmfe_Solver_LinearTypeSet
    MODULE PROCEDURE cmfe_Solver_LinearTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_LinearTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_LinearTypeSetObj
  END INTERFACE cmfe_Solver_LinearTypeSet

  !>Sets/changes the absolute tolerance for a nonlinear Quasi-Newton solver.
  INTERFACE cmfe_Solver_QuasiNewtonAbsoluteToleranceSet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetObj
  END INTERFACE cmfe_Solver_QuasiNewtonAbsoluteToleranceSet

  !>Enables/disables output monitoring for a nonlinear Quasi-Newton line search solver.
  INTERFACE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetObj
  END INTERFACE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSet

  !>Sets/changes the Jacobian calculation type for a nonlinear Quasi-Newton solver.
  INTERFACE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetObj
  END INTERFACE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSet

  !>Returns the linear solver associated with a nonlinear Quasi-Newton solver.
  INTERFACE cmfe_Solver_QuasiNewtonLinearSolverGet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonLinearSolverGetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonLinearSolverGetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonLinearSolverGetObj
  END INTERFACE cmfe_Solver_QuasiNewtonLinearSolverGet

  !>Returns the linear solver associated with a nonlinear Quasi-Newton solver.
  INTERFACE cmfe_Solver_QuasiNewtonCellMLSolverGet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonCellMLSolverGetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonCellMLSolverGetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonCellMLSolverGetObj
  END INTERFACE cmfe_Solver_QuasiNewtonCellMLSolverGet

  !>Sets/change the convergence test for a nonlinear Quasi-Newton solver.
  INTERFACE cmfe_Solver_QuasiNewtonConvergenceTestTypeSet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetObj
  END INTERFACE cmfe_Solver_QuasiNewtonConvergenceTestTypeSet

  !>Sets/changes the line search maximum step for a nonlinear Quasi-Newton solver.
  INTERFACE cmfe_Solver_QuasiNewtonLineSearchMaxStepSet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetObj
  END INTERFACE cmfe_Solver_QuasiNewtonLineSearchMaxStepSet

  !>Sets/changes the line search step tolerance for a nonlinear Quasi-Newton solver.
  INTERFACE cmfe_Solver_QuasiNewtonLineSearchStepTolSet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchStepTolSetObj
  END INTERFACE cmfe_Solver_QuasiNewtonLineSearchStepTolSet

  !>Sets/changes the type of line search for a nonlinear Quasi-Newton solver.
  INTERFACE cmfe_Solver_QuasiNewtonLineSearchTypeSet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonLineSearchTypeSetObj
  END INTERFACE cmfe_Solver_QuasiNewtonLineSearchTypeSet

  !>Sets/changes the maximum number of function evaluations for a nonlinear Quasi-Newton solver.
  INTERFACE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj
  END INTERFACE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSet

  !>Sets/changes the maximum number of iterations for a nonlinear Quasi-Newton solver.
  INTERFACE cmfe_Solver_QuasiNewtonMaximumIterationsSet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonMaximumIterationsSetObj
  END INTERFACE cmfe_Solver_QuasiNewtonMaximumIterationsSet

  !>Sets/changes the relative tolerance for a nonlinear Quasi-Newton solver.
  INTERFACE cmfe_Solver_QuasiNewtonRelativeToleranceSet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonRelativeToleranceSetObj
  END INTERFACE cmfe_Solver_QuasiNewtonRelativeToleranceSet

  !>Sets/changes the solution tolerance for a nonlinear Quasi-Newton solver.
  INTERFACE cmfe_Solver_QuasiNewtonSolutionToleranceSet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonSolutionToleranceSetObj
  END INTERFACE cmfe_Solver_QuasiNewtonSolutionToleranceSet

  !>Sets/changes the trust region delta0 tolerance for a nonlinear Quasi-Newton trust region solver.
  INTERFACE cmfe_Solver_QuasiNewtonTrustRegionDelta0Set
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetObj
  END INTERFACE cmfe_Solver_QuasiNewtonTrustRegionDelta0Set

  !>Sets/changes the trust region tolerance for a nonlinear Quasi-Newton trust region solver.
  INTERFACE cmfe_Solver_QuasiNewtonTrustRegionToleranceSet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetObj
  END INTERFACE cmfe_Solver_QuasiNewtonTrustRegionToleranceSet

  !>Sets/changes the nonlinear Quasi-Newton restart.
  INTERFACE cmfe_Solver_QuasiNewtonRestartSet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonRestartSetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonRestartSetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonRestartSetObj
  END INTERFACE cmfe_Solver_QuasiNewtonRestartSet

  !>Sets/changes the nonlinear Quasi-Newton restart type.
  INTERFACE cmfe_Solver_QuasiNewtonRestartTypeSet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonRestartTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonRestartTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonRestartTypeSetObj
  END INTERFACE cmfe_Solver_QuasiNewtonRestartTypeSet

  !>Sets/changes the nonlinear Quasi-Newton scale type.
  INTERFACE cmfe_Solver_QuasiNewtonScaleTypeSet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonScaleTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonScaleTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonScaleTypeSetObj
  END INTERFACE cmfe_Solver_QuasiNewtonScaleTypeSet

  !>Sets/changes the type of nonlinear Quasi-Newton solver.
  INTERFACE cmfe_Solver_QuasiNewtonSolveTypeSet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonSolveTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonSolveTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonSolveTypeSetObj
  END INTERFACE cmfe_Solver_QuasiNewtonSolveTypeSet

  !>Sets/changes the nonlinear Quasi-Newton type.
  INTERFACE cmfe_Solver_QuasiNewtonTypeSet
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_QuasiNewtonTypeSetObj
  END INTERFACE cmfe_Solver_QuasiNewtonTypeSet

  !>Sets/changes the absolute tolerance for a nonlinear Newton solver.
  INTERFACE cmfe_Solver_NewtonAbsoluteToleranceSet
    MODULE PROCEDURE cmfe_Solver_NewtonAbsoluteToleranceSetNumber0
    MODULE PROCEDURE cmfe_Solver_NewtonAbsoluteToleranceSetNumber1
    MODULE PROCEDURE cmfe_Solver_NewtonAbsoluteToleranceSetObj
  END INTERFACE cmfe_Solver_NewtonAbsoluteToleranceSet

  !>Enables/disables output monitoring for a nonlinear Newton line search solver.
  INTERFACE cmfe_Solver_NewtonLineSearchMonitorOutputSet
    MODULE PROCEDURE cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber0
    MODULE PROCEDURE cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber1
    MODULE PROCEDURE cmfe_Solver_NewtonLineSearchMonitorOutputSetObj
  END INTERFACE cmfe_Solver_NewtonLineSearchMonitorOutputSet

  !>Sets/changes the Jacobian calculation type for a nonlinear Newton solver.
  INTERFACE cmfe_Solver_NewtonJacobianCalculationTypeSet
    MODULE PROCEDURE cmfe_Solver_NewtonJacobianCalculationTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_NewtonJacobianCalculationTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_NewtonJacobianCalculationTypeSetObj
  END INTERFACE cmfe_Solver_NewtonJacobianCalculationTypeSet

  !>Returns the linear solver associated with a nonlinear Newton solver.
  INTERFACE cmfe_Solver_NewtonLinearSolverGet
    MODULE PROCEDURE cmfe_Solver_NewtonLinearSolverGetNumber0
    MODULE PROCEDURE cmfe_Solver_NewtonLinearSolverGetNumber1
    MODULE PROCEDURE cmfe_Solver_NewtonLinearSolverGetObj
  END INTERFACE cmfe_Solver_NewtonLinearSolverGet

  !>Returns the linear solver associated with a nonlinear Newton solver.
  INTERFACE cmfe_Solver_NewtonCellMLSolverGet
    MODULE PROCEDURE cmfe_Solver_NewtonCellMLSolverGetNumber0
    MODULE PROCEDURE cmfe_Solver_NewtonCellMLSolverGetNumber1
    MODULE PROCEDURE cmfe_Solver_NewtonCellMLSolverGetObj
  END INTERFACE cmfe_Solver_NewtonCellMLSolverGet

  !>Sets/change the convergence test for a nonlinear Newton solver.
  INTERFACE cmfe_Solver_NewtonConvergenceTestTypeSet
    MODULE PROCEDURE cmfe_Solver_NewtonConvergenceTestTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_NewtonConvergenceTestTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_NewtonConvergenceTestTypeSetObj
  END INTERFACE cmfe_Solver_NewtonConvergenceTestTypeSet

  !>Sets/changes the line search alpha for a nonlinear Newton solver.
  INTERFACE cmfe_Solver_NewtonLineSearchAlphaSet
    MODULE PROCEDURE cmfe_Solver_NewtonLineSearchAlphaSetNumber0
    MODULE PROCEDURE cmfe_Solver_NewtonLineSearchAlphaSetNumber1
    MODULE PROCEDURE cmfe_Solver_NewtonLineSearchAlphaSetObj
  END INTERFACE cmfe_Solver_NewtonLineSearchAlphaSet

  !>Sets/changes the line search maximum step for a nonlinear Newton solver.
  INTERFACE cmfe_Solver_NewtonLineSearchMaxStepSet
    MODULE PROCEDURE cmfe_Solver_NewtonLineSearchMaxStepSetNumber0
    MODULE PROCEDURE cmfe_Solver_NewtonLineSearchMaxStepSetNumber1
    MODULE PROCEDURE cmfe_Solver_NewtonLineSearchMaxStepSetObj
  END INTERFACE cmfe_Solver_NewtonLineSearchMaxStepSet

  !>Sets/changes the line search step tolerance for a nonlinear Newton solver.
  INTERFACE cmfe_Solver_NewtonLineSearchStepTolSet
    MODULE PROCEDURE cmfe_Solver_NewtonLineSearchStepTolSetNumber0
    MODULE PROCEDURE cmfe_Solver_NewtonLineSearchStepTolSetNumber1
    MODULE PROCEDURE cmfe_Solver_NewtonLineSearchStepTolSetObj
  END INTERFACE cmfe_Solver_NewtonLineSearchStepTolSet

  !>Sets/changes the type of line search for a nonlinear Newton solver.
  INTERFACE cmfe_Solver_NewtonLineSearchTypeSet
    MODULE PROCEDURE cmfe_Solver_NewtonLineSearchTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_NewtonLineSearchTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_NewtonLineSearchTypeSetObj
  END INTERFACE cmfe_Solver_NewtonLineSearchTypeSet

  !>Sets/changes the maximum number of function evaluations for a nonlinear Newton solver.
  INTERFACE cmfe_Solver_NewtonMaximumFunctionEvaluationsSet
    MODULE PROCEDURE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber0
    MODULE PROCEDURE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber1
    MODULE PROCEDURE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetObj
  END INTERFACE cmfe_Solver_NewtonMaximumFunctionEvaluationsSet

  !>Sets/changes the maximum number of iterations for a nonlinear Newton solver.
  INTERFACE cmfe_Solver_NewtonMaximumIterationsSet
    MODULE PROCEDURE cmfe_Solver_NewtonMaximumIterationsSetNumber0
    MODULE PROCEDURE cmfe_Solver_NewtonMaximumIterationsSetNumber1
    MODULE PROCEDURE cmfe_Solver_NewtonMaximumIterationsSetObj
  END INTERFACE cmfe_Solver_NewtonMaximumIterationsSet

  !>Sets/changes the relative tolerance for a nonlinear Newton solver.
  INTERFACE cmfe_Solver_NewtonRelativeToleranceSet
    MODULE PROCEDURE cmfe_Solver_NewtonRelativeToleranceSetNumber0
    MODULE PROCEDURE cmfe_Solver_NewtonRelativeToleranceSetNumber1
    MODULE PROCEDURE cmfe_Solver_NewtonRelativeToleranceSetObj
  END INTERFACE cmfe_Solver_NewtonRelativeToleranceSet

  !>Sets/changes the solution tolerance for a nonlinear Newton solver.
  INTERFACE cmfe_Solver_NewtonSolutionToleranceSet
    MODULE PROCEDURE cmfe_Solver_NewtonSolutionToleranceSetNumber0
    MODULE PROCEDURE cmfe_Solver_NewtonSolutionToleranceSetNumber1
    MODULE PROCEDURE cmfe_Solver_NewtonSolutionToleranceSetObj
  END INTERFACE cmfe_Solver_NewtonSolutionToleranceSet

  !>Sets/changes the trust region delta0 tolerance for a nonlinear Newton trust region solver.
  INTERFACE cmfe_Solver_NewtonTrustRegionDelta0Set
    MODULE PROCEDURE cmfe_Solver_NewtonTrustRegionDelta0SetNumber0
    MODULE PROCEDURE cmfe_Solver_NewtonTrustRegionDelta0SetNumber1
    MODULE PROCEDURE cmfe_Solver_NewtonTrustRegionDelta0SetObj
  END INTERFACE cmfe_Solver_NewtonTrustRegionDelta0Set

  !>Sets/changes the trust region tolerance for a nonlinear Newton trust region solver.
  INTERFACE cmfe_Solver_NewtonTrustRegionToleranceSet
    MODULE PROCEDURE cmfe_Solver_NewtonTrustRegionToleranceSetNumber0
    MODULE PROCEDURE cmfe_Solver_NewtonTrustRegionToleranceSetNumber1
    MODULE PROCEDURE cmfe_Solver_NewtonTrustRegionToleranceSetObj
  END INTERFACE cmfe_Solver_NewtonTrustRegionToleranceSet

  !>Sets/changes the type of nonlinear Newton trust region solver.
  INTERFACE cmfe_Solver_NewtonTypeSet
    MODULE PROCEDURE cmfe_Solver_NewtonTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_NewtonTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_NewtonTypeSetObj
  END INTERFACE cmfe_Solver_NewtonTypeSet

  !>Sets/changes the type of nonlinear solver.
  INTERFACE cmfe_Solver_NonlinearTypeSet
    MODULE PROCEDURE cmfe_Solver_NonlinearTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_NonlinearTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_NonlinearTypeSetObj
  END INTERFACE cmfe_Solver_NonlinearTypeSet

  !>Sets/changes the output type for a solver.
  INTERFACE cmfe_Solver_OutputTypeSet
    MODULE PROCEDURE cmfe_Solver_OutputTypeSetNumber0
    MODULE PROCEDURE cmfe_Solver_OutputTypeSetNumber1
    MODULE PROCEDURE cmfe_Solver_OutputTypeSetObj
  END INTERFACE cmfe_Solver_OutputTypeSet

  !>Returns the solver equations for a solver.
  INTERFACE cmfe_Solver_SolverEquationsGet
    MODULE PROCEDURE cmfe_Solver_SolverEquationsGetNumber0
    MODULE PROCEDURE cmfe_Solver_SolverEquationsGetNumber1
    MODULE PROCEDURE cmfe_Solver_SolverEquationsGetObj
  END INTERFACE cmfe_Solver_SolverEquationsGet

  !>Adds equations sets to solver equations.
  INTERFACE cmfe_SolverEquations_EquationsSetAdd
    MODULE PROCEDURE cmfe_SolverEquations_EquationsSetAddNumber0
    MODULE PROCEDURE cmfe_SolverEquations_EquationsSetAddNumber1
    MODULE PROCEDURE cmfe_SolverEquations_EquationsSetAddObj
  END INTERFACE cmfe_SolverEquations_EquationsSetAdd

  !>Adds an interface condition to solver equations.
  INTERFACE cmfe_SolverEquations_InterfaceConditionAdd
    MODULE PROCEDURE cmfe_SolverEquations_InterfaceConditionAddNumber0
    MODULE PROCEDURE cmfe_SolverEquations_InterfaceConditionAddNumber1
    MODULE PROCEDURE cmfe_SolverEquations_InterfaceConditionAddObj
  END INTERFACE cmfe_SolverEquations_InterfaceConditionAdd

  !>Sets/changes the sparsity type for solver equations.
  INTERFACE cmfe_SolverEquations_SparsityTypeSet
    MODULE PROCEDURE cmfe_SolverEquations_SparsityTypeSetNumber0
    MODULE PROCEDURE cmfe_SolverEquations_SparsityTypeSetNumber1
    MODULE PROCEDURE cmfe_SolverEquations_SparsityTypeSetObj
  END INTERFACE cmfe_SolverEquations_SparsityTypeSet

  !>Finish the creation of boundary conditions for solver equations. \see OpenCMISS::Iron::cmfe_SolverEquations_BoundaryConditionsCreateStart
  INTERFACE cmfe_SolverEquations_BoundaryConditionsCreateFinish
    MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber0
    MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber1
    MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsCreateFinishObj
  END INTERFACE cmfe_SolverEquations_BoundaryConditionsCreateFinish

  !>Start the creation of boundary conditions for solver equations. \see OpenCMISS::Iron::cmfe_SolverEquations_BoundaryConditionsCreateFinish
  INTERFACE cmfe_SolverEquations_BoundaryConditionsCreateStart
    MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsCreateStartNumber0
    MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsCreateStartNumber1
    MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsCreateStartObj
  END INTERFACE cmfe_SolverEquations_BoundaryConditionsCreateStart

  !>Get the boundary conditions for solver equations. \see OpenCMISS::Iron::cmfe_SolverEquations_BoundaryConditionsCreateFinish
  INTERFACE cmfe_SolverEquations_BoundaryConditionsGet
    MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsGetNumber0
    MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsGetNumber1
    MODULE PROCEDURE cmfe_SolverEquations_BoundaryConditionsGetObj
  END INTERFACE cmfe_SolverEquations_BoundaryConditionsGet

  PUBLIC CMFE_SOLVER_LINEAR_TYPE,CMFE_SOLVER_NONLINEAR_TYPE,CMFE_SOLVER_DYNAMIC_TYPE,CMFE_SOLVER_DAE_TYPE, &
    & CMFE_SOLVER_EIGENPROBLEM_TYPE, &
    & CMFE_SOLVER_OPTIMISER_TYPE

  PUBLIC CMFE_SOLVER_CMISS_LIBRARY,CMFE_SOLVER_PETSC_LIBRARY,CMFE_SOLVER_MUMPS_LIBRARY,CMFE_SOLVER_SUPERLU_LIBRARY, &
    & CMFE_SOLVER_SPOOLES_LIBRARY,CMFE_SOLVER_UMFPACK_LIBRARY,CMFE_SOLVER_LUSOL_LIBRARY,CMFE_SOLVER_ESSL_LIBRARY, &
    & CMFE_SOLVER_LAPACK_LIBRARY,CMFE_SOLVER_TAO_LIBRARY,CMFE_SOLVER_HYPRE_LIBRARY,CMFE_SOLVER_PASTIX_LIBRARY

  PUBLIC CMFE_SOLVER_LINEAR_DIRECT_SOLVE_TYPE,CMFE_SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE

  PUBLIC CMFE_SOLVER_DIRECT_LU,CMFE_SOLVER_DIRECT_CHOLESKY,CMFE_SOLVER_DIRECT_SVD

   PUBLIC CMFE_SOLVER_ITERATIVE_RICHARDSON,CMFE_SOLVER_ITERATIVE_CONJUGATE_GRADIENT,CMFE_SOLVER_ITERATIVE_CHEBYSHEV, &
    & CMFE_SOLVER_ITERATIVE_BICONJUGATE_GRADIENT,CMFE_SOLVER_ITERATIVE_GMRES,CMFE_SOLVER_ITERATIVE_BiCGSTAB, &
    & CMFE_SOLVER_ITERATIVE_CONJGRAD_SQUARED

  PUBLIC CMFE_SOLVER_ITERATIVE_NO_PRECONDITIONER,CMFE_SOLVER_ITERATIVE_JACOBI_PRECONDITIONER, &
    & CMFE_SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER,CMFE_SOLVER_ITERATIVE_SOR_PRECONDITIONER, &
    & CMFE_SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER,CMFE_SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER, &
    & CMFE_SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER

  PUBLIC CMFE_SOLVER_NONLINEAR_NEWTON,CMFE_SOLVER_NONLINEAR_BFGS_INVERSE,CMFE_SOLVER_NONLINEAR_SQP
  
  PUBLIC CMFE_SOLVER_NONLINEAR_QUASI_NEWTON

  PUBLIC CMFE_SOLVER_QUASI_NEWTON_LINESEARCH,CMFE_SOLVER_QUASI_NEWTON_TRUSTREGION

  PUBLIC CMFE_SOLVER_QUASI_NEWTON_LBFGS,CMFE_SOLVER_QUASI_NEWTON_GOODBROYDEN,CMFE_SOLVER_QUASI_NEWTON_BADBROYDEN

  PUBLIC CMFE_SOLVER_QUASI_NEWTON_LINESEARCH_BASIC,CMFE_SOLVER_QUASI_NEWTON_LINESEARCH_L2, &
    & CMFE_SOLVER_QUASI_NEWTON_LINESEARCH_CP

  PUBLIC CMFE_SOLVER_QUASI_NEWTON_RESTART_NONE,CMFE_SOLVER_QUASI_NEWTON_RESTART_POWELL, &
    & CMFE_SOLVER_QUASI_NEWTON_RESTART_PERIODIC

  PUBLIC CMFE_SOLVER_QUASI_NEWTON_SCALE_NONE,CMFE_SOLVER_QUASI_NEWTON_SCALE_SHANNO, &
    & CMFE_SOLVER_QUASI_NEWTON_SCALE_LINESEARCH,CMFE_SOLVER_QUASI_NEWTON_SCALE_JACOBIAN
  
  PUBLIC CMFE_SOLVER_NEWTON_LINESEARCH,CMFE_SOLVER_NEWTON_TRUSTREGION

  PUBLIC CMFE_SOLVER_NEWTON_LINESEARCH_LINEAR,CMFE_SOLVER_NEWTON_LINESEARCH_QUADRATIC,CMFE_SOLVER_NEWTON_LINESEARCH_CUBIC
 
  PUBLIC CMFE_SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED,CMFE_SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED, &
    & CMFE_SOLVER_NEWTON_JACOBIAN_FD_CALCULATED

  PUBLIC CMFE_SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT,CMFE_SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM, &
    & CMFE_SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO

  PUBLIC CMFE_SOLVER_DYNAMIC_FIRST_ORDER,CMFE_SOLVER_DYNAMIC_SECOND_ORDER

  PUBLIC CMFE_SOLVER_DYNAMIC_LINEAR,CMFE_SOLVER_DYNAMIC_NONLINEAR

  PUBLIC CMFE_SOLVER_DYNAMIC_FIRST_DEGREE,CMFE_SOLVER_DYNAMIC_SECOND_DEGREE,CMFE_SOLVER_DYNAMIC_THIRD_DEGREE

  PUBLIC CMFE_SOLVER_DYNAMIC_EULER_SCHEME,CMFE_SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME,CMFE_SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME, &
    & CMFE_SOLVER_DYNAMIC_GALERKIN_SCHEME,CMFE_SOLVER_DYNAMIC_ZLAMAL_SCHEME,CMFE_SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME, &
    & CMFE_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME,CMFE_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME, &
    & CMFE_SOLVER_DYNAMIC_NEWMARK1_SCHEME,CMFE_SOLVER_DYNAMIC_NEWMARK2_SCHEME,CMFE_SOLVER_DYNAMIC_NEWMARK3_SCHEME, &
    & CMFE_SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME,CMFE_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME, &
    & CMFE_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME,CMFE_SOLVER_DYNAMIC_HOUBOLT_SCHEME,CMFE_SOLVER_DYNAMIC_WILSON_SCHEME, &
    & CMFE_SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME,CMFE_SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME, &
    & CMFE_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME, &
    & CMFE_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME,CMFE_SOLVER_DYNAMIC_USER_DEFINED_SCHEME

  PUBLIC CMFE_SOLVER_DAE_DIFFERENTIAL_ONLY,CMFE_SOLVER_DAE_INDEX_1,CMFE_SOLVER_DAE_INDEX_2,CMFE_SOLVER_DAE_INDEX_3

  PUBLIC CMFE_SOLVER_DAE_EULER,CMFE_SOLVER_DAE_CRANK_NICOLSON,CMFE_SOLVER_DAE_RUNGE_KUTTA,CMFE_SOLVER_DAE_ADAMS_MOULTON, &
    & CMFE_SOLVER_DAE_BDF, &
    & CMFE_SOLVER_DAE_RUSH_LARSON,CMFE_SOLVER_DAE_EXTERNAL

  PUBLIC CMFE_SOLVER_DAE_EULER_FORWARD,CMFE_SOLVER_DAE_EULER_BACKWARD,CMFE_SOLVER_DAE_EULER_IMPROVED

  PUBLIC CMFE_SOLVER_SOLUTION_INITIALISE_ZERO,CMFE_SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD, &
    & CMFE_SOLVER_SOLUTION_INITIALISE_NO_CHANGE

  PUBLIC CMFE_SOLVER_NO_OUTPUT,CMFE_SOLVER_PROGRESS_OUTPUT,CMFE_SOLVER_TIMING_OUTPUT,CMFE_SOLVER_SOLVER_OUTPUT, &
    & CMFE_SOLVER_MATRIX_OUTPUT

  PUBLIC CMFE_SOLVER_SPARSE_MATRICES,CMFE_SOLVER_FULL_MATRICES

  PUBLIC cmfe_Solver_CellMLEquationsGet

  PUBLIC cmfe_CellMLEquations_CellMLAdd

  PUBLIC cmfe_Solver_DAEEulerSolverTypeGet,cmfe_Solver_DAEEulerSolverTypeSet

  PUBLIC cmfe_Solver_DAESolverTypeGet,cmfe_Solver_DAESolverTypeSet

  PUBLIC cmfe_Solver_DAETimesSet,cmfe_Solver_DAETimeStepSet

  PUBLIC cmfe_Solver_DynamicDegreeGet,cmfe_Solver_DynamicDegreeSet

  PUBLIC cmfe_Solver_DynamicLinearityTypeGet

  PUBLIC cmfe_Solver_DynamicLinearSolverGet,cmfe_Solver_DynamicNonlinearSolverGet

  PUBLIC cmfe_Solver_DynamicSchemeSet

  PUBLIC cmfe_Solver_DynamicThetaSet

  PUBLIC cmfe_Solver_DynamicTimesSet
  
  PUBLIC cmfe_Solver_GeometricTransformationArbitraryPathSet,cmfe_Solver_GeometricTransformationClear
  
  PUBLIC cmfe_Solver_GeometricTransformationNumberOfLoadIncrementsSet
  
  PUBLIC cmfe_Solver_GeometricTransformationScalingsSet
  
  PUBLIC cmfe_Solver_GeometricTransformationFieldSet
  
  PUBLIC cmfe_Solver_GeometricTransformationMatrixSet
  
  PUBLIC cmfe_Solver_GeometricTransformationRotationSet,cmfe_Solver_GeometricTransformationTranslationSet

  PUBLIC cmfe_Solver_LabelGet,cmfe_Solver_LabelSet

  PUBLIC cmfe_Solver_LibraryTypeGet,cmfe_Solver_LibraryTypeSet

  PUBLIC cmfe_Solver_LinearDirectTypeSet

  PUBLIC cmfe_Solver_MumpsSetIcntl,cmfe_Solver_MumpsSetCntl

  PUBLIC cmfe_Solver_LinearIterativeAbsoluteToleranceSet

  PUBLIC cmfe_Solver_LinearIterativeDivergenceToleranceSet

  PUBLIC cmfe_Solver_LinearIterativeGMRESRestartSet

  PUBLIC cmfe_Solver_LinearIterativeMaximumIterationsSet

  PUBLIC cmfe_Solver_LinearIterativePreconditionerTypeSet

  PUBLIC cmfe_Solver_LinearIterativeRelativeToleranceSet

  PUBLIC cmfe_Solver_LinearIterativeTypeSet

  PUBLIC cmfe_Solver_LinearTypeSet

  PUBLIC cmfe_Solver_NewtonAbsoluteToleranceSet

  PUBLIC cmfe_Solver_NewtonLineSearchMonitorOutputSet

  PUBLIC cmfe_Solver_NewtonJacobianCalculationTypeSet

  PUBLIC cmfe_Solver_NewtonLinearSolverGet

  PUBLIC cmfe_Solver_NewtonCellMLSolverGet

  PUBLIC cmfe_Solver_NewtonConvergenceTestTypeSet

  PUBLIC cmfe_Solver_NewtonLineSearchAlphaSet

  PUBLIC cmfe_Solver_NewtonLineSearchMaxStepSet

  PUBLIC cmfe_Solver_NewtonLineSearchStepTolSet

  PUBLIC cmfe_Solver_NewtonLineSearchTypeSet

  PUBLIC cmfe_Solver_NewtonMaximumFunctionEvaluationsSet

  PUBLIC cmfe_Solver_NewtonMaximumIterationsSet

  PUBLIC cmfe_Solver_NewtonRelativeToleranceSet

  PUBLIC cmfe_Solver_NewtonSolutionToleranceSet

  PUBLIC cmfe_Solver_NewtonTrustRegionDelta0Set

  PUBLIC cmfe_Solver_NewtonTrustRegionToleranceSet

  PUBLIC cmfe_Solver_NewtonTypeSet

  PUBLIC cmfe_Solver_QuasiNewtonAbsoluteToleranceSet
  
  PUBLIC cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSet
  
  PUBLIC cmfe_Solver_QuasiNewtonJacobianCalculationTypeSet
  
  PUBLIC cmfe_Solver_QuasiNewtonLinearSolverGet
  
  PUBLIC cmfe_Solver_QuasiNewtonCellMLSolverGet
  
  PUBLIC cmfe_Solver_QuasiNewtonConvergenceTestTypeSet
  
  PUBLIC cmfe_Solver_QuasiNewtonLineSearchMaxStepSet
  
  PUBLIC cmfe_Solver_QuasiNewtonLineSearchStepTolSet
  
  PUBLIC cmfe_Solver_QuasiNewtonLineSearchTypeSet
  
  PUBLIC cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSet
  
  PUBLIC cmfe_Solver_QuasiNewtonMaximumIterationsSet
  
  PUBLIC cmfe_Solver_QuasiNewtonRelativeToleranceSet
  
  PUBLIC cmfe_Solver_QuasiNewtonSolutionToleranceSet
  
  PUBLIC cmfe_Solver_QuasiNewtonTrustRegionDelta0Set
  
  PUBLIC cmfe_Solver_QuasiNewtonTrustRegionToleranceSet
  
  PUBLIC cmfe_Solver_QuasiNewtonRestartSet
  
  PUBLIC cmfe_Solver_QuasiNewtonRestartTypeSet
  
  PUBLIC cmfe_Solver_QuasiNewtonScaleTypeSet
  
  PUBLIC cmfe_Solver_QuasiNewtonSolveTypeSet
  
  PUBLIC cmfe_Solver_QuasiNewtonTypeSet

  PUBLIC cmfe_Solver_NonlinearTypeSet

  PUBLIC cmfe_Solver_OutputTypeSet

  PUBLIC cmfe_Solver_SolverEquationsGet

  PUBLIC cmfe_SolverEquations_EquationsSetAdd

  PUBLIC cmfe_SolverEquations_InterfaceConditionAdd

  PUBLIC cmfe_SolverEquations_SparsityTypeSet

  PUBLIC cmfe_SolverEquations_BoundaryConditionsCreateFinish,cmfe_SolverEquations_BoundaryConditionsCreateStart

  PUBLIC cmfe_SolverEquations_BoundaryConditionsGet

  PUBLIC cmfe_SolverEquations_NumberOfMatricesGet

  PUBLIC cmfe_SolverEquations_MatrixGet

  PUBLIC cmfe_SolverEquations_JacobianMatrixGet

  PUBLIC cmfe_SolverEquations_VectorGet

  PUBLIC cmfe_SolverEquations_ResidualVectorGet

  PUBLIC cmfe_SolverEquations_RhsVectorGet

  PUBLIC cmfe_BioelectricsFiniteElasticity_UpdateGeometricField
  
!!==================================================================================================================================
!!
!! FieldML routines
!!
!!==================================================================================================================================

  !> Provides input and output of fields through the FieldML API
  TYPE cmfe_FieldMLIOType
    PRIVATE
#ifdef USEFIELDML
    TYPE(FIELDML_IO_TYPE), POINTER :: fieldmlInfo
#endif
  END TYPE cmfe_FieldMLIOType

  !> Creates a mesh component using the given FieldML evaluator.
  INTERFACE cmfe_FieldML_InputCreateMeshComponent
    MODULE PROCEDURE cmfe_FieldML_InputCreateMeshComponentObjVS
    MODULE PROCEDURE cmfe_FieldML_InputCreateMeshComponentNumberVS
    MODULE PROCEDURE cmfe_FieldML_InputCreateMeshComponentObjC
    MODULE PROCEDURE cmfe_FieldML_InputCreateMeshComponentNumberC
  END INTERFACE cmfe_FieldML_InputCreateMeshComponent

  !> Creates a field component using the given FieldML evaluator.
  INTERFACE cmfe_FieldML_InputFieldCreateStart
    MODULE PROCEDURE cmfe_FieldML_InputFieldCreateStartObjVS
    MODULE PROCEDURE cmfe_FieldML_InputFieldCreateStartNumberVS
    MODULE PROCEDURE cmfe_FieldML_InputFieldCreateStartObjC
    MODULE PROCEDURE cmfe_FieldML_InputFieldCreateStartNumberC
  END INTERFACE cmfe_FieldML_InputFieldCreateStart

  !> Updates the given field's dofs using the given parameter evaluator.
  INTERFACE cmfe_FieldML_InputFieldParametersUpdate
    MODULE PROCEDURE cmfe_FieldML_InputFieldParametersUpdateObjVS
    MODULE PROCEDURE cmfe_FieldML_InputFieldParametersUpdateNumberVS
    MODULE PROCEDURE cmfe_FieldML_InputFieldParametersUpdateObjC
    MODULE PROCEDURE cmfe_FieldML_InputFieldParametersUpdateNumberC
  END INTERFACE cmfe_FieldML_InputFieldParametersUpdate

  !> Creates a basis using the given FieldML evaluator.
  INTERFACE cmfe_FieldML_InputBasisCreateStart
    MODULE PROCEDURE cmfe_FieldML_InputBasisCreateStartObjVS
    MODULE PROCEDURE cmfe_FieldML_InputBasisCreateStartNumberVS
    MODULE PROCEDURE cmfe_FieldML_InputBasisCreateStartObjC
    MODULE PROCEDURE cmfe_FieldML_InputBasisCreateStartNumberC
  END INTERFACE cmfe_FieldML_InputBasisCreateStart

  !> Creates the region's nodes using the given FieldML evaluator.
  INTERFACE cmfe_FieldML_InputNodesCreateStart
    MODULE PROCEDURE cmfe_FieldML_InputNodesCreateStartObjVS
    MODULE PROCEDURE cmfe_FieldML_InputNodesCreateStartNumberVS
    MODULE PROCEDURE cmfe_FieldML_InputNodesCreateStartObjC
    MODULE PROCEDURE cmfe_FieldML_InputNodesCreateStartNumberC
  END INTERFACE cmfe_FieldML_InputNodesCreateStart

  !> Creates the region's coordinate system using the given FieldML evaluator.
  INTERFACE cmfe_FieldML_InputCoordinateSystemCreateStart
    MODULE PROCEDURE cmfe_FieldML_InputCoordinateSystemCreateStartObjVS
    MODULE PROCEDURE cmfe_FieldML_InputCoordinateSystemCreateStartNumberVS
    MODULE PROCEDURE cmfe_FieldML_InputCoordinateSystemCreateStartObjC
    MODULE PROCEDURE cmfe_FieldML_InputCoordinateSystemCreateStartNumberC
  END INTERFACE cmfe_FieldML_InputCoordinateSystemCreateStart

  !> Creates a mesh using the given FieldML evaluator.
  INTERFACE cmfe_FieldML_InputMeshCreateStart
    MODULE PROCEDURE cmfe_FieldML_InputMeshCreateStartObjVS
    MODULE PROCEDURE cmfe_FieldML_InputMeshCreateStartNumberVS
    MODULE PROCEDURE cmfe_FieldML_InputMeshCreateStartObjC
    MODULE PROCEDURE cmfe_FieldML_InputMeshCreateStartNumberC
  END INTERFACE cmfe_FieldML_InputMeshCreateStart

  !> Initialise the given FieldML context using the given FieldML XML file.
  INTERFACE cmfe_FieldML_InputCreateFromFile
    MODULE PROCEDURE cmfe_FieldML_InputCreateFromFileVS
    MODULE PROCEDURE cmfe_FieldML_InputCreateFromFileC
  END INTERFACE cmfe_FieldML_InputCreateFromFile

  PUBLIC :: cmfe_FieldML_InputCreateFromFile,cmfe_FieldML_InputMeshCreateStart, &
    & cmfe_FieldML_InputCoordinateSystemCreateStart,cmfe_FieldML_InputCreateMeshComponent, &
    & cmfe_FieldML_InputFieldCreateStart,cmfe_FieldML_InputBasisCreateStart,cmfe_FieldML_InputNodesCreateStart, &
    & cmfe_FieldML_InputFieldParametersUpdate

  PUBLIC :: cmfe_FieldMLIO_Finalise,cmfe_FieldMLIO_Initialise,cmfe_FieldMLIO_GetSession

  !> Add the given field to the current FieldML context.
  INTERFACE cmfe_FieldML_OutputAddField
    MODULE PROCEDURE cmfe_FieldML_OutputAddFieldNoTypeObjVS
    MODULE PROCEDURE cmfe_FieldML_OutputAddFieldNoTypeNumberVS
    MODULE PROCEDURE cmfe_FieldML_OutputAddFieldWithTypeObjVS
    MODULE PROCEDURE cmfe_FieldML_OutputAddFieldWithTypeNumberVS
    MODULE PROCEDURE cmfe_FieldML_OutputAddFieldNoTypeObjC
    MODULE PROCEDURE cmfe_FieldML_OutputAddFieldNoTypeNumberC
    MODULE PROCEDURE cmfe_FieldML_OutputAddFieldWithTypeObjC
    MODULE PROCEDURE cmfe_FieldML_OutputAddFieldWithTypeNumberC
  END INTERFACE cmfe_FieldML_OutputAddField

  !> Initialise a new FieldML context.
  INTERFACE cmfe_FieldML_OutputCreate
    MODULE PROCEDURE cmfe_FieldML_OutputCreateObjVS
    MODULE PROCEDURE cmfe_FieldML_OutputCreateNumberVS
    MODULE PROCEDURE cmfe_FieldML_OutputCreateObjC
    MODULE PROCEDURE cmfe_FieldML_OutputCreateNumberC
  END INTERFACE cmfe_FieldML_OutputCreate

  !> Add the given field to the current FieldML context, using only the given components.
  INTERFACE cmfe_FieldML_OutputAddFieldComponents
    MODULE PROCEDURE cmfe_FieldML_OutputAddFieldComponentsObjVS
    MODULE PROCEDURE cmfe_FieldML_OutputAddFieldComponentsNumberVS
    MODULE PROCEDURE cmfe_FieldML_OutputAddFieldComponentsObjC
    MODULE PROCEDURE cmfe_FieldML_OutputAddFieldComponentsNumberC
  END INTERFACE cmfe_FieldML_OutputAddFieldComponents

  !> Write the current FieldML document to the given file.
  INTERFACE cmfe_FieldML_OutputWrite
    MODULE PROCEDURE cmfe_FieldML_OutputWriteVS
    MODULE PROCEDURE cmfe_FieldML_OutputWriteC
  END INTERFACE cmfe_FieldML_OutputWrite

  PUBLIC :: cmfe_FieldMLIOType

  PUBLIC :: cmfe_FieldML_OutputWrite,cmfe_FieldML_OutputAddField,cmfe_FieldML_OutputCreate, &
    & cmfe_FieldML_OutputAddFieldComponents, &
    & cmfe_FieldML_OutputAddImport

!!==================================================================================================================================
!!
!! GENERAL_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the user number of an object.
  INTERFACE cmfe_UserNumberGet
    MODULE PROCEDURE cmfe_UserNumberGetRegion
    MODULE PROCEDURE cmfe_UserNumberGetMesh
    MODULE PROCEDURE cmfe_UserNumberGetBasis
  END INTERFACE cmfe_UserNumberGet

  PUBLIC cmfe_UserNumberGet

!!
!!==================================================================================================================================
!!

CONTAINS

  !
  !================================================================================================================================
  !

  !>Finalises CMISS.
  SUBROUTINE cmfe_Finalise(err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL cmfe_Finalise_(err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('OpenCMISS World Phase')
#endif

    RETURN
999 CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises CMISS returning a user number to the world coordinate system and region.
  SUBROUTINE cmfe_InitialiseNumber(worldCoordinateSystemUserNumber,worldRegionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: worldCoordinateSystemUserNumber !<On return, the world coordinate system user number.
    INTEGER(INTG), INTENT(OUT) :: worldRegionUserNumber !<On return, the world region user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: WORLD_COORDINATE_SYSTEM
    TYPE(REGION_TYPE), POINTER :: WORLD_REGION

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('OpenCMISS World Phase')
#endif

    NULLIFY(WORLD_COORDINATE_SYSTEM)
    NULLIFY(WORLD_REGION)
    CALL cmfe_Initialise_(WORLD_REGION,err,error,*999)
    worldCoordinateSystemUserNumber=0
    worldRegionUserNumber=WORLD_REGION%USER_NUMBER

    RETURN
999 CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InitialiseNumber

  !
  !================================================================================================================================
  !

  !>Initialises CMISS returning a pointer to the world coordinate system and region.
  SUBROUTINE cmfe_InitialiseObj(worldCoordinateSystem,worldRegion,err)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: worldCoordinateSystem !<On return, the world coordinate system.
    TYPE(cmfe_RegionType), INTENT(INOUT) :: worldRegion !<On return, the world region.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('OpenCMISS World Phase')
#endif

    CALL cmfe_CoordinateSystem_Initialise(worldCoordinateSystem,err)
    CALL cmfe_Region_Initialise(worldRegion,err)
    CALL cmfe_Initialise_(worldRegion%region,err,error,*999)

    RETURN
999 CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InitialiseObj

  !
  !================================================================================================================================
  !

  !>Copy an array of cmfe_BasisTypes from C to an allocated Fortran array, for use by the C bindings
  SUBROUTINE cmfe_BasisTypesCopy(bases,basesSize,basesPtr,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: bases(:) !<On return, the array of cmfe_BasisTypes
    INTEGER(C_INT), INTENT(IN) :: basesSize !<The length of the C array of pointers to cmfe_BasisTypes
    TYPE(C_PTR), INTENT(IN) :: basesPtr !<The pointer to the first cmfe_BasisType pointer
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: basis_idx
    TYPE(C_PTR), POINTER :: BasesCPtrs(:)
    TYPE(cmfe_BasisType), POINTER :: Basis

    ENTERS("cmfe_BasisTypesCopy",err,error,*999)

    IF(C_ASSOCIATED(basesPtr)) THEN
      CALL C_F_POINTER(basesPtr,BasesCPtrs,[basesSize])
      IF(ASSOCIATED(BasesCPtrs)) THEN
        DO basis_idx=1,basesSize
          CALL C_F_POINTER(BasesCPtrs(basis_idx),Basis)
          IF(ASSOCIATED(BasesCPtrs)) THEN
            bases(basis_idx)%basis => Basis%basis
          ELSE
            CALL FlagError("error converting C pointer.",ERR,error,*999)
          END IF
        END DO
      ELSE
        CALL FlagError("error converting C pointer.",ERR,error,*999)
      END IF
    ELSE
      CALL FlagError("bases C pointer is not associated.",ERR,error,*999)
    END IF

    EXITS("cmfe_BasisTypesCopy")
    RETURN
999 ERRORSEXITS("cmfe_BasisTypesCopy",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BasisTypesCopy

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_BasisType object.
  SUBROUTINE cmfe_Basis_Finalise(cmfe_Basis,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(OUT) :: cmfe_Basis !<The cmfe_BasisType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Basis%basis)) CALL Basis_Destroy(cmfe_Basis%basis,err,error,*999)

    EXITS("cmfe_Basis_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Basis_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_BasisType object.
  SUBROUTINE cmfe_Basis_Initialise(cmfe_Basis,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(OUT) :: cmfe_Basis !<The cmfe_BasisType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_Initialise",err,error,*999)

    NULLIFY(cmfe_Basis%basis)

    EXITS("cmfe_Basis_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Basis_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_BoundaryConditionsType object.
  SUBROUTINE cmfe_BoundaryConditions_Finalise(cmfe_BoundaryConditions,err)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(OUT) :: cmfe_BoundaryConditions !<The cmfe_BoundaryConditionsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_BoundaryConditions%boundaryConditions))  &
      & CALL BOUNDARY_CONDITIONS_DESTROY(cmfe_BoundaryConditions%boundaryConditions,err,error,*999)

    EXITS("cmfe_BoundaryConditions_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_Finalise
  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_BoundaryConditionsType object.
  SUBROUTINE cmfe_BoundaryConditions_Initialise(cmfe_BoundaryConditions,err)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(OUT) :: cmfe_BoundaryConditions !<The cmfe_BoundaryConditionsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_Initialise",err,error,*999)

    NULLIFY(cmfe_BoundaryConditions%boundaryConditions)

    EXITS("cmfe_BoundaryConditions_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_CellMLType object.
  SUBROUTINE cmfe_CellML_Finalise(cmfe_CellML,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(OUT) :: cmfe_CellML !<The cmfe_CellMLType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_CellML%cellml)) CALL Cellml_Destroy(cmfe_CellML%cellml,err,error,*999)

    EXITS("cmfe_CellML_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_CellML_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_Finalise
  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_CellMLType object.
  SUBROUTINE cmfe_CellML_Initialise(cmfe_CellML,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(OUT) :: cmfe_CellML !<The cmfe_CellMLType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_Initialise",err,error,*999)

    NULLIFY(cmfe_CellML%cellml)

    EXITS("cmfe_CellML_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_CellML_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_CellMLEquationsType object.
  SUBROUTINE cmfe_CellMLEquations_Finalise(cmfe_CellMLEquations,err)

    !Argument variables
    TYPE(cmfe_CellMLEquationsType), INTENT(OUT) :: cmfe_CellMLEquations !<The cmfe_CellMLEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellMLEquations_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_CellMLEquations%cellmlEquations))  &
      & CALL CELLML_EQUATIONS_DESTROY(cmfe_CellMLEquations%cellmlEquations,err,error,*999)

    EXITS("cmfe_CellMLEquations_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_CellMLEquations_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_CellMLEquationsType object.
  SUBROUTINE cmfe_CellMLEquations_Initialise(cmfe_CellMLEquations,err)

    !Argument variables
    TYPE(cmfe_CellMLEquationsType), INTENT(OUT) :: cmfe_CellMLEquations !<The cmfe_CellMLEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellMLEquations_Initialise",err,error,*999)

    NULLIFY(cmfe_CellMLEquations%cellmlEquations)

    EXITS("cmfe_CellMLEquations_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_CellMLEquations_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_Initialise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_ComputationalWorkGroupType object.
  SUBROUTINE cmfe_ComputationalWorkGroup_Initialise(cmfe_ComputationalWorkGroup,err)

    !Argument variables
    TYPE(cmfe_ComputationalWorkGroupType), INTENT(OUT) :: cmfe_ComputationalWorkGroup !<The cmfe_ComputationalWorkGroupType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ComputationalWorkGroup_Initialise",err,error,*999)

    NULLIFY(cmfe_ComputationalWorkGroup%computationalWorkGroup)

    EXITS("cmfe_ComputationalWorkGroup_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_ComputationalWorkGroup_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ComputationalWorkGroup_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_ControlLoopType object.
  SUBROUTINE cmfe_ControlLoop_Finalise(cmfe_ControlLoop,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(OUT) :: cmfe_ControlLoop !<The cmfe_ControlLoopType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_ControlLoop%controlLoop))  &
      & CALL CONTROL_LOOP_DESTROY(cmfe_ControlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_ControlLoop_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_Finalise
  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_ControlLoopType object.
  SUBROUTINE cmfe_ControlLoop_Initialise(cmfe_ControlLoop,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(OUT) :: cmfe_ControlLoop !<The cmfe_ControlLoopType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_Initialise",err,error,*999)

    NULLIFY(cmfe_ControlLoop%controlLoop)

    EXITS("cmfe_ControlLoop_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_CoordinateSystemType object.
  SUBROUTINE cmfe_CoordinateSystem_Finalise(cmfe_CoordinateSystem,err)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(OUT) :: cmfe_CoordinateSystem !<The cmfe_CoordinateSystemType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_CoordinateSystem%coordinateSystem))  &
      & CALL COORDINATE_SYSTEM_DESTROY(cmfe_CoordinateSystem%coordinateSystem,err,error,*999)

    EXITS("cmfe_CoordinateSystem_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_Finalise
  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_CoordinateSystemType object.
  SUBROUTINE cmfe_CoordinateSystem_Initialise(cmfe_CoordinateSystem,err)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(OUT) :: cmfe_CoordinateSystem !<The cmfe_CoordinateSystemType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_Initialise",err,error,*999)

    NULLIFY(cmfe_CoordinateSystem%coordinateSystem)

    EXITS("cmfe_CoordinateSystem_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_DataPointsType object.
  SUBROUTINE cmfe_DataPoints_Finalise(cmfe_DataPoints,err)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(OUT) :: cmfe_DataPoints !<The cmfe_DataPointsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_DataPoints%dataPoints))  &
      & CALL DATA_POINTS_DESTROY(cmfe_DataPoints%dataPoints,err,error,*999)

    EXITS("cmfe_DataPoints_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_DataPointsType object.
  SUBROUTINE cmfe_DataPoints_Initialise(cmfe_DataPoints,err)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(OUT) :: cmfe_DataPoints !<The cmfe_DataPointsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_Initialise",err,error,*999)

    NULLIFY(cmfe_DataPoints%dataPoints)

    EXITS("cmfe_DataPoints_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_DataProjectionType object.
  SUBROUTINE cmfe_DataProjection_Finalise(cmfe_DataProjection,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(OUT) :: cmfe_DataProjection !<The cmfe_DataProjectionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_DataProjection%dataProjection))  &
      & CALL DATA_PROJECTION_DESTROY(cmfe_DataProjection%dataProjection,err,error,*999)

    EXITS("cmfe_DataProjection_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_DataProjectionType object.
  SUBROUTINE cmfe_DataProjection_Initialise(cmfe_DataProjection,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(OUT) :: cmfe_DataProjection !<The cmfe_DataProjectionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_Initialise",err,error,*999)

    NULLIFY(cmfe_DataProjection%dataProjection)

    EXITS("cmfe_DataProjection_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_DecompositionType object.
  SUBROUTINE cmfe_Decomposition_Finalise(cmfe_Decomposition,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(OUT) :: cmfe_Decomposition !<The cmfe_DecompositionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Decomposition%decomposition))  &
      & CALL DECOMPOSITION_DESTROY(cmfe_Decomposition%decomposition,err,error,*999)

    EXITS("cmfe_Decomposition_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_DecompositionType object.
  SUBROUTINE cmfe_Decomposition_Initialise(cmfe_Decomposition,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(OUT) :: cmfe_Decomposition !<The cmfe_DecompositionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_Initialise",err,error,*999)

    NULLIFY(cmfe_Decomposition%decomposition)

    EXITS("cmfe_Decomposition_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_EquationsType object.
  SUBROUTINE cmfe_Equations_Finalise(cmfe_Equations,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(OUT) :: cmfe_Equations !<The cmfe_EquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Equations%equations))  &
      & CALL EQUATIONS_DESTROY(cmfe_Equations%equations,err,error,*999)

    EXITS("cmfe_Equations_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Equations_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_EquationsType object.
  SUBROUTINE cmfe_Equations_Initialise(cmfe_Equations,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(OUT) :: cmfe_Equations !<The cmfe_EquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_Initialise",err,error,*999)

    NULLIFY(cmfe_Equations%equations)

    EXITS("cmfe_Equations_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Equations_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_EquationsSetType object.
  SUBROUTINE cmfe_EquationsSet_Finalise(cmfe_EquationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(OUT) :: cmfe_EquationsSet !<The cmfe_EquationsSetType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_EquationsSet%equationsSet))  &
      & CALL EQUATIONS_SET_DESTROY(cmfe_EquationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_EquationsSetType object.
  SUBROUTINE cmfe_EquationsSet_Initialise(cmfe_EquationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(OUT) :: cmfe_EquationsSet !<The cmfe_EquationsSetType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_Initialise",err,error,*999)

    NULLIFY(cmfe_EquationsSet%equationsSet)

    EXITS("cmfe_EquationsSet_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_FieldType object.
  SUBROUTINE cmfe_Field_Finalise(cmfe_Field,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(OUT) :: cmfe_Field !<The cmfe_FieldType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Field%field)) CALL Field_Destroy(cmfe_Field%field,err,error,*999)

    EXITS("cmfe_Field_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Field_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_FieldType object.
  SUBROUTINE cmfe_Field_Initialise(cmfe_Field,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(OUT) :: cmfe_Field !<The cmfe_FieldType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_Initialise",err,error,*999)

    NULLIFY(cmfe_Field%field)

    EXITS("cmfe_Field_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Field_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_Initialise

  !
  !================================================================================================================================
  !

  !>Creates a cmfe_FieldsType object for an inteface by an object reference.
  SUBROUTINE cmfe_Fields_CreateInterface(interface,fields,err)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to get the fields from
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<On return, the fields attached to the specified interface. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Fields_CreateInterface",err,error,*999)

    IF(ASSOCIATED(interface%interface)) THEN
      IF(ASSOCIATED(fields%fields)) THEN
        CALL FlagError("Fields is already associated.",err,error,*999)
      ELSE
        fields%fields=>interface%interface%fields
      END IF
    ELSE
      CALL FlagError("The interface is not associated.",err,error,*999)
    END IF

    EXITS("cmfe_Fields_CreateInterface")
    RETURN
999 ERRORSEXITS("cmfe_Fields_CreateInterface",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_CreateInterface

  !
  !================================================================================================================================
  !

  !>Creates a cmfe_FieldsType object for a region by an object reference.
  SUBROUTINE cmfe_Fields_CreateRegion(region,fields,err)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to get the fields from
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<On return, the fields attached to the specified region. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Fields_CreateRegion",err,error,*999)

    IF(ASSOCIATED(region%region)) THEN
      IF(ASSOCIATED(fields%fields)) THEN
        CALL FlagError("fields is already associated.",err,error,*999)
      ELSE
        fields%fields=>region%region%fields
      END IF
    ELSE
      CALL FlagError("The region is not associated.",err,error,*999)
    END IF

    EXITS("cmfe_Fields_CreateRegion")
    RETURN
999 ERRORSEXITS("cmfe_Fields_CreateRegion",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_CreateRegion

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_FieldsType object.
  SUBROUTINE cmfe_Fields_Finalise(cmfe_Fields,err)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(OUT) :: cmfe_Fields !<The cmfe_FieldsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Fields_Finalise",err,error,*999)

    NULLIFY(cmfe_Fields%fields)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Fields Type')
#endif

    EXITS("cmfe_Fields_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Fields_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_FieldsType object.
  SUBROUTINE cmfe_Fields_Initialise(cmfe_Fields,err)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(OUT) :: cmfe_Fields !<The cmfe_FieldsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Fields_Initialise",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Fields Type')
#endif

    NULLIFY(cmfe_Fields%fields)

    EXITS("cmfe_Fields_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Fields_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_GeneratedMeshType object.
  SUBROUTINE cmfe_GeneratedMesh_Finalise(cmfe_GeneratedMesh,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(OUT) :: cmfe_GeneratedMesh !<The cmfe_GeneratedMeshType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_GeneratedMesh%generatedMesh))  &
      & CALL GENERATED_MESH_DESTROY(cmfe_GeneratedMesh%generatedMesh,err,error,*999)

    EXITS("cmfe_GeneratedMesh_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_GeneratedMeshType object.
  SUBROUTINE cmfe_GeneratedMesh_Initialise(cmfe_GeneratedMesh,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(OUT) :: cmfe_GeneratedMesh !<The cmfe_GeneratedMeshType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_Initialise",err,error,*999)

    NULLIFY(cmfe_GeneratedMesh%generatedMesh)

    EXITS("cmfe_GeneratedMesh_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_InterfaceType object.
  SUBROUTINE cmfe_Interface_Finalise(cmfe_Interface,err)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(OUT) :: cmfe_Interface !<The cmfe_InterfaceType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Interface%interface))  &
      & CALL Interface_Destroy(cmfe_Interface%interface,err,error,*999)

    EXITS("cmfe_Interface_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Interface_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_InterfaceType object.
  SUBROUTINE cmfe_Interface_Initialise(cmfe_Interface,err)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(OUT) :: cmfe_Interface !<The cmfe_InterfaceType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_Initialise",err,error,*999)

    NULLIFY(cmfe_Interface%interface)

    EXITS("cmfe_Interface_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Interface_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_InterfaceConditionType object.
  SUBROUTINE cmfe_InterfaceCondition_Finalise(cmfe_InterfaceCondition,err)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(OUT) :: cmfe_InterfaceCondition !<The cmfe_InterfaceConditionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_InterfaceCondition%interfaceCondition))  &
      & CALL INTERFACE_CONDITION_DESTROY(cmfe_InterfaceCondition%interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceTypeConditionFinalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_InterfaceConditionType object.
  SUBROUTINE cmfe_InterfaceCondition_Initialise(cmfe_InterfaceCondition,err)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(OUT) :: cmfe_InterfaceCondition !<The cmfe_InterfaceConditionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_Initialise",err,error,*999)

    NULLIFY(cmfe_InterfaceCondition%interfaceCondition)

    EXITS("cmfe_InterfaceCondition_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_Initialise

   !
  !================================================================================================================================
  !

  !>Finalises a cmfe_InterfaceEquationsType object.
  SUBROUTINE cmfe_InterfaceEquations_Finalise(cmfe_InterfaceEquations,err)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(OUT) :: cmfe_InterfaceEquations !<The cmfe_InterfaceEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_InterfaceEquations%interfaceEquations))  &
      & CALL INTERFACE_EQUATIONS_DESTROY(cmfe_InterfaceEquations%interfaceEquations,err,error,*999)

    EXITS("cmfe_InterfaceEquations_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_InterfaceEquationsType object.
  SUBROUTINE cmfe_InterfaceEquations_Initialise(cmfe_InterfaceEquations,err)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(OUT) :: cmfe_InterfaceEquations !<The cmfe_InterfaceEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_Initialise",err,error,*999)

    NULLIFY(cmfe_InterfaceEquations%interfaceEquations)

    EXITS("cmfe_InterfaceEquations_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_Initialise
  
  !
  !================================================================================================================================
  !
  
  !>Finalise a cmfe_InterfaceMeshConnectivityType object.
  SUBROUTINE cmfe_InterfacePointsConnectivity_Finalise(cmfe_InterfacePointsConnectivity,err)
   
    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(OUT) :: cmfe_InterfacePointsConnectivity !<The cmfe_InterfacePointsConnectivityType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfacePointsConnectivity_Finalise",err,error,*999)
    
    IF(ASSOCIATED(cmfe_InterfacePointsConnectivity%pointsConnectivity)) &
      & CALL InterfacePointsConnectivity_DESTROY(cmfe_InterfacePointsConnectivity%pointsConnectivity,err,error,*999)
 
    EXITS("cmfe_InterfacePointsConnectivity_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_InterfacePointsConnectivity_Finalise",err,error)
    CALL cmfe_HandleError(Err,error)
    RETURN
     
  END SUBROUTINE cmfe_InterfacePointsConnectivity_Finalise
  
  !
  !================================================================================================================================
  !
  
  !>Initialises a cmfe_InterfaceMeshConnectivityType object.
  SUBROUTINE cmfe_InterfacePointsConnectivity_Initialise(cmfe_InterfacePointsConnectivity,err)
   
    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(OUT) :: cmfe_InterfacePointsConnectivity !<The cmfe_InterfacePointsConnectivityType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfacePointsConnectivity_Initialise",err,error,*999)
    
    NULLIFY(cmfe_InterfacePointsConnectivity%pointsConnectivity)
 
    EXITS("cmfe_InterfacePointsConnectivity_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_InterfacePointsConnectivity_Initialise",err,error)
    CALL cmfe_HandleError(Err,error)
    RETURN
     
  END SUBROUTINE cmfe_InterfacePointsConnectivity_Initialise

  !
  !================================================================================================================================
  !

   !>Finalises a cmfe_InterfaceMeshConnectivityType object.
   SUBROUTINE cmfe_InterfaceMeshConnectivity_Finalise(cmfe_InterfaceMeshConnectivity,err)

     !Argument variables
     TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(OUT) :: cmfe_InterfaceMeshConnectivity !<The cmfe_InterfaceMeshConnectivityType object to finalise.
     INTEGER(INTG), INTENT(OUT) :: err !<The error code.
     !Local variables

     ENTERS("cmfe_InterfaceMeshConnectivity_Finalise",err,error,*999)

     IF(ASSOCIATED(cmfe_InterfaceMeshConnectivity%meshConnectivity)) &
       & CALL INTERFACE_MESH_CONNECTIVITY_DESTROY(cmfe_InterfaceMeshConnectivity%meshConnectivity,err,error,*999)

     EXITS("cmfe_InterfaceMeshConnectivity_Finalise")
     RETURN
 999 ERRORSEXITS("cmfe_InterfaceMeshConnectivity_Finalise",err,error)
     CALL cmfe_HandleError(err,error)
     RETURN

   END SUBROUTINE cmfe_InterfaceMeshConnectivity_Finalise

  !
  !================================================================================================================================
  !

   !>Initialises a cmfe_InterfaceMeshConnectivityType object.
   SUBROUTINE cmfe_InterfaceMeshConnectivity_Initialise(cmfe_InterfaceMeshConnectivity,err)

     !Argument variables
     TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(OUT) :: cmfe_InterfaceMeshConnectivity !<The cmfe_InterfaceMeshConnectivityType object to initialise.
     INTEGER(INTG), INTENT(OUT) :: err !<The error code.
     !Local variables

     ENTERS("cmfe_InterfaceMeshConnectivity_Initialise",err,error,*999)

     NULLIFY(cmfe_InterfaceMeshConnectivity%meshConnectivity)

     EXITS("cmfe_InterfaceMeshConnectivity_Initialise")
     RETURN
 999 ERRORSEXITS("cmfe_InterfaceMeshConnectivity_Initialise",err,error)
     CALL cmfe_HandleError(err,error)
     RETURN

   END SUBROUTINE cmfe_InterfaceMeshConnectivity_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_HistoryType object.
  SUBROUTINE cmfe_History_Finalise(cmfe_History,err)

    !Argument variables
    TYPE(cmfe_HistoryType), INTENT(OUT) :: cmfe_History !<The cmfe_HistoryType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_History_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_History%history))  &
      & CALL History_Destroy(cmfe_History%history,err,error,*999)

    EXITS("cmfe_History_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_History_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_History_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_HistoryType object.
  SUBROUTINE cmfe_History_Initialise(cmfe_History,err)

    !Argument variables
    TYPE(cmfe_HistoryType), INTENT(OUT) :: cmfe_History !<The cmfe_HistoryType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_History_Initialise",err,error,*999)

    NULLIFY(cmfe_History%history)

    EXITS("cmfe_History_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_History_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_History_Initialise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_DistributedMatrixType object.
  SUBROUTINE cmfe_DistributedMatrix_Initialise(cmfe_DistributedMatrix,err)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(OUT) :: cmfe_DistributedMatrix !<The cmfe_DistributedMatrixType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DistributedMatrix_Initialise",err,error,*999)

    NULLIFY(cmfe_DistributedMatrix%distributedMatrix)

    EXITS("cmfe_DistributedMatrix_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_Initialise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_DistributedVectorType object.
  SUBROUTINE cmfe_DistributedVector_Initialise(cmfe_DistributedVector,err)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(OUT) :: cmfe_DistributedVector !<The cmfe_DistributedVectorType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DistributedVector_Initialise",err,error,*999)

    NULLIFY(cmfe_DistributedVector%distributedVector)

    EXITS("cmfe_DistributedVector_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_MeshType object.
  SUBROUTINE cmfe_Mesh_Finalise(cmfe_Mesh,err)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(OUT) :: cmfe_Mesh !<The cmfe_MeshType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Mesh%mesh))  &
      & CALL Mesh_Destroy(cmfe_Mesh%mesh,err,error,*999)

    EXITS("cmfe_Mesh_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_MeshType object.
  SUBROUTINE cmfe_Mesh_Initialise(cmfe_Mesh,err)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(OUT) :: cmfe_Mesh !<The cmfe_MeshType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_Initialise",err,error,*999)

    NULLIFY(cmfe_Mesh%mesh)

    EXITS("cmfe_Mesh_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_Mesh_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_MeshElementsType object.
  SUBROUTINE cmfe_MeshElements_Finalise(cmfe_MeshElements,err)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(OUT) :: cmfe_MeshElements !<The cmfe_MeshElementsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_MeshElements%meshElements))  &
      & CALL MESH_TOPOLOGY_ELEMENTS_DESTROY(cmfe_MeshElements%meshElements,err,error,*999)

    EXITS("cmfe_MeshElements_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_MeshElementsType object.
  SUBROUTINE cmfe_MeshElements_Initialise(cmfe_MeshElements,err)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(OUT) :: cmfe_MeshElements !<The cmfe_MeshElementsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_Initialise",err,error,*999)

    NULLIFY(cmfe_MeshElements%meshElements)

    EXITS("cmfe_MeshElements_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_MeshNodesType object.
  SUBROUTINE cmfe_MeshNodes_Finalise(cmfe_MeshNodes,err)

    !Argument variables
    TYPE(cmfe_MeshNodesType), INTENT(OUT) :: cmfe_MeshNodes !<The cmfe_MeshNodesType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshNodes_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_MeshNodes%meshNodes))  &
      & CALL MeshTopologyNodesDestroy(cmfe_MeshNodes%meshNodes,err,error,*999)

    EXITS("cmfe_MeshNodes_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_MeshNodesType object.
  SUBROUTINE cmfe_MeshNodes_Initialise(cmfe_MeshNodes,err)

    !Argument variables
    TYPE(cmfe_MeshNodesType), INTENT(OUT) :: cmfe_MeshNodes !<The cmfe_MeshNodesType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshNodes_Initialise",err,error,*999)

    NULLIFY(cmfe_MeshNodes%meshNodes)

    EXITS("cmfe_MeshNodes_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_NodesType object.
  SUBROUTINE cmfe_Nodes_Finalise(cmfe_Nodes,err)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(OUT) :: cmfe_Nodes !<The cmfe_NodesType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Nodes%nodes)) CALL Nodes_Destroy(cmfe_Nodes%nodes,err,error,*999)

    EXITS("cmfe_Nodes_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_NodesType object.
  SUBROUTINE cmfe_Nodes_Initialise(cmfe_Nodes,err)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(OUT) :: cmfe_Nodes !<The cmfe_NodesType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_Initialise",err,error,*999)

    NULLIFY(cmfe_Nodes%nodes)

    EXITS("cmfe_Nodes_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_ProblemType object.
  SUBROUTINE cmfe_Problem_Finalise(cmfe_Problem,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(OUT) :: cmfe_Problem !<The cmfe_ProblemType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Problem%problem)) CALL Problem_Destroy(cmfe_Problem%problem,err,error,*999)

    EXITS("cmfe_Problem_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Problem_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_ProblemType object.
  SUBROUTINE cmfe_Problem_Initialise(cmfe_Problem,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(OUT) :: cmfe_Problem !<The cmfe_ProblemType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_Initialise",err,error,*999)

    NULLIFY(cmfe_Problem%problem)

    EXITS("cmfe_Problem_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Problem_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_QuadratureType object.
  SUBROUTINE cmfe_Quadrature_Finalise(cmfe_Quadrature,err)

    !Argument variables
    TYPE(cmfe_QuadratureType), INTENT(OUT) :: cmfe_Quadrature !<The cmfe_QuadratureType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Quadrature_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Quadrature%quadrature))  &
      & CALL BASIS_QUADRATURE_DESTROY(cmfe_Quadrature%quadrature,err,error,*999)

    EXITS("cmfe_Quadrature_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Quadrature_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Quadrature_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_QuadratureType object.
  SUBROUTINE cmfe_Quadrature_Initialise(cmfe_Quadrature,err)

    !Argument variables
    TYPE(cmfe_QuadratureType), INTENT(OUT) :: cmfe_Quadrature !<The cmfe_QuadratureType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Quadrature_Initialise",err,error,*999)

    NULLIFY(cmfe_Quadrature%quadrature)

    EXITS("cmfe_Quadrature_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Quadrature_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Quadrature_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_RegionType object.
  SUBROUTINE cmfe_Region_Finalise(cmfe_Region,err)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(OUT) :: cmfe_Region !<The cmfe_RegionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Region%region))  &
      & CALL Region_Destroy(cmfe_Region%region,err,error,*999)

    EXITS("cmfe_Region_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Region_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_RegionType object.
  SUBROUTINE cmfe_Region_Initialise(cmfe_Region,err)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(OUT) :: cmfe_Region !<The cmfe_RegionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_Initialise",err,error,*999)

    NULLIFY(cmfe_Region%region)

    EXITS("cmfe_Region_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Region_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_SolverType object.
  SUBROUTINE cmfe_Solver_Finalise(cmfe_Solver,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(OUT) :: cmfe_Solver !<The cmfe_SolverType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_Solver%solver)) CALL Solver_Destroy(cmfe_Solver%solver,err,error,*999)

    EXITS("cmfe_Solver_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_Solver_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_SolverType object.
  SUBROUTINE cmfe_Solver_Initialise(cmfe_Solver,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(OUT) :: cmfe_Solver !<The cmfe_SolverType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_Initialise",err,error,*999)

    NULLIFY(cmfe_Solver%solver)

    EXITS("cmfe_Solver_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_Solver_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a cmfe_SolverEquationsType object.
  SUBROUTINE cmfe_SolverEquations_Finalise(cmfe_SolverEquations,err)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(OUT) :: cmfe_SolverEquations !<The cmfe_SolverEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_SolverEquations_Finalise",err,error,*999)

    IF(ASSOCIATED(cmfe_SolverEquations%solverEquations))  &
      & CALL SOLVER_EQUATIONS_DESTROY(cmfe_SolverEquations%solverEquations,err,error,*999)

    EXITS("cmfe_SolverEquations_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_Finalise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a cmfe_SolverEquationsType object.
  SUBROUTINE cmfe_SolverEquations_Initialise(cmfe_SolverEquations,err)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(OUT) :: cmfe_SolverEquations !<The cmfe_SolverEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_SolverEquations_Initialise",err,error,*999)

    NULLIFY(cmfe_SolverEquations%solverEquations)

    EXITS("cmfe_SolverEquations_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_Initialise

!!==================================================================================================================================
!!
!! ANALYTIC_ANALYSIS_ROUTINES
!!
!!==================================================================================================================================

  !>Output the analytic error analysis for a field specified by a user number compared to the analytic values parameter set.
  SUBROUTINE cmfe_AnalyticAnalysis_OutputNumber(regionUserNumber,fieldUserNumber,fileName,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<If not empty, the filename to output the analytic analysis to. If empty, the analysis will be output to the standard output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_OutputNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL AnalyticAnalysis_Output(field,fileName,err,error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_AnalyticAnalysis_OutputNumber")
    RETURN
999 ERRORSEXITS("cmfe_AnalyticAnalysis_OutputNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_OutputNumber

  !
  !================================================================================================================================
  !

  !>Output the analytic error analysis for a field identified by an object compared to the analytic values parameter set.
  SUBROUTINE cmfe_AnalyticAnalysis_OutputObj(field,fileName,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<If not empty, the filename to output the analytic analysis to. If empty, the analysis will be output to the standard output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_OutputObj",err,error,*999)

    CALL AnalyticAnalysis_Output(field%field,fileName,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_OutputObj")
    RETURN
999 ERRORSEXITS("cmfe_AnalyticAnalysis_OutputObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_OutputObj

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeNumber(regionUserNumber,fieldUserNumber,variableType,versionNumber, &
    & derivativeNumber, nodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_AbsoluteErrorGetNode(FIELD,variableType,versionNumber,derivativeNumber,nodeNumber, &
          & componentNumber,value,ERR, error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeObj(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeObj",err,error,*999)

    CALL AnalyticAnalysis_AbsoluteErrorGetNode(field%field,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetNodeObj

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetNodeNumber(regionUserNumber,fieldUserNumber,variableType,versionNumber, &
    & derivativeNumber,nodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_PercentageErrorGetNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_PercentageErrorGetNode(FIELD,variableType,versionNumber,derivativeNumber,nodeNumber, &
          & componentNumber,value,ERR,error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetNodeNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_PercentageErrorGetNodeNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetNodeNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetNodeObj(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_PercentageErrorGetNodeObj",err,error,*999)

    CALL AnalyticAnalysis_PercentageErrorGetNode(field%field,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetNodeObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_PercentageErrorGetNodeObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetNodeObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetNodeObj


  !
  !================================================================================================================================
  !

  !>Get relative error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetNodeNumber(regionUserNumber,fieldUserNumber,variableType,versionNumber, &
    & derivativeNumber,nodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_RelativeErrorGetNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_RelativeErrorGetNode(FIELD,variableType,versionNumber,derivativeNumber,nodeNumber, &
          & componentNumber,value,ERR,error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetNodeNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_RelativeErrorGetNodeNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetNodeNumber")
    CALL cmfe_HandleError(err,error)
    RETURN
    
  END SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetNodeObj(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_RelativeErrorGetNodeObj",err,error,*999)

    CALL AnalyticAnalysis_RelativeErrorGetNode(field%field,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysisRelativeErrorGetNodeObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysisRelativeErrorGetNodeObj",err,error)
    EXITS("cmfe_AnalyticAnalysisRelativeErrorGetNodeObj")
    CALL cmfe_HandleError(err,error)
   RETURN

 END SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetNodeObj

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetElementNumber(regionUserNumber,fieldUserNumber,variableType,elementNumber, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_AbsoluteErrorGetElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_AbsoluteErrorGetElement(FIELD,variableType,elementNumber,componentNumber,value,ERR,error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetElementNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_AbsoluteErrorGetElementNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetElementNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetElementObj(field,variableType,elementNumber,componentNumber,VALUE,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_AbsoluteErrorGetElementObj",err,error,*999)

    CALL AnalyticAnalysis_AbsoluteErrorGetElement(field%field,variableType,elementNumber,componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetElementObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_AbsoluteErrorGetElementObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetElementObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetElementObj

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetElementNumber(regionUserNumber,fieldUserNumber,variableType,elementNumber, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_PercentageErrorGetElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_PercentageErrorGetElement(field,variableType,elementNumber,componentNumber,value,ERR,error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetElementNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_PercentageErrorGetElementNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetElementNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetElementObj(field,variableType,elementNumber,componentNumber,VALUE,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_PercentageErrorGetElementObj",err,error,*999)

    CALL AnalyticAnalysis_PercentageErrorGetElement(field%field,variableType,elementNumber,componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetElementObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_PercentageErrorGetElementObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetElementObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetElementObj


  !
  !================================================================================================================================
  !

  !>Get relative error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetElementNumber(regionUserNumber,fieldUserNumber,variableType,elementNumber, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_RelativeErrorGetElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_RelativeErrorGetElement(field,variableType,elementNumber,componentNumber,value,err,error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetElementNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_RelativeErrorGetElementNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetElementNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetElementObj(field,variableType,elementNumber,componentNumber,VALUE,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: value !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_RelativeErrorGetElementObj",err,error,*999)

    CALL AnalyticAnalysis_RelativeErrorGetElement(field%field,variableType,elementNumber,componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetElementObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_RelativeErrorGetElementObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetElementObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetElementObj

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_AbsoluteErrorGetConstant(FIELD,variableType,componentNumber,value,ERR,error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantNumber

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantObj(field,variableType,componentNumber,VALUE,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantObj",err,error,*999)

    CALL AnalyticAnalysis_AbsoluteErrorGetConstant(field%field,variableType,componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_AbsoluteErrorGetConstantObj

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetConstantNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_PercentageErrorGetConstantNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_PercentageErrorGetConstant(FIELD,variableType,componentNumber,value,ERR,error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetConstantNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_PercentageErrorGetConstantNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetConstantNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetConstantNumber

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetConstantObj(field,variableType,componentNumber,VALUE,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_PercentageErrorGetConstantObj",err,error,*999)

    CALL AnalyticAnalysis_PercentageErrorGetConstant(field%field,variableType,componentNumber,value,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetConstantObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_PercentageErrorGetConstantObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_PercentageErrorGetConstantObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_PercentageErrorGetConstantObj


  !
  !================================================================================================================================
  !

  !>Get relative error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetConstantNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_RelativeErrorGetConstantNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_RelativeErrorGetConstant(FIELD,variableType,componentNumber,value,ERR,error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetConstantNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_RelativeErrorGetConstantNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetConstantNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetConstantNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetConstantObj(field,variableType,componentNumber,VALUE,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_RelativeErrorGetConstantObj",err,error,*999)

    CALL AnalyticAnalysis_RelativeErrorGetConstant(field%field,variableType,componentNumber,value,ERR,error,*999)

    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetConstantObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_RelativeErrorGetConstantObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_RelativeErrorGetConstantObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_RelativeErrorGetConstantObj

  !
  !================================================================================================================================
  !

  !>Get rms error value for nodes in a field compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RMSErrorGetNodeNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber,errorType, &
    & localValue,localGhostValue,globalValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    INTEGER(INTG), INTENT(IN) :: errorType !<error type
    REAL(DP), INTENT(OUT) :: localValue(8) !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue(8) !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue(8) !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_RMSErrorGetNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_RMSErrorGetNode(FIELD,variableType,componentNumber,errorType,localValue,localGhostValue, &
          & globalValue,ERR,error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_RMSErrorGetNodeNumber")
    RETURN
999 ERRORSEXITS("cmfe_AnalyticAnalysis_RMSErrorGetNodeNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_RMSErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get rms error value for nodes in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RMSErrorGetNodeObj(field,variableType,componentNumber,errorType,localValue,localGhostValue, &
    & globalValue,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    INTEGER(INTG), INTENT(IN) :: errorType !<error type
    REAL(DP), INTENT(OUT) :: localValue(8) !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue(8) !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue(8) !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_RMSErrorGetNodeObj",err,error,*999)

    CALL AnalyticAnalysis_RMSErrorGetNode(field%field,variableType,componentNumber,errorType,localValue,localGhostValue, &
      & globalValue,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_RMSErrorGetNodeObj")
    RETURN
999 ERRORSEXITS("cmfe_AnalyticAnalysis_RMSErrorGetNodeObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_RMSErrorGetNodeObj

  !
  !================================================================================================================================
  !

  !>Get rms error value for elements in a field compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RMSErrorGetElementNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & errorType,localValue,localGhostValue,globalValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    INTEGER(INTG), INTENT(IN) :: errorType !<error type
    REAL(DP), INTENT(OUT) :: localValue !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_RMSErrorGetElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_RMSErrorGetElement(FIELD,variableType,componentNumber,errorType,localValue,localGhostValue, &
          & globalValue,ERR,error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_RMSErrorGetElementNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_RMSErrorGetElementNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_RMSErrorGetElementNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_RMSErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE cmfe_AnalyticAnalysis_RMSErrorGetElementObj(field,variableType,componentNumber,errorType,localValue,localGhostValue, &
    & globalValue,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    INTEGER(INTG), INTENT(IN) :: errorType !<error type
    REAL(DP), INTENT(OUT) :: localValue !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_RMSErrorGetNodeObj",err,error,*999)

    CALL AnalyticAnalysis_RMSErrorGetElement(field%field,variableType,componentNumber,errorType,localValue,localGhostValue, &
      & globalValue,ERR,error,*999)

    EXITS("cmfe_AnalyticAnalysis_RMSErrorGetElementObj")
    RETURN
999 ERRORSEXITS("cmfe_AnalyticAnalysis_RMSErrorGetElementObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_RMSErrorGetElementObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the numerical values.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralNumericalValueGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_IntegralNumericalValueGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_IntegralNumericalValueGet(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_IntegralNumericalValueGetNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralNumericalValueGetNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralNumericalValueGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralNumericalValueGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the numerical values.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralNumericalValueGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_IntegralNumericalValueGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralNumericalValueGet(field%field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralNumericalValueGetObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralNumericalValueGetObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralNumericalValueGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralNumericalValueGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the analytic values.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralAnalyticValueGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_IntegralAnalyticValueGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_IntegralAnalyticValueGet(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_IntegralAnalyticValueGetNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralAnalyticValueGetNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralAnalyticValueGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralAnalyticValueGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the analytic values.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralAnalyticValueGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_IntegralAnalyticValueGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralAnalyticValueGet(field%field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralAnalyticValueGetObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralAnalyticValueGetObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralAnalyticValueGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralAnalyticValueGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the percentage errors.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralPercentageErrorGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_IntegralPercentageErrorGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_IntegralPercentageErrorGet(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_IntegralPercentageErrorGetNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralPercentageErrorGetNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralPercentageErrorGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralPercentageErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the percentage errors.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralPercentageErrorGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_IntegralPercentageErrorGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralPercentageErrorGet(field%field,variableType,componentNumber,integralValue, &
      & ghostIntegralValue,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralPercentageErrorGetObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralPercentageErrorGetObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralPercentageErrorGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN
    
  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralPercentageErrorGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the absolute errors.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_IntegralAbsoluteErrorGet(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the absolute errors.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralAbsoluteErrorGet(field%field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralAbsoluteErrorGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the relative error.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralRelativeErrorGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_IntegralRelativeErrorGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_IntegralRelativeErrorGet(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_IntegralRelativeErrorGetNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralRelativeErrorGetNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralRelativeErrorGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralRelativeErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the relative error.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralRelativeErrorGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_IntegralRelativeErrorGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralRelativeErrorGet(field%field,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralRelativeErrorGetObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralRelativeErrorGetObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralRelativeErrorGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralRelativeErrorGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid numerical.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber(regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_IntegralNIDNumericalValueGet(FIELD,variableType,componentNumber,integralValue, &
          & ghostIntegralValue,ERR,error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid numerical.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_IntegralNidNumericalValueGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralNIDNumericalValueGet(field%field,variableType,componentNumber,integralValue, &
      & ghostIntegralValue,err,error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralNidNumericalValueGetObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralNidNumericalValueGetObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralNidNumericalValueGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralNIDNumericalValueGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid error.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralNIDErrorGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_AnalyticAnalysis_IntegralNidErrorGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL AnalyticAnalysis_IntegralNIDErrorGet(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue,ERR, &
          & error,*999)
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_AnalyticAnalysis_IntegralNidErrorGetNumber")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralNidErrorGetNumber",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralNidErrorGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralNidErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid error.
  SUBROUTINE cmfe_AnalyticAnalysis_IntegralNIDErrorGetObj(field,variableType,componentNumber,integralValue,ghostIntegralValue,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_AnalyticAnalysis_IntegralNIDErrorGetObj",err,error,*999)

    CALL AnalyticAnalysis_IntegralNIDErrorGet(field%field,variableType,componentNumber,integralValue,ghostIntegralValue,ERR, &
      & error,*999)

    EXITS("cmfe_AnalyticAnalysis_IntegralNIDErrorGetObj")
    RETURN
999 ERRORS("cmfe_AnalyticAnalysis_IntegralNIDErrorGetObj",err,error)
    EXITS("cmfe_AnalyticAnalysis_IntegralNIDErrorGetObj")
     CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_AnalyticAnalysis_IntegralNIDErrorGetObj
  

!!==================================================================================================================================
!!
!! BASE_ROUTINES
!!
!!==================================================================================================================================

  !>Sets diagnostics off. \see OpenCMISS::Iron::cmfe_DiagnosticsSetOn
  SUBROUTINE cmfe_DiagnosticsSetOff(err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_DiagnosticsSetOff",err,error,*999)

    CALL DIAGNOSTICS_SET_OFF(err,error,*999)

    EXITS("cmfe_DiagnosticsSetOff")
    RETURN
999 ERRORSEXITS("cmfe_DiagnosticsSetOff",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DiagnosticsSetOff

  !
  !================================================================================================================================
  !

  !>Sets diagnostics on \see OpenCMISS::Iron::cmfe_DiagnosticsSetOff
  SUBROUTINE cmfe_DiagnosticsSetOn(diagType,levelList,diagFilename,routineList,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: diagType !<The type of diagnostics to set on \see OPENCMISS_DiagnosticTypes.
    INTEGER(INTG), INTENT(IN) :: levelList(:) !<The list of diagnostic levels to set on.
    CHARACTER(LEN=*), INTENT(IN) :: diagFilename !<If present the name of the file to output diagnostic information to. If omitted the diagnostic output is sent to the screen.
    CHARACTER(LEN=*), INTENT(IN) :: routineList(:) !<The list of routines to set diagnostics on in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_DiagnosticsSetOn",err,error,*999)

    CALL DIAGNOSTICS_SET_ON(diagType,levelList,diagFilename,routineList,err,error,*999)

    EXITS("cmfe_DiagnosticsSetOn")
    RETURN
999 ERRORSEXITS("cmfe_DiagnosticsSetOn",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DiagnosticsSetOn

  !
  !================================================================================================================================
  !

  !>Sets output off \see OpenCMISS::Iron::cmfe_OutputSetOff
  SUBROUTINE cmfe_OutputSetOff(err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_OutputSetOff",err,error,*999)

    CALL OUTPUT_SET_OFF(err,error,*999)

    EXITS("cmfe_OutputSetOff")
    RETURN
999 ERRORSEXITS("cmfe_OutputSetOff",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_OutputSetOff

  !
  !================================================================================================================================
  !

  !>Sets output on \see OpenCMISS::Iron::cmfe_OutputSetOff
  SUBROUTINE cmfe_OutputSetOn(echoFilename,err)

    !Argument variables
    CHARACTER(LEN=*), INTENT(IN) :: echoFilename !<The filename of the file to echo output to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_OutputSetOn",err,error,*999)

    CALL OUTPUT_SET_ON(echoFilename,err,error,*999)

    EXITS("cmfe_OutputSetOn")
    RETURN
999 ERRORSEXITS("cmfe_OutputSetOn",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_OutputSetOn

  !
  !================================================================================================================================
  !

  !>Sets timing off \see OpenCMISS::Iron::cmfe_TimingSetOn
  SUBROUTINE cmfe_TimingSetOff(err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_TimingSetOff",ERR,error,*999)

    CALL TIMING_SET_OFF(err,error,*999)

    EXITS("cmfe_TimingSetOff")
    RETURN
999 ERRORSEXITS("cmfe_TimingSetOff",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_TimingSetOff

  !
  !================================================================================================================================
  !

  !>Sets timing on \see OpenCMISS::Iron::cmfe_TimingSetOff
  SUBROUTINE cmfe_TimingSetOn(timingType,timingSummaryFlag,timingFilename,routineList,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: timingType !<The type of timing to set on \see OPENCMISS_TimingTypes.
    LOGICAL, INTENT(IN) :: timingSummaryFlag !<.TRUE. if the timing information will be output with subsequent OpenCMISS::Iron::cmfe_TimingSummaryOutput calls, .FALSE. if the timing information will be output every time the routine exits.
    CHARACTER(LEN=*), INTENT(IN) :: timingFilename !<If present the name of the file to output timing information to. If omitted the timing output is sent to the screen.
    CHARACTER(LEN=*), INTENT(IN) :: routineList(:) !<The list of routines to set timing on in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_TimingSetOn",err,error,*999)

    CALL TIMING_SET_ON(timingType,timingSummaryFlag,timingFilename,routineList,err,error,*999)

    EXITS("cmfe_TimingSetOn")
    RETURN
999 ERRORSEXITS("cmfe_TimingSetOn",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_TimingSetOn

  !
  !================================================================================================================================
  !

  !>Outputs the timing summary.
  SUBROUTINE cmfe_TimingSummaryOutput(err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    !Local variables

    ENTERS("cmfe_TimingSummaryOutput",err,error,*999)

    CALL TIMING_SUMMARY_OUTPUT(err,error,*999)

    EXITS("cmfe_TimingSummaryOutput")
    RETURN
999 ERRORSEXITS("cmfe_TimingSummaryOutput",err,error)
    RETURN

  END SUBROUTINE cmfe_TimingSummaryOutput

!!==================================================================================================================================
!!
!! BASIS_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the collapsed Xi flags of a basis identified by a user number.
  SUBROUTINE cmfe_Basis_CollapsedXiGetNumber(userNumber,collapsedXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the collapsed Xi flags for.
    INTEGER(INTG), INTENT(OUT) :: collapsedXi(:) !<collapsedXi(ni). On return, the collapsed Xi parameter for the ni'th Xi direction. \see OPENCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_CollapsedXiGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_COLLAPSED_XI_GET(BASIS,collapsedXi,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_CollapsedXiGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_CollapsedXiGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_CollapsedXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the collapsed Xi flags of a basis identified by an object.
  SUBROUTINE cmfe_Basis_CollapsedXiGetObj(basis,collapsedXi,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the collapsed Xi flags for.
    INTEGER(INTG), INTENT(OUT) :: collapsedXi(:) !<collapsedXi(ni). On return, the collapsed Xi parameter for the ni'th Xi direction. \see OPENCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_CollapsedXiGetObj",err,error,*999)

    CALL BASIS_COLLAPSED_XI_GET(basis%basis,collapsedXi,err,error,*999)

    EXITS("cmfe_Basis_CollapsedXiGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_CollapsedXiGetObj",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_Basis_CollapsedXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the collapsed Xi flags of a basis identified by a user number.
  SUBROUTINE cmfe_Basis_CollapsedXiSetNumber(userNumber,collapsedXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to set the collapsed Xi flags for.
    INTEGER(INTG), INTENT(IN) :: collapsedXi(:) !<collapsedXi(ni). The collapsed Xi parameter for the ni'th Xi direction to set. \see OPENCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_CollapsedXiSetNumber",ERR,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_COLLAPSED_XI_SET(BASIS,collapsedXi,err,error,*999)
    ELSE
     localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_CollapsedXiSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_CollapsedXiSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_CollapsedXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the collapsed Xi flags of a basis identified by an object.
  SUBROUTINE cmfe_Basis_CollapsedXiSetObj(basis,collapsedXi,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to set the collapsed Xi flags for.
    INTEGER(INTG), INTENT(IN) :: collapsedXi(:) !<collapsedXi(ni). The collapsed Xi parameter for the ni'th Xi direction to set. \see OPENCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_CollapsedXiSetObj",err,error,*999)

    CALL BASIS_COLLAPSED_XI_SET(basis%basis,collapsedXi,err,error,*999)

    EXITS("cmfe_Basis_CollapsedXiSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_CollapsedXiSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_CollapsedXiSetObj

  !
  !================================================================================================================================
  !

   !>Finishes the creation of a new basis identified by a user number.
  SUBROUTINE cmfe_Basis_CreateFinishNumber(userNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_CreateFinishNumber",ERR,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,err,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_CREATE_FINISH(Basis,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Basis Create')
#endif

    EXITS("cmfe_Basis_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a new basis identified by an object.
  SUBROUTINE cmfe_Basis_CreateFinishObj(basis,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_Basis_CreateFinishObj",err,error,*999)

    CALL BASIS_CREATE_FINISH(basis%basis,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('basis Create')
#endif

    EXITS("cmfe_Basis_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new basis for a basis identified by a user number.
  SUBROUTINE cmfe_Basis_CreateStartNumber(userNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS

    ENTERS("cmfe_Basis_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Basis Create')
#endif

    NULLIFY(BASIS)
    CALL BASIS_CREATE_START(userNumber,BASIS,err,error,*999)

    EXITS("cmfe_Basis_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new basis for a basis identified by an object.
  SUBROUTINE cmfe_Basis_CreateStartObj(userNumber,basis,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to start the creation of.
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<On exit, the newly created basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('basis Create')
#endif

    CALL BASIS_CREATE_START(userNumber,basis%basis,err,error,*999)

    EXITS("cmfe_Basis_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a basis identified by its basis user number.
  SUBROUTINE cmfe_Basis_DestroyNumber(userNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_DestroyNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_DESTROY(BASIS,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a basis identified by an object.
  SUBROUTINE cmfe_Basis_DestroyObj(basis,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_DestroyObj",err,error,*999)

    CALL BASIS_DESTROY(basis%basis,err,error,*999)

    EXITS("cmfe_Basis_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_DestroyObj

  !
  !================================================================================================================================
  !

  !>Get the interpolation type in each xi directions for a basis identified by a user number.
  SUBROUTINE cmfe_Basis_InterpolationXiGetNumber(userNumber,interpolationXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: interpolationXi(:) !<On return, the interpolation xi parameters for each Xi direction \see OPENCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_InterpolationXiGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_INTERPOLATION_XI_GET(BASIS,interpolationXi,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_InterpolationXiGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_InterpolationXiGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_InterpolationXiGetNumber

  !
  !================================================================================================================================
  !

  !>Get the interpolation type in each xi directions for a basis indentified by an object.
  SUBROUTINE cmfe_Basis_InterpolationXiGetObj(basis,interpolationXi,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: interpolationXi(:) !<On return, the interpolation xi parameters for each Xi direction \see OPENCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_InterpolationXiGetObj",err,error,*999)

    CALL BASIS_INTERPOLATION_XI_GET(basis%basis,interpolationXi,err,error,*999)

    EXITS("cmfe_Basis_InterpolationXiGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_InterpolationXiGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    EXITS("cmfe_Basis_InterpolationXiGetObj")
    RETURN

  END SUBROUTINE cmfe_Basis_InterpolationXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type in each xi directions for a basis identified by a user number.
  SUBROUTINE cmfe_Basis_InterpolationXiSetNumber(userNumber,interpolationXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(IN) :: interpolationXi(:) !<The interpolation xi parameters for each Xi direction \see OPENCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_InterpolationXiSetNumber",ERR,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_INTERPOLATION_XI_SET(BASIS,interpolationXi,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_InterpolationXiSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_InterpolationXiSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_InterpolationXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type in each xi directions for a basis indentified by an object.
  SUBROUTINE cmfe_Basis_InterpolationXiSetObj(basis,interpolationXi,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(IN) :: interpolationXi(:) !<The interpolation xi parameters for each Xi direction \see OPENCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_InterpolationXiSetObj",err,error,*999)

    CALL BASIS_INTERPOLATION_XI_SET(basis%basis,interpolationXi,err,error,*999)

    EXITS("cmfe_Basis_InterpolationXiSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_InterpolationXiSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_InterpolationXiSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of local nodes in a basis identified by a user number.
  SUBROUTINE cmfe_Basis_NumberOfLocalNodesGetNumber(userNumber,numberOfLocalNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfLocalNodes !<On return, the number of local nodes in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_NumberOfLocalNodesGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_NUMBER_OF_LOCAL_NODES_GET(BASIS,numberOfLocalNodes,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_NumberOfLocalNodesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_NumberOfLocalNodesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_NumberOfLocalNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of local nodes in a basis identified by an object.
  SUBROUTINE cmfe_Basis_NumberOfLocalNodesGetObj(basis,numberOfLocalNodes,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the number of local nodes for.
    INTEGER(INTG), INTENT(OUT) :: numberOfLocalNodes !<On return, the number of local nodes in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_NumberOfLocalNodesGetObj",err,error,*999)

    CALL BASIS_NUMBER_OF_LOCAL_NODES_GET(basis%basis,numberOfLocalNodes,err,error,*999)

    EXITS("cmfe_Basis_NumberOfLocalNodesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_NumberOfLocalNodesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_NumberOfLocalNodesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of Xi directions in a basis identified by a user number.
  SUBROUTINE cmfe_Basis_NumberOfXiGetNumber(userNumber,numberOfXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the number xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfXi !<On return, the number of xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_NumberOfXiGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_NUMBER_OF_XI_GET(BASIS,numberOfXi,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_NumberOfXiGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_NumberOfXiGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_NumberOfXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of Xi directions in a basis identified by an object.
  SUBROUTINE cmfe_Basis_NumberOfXiGetObj(basis,numberOfXi,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the number of xi directions for.
    INTEGER(INTG), INTENT(OUT) :: numberOfXi !<On return, the number of xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_NumberOfXiGetObj",err,error,*999)

    CALL BASIS_NUMBER_OF_XI_GET(basis%basis,numberOfXi,err,error,*999)

    EXITS("cmfe_Basis_NumberOfXiGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_NumberOfXiGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_NumberOfXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of Xi directions in a basis identified by a user number.
  SUBROUTINE cmfe_Basis_NumberOfXiSetNumber(userNumber,numberOfXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to set the number xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfXi !<The number of xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_NumberOfXiSetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_NUMBER_OF_XI_SET(BASIS,numberOfXi,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_NumberOfXiSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_NumberOfXiSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_NumberOfXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of Xi directions in a basis identified by an object.
  SUBROUTINE cmfe_Basis_NumberOfXiSetObj(basis,numberOfXi,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to set the number of xi directions for.
    INTEGER(INTG), INTENT(IN) :: numberOfXi !<The number of xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_NumberOfXiSetObj",err,error,*999)

    CALL BASIS_NUMBER_OF_XI_SET(basis%basis,numberOfXi,err,error,*999)

    EXITS("cmfe_Basis_NumberOfXiSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_NumberOfXiSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_NumberOfXiSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of Gauss points in each Xi directions for a basis quadrature identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureNumberOfGaussXiGetNumber(userNumber,numberOfGaussXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfGaussXi(:) !<On return, the number of Gauss points in each Xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_QuadratureNumberOfGaussXiGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_NUMBER_OF_GAUSS_XI_GET(BASIS,numberOfGaussXi,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_QuadratureNumberOfGaussXiGetNumber")
    RETURN
999 ERRORS("cmfe_Basis_QuadratureNumberOfGaussXiGetNumber",err,error)
    EXITS("cmfe_Basis_QuadratureNumberOfGaussXiGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureNumberOfGaussXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number Gauss points in each Xi directions for a basis quadrature identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureNumberOfGaussXiGetObj(basis,numberOfGaussXi,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfGaussXi(:) !<On return, the number of Gauss points in each Xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_QuadratureNumberOfGaussXiGetObj",err,error,*999)

    CALL BASIS_QUADRATURE_NUMBER_OF_GAUSS_XI_GET(basis%basis,numberOfGaussXi,err,error,*999)

    EXITS("cmfe_Basis_QuadratureNumberOfGaussXiGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureNumberOfGaussXiGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureNumberOfGaussXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of Gauss points in each Xi directions for a basis quadrature identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureNumberOfGaussXiSetNumber(userNumber,numberOfGaussXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to set the number of Gauss Xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfGaussXi(:) !<The number of Gauss points in each Xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_QuadratureNumberOfGaussXiSetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_NUMBER_OF_GAUSS_XI_SET(BASIS,numberOfGaussXi,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_QuadratureNumberOfGaussXiSetNumber")
    RETURN
999 ERRORS("cmfe_Basis_QuadratureNumberOfGaussXiSetNumber",err,error)
    EXITS("cmfe_Basis_QuadratureNumberOfGaussXiSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureNumberOfGaussXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the number Gauss points in each Xi directions for a basis quadrature identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureNumberOfGaussXiSetObj(basis,numberOfGaussXi,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfGaussXi(:) !<The number of Gauss points in each Xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_QuadratureNumberOfGaussXiSetObj",err,error,*999)

    CALL BASIS_QUADRATURE_NUMBER_OF_GAUSS_XI_SET(basis%basis,numberOfGaussXi,err,error,*999)

    EXITS("cmfe_Basis_QuadratureNumberOfGaussXiSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureNumberOfGaussXiSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureNumberOfGaussXiSetObj

  !
  !================================================================================================================================
  !
  !>Returns the xi position of a Gauss point on a basis quadrature identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureSingleGaussXiGetNumber(userNumber,quadratureScheme,GaussPoint,GaussXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the Gauss Xi positions for.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to return the Gauss positions for.
    INTEGER(INTG), INTENT(IN) :: GaussPoint !<The Gauss point to return the element xi positions for.
    REAL(DP), INTENT(OUT) :: GaussXi(:) !<On return, GaussXi(xi_direction) the xi position of the specified Gauss point for the specified quadrature scheme.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_QuadratureSingleGaussXiGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_SINGLE_GAUSS_XI_GET(BASIS,quadratureScheme,GaussPoint,GaussXi,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_QuadratureSingleGaussXiGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureSingleGaussXiGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureSingleGaussXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the xi position of a Gauss point on a basis quadrature identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureSingleGaussXiGetObj(basis,quadratureScheme,GaussPoint,GaussXi,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the Gauss Xi positions for.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to return the Gauss xi positions for.
    INTEGER(INTG), INTENT(IN) :: GaussPoint !<The Gauss point to return the element xi positions for.
    REAL(DP), INTENT(OUT) :: GaussXi(:) !<On return, GaussXi(xi_direction) the xi position of the specified Gauss point for the specified quadrature scheme.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_QuadratureSingleGaussXiGetObj",err,error,*999)

    CALL BASIS_QUADRATURE_SINGLE_GAUSS_XI_GET(basis%basis,quadratureScheme,GaussPoint,GaussXi,err,error,*999)

    EXITS("cmfe_Basis_QuadratureSingleGaussXiGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureSingleGaussXiGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureSingleGaussXiGetObj

  !
  !================================================================================================================================
  !

  !>Returns the xi positions of Gauss points on a basis quadrature identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureMultipleGaussXiGetNumber(userNumber,quadratureScheme,GaussPoints,GaussXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the Gauss Xi positions for.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to return the Gauss positions for.
    INTEGER(INTG), INTENT(IN) :: GaussPoints(:) !<The Gauss points to return the element xi positions for.
    REAL(DP), INTENT(OUT) :: GaussXi(:,:) !<On return, GaussXi(Gauss_point,xi_direction) the Gauss xi positions for the specified quadrature scheme.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_QuadratureMultipleGaussXiGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_MULTIPLE_GAUSS_XI_GET(BASIS,quadratureScheme,GaussPoints,GaussXi,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_QuadratureMultipleGaussXiGetNumber")
    RETURN
999 ERRORS("cmfe_Basis_QuadratureMultipleGaussXiGetNumber",err,error)
    EXITS("cmfe_Basis_QuadratureMultipleGaussXiGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureMultipleGaussXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the xi positions of Gauss points on a basis quadrature identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureMultipleGaussXiGetObj(basis,quadratureScheme,GaussPoints,GaussXi,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the Gauss Xi positions for.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to return the Gauss xi positions for.
    INTEGER(INTG), INTENT(IN) :: GaussPoints(:) !<The Gauss points to return the element xi positions for.
    REAL(DP), INTENT(OUT) :: GaussXi(:,:) !<On return, GaussXi(Gauss_point,xi_direction) the Gauss xi positions for the specified quadrature scheme.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_QuadratureMultipleGaussXiGetObj",err,error,*999)

    CALL BASIS_QUADRATURE_MULTIPLE_GAUSS_XI_GET(basis%basis,quadratureScheme,GaussPoints,GaussXi,err,error,*999)

    EXITS("cmfe_Basis_QuadratureMultipleGaussXiGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureMultipleGaussXiGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureMultipleGaussXiGetObj

  !
  !================================================================================================================================
  !

  !>Returns the order of quadrature a basis quadrature identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureOrderGetNumber(userNumber,quadratureOrder,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: quadratureOrder !<On return, the order of quadrature in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_QuadratureOrderGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_ORDER_GET(BASIS,quadratureOrder,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_QuadratureOrderGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureOrderGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureOrderGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the the order of quadrature for a basis quadrature identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureOrderGetObj(basis,quadratureOrder,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: quadratureOrder !<On return, the order of quadrature in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_QuadratureOrderGetObj",err,error,*999)

    CALL BASIS_QUADRATURE_ORDER_GET(basis%basis,quadratureOrder,err,error,*999)

    EXITS("cmfe_Basis_QuadratureOrderGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureOrderGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureOrderGetObj


  !
  !================================================================================================================================
  !

  !>Sets/changes the order of quadrature a basis quadrature identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureOrderSetNumber(userNumber,quadratureOrder,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to set the quadrature order for.
    INTEGER(INTG), INTENT(IN) :: quadratureOrder !<The order of quadrature in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_QuadratureOrderSetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_ORDER_SET(BASIS,quadratureOrder,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_QuadratureOrderSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureOrderSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureOrderSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the the order of quadrature for a basis quadrature identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureOrderSetObj(basis,quadratureOrder,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to set the quadrature order for.
    INTEGER(INTG), INTENT(IN) :: quadratureOrder !<The order of quadrature in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_QuadratureOrderSetObj",err,error,*999)

    CALL BASIS_QUADRATURE_ORDER_SET(basis%basis,quadratureOrder,err,error,*999)

    EXITS("cmfe_Basis_QuadratureOrderSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureOrderSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureOrderSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of quadrature a basis quadrature identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureTypeGetNumber(userNumber,quadratureType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the quadrature type for.
    INTEGER(INTG), INTENT(OUT) :: quadratureType !<On return, the type of quadrature in the specified basis. \see OPENCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_QuadratureTypeGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_TYPE_GET(BASIS,quadratureType,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_QuadratureTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the the type of quadrature for a basis quadrature identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureTypeGetObj(basis,quadratureType,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: quadratureType !<On return, the type of quadrature in the specified basis. \see OPENCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_QuadratureTypeGetObj",err,error,*999)

    CALL BASIS_QUADRATURE_TYPE_GET(basis%basis,quadratureType,err,error,*999)

    EXITS("cmfe_Basis_QuadratureTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of quadrature a basis quadrature identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureTypeSetNumber(userNumber,quadratureType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the quadrature type for.
    INTEGER(INTG), INTENT(IN) :: quadratureType !<The type of quadrature in the specified basis to set. \see OPENCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_QuadratureTypeSetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_TYPE_SET(BASIS,quadratureType,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_QuadratureTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the the type of quadrature for a basis quadrature identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureTypeSetObj(basis,quadratureType,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to get the quadrature type for.
    INTEGER(INTG), INTENT(IN) :: quadratureType !<The type of quadrature in the specified basis to set. \see OPENCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_QuadratureTypeSetObj",err,error,*999)

    CALL BASIS_QUADRATURE_TYPE_SET(basis%basis,quadratureType,err,error,*999)

    EXITS("cmfe_Basis_QuadratureTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_QuadratureTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the local face Gauss scheme calculation, on a basis identified by a user number.
  SUBROUTINE cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetNumber(userNumber,faceGaussEvaluate,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the quadrature type for.
    LOGICAL, INTENT(IN) :: faceGaussEvaluate !<The value to set face Gauss evaluation flag to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL Basis_QuadratureLocalFaceGaussEvaluateSet(BASIS,faceGaussEvaluate,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetNumber")
    RETURN
999 ERRORS("cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetNumber",err,error)
    EXITS("cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the local face Gauss scheme calculation, on a basis identified by an object.
  SUBROUTINE cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetObj(basis,faceGaussEvaluate,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to get the quadrature type for.
    LOGICAL, INTENT(IN) :: faceGaussEvaluate !<The type of quadrature in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetObj",err,error,*999)

    CALL Basis_QuadratureLocalFaceGaussEvaluateSet(basis%basis,faceGaussEvaluate,err,error,*999)

    EXITS("cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetObj")
    RETURN
999 ERRORS("cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetObj",err,error)
    EXITS("cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_QuadratureLocalFaceGaussEvaluateSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a basis identified by a user number.
  SUBROUTINE cmfe_Basis_TypeGetNumber(userNumber,basisType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the type for.
    INTEGER(INTG), INTENT(OUT) :: basisType !<On return, the type of the specified basis. \see OPENCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_TypeGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_TYPE_GET(BASIS,basisType,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_TypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_TypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a basis identified by an object.
  SUBROUTINE cmfe_Basis_TypeGetObj(basis,basisType,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the type for.
    INTEGER(INTG), INTENT(OUT) :: basisType !<On return, the type of the specified basis. \see OPENCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_TypeGetObj",err,error,*999)

    CALL BASIS_TYPE_GET(basis%basis,basisType,err,error,*999)

    EXITS("cmfe_Basis_TypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_TypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a basis identified by a user number.
  SUBROUTINE cmfe_Basis_TypeSetNumber(userNumber,basisType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to set the type for.
    INTEGER(INTG), INTENT(IN) :: basisType !<The type of the specified basis to set. \see OPENCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Basis_TypeSetNumber",ERR,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_TYPE_SET(BASIS,basisType,err,error,*999)
    ELSE
      localError="A basis with an user number of "//TRIM(NumberToVString(userNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Basis_TypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Basis_TypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a basis identified by an object.
  SUBROUTINE cmfe_Basis_TypeSetObj(basis,basisType,err)

    !Argument variables
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<The basis to set the type for.
    INTEGER(INTG), INTENT(IN) :: basisType !<The type of the specified basis to set. \see OPENCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Basis_TypeSetObj",err,error,*999)

    CALL BASIS_TYPE_SET(basis%basis,basisType,err,error,*999)

    EXITS("cmfe_Basis_TypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Basis_TypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Basis_TypeSetObj


!!==================================================================================================================================
!!
!! BOUNDARY_CONDITIONS_ROUTINES
!!
!!==================================================================================================================================

  !>Destroys the boundary conditions for solver equations identified by a control loop identifier.
  SUBROUTINE cmfe_BoundaryConditions_DestroyNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_BoundaryConditions_DestroyNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
        IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
          CALL BOUNDARY_CONDITIONS_DESTROY(BOUNDARY_CONDITIONS,err,error,*999)
        ELSE
          localError="Solver equations boundary conditions is not associated."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_BoundaryConditions_DestroyNumber0")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_DestroyNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_DestroyNumber0

  !
  !================================================================================================================================
  !

  !>Destroys the boundary conditions for solver equations identified by a control loop identifier.
  SUBROUTINE cmfe_BoundaryConditions_DestroyNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_BoundaryConditions_DestroyNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
        IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
          CALL BOUNDARY_CONDITIONS_DESTROY(BOUNDARY_CONDITIONS,err,error,*999)
        ELSE
          localError="Solver equations boundary conditions is not associated."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_BoundaryConditions_DestroyNumber1")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_DestroyNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_DestroyNumber1

  !
  !================================================================================================================================
  !

  !>Destroys boundary conditions identified by an object.
  SUBROUTINE cmfe_BoundaryConditions_DestroyObj(boundaryConditions,err)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<The boundary conditions to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_DestroyObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_DESTROY(boundaryConditions%boundaryConditions,err,error,*999)

    EXITS("cmfe_BoundaryConditions_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_DestroyObj

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by a user number.
  SUBROUTINE cmfe_BoundaryConditions_AddConstantNumber(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & fieldUserNumber,variableType,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the dependent field to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_BoundaryConditions_AddConstantNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_ADD_CONSTANT(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,componentNumber, &
                & condition,value,err,error,*999)
            ELSE
              localError="A field with a user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FlagError(localError,err,error,*999)
            END IF
          ELSE
            CALL FlagError("The solver equations boundary conditions are not associated.",err,error,*999)
          END IF
        ELSE
          CALL FlagError("The solver equations are not associated.",err,error,*999)
        END IF
      ELSE
        localError="A problem with a user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_BoundaryConditions_AddConstantNumber")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_AddConstantNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_AddConstantNumber

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by an object.
  SUBROUTINE cmfe_BoundaryConditions_AddConstantObj(boundaryConditions,field,variableType,componentNumber,condition,value,err)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to add the constant to.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_AddConstantObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_ADD_CONSTANT(boundaryConditions%boundaryConditions,field%field,variableType,componentNumber, &
      & condition,value,err,error,*999)

    EXITS("cmfe_BoundaryConditions_AddConstantObj")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_AddConstantObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_AddConstantObj

  !
  !================================================================================================================================
  !


  !>Sets the value of the specified constant as a boundary condition on the specified constant for boundary conditions identified by a user number.
  SUBROUTINE cmfe_BoundaryConditions_SetConstantNumber(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & variableType,fieldUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_BoundaryConditions_SetConstantNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_SET_CONSTANT(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,componentNumber, &
                & condition,value,err,error,*999)
            ELSE
              localError="A field with a user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FlagError(localError,err,error,*999)
            END IF
          ELSE
            CALL FlagError("The solver equations boundary conditions are not associated.",err,error,*999)
          END IF
        ELSE
          CALL FlagError("The solver equations are not associated.",err,error,*999)
        END IF
      ELSE
        localError="A problem with a user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_BoundaryConditions_SetConstantNumber")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_SetConstantNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_SetConstantNumber

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by an object.
  SUBROUTINE cmfe_BoundaryConditions_SetConstantObj(boundaryConditions,field,variableType,componentNumber,condition,value,err)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to set the constant to.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_SetConstantObj",ERR,error,*999)

    CALL BOUNDARY_CONDITIONS_SET_CONSTANT(boundaryConditions%boundaryConditions,field%field,variableType,componentNumber, &
      & condition,value,err,error,*999)

    EXITS("cmfe_BoundaryConditions_SetConstantObj")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_SetConstantObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_SetConstantObj

  !
  !================================================================================================================================
  !

  !>Adds the value to the specified element and sets this as a boundary condition on the specified element for boundary conditions identified by a user number.
  SUBROUTINE cmfe_BoundaryConditions_AddElementNumber(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & fieldUserNumber,variableType,elementUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_BoundaryConditions_AddElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_ADD_ELEMENT(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,elementUserNumber, &
                & componentNumber,condition,value,err,error,*999)
            ELSE
              localError="A field with a user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FlagError(localError,err,error,*999)
            END IF
          ELSE
            CALL FlagError("The solver equations boundary conditions are not associated.",err,error,*999)
          END IF
        ELSE
          CALL FlagError("The solver equations are not associated.",err,error,*999)
        END IF
      ELSE
        localError="A problem with a user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_BoundaryConditions_AddElementNumber")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_AddElementNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_AddElementNumber

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified element and sets this as a boundary condition on the specified element for boundary conditions identified by an object.
  SUBROUTINE cmfe_BoundaryConditions_AddElementObj(boundaryConditions,field,variableType,elementUserNumber,componentNumber, &
    & condition,value,err)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to add the element to.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_AddElementObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_ADD_ELEMENT(boundaryConditions%boundaryConditions,field%field,variableType,elementUserNumber, &
      & componentNumber,condition,value,err,error,*999)

    EXITS("cmfe_BoundaryConditions_AddElementObj")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_AddElementObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_AddElementObj

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified element as a boundary condition on the specified element for boundary conditions identified by a user number.
  SUBROUTINE cmfe_BoundaryConditions_SetElementNumber(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & fieldUserNumber,variableType,elementUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_BoundaryConditions_SetElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_SET_ELEMENT(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,elementUserNumber, &
                & componentNumber,condition,value,err,error,*999)
            ELSE
              localError="A field with a user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FlagError(localError,err,error,*999)
            END IF
          ELSE
            CALL FlagError("The solver equations boundary conditions are not associated.",err,error,*999)
          END IF
        ELSE
          CALL FlagError("The solver equations are not associated.",err,error,*999)
        END IF
      ELSE
        localError="A problem with a user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_BoundaryConditions_SetElementNumber")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_SetElementNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_SetElementNumber

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified element and sets this as a boundary condition on the specified elements for boundary conditions identified by an object.
  SUBROUTINE cmfe_BoundaryConditions_SetElementObj(boundaryConditions,field,variableType,elementUserNumber,componentNumber, &
    & condition,value,err)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to set the element to.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_SetElementObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_SET_ELEMENT(boundaryConditions%boundaryConditions,field%field,variableType,elementUserNumber, &
      & componentNumber,condition,value,err,error,*999)

    EXITS("cmfe_BoundaryConditions_SetElementObj")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_SetElementObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_SetElementObj

  !
  !================================================================================================================================
  !

  !>Adds the value to the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by a user number.
  SUBROUTINE cmfe_BoundaryConditions_AddNodeNumber(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & fieldUserNumber,variableType,versionNumber,derivativeNumber,nodeUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_BoundaryConditions_AddNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_ADD_NODE(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,versionNumber,derivativeNumber, &
                & nodeUserNumber,componentNumber,condition,value,err,error,*999)
            ELSE
              localError="A field with a user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FlagError(localError,err,error,*999)
            END IF
          ELSE
            CALL FlagError("The solver equations boundary conditions are not associated.",err,error,*999)
          END IF
        ELSE
          CALL FlagError("The solver equations are not associated.",err,error,*999)
        END IF
      ELSE
        localError="A problem with a user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_BoundaryConditions_AddNodeNumber")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_AddNodeNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_AddNodeNumber

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by an object.
  SUBROUTINE cmfe_BoundaryConditions_AddNodeObj(boundaryConditions,field,variableType,versionNumber,derivativeNumber, &
      & nodeUserNumber,componentNumber,condition,value,err)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to add the node to.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_AddNodeObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_ADD_NODE(boundaryConditions%boundaryConditions,field%field,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,condition,value,err,error,*999)

    EXITS("cmfe_BoundaryConditions_AddNodeObj")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_AddNodeObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_AddNodeObj

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified node as a boundary condition on the specified node for boundary conditions identified by a user number.
  SUBROUTINE cmfe_BoundaryConditions_SetNodeNumber0(regionUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & fieldUserNumber,variableType,versionNumber,derivativeNumber,nodeUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_BoundaryConditions_SetNodeNumber0",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_SET_NODE(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,versionNumber,derivativeNumber, &
                & nodeUserNumber,componentNumber,condition,value,err,error,*999)
            ELSE
              localError="A field with a user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FlagError(localError,err,error,*999)
            END IF
          ELSE
            CALL FlagError("The solver equations boundary conditions are not associated.",err,error,*999)
          END IF
        ELSE
          CALL FlagError("The solver equations are not associated.",err,error,*999)
        END IF
      ELSE
        localError="A problem with a user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_BoundaryConditions_SetNodeNumber0")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_SetNodeNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_SetNodeNumber0

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified node as a boundary condition on the specified node for boundary conditions identified by a user number.
  SUBROUTINE cmfe_BoundaryConditions_SetNodeNumber1(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & fieldUserNumber,variableType,versionNumber,derivativeNumber,nodeUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_BoundaryConditions_SetNodeNumber1",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_SET_NODE(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,versionNumber,derivativeNumber, &
                & nodeUserNumber,componentNumber,condition,value,err,error,*999)
            ELSE
              localError="A field with a user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FlagError(localError,err,error,*999)
            END IF
          ELSE
            CALL FlagError("The solver equations boundary conditions are not associated.",err,error,*999)
          END IF
        ELSE
          CALL FlagError("The solver equations are not associated.",err,error,*999)
        END IF
      ELSE
        localError="A problem with a user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_BoundaryConditions_SetNodeNumber1")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_SetNodeNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_SetNodeNumber1

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by an object.
  SUBROUTINE cmfe_BoundaryConditions_SetNodeObj(boundaryConditions,field,variableType,versionNumber,derivativeNumber, &
    & nodeUserNumber,componentNumber,condition,value,err)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to set the node to.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_SetNodeObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_SET_NODE(boundaryConditions%boundaryConditions,field%field,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,condition,value,err,error,*999)

    EXITS("cmfe_BoundaryConditions_SetNodeObj")
    RETURN
999 ERRORSEXITS("cmfe_BoundaryConditions_SetNodeObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_SetNodeObj

  !
  !================================================================================================================================
  !

  !>Sets the Neumann integration matrix sparsity for boundary conditions identified by a control loop identifier.
  SUBROUTINE cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber0( &
      & problemUserNumber,controlLoopIdentifier,solverIndex,sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier of the solver equations containing the boundary conditions.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type for the Neumann integration matrices. \see OPENCMISS_BoundaryConditionSparsityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: solverEquations
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: boundaryConditions
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber0",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
      IF(ASSOCIATED(solverEquations)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(solverEquations,boundaryConditions,err,error,*999)
        IF(ASSOCIATED(boundaryConditions)) THEN
          CALL BoundaryConditions_NeumannSparsityTypeSet(boundaryConditions,sparsityType,err,error,*999)
        ELSE
          localError="Solver equations boundary conditions is not associated."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber0")
    RETURN
999 ERRORS("cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber0",err,error)
    EXITS("cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the Neumann integration matrix sparsity for boundary conditions identified by a control loop identifier.
  SUBROUTINE cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber1( &
      & problemUserNumber,controlLoopIdentifiers,solverIndex,sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type for the Neumann integration matrices. \see OPENCMISS_BoundaryConditionSparsityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: solverEquations
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: boundaryConditions
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber1",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
      IF(ASSOCIATED(solverEquations)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(solverEquations,boundaryConditions,err,error,*999)
        IF(ASSOCIATED(boundaryConditions)) THEN
          CALL BoundaryConditions_NeumannSparsityTypeSet(boundaryConditions,sparsityType,err,error,*999)
        ELSE
          localError="Solver equations boundary conditions is not associated."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber1")
    RETURN
999 ERRORS("cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber1",err,error)
    EXITS("cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_NeumannSparsityTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the Neumann integration matrix sparsity type for the boundary conditions
  SUBROUTINE cmfe_BoundaryConditions_NeumannSparsityTypeSetObj(boundaryConditions,sparsityType,err)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<The boundary conditions
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type for the Neumann integration matrices. \see OPENCMISS_BoundaryConditionSparsityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_BoundaryConditions_NeumannSparsityTypeSetObj",err,error,*999)

    CALL BoundaryConditions_NeumannSparsityTypeSet(boundaryConditions%boundaryConditions,sparsityType,err,error,*999)

    EXITS("cmfe_BoundaryConditions_NeumannSparsityTypeSetObj")
    RETURN
999 ERRORS("cmfe_BoundaryConditions_NeumannSparsityTypeSetObj",err,error)
    EXITS("cmfe_BoundaryConditions_NeumannSparsityTypeSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_NeumannSparsityTypeSetObj

  !
  !================================================================================================================================
  !

  !>Constrain multiple nodal equations dependent field DOFs to be a single solver DOF in the solver equations
  SUBROUTINE cmfe_BoundaryConditions_ConstrainNodeDofsEqualNumber(regionUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,fieldUserNumber,fieldVariableType,versionNumber,derivativeNumber,component,nodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field DOFs to constrain.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index of the solver equations.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field containing the DOFs to contrain.
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The variable type of the dependent field containing the DOFs to constrain. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number.
    INTEGER(INTG), INTENT(IN) :: component !<The field component number of the DOFs to be constrained.
    INTEGER(INTG), INTENT(IN) :: nodes(:) !<The user numbers of the nodes to be constrained to be equal.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: solverEquations
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: boundaryConditions
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_BoundaryConditions_ConstrainNodeDofsEqualNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(field)

    CALL Region_user_number_find(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL Problem_user_number_find(problemUserNumber,problem,err,error,*999)
      IF(ASSOCIATED(problem)) THEN
        CALL Problem_solver_equations_get(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
        IF(ASSOCIATED(solverEquations)) THEN
          CALL Solver_equations_boundary_conditions_get(solverEquations,boundaryConditions,err,error,*999)
          IF(ASSOCIATED(boundaryConditions)) THEN
            CALL Field_user_number_find(fieldUserNumber,region,field,err,error,*999)
            IF(ASSOCIATED(field)) THEN
              CALL BoundaryConditions_ConstrainNodeDofsEqual(boundaryConditions,field, &
                & fieldVariableType,versionNumber,derivativeNumber,component,nodes,err,error,*999)
            ELSE
              localError="A field with a user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FlagError(localError,err,error,*999)
            END IF
          ELSE
            localError="The boundary conditions for the solver equations are not associated."
            CALL FlagError(localError,err,error,*999)
          END IF
        ELSE
          CALL FlagError("The solver equations are not associated.",err,error,*999)
        END IF
      ELSE
        localError="A problem with a user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_BoundaryConditions_ConstrainNodeDofsEqualNumber")
    RETURN
999 ERRORS("cmfe_BoundaryConditions_ConstrainNodeDofsEqualNumber",err,error)
    EXITS("cmfe_BoundaryConditions_ConstrainNodeDofsEqualNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_ConstrainNodeDofsEqualNumber

  !
  !================================================================================================================================
  !

  !>Constrain multiple nodal equations dependent field DOFs to be a single solver DOF in the solver equations
  SUBROUTINE cmfe_BoundaryConditions_ConstrainNodeDofsEqualObj( &
      & boundaryConditions,field,fieldVariableType,versionNumber,derivativeNumber,component,nodes,err)

    !Argument variables
    TYPE(cmfe_BoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to constrain the DOFs in.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The equations dependent field containing the field DOFs to be constrained.
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The field variable type of the DOFs to be constrained. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number.
    INTEGER(INTG), INTENT(IN) :: component !<The field component number of the DOFs to be constrained.
    INTEGER(INTG), INTENT(IN) :: nodes(:) !<The user numbers of the nodes to be constrained to be equal.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_BoundaryConditions_ConstrainNodeDofsEqualObj",err,error,*999)

    CALL BoundaryConditions_ConstrainNodeDofsEqual(boundaryConditions%boundaryConditions,field%field, &
      & fieldVariableType,versionNumber,derivativeNumber,component,nodes,err,error,*999)

    EXITS("cmfe_BoundaryConditions_ConstrainNodeDofsEqualObj")
    RETURN
999 ERRORS("cmfe_BoundaryConditions_ConstrainNodeDofsEqualObj",err,error)
    EXITS("cmfe_BoundaryConditions_ConstrainNodeDofsEqualObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BoundaryConditions_ConstrainNodeDofsEqualObj

!!==================================================================================================================================
!!
!! CMISS
!!
!!==================================================================================================================================

  !>Returns the error handling mode for OpenCMISS
  SUBROUTINE cmfe_ErrorHandlingModeGet(errorHandlingMode,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: errorHandlingMode !<On return, the error handling mode. \see OPENCMISS_CMISSErrorHandlingModes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ErrorHandlingModeGet",err,error,*999)

    CALL cmfe_ErrorHandlingModeGet_(errorHandlingMode,err,error,*999)

    EXITS("cmfe_ErrorHandlingModeGet")
    RETURN
999 ERRORSEXITS("cmfe_ErrorHandlingModeGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ErrorHandlingModeGet

  !
  !================================================================================================================================
  !

  !>Sets the error handling mode for OpenCMISS
  SUBROUTINE cmfe_ErrorHandlingModeSet(errorHandlingMode,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: errorHandlingMode !<The error handling mode to set. \see OPENCMISS_CMISSErrorHandlingModes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ErrorHandlingModeSet",err,error,*999)

    CALL cmfe_ErrorHandlingModeSet_(errorHandlingMode,err,error,*999)

    EXITS("cmfe_ErrorHandlingModeSet")
    RETURN
999 ERRORSEXITS("cmfe_ErrorHandlingModeSet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ErrorHandlingModeSet

  !
  !================================================================================================================================
  !

  !>Extracts the most recent error string for OpenCMISS
  SUBROUTINE cmfe_ExtractErrorMessageC(errorMessage,err)

    !Argument variables
    CHARACTER(LEN=*), INTENT(OUT) :: errorMessage !<On return, the extracted error message.
    INTEGER(INTG), INTENT(IN) :: err !<The error code.
    !Local variables

    CALL ExtractErrorMessage(errorMessage,err,error,*999)

    RETURN
999 RETURN

  END SUBROUTINE cmfe_ExtractErrorMessageC

  !
  !================================================================================================================================
  !

  !>Extracts the most recent error string for OpenCMISS
  SUBROUTINE cmfe_ExtractErrorMessageVS(errorMessage,err)

    !Argument variables
    TYPE(VARYING_STRING), INTENT(OUT) :: errorMessage !<On return, the extracted error message.
    INTEGER(INTG), INTENT(IN) :: err !<The error code.
    !Local variables

    CALL ExtractErrorMessage(errorMessage,err,error,*999)

    RETURN
999 RETURN

  END SUBROUTINE cmfe_ExtractErrorMessageVS

  !
  !================================================================================================================================
  !

  !>Returns the random seeds for OpenCMISS
  SUBROUTINE cmfe_RandomSeedsGet0(randomSeed,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: randomSeed !<On return, the random seed.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: RandomSeeds(1)

    ENTERS("cmfe_RandomSeedsGet0",err,error,*999)

    CALL RANDOM_SEEDS_GET(RandomSeeds,err,error,*999)
    randomSeed=RandomSeeds(1)

    EXITS("cmfe_RandomSeedsGet0")
    RETURN
999 ERRORSEXITS("cmfe_RandomSeedsGet0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_RandomSeedsGet0

  !
  !================================================================================================================================
  !

  !>Returns the random seeds for OpenCMISS
  SUBROUTINE cmfe_RandomSeedsGet1(randomSeeds,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: randomSeeds(:) !<On return, the random seeds.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_RandomSeedsGet1",err,error,*999)

    CALL RANDOM_SEEDS_GET(randomSeeds,err,error,*999)

    EXITS("cmfe_RandomSeedsGet1")
    RETURN
999 ERRORSEXITS("cmfe_RandomSeedsGet1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_RandomSeedsGet1

  !
  !================================================================================================================================
  !

  !>Returns the size of the random seeds array for OpenCMISS
  SUBROUTINE cmfe_RandomSeedsSizeGet(randomSeedsSize,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: randomSeedsSize !<On return, the size of the random seeds array.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_RandomSeedsSizeGet",err,error,*999)

    CALL RANDOM_SEEDS_SIZE_GET(randomSeedsSize,err,error,*999)

    EXITS("cmfe_RandomSeedsSizeGet")
    RETURN
999 ERRORSEXITS("cmfe_RandomSeedsSizeGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_RandomSeedsSizeGet

  !
  !================================================================================================================================
  !

  !>Sets the random seeds for OpenCMISS
  SUBROUTINE cmfe_RandomSeedsSet0(randomSeed,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: randomSeed !<The random seed to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_RandomSeedsSet0",err,error,*999)

    CALL RANDOM_SEEDS_SET([randomSeed],err,error,*999)

    EXITS("cmfe_RandomSeedsSet0")
    RETURN
999 ERRORSEXITS("cmfe_RandomSeedsSet0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_RandomSeedsSet0

  !
  !================================================================================================================================
  !

  !>Sets the random seeds for OpenCMISS
  SUBROUTINE cmfe_RandomSeedsSet1(randomSeeds,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: randomSeeds(:) !<The random seeds to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_RandomSeedsSet1",err,error,*999)

    CALL RANDOM_SEEDS_SET(randomSeeds,err,error,*999)

    EXITS("cmfe_RandomSeedsSet1")
    RETURN
999 ERRORSEXITS("cmfe_RandomSeedsSet1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_RandomSeedsSet1

!!==================================================================================================================================
!!
!! CMISS_CELLML
!!
!!==================================================================================================================================

  !>Sets a CellML model variable to be known by user number.
  SUBROUTINE cmfe_CellML_VariableSetAsKnownNumberC(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_VariableSetAsKnownNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_VARIABLE_SET_AS_KNOWN(CELLML,CellMLModelUserNumber,variableID,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_VariableSetAsKnownNumberC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_VariableSetAsKnownNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_VariableSetAsKnownNumberC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be known by object.
  SUBROUTINE cmfe_CellML_VariableSetAsKnownObjC(CellML,CellMLModelUserNumber,variableID,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_VariableSetAsKnownObjC",err,error,*999)

    CALL CELLML_VARIABLE_SET_AS_KNOWN(CellML%CELLML,CellMLModelUserNumber,variableID,err,error,*999)

    EXITS("cmfe_CellML_VariableSetAsKnownObjC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_VariableSetAsKnownObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_VariableSetAsKnownObjC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be known by user number.
  SUBROUTINE cmfe_CellML_VariableSetAsKnownNumberVS(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_VariableSetAsKnownNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_VARIABLE_SET_AS_KNOWN(CELLML,CellMLModelUserNumber,variableID,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_VariableSetAsKnownNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_VariableSetAsKnownNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_VariableSetAsKnownNumberVS

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be known by object.
  SUBROUTINE cmfe_CellML_VariableSetAsKnownObjVS(CellML,CellMLModelUserNumber,variableID,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_VariableSetAsKnownObjVS",err,error,*999)

    CALL CELLML_VARIABLE_SET_AS_KNOWN(CellML%CELLML,CellMLModelUserNumber,variableID,err,error,*999)

    EXITS("cmfe_CellML_VariableSetAsKnownObjVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_VariableSetAsKnownObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_VariableSetAsKnownObjVS

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by user number.
  SUBROUTINE cmfe_CellML_VariableSetAsWantedNumberC(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_VariableSetAsWantedNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_VARIABLE_SET_AS_WANTED(CELLML,CellMLModelUserNumber,variableID,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_VariableSetAsWantedNumberC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_VariableSetAsWantedNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_VariableSetAsWantedNumberC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by object.
  SUBROUTINE cmfe_CellML_VariableSetAsWantedObjC(CellML,CellMLModelUserNumber,variableID,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_VariableSetAsWantedObjC",err,error,*999)

    CALL CELLML_VARIABLE_SET_AS_WANTED(CellML%CELLML,CellMLModelUserNumber,variableID,err,error,*999)

    EXITS("cmfe_CellML_VariableSetAsWantedObjC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_VariableSetAsWantedObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_VariableSetAsWantedObjC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by user number.
  SUBROUTINE cmfe_CellML_VariableSetAsWantedNumberVS(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_VariableSetAsWantedNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_VARIABLE_SET_AS_WANTED(CELLML,CellMLModelUserNumber,variableID,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_VariableSetAsWantedNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_VariableSetAsWantedNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_VariableSetAsWantedNumberVS

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by object.
  SUBROUTINE cmfe_CellML_VariableSetAsWantedObjVS(CellML,CellMLModelUserNumber,variableID,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_VariableSetAsWantedObjVS",err,error,*999)

    CALL CELLML_VARIABLE_SET_AS_WANTED(CellML%CELLML,CellMLModelUserNumber,variableID,err,error,*999)

    EXITS("cmfe_CellML_VariableSetAsWantedObjVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_VariableSetAsWantedObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_VariableSetAsWantedObjVS

  !
  !================================================================================================================================
  !

  !>Defines a CellML model variable to field variable component map by user number
  SUBROUTINE cmfe_CellML_CreateCellMLToFieldMapNumberC(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID, &
    & CellMLParameterSet,fieldUserNumber,variableType,componentNumber,fieldParameterSet,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map fom.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map from.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to map to
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_CreateCellMLToFieldMapNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
        IF(ASSOCIATED(FIELD)) THEN
          CALL CELLML_CREATE_CELLML_TO_FIELD_MAP(CELLML,CellMLModelUserNumber,variableID,CellMLParameterSet, &
            & FIELD,variableType,componentNumber,fieldParameterSet,err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_CreateCellMLToFieldMapNumberC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateCellMLToFieldMapNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateCellMLToFieldMapNumberC

  !
  !================================================================================================================================
  !

  !>Defines a CellML model variable to field variable component map by object.
  SUBROUTINE cmfe_CellML_CreateCellMLToFieldMapObjC(CellML, CellMLModelUserNumber,variableID,CellMLParameterSet, &
    & field,variableType,componentNumber,fieldParameterSet,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map from.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to map to.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_CreateCellMLToFieldMapObjC",err,error,*999)

    CALL CELLML_CREATE_CELLML_TO_FIELD_MAP(CellML%CELLML,CellMLModelUserNumber,variableID,CellMLParameterSet, &
      & field%field,variableType,componentNumber,fieldParameterSet,err,error,*999)

    EXITS("cmfe_CellML_CreateCellMLToFieldMapObjC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateCellMLToFieldMapObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateCellMLToFieldMapObjC

  !
  !================================================================================================================================
  !

  !>Defines a CellML model variable to field variable component map by user number
  SUBROUTINE cmfe_CellML_CreateCellMLToFieldMapNumberVS(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID, &
    & CellMLParameterSet,fieldUserNumber,variableType,componentNumber,fieldParameterSet,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable ID in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_CreateCellMLToFieldMapNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
        IF(ASSOCIATED(FIELD)) THEN
          CALL CELLML_CREATE_CELLML_TO_FIELD_MAP(CELLML,CellMLModelUserNumber,variableID,CellMLParameterSet, &
            & FIELD,variableType,componentNumber,fieldParameterSet,err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_CreateCellMLToFieldMapNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateCellMLToFieldMapNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateCellMLToFieldMapNumberVS

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map, by object.
  SUBROUTINE cmfe_CellML_CreateCellMLToFieldMapObjVS(CellML,CellMLModelUserNumber,variableID,CellMLParameterSet, &
    & field,variableType,componentNumber,fieldParameterSet,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map from.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to map to.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_CreateCellMLToFieldMapNumberVS",err,error,*999)

    CALL CELLML_CREATE_CELLML_TO_FIELD_MAP(CellML%CELLML,CellMLModelUserNumber,variableID,CellMLParameterSet, &
      & field%field,variableType,componentNumber,fieldParameterSet,err,error,*999)

    EXITS("cmfe_CellML_CreateCellMLToFieldMapObjVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateCellMLToFieldMapObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateCellMLToFieldMapObjVS

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by user number.
  SUBROUTINE cmfe_CellML_CreateFieldToCellMLMapNumberC(regionUserNumber,CellMLUserNumber,fieldUserNumber,variableType, &
    & componentNumber,fieldParameterSet,CellMLModelUserNumber,variableID,CellMLParameterSet,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map from.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map to.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_CreateFieldToCellMLMapNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
        IF(ASSOCIATED(FIELD)) THEN
          CALL CELLML_CREATE_FIELD_TO_CELLML_MAP(CELLML,FIELD,variableType,componentNumber,fieldParameterSet, &
            & CellMLModelUserNumber,variableID,CellMLParameterSet,err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_CreateFieldToCellMLMapNumberC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateFieldToCellMLMapNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateFieldToCellMLMapNumberC

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by object.
  SUBROUTINE cmfe_CellML_CreateFieldToCellMLMapObjC(CellML,field,variableType,componentNumber,fieldParameterSet, &
    & CellMLModelUserNumber,variableID,CellMLParameterSet,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number to map from the given field variable.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map to.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_CreateFieldToCellMLMapObjC",err,error,*999)

    CALL CELLML_CREATE_FIELD_TO_CELLML_MAP(CellML%CELLML,field%field,variableType,componentNumber,fieldParameterSet, &
      & CellMLModelUserNumber,variableID,CellMLParameterSet,err,error,*999)

    EXITS("cmfe_CellML_CreateFieldToCellMLMapObjC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateFieldToCellMLMapObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateFieldToCellMLMapObjC

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by user number
  SUBROUTINE cmfe_CellML_CreateFieldToCellMLMapNumberVS(regionUserNumber,CellMLUserNumber,fieldUserNumber,variableType, &
    & fieldParameterSet,componentNumber,CellMLModelUserNumber,variableID,CellMLParameterSet,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map from.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map to.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_CreateFieldToCellMLMapNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
        IF(ASSOCIATED(FIELD)) THEN
          CALL CELLML_CREATE_FIELD_TO_CELLML_MAP(CELLML,FIELD,variableType,componentNumber,fieldParameterSet, &
            & CellMLModelUserNumber,variableID,CellMLParameterSet,err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_CreateFieldToCellMLMapNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateFieldToCellMLMapNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateFieldToCellMLMapNumberVS

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by by object.
  SUBROUTINE cmfe_CellML_CreateFieldToCellMLMapObjVS(CellML,field,variableType,componentNumber,fieldParameterSet, &
    & CellMLModelUserNumber,variableID,CellMLParameterSet,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map from.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map to.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable ID in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_CreateFieldToCellMLMapNumberVS",err,error,*999)

    CALL CELLML_CREATE_FIELD_TO_CELLML_MAP(CellML%CELLML,field%field,variableType,componentNumber,fieldParameterSet, &
      & CellMLModelUserNumber,variableID,CellMLParameterSet,err,error,*999)

    EXITS("cmfe_CellML_CreateFieldToCellMLMapObjVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateFieldToCellMLMapObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateFieldToCellMLMapObjVS

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_CreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    EXITS("cmfe_CellML_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_CreateFinishObj(CellML,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_CreateFinishObj",err,error,*999)

    CALL CELLML_CREATE_FINISH(CellML%CELLML,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    EXITS("cmfe_CellML_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_CreateStartNumber(CellMLUserNumber,regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to start creating.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the field to start the CellML enviroment creation on.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_CREATE_START(CellMLUserNumber,REGION,CELLML,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_CreateStartObj(CellMLUserNumber,region,CellML,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to start creating.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region containing the field to start the CellML enviroment creation on.
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<On return, the created CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    CALL CELLML_CREATE_START(CellMLUserNumber,region%region,CellML%CELLML,err,error,*999)

    EXITS("cmfe_CellML_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_DestroyNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to destroy.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_DESTROY(CELLML,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_DestroyObj(CellML,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_DestroyObj",err,error,*999)

    CALL CELLML_DESTROY(CellML%CELLML,err,error,*999)

    EXITS("cmfe_CellML_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_DestroyObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of field maps for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_FieldMapsCreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_FieldMapsCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_FIELD_MAPS_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    EXITS("cmfe_CellML_FieldMapsCreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_FieldMapsCreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_FieldMapsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of field maps for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_FieldMapsCreateFinishObj(CellML,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of maps for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_FieldMapsCreateFinishObj",err,error,*999)

    CALL CELLML_FIELD_MAPS_CREATE_FINISH(CellML%CELLML,err,error,*999)

    EXITS("cmfe_CellML_FieldMapsCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_FieldMapsCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_FieldMapsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of field maps for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_FieldMapsCreateStartNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to start creating the maps for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_FieldMapsCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_FIELD_MAPS_CREATE_START(CELLML,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellMLFieldCreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellMLFieldCreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_FieldMapsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of field maps for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_FieldMapsCreateStartObj(CellML,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment object to start the creation of maps for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_FieldMapsCreateStartObj",err,error,*999)

    CALL CELLML_FIELD_MAPS_CREATE_START(CellML%CELLML,err,error,*999)

    EXITS("cmfe_CellML_FieldMapsCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_FieldMapsCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_FieldMapsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a character URI into a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_ModelImportNumberC(regionUserNumber,CellMLUserNumber,URI,modelIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to import the model into.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to import the model into.
    CHARACTER(LEN=*), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_ModelImportNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_MODEL_IMPORT(CELLML,URI,modelIndex,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_ModelImportNumberC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelImportNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelImportNumberC

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a character URI into a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_ModelImportObjC(CellML,URI,modelIndex,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to import the model into.
    CHARACTER(LEN=*), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_ModelImportObjC",err,error,*999)

    CALL CELLML_MODEL_IMPORT(CellML%CELLML,URI,modelIndex,err,error,*999)

    EXITS("cmfe_CellML_ModelImportObjC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelImportObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelImportObjC

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a varying string URI into a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_ModelImportNumberVS(regionUserNumber,CellMLUserNumber,URI,modelIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to import the model into.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to import the model into.
    TYPE(VARYING_STRING), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_ModelImportNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_MODEL_IMPORT(CELLML,URI,modelIndex,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_ModelImportNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelImportNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelImportNumberVS

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a varying string URI into a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_ModelImportObjVS(CellML,URI,modelIndex,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to import the model into.
    TYPE(VARYING_STRING), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_ModelImportObjVS",err,error,*999)

    CALL CELLML_MODEL_IMPORT(CellML%CELLML,URI,modelIndex,err,error,*999)

    EXITS("cmfe_CellML_ModelImportObjVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelImportObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelImportObjVS

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML models field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_ModelsFieldCreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to finish creating.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the models field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_ModelsFieldCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_MODELS_FIELD_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_ModelsFieldCreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelsFieldCreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelsFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML models field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_ModelsFieldCreateFinishObj(CellML,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the models field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_ModelsFieldCreateFinishObj",err,error,*999)

    CALL CELLML_MODELS_FIELD_CREATE_FINISH(CellML%CELLML,err,error,*999)

    EXITS("cmfe_CellML_ModelsFieldCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelsFieldCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelsFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML models field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_ModelsFieldCreateStartNumber(regionUserNumber,CellMLUserNumber,CellMLModelsFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to start creating the models field for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelsFieldUserNumber !<The user number of the CellML models field to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_ModelsFieldCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_MODELS_FIELD_CREATE_START(CellMLModelsFieldUserNumber,CELLML,FIELD,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_ModelsFieldCreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelsFieldCreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelsFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML models field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_ModelsFieldCreateStartObj(CellML,CellMLModelsFieldUserNumber,field,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of models field for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelsFieldUserNumber !<The user number of the CellML models field to start creating.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the created CellML models field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_ModelsFieldCreateStartObj",err,error,*999)

    CALL CELLML_MODELS_FIELD_CREATE_START(CellMLModelsFieldUserNumber,CellML%CELLML,field%field,err,error,*999)

    EXITS("cmfe_CellML_ModelsFieldCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelsFieldCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelsFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML models field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_ModelsFieldGetNumber(regionUserNumber,CellMLUserNumber,CellMLModelsFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to get the CellML models field for.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the CellML models field for.
    INTEGER(INTG), INTENT(OUT) :: CellMLModelsFieldUserNumber !<On return, the user number of the CellML models field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_ModelsFieldGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_MODELS_FIELD_GET(CELLML,FIELD,err,error,*999)
        CellMLModelsFieldUserNumber = FIELD%USER_NUMBER
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_ModelsFieldGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelsFieldGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelsFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML models field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_ModelsFieldGetObj(CellML,field,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the models field for.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the CellML models field. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_ModelsFieldGetObj",err,error,*999)

    CALL CELLML_MODELS_FIELD_GET(CellML%CELLML,field%field,err,error,*999)

    EXITS("cmfe_CellML_ModelsFieldGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ModelsFieldGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ModelsFieldGetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML state field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_StateFieldCreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the state field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_StateFieldCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_STATE_FIELD_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_StateFieldCreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_StateFieldCreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_StateFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML state field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_StateFieldCreateFinishObj(CellML,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the state field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_StateFieldCreateFinishObj",err,error,*999)

    CALL CELLML_STATE_FIELD_CREATE_FINISH(CellML%CELLML,err,error,*999)

    EXITS("cmfe_CellML_StateFieldCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_StateFieldCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_StateFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML state field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_StateFieldCreateStartNumber(regionUserNumber,CellMLUserNumber,CellMLStateFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to start creating the state field for.
    INTEGER(INTG), INTENT(IN) :: CellMLStateFieldUserNumber !<The user number of the CellML state field to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_StateFieldCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_STATE_FIELD_CREATE_START(CellMLStateFieldUserNumber,CELLML,FIELD,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_StateFieldCreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_StateFieldCreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_StateFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML state field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_StateFieldCreateStartObj(CellML,CellMLStateFieldUserNumber,field,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of state field for.
    INTEGER(INTG), INTENT(IN) :: CellMLStateFieldUserNumber !<The user number of the CellML state field to start creating.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the created CellML state field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_StateFieldCreateStartObj",err,error,*999)

    CALL CELLML_STATE_FIELD_CREATE_START(CellMLStateFieldUserNumber,CellML%CELLML,field%field,err,error,*999)

    EXITS("cmfe_CellML_StateFieldCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_StateFieldCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_StateFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML state field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_StateFieldGetNumber(regionUserNumber,CellMLUserNumber,CellMLStateFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the CellML state field for.
    INTEGER(INTG), INTENT(OUT) :: CellMLStateFieldUserNumber !<On return, the user number of the CellML state field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_StateFieldGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_STATE_FIELD_GET(CELLML,FIELD,err,error,*999)
        CellMLStateFieldUserNumber = FIELD%USER_NUMBER
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_StateFieldGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_StateFieldGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_StateFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML state field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_StateFieldGetObj(CellML,field,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the state field for.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the CellML state field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_StateFieldGetObj",err,error,*999)

    CALL CELLML_STATE_FIELD_GET(CellML%CELLML,field%field,err,error,*999)

    EXITS("cmfe_CellML_StateFieldGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_StateFieldGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_StateFieldGetObj

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a character string VariableID for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_FieldComponentGetNumberC(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,CellMLFieldType,&
  & variableID,fieldComponent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map fom.
    INTEGER(INTG), INTENT(IN) :: CellMLFieldType !<The type of CellML field to get the component for. \see OPENCMISS_CellMLFieldTypes,OPENCMISS
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The variable ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_FieldComponentGetNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_FIELD_COMPONENT_GET(CELLML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_FieldComponentGetNumberC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_FieldComponentGetNumberC",err,error)
    CALL cmfe_HandleError(err,error)

    RETURN

  END SUBROUTINE cmfe_CellML_FieldComponentGetNumberC

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a character string variable ID for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_FieldComponentGetObjC(CellML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLFieldType !<The type of CellML field to get the component for. \see OPENCMISS_CellMLFieldTypes,OPENCMISS
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_FieldComponentGetObjC",err,error,*999)

    CALL CELLML_FIELD_COMPONENT_GET(CellML%CELLML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err,error,*999)

    EXITS("cmfe_CellML_FieldComponentGetObjC")
    RETURN
999 ERRORSEXITS("cmfe_CellML_FieldComponentGetObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_FieldComponentGetObjC

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a varying string variable ID for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_FieldComponentGetNumberVS(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,CellMLFieldType,&
  & variableID,fieldComponent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLFieldType !<The type of CellML field to get the component for. \see OPENCMISS_CellMLFieldTypes,OPENCMISS
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_FieldComponentGetNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_FIELD_COMPONENT_GET(CELLML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_FieldComponentGetNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_FieldComponentGetNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_FieldComponentGetNumberVS

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a varying string variable ID for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_FieldComponentGetObjVS(CellML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLFieldType !<The type of CellML field to get the component for. \see OPENCMISS_CellMLFieldTypes,OPENCMISS
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_FieldComponentGetObjVS",err,error,*999)

    CALL CELLML_FIELD_COMPONENT_GET(CellML%CELLML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err,error,*999)

    EXITS("cmfe_CellML_FieldComponentGetObjVS")
    RETURN
999 ERRORSEXITS("cmfe_CellML_FieldComponentGetObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_FieldComponentGetObjVS

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_IntermediateFieldCreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_IntermediateFieldCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_INTERMEDIATE_FIELD_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_IntermediateFieldCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_CellML_IntermediateFieldCreateFinishNumber",err,error)
    EXITS("cmfe_CellML_IntermediateFieldCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_IntermediateFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_IntermediateFieldCreateFinishObj(CellML,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_IntermediateFieldCreateFinishObj",err,error,*999)

    CALL CELLML_INTERMEDIATE_FIELD_CREATE_FINISH(CellML%CELLML,err,error,*999)

    EXITS("cmfe_CellML_IntermediateFieldCreateFinishObj")
    RETURN
999 ERRORS("cmfe_CellML_IntermediateFieldCreateFinishObj",err,error)
    EXITS("cmfe_CellML_IntermediateFieldCreateFinishObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_IntermediateFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_IntermediateFieldCreateStartNumber(regionUserNumber,CellMLUserNumber,CellMLIntermediateFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to start creating the intermediate field for.
    INTEGER(INTG), INTENT(IN) :: CellMLIntermediateFieldUserNumber !<The user number of the CellML intermediate field to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_IntermediateFieldCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_INTERMEDIATE_FIELD_CREATE_START(CellMLIntermediateFieldUserNumber,CELLML,FIELD,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_IntermediateFieldCreateStartNumber")
    RETURN
999 ERRORS("cmfe_CellML_IntermediateFieldCreateStartNumber",err,error)
    EXITS("cmfe_CellML_IntermediateFieldCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_IntermediateFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_IntermediateFieldCreateStartObj(CellML,CellMLIntermediateFieldUserNumber,field,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of intermediate field for.
    INTEGER(INTG), INTENT(IN) :: CellMLIntermediateFieldUserNumber !<The user number of the CellML intermediate field to start creating.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the created CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_IntermediateFieldCreateStartObj",err,error,*999)

    CALL CELLML_INTERMEDIATE_FIELD_CREATE_START(CellMLIntermediateFieldUserNumber,CellML%CELLML,field%field,err,error,*999)

    EXITS("cmfe_CellML_IntermediateFieldCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_IntermediateFieldCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_IntermediateFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_IntermediateFieldGetNumber(regionUserNumber,CellMLUserNumber,CellMLIntermediateFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the CellML intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: CellMLIntermediateFieldUserNumber !<On return, the user number of the CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_IntermediateFieldGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_INTERMEDIATE_FIELD_GET(CELLML,FIELD,err,error,*999)
        CellMLIntermediateFieldUserNumber = FIELD%USER_NUMBER
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_IntermediateFieldGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_IntermediateFieldGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_IntermediateFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_IntermediateFieldGetObj(CellML,field,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the intermediate field for.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_IntermediateFieldGetObj",err,error,*999)

    CALL CELLML_INTERMEDIATE_FIELD_GET(CellML%CELLML,field%field,err,error,*999)

    EXITS("cmfe_CellML_IntermediateFieldGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_IntermediateFieldGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_IntermediateFieldGetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_ParametersFieldCreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the parameters field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_ParametersFieldCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_PARAMETERS_FIELD_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_ParametersFieldCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_CellML_ParametersFieldCreateFinishNumber",err,error)
    EXITS("cmfe_CellML_ParametersFieldCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ParametersFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_ParametersFieldCreateFinishObj(CellML,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the parameters field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_ParametersFieldCreateFinishObj",err,error,*999)

    CALL CELLML_PARAMETERS_FIELD_CREATE_FINISH(CellML%CELLML,err,error,*999)

    EXITS("cmfe_CellML_ParametersFieldCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ParametersFieldCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ParametersFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_ParametersFieldCreateStartNumber(regionUserNumber,CellMLUserNumber,CellMLParametersFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to start creating the parameters field for.
    INTEGER(INTG), INTENT(IN) :: CellMLParametersFieldUserNumber !<The user number of the CellML parameters field to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_ParametersFieldCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_PARAMETERS_FIELD_CREATE_START(CellMLParametersFieldUserNumber,CELLML,FIELD,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_ParametersFieldCreateStartNumber")
    RETURN
999 ERRORS("cmfe_CellML_ParametersFieldCreateStartNumber",err,error)
    EXITS("cmfe_CellML_ParametersFieldCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ParametersFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_ParametersFieldCreateStartObj(CellML,CellMLParametersFieldUserNumber,field,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of parameters field for.
    INTEGER(INTG), INTENT(IN) :: CellMLParametersFieldUserNumber !<The user number of the CellML parameters field to start creating.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the created CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_ParametersFieldCreateStartObj",err,error,*999)

    CALL CELLML_PARAMETERS_FIELD_CREATE_START(CellMLParametersFieldUserNumber,CellML%CELLML,field%field,err,error,*999)

    EXITS("cmfe_CellML_ParametersFieldCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ParametersFieldCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ParametersFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_ParametersFieldGetNumber(regionUserNumber,CellMLUserNumber,CellMLParametersFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the CellML parameters field for.
    INTEGER(INTG), INTENT(OUT) :: CellMLParametersFieldUserNumber !<On return, the user number of the CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_ParametersFieldGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_PARAMETERS_FIELD_GET(CELLML,FIELD,err,error,*999)
        CellMLParametersFieldUserNumber = FIELD%USER_NUMBER
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_ParametersFieldGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ParametersFieldGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ParametersFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_ParametersFieldGetObj(CellML,field,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the parameters field for.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_ParametersFieldGetObj",err,error,*999)

    CALL CELLML_PARAMETERS_FIELD_GET(CellML%CELLML,field%field,err,error,*999)

    EXITS("cmfe_CellML_ParametersFieldGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_ParametersFieldGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_ParametersFieldGetObj

  !
  !================================================================================================================================
  !

  !>Validiate and instantiate a CellML environment identified by a user number.
  SUBROUTINE cmfe_CellML_GenerateNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to generate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellML_GenerateNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_GENERATE(CELLML,err,error,*999)
      ELSE
        localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellML_GenerateNumber")
    RETURN
999 ERRORSEXITS("cmfe_CellML_GenerateNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_GenerateNumber

  !
  !================================================================================================================================
  !

  !>Validiate and instantiate a CellML environment identified by an object.
  SUBROUTINE cmfe_CellML_GenerateObj(CellML,err)

    !Argument variables
    TYPE(cmfe_CellMLType), INTENT(INOUT) :: CellML !<The CellML environment to generate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellML_GenerateObj",err,error,*999)

    CALL CELLML_GENERATE(CellML%CELLML,err,error,*999)

    EXITS("cmfe_CellML_GenerateObj")
    RETURN
999 ERRORSEXITS("cmfe_CellML_GenerateObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellML_GenerateObj


!!==================================================================================================================================
!!
!! COMP_ENVIRONMENT
!!
!!==================================================================================================================================

  !>Returns the computational node number of the running process.
  SUBROUTINE cmfe_ComputationalNodeNumberGet(nodeNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: nodeNumber !<On return, the computational node number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ComputationalNodeNumberGet",ERR,error,*999)

    nodeNumber = COMPUTATIONAL_NODE_NUMBER_GET(err,error)

    EXITS("cmfe_ComputationalNodeNumberGet")
    RETURN
999 ERRORSEXITS("cmfe_ComputationalNodeNumberGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ComputationalNodeNumberGet

  !
  !================================================================================================================================
  !

  !>Returns the number of computational nodes for the running process.
  SUBROUTINE cmfe_ComputationalNumberOfNodesGet(numberOfNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<On return, the number of computational nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ComputationalNumberOfNodesGet",ERR,error,*999)

    numberOfNodes = COMPUTATIONAL_NODES_NUMBER_GET(err,error)

    EXITS("cmfe_ComputationalNumberOfNodesGet")
    RETURN
999 ERRORSEXITS("cmfe_ComputationalNumberOfNodesGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ComputationalNumberOfNodesGet

  !
  !================================================================================================================================
  !

  !>CREATE THE HIGHEST LEVEL WORK GROUP (DEFAULT: GROUP_WORLD)
  SUBROUTINE cmfe_ComputationalWorkGroup_CreateStart(worldWorkGroup, numberComputationalNodes, err)
    !Argument Variables
    TYPE(cmfe_ComputationalWorkGroupType), INTENT(INOUT) :: worldWorkGroup
    INTEGER(INTG),INTENT(IN) :: numberComputationalNodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_ComputationalWorkGroup_CreateStart",ERR,error,*999)

    CALL COMPUTATIONAL_WORK_GROUP_CREATE_START(worldWorkGroup%computationalWorkGroup,numberComputationalNodes, &
      & err,error,*999)

    EXITS("cmfe_ComputationalWorkGroup_CreateStart")
    RETURN
999 ERRORSEXITS("cmfe_ComputationalWorkGroup_CreateStart",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ComputationalWorkGroup_CreateStart

  !
  !================================================================================================================================
  !

  !>GENERATE THE HIERARCHY COMPUTATIONAL ENVIRONMENT BASED ON WORK GROUP TREE
  SUBROUTINE cmfe_ComputationalWorkGroup_CreateFinish(worldWorkGroup, err)
    !Argument Variables
    TYPE(cmfe_ComputationalWorkGroupType), INTENT(INOUT) :: worldWorkGroup
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_ComputationalWorkGroup_CreateFinish",ERR,error,*999)

    CALL COMPUTATIONAL_WORK_GROUP_CREATE_FINISH(worldWorkGroup%computationalWorkGroup, err,error,*999)

    EXITS("cmfe_ComputationalWorkGroup_CreateFinish")
    RETURN
999 ERRORSEXITS("cmfe_ComputationalWorkGroup_CreateFinish",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ComputationalWorkGroup_CreateFinish

  !
  !================================================================================================================================
  !

  !>ADD WORK SUB-GROUP TO THE PARENT GROUP BASED ON THE COMPUTATIONAL REQUIREMENTS (CALLED BY THE USER)
  SUBROUTINE cmfe_ComputationalWorkGroup_SubgroupAdd(parentWorkGroup, numberComputationalNodes,addedWorkGroup, err)
    !Argument Variables
    TYPE(cmfe_ComputationalWorkGroupType), INTENT(INOUT) :: parentWorkGroup
    TYPE(cmfe_ComputationalWorkGroupType), INTENT(INOUT) :: addedWorkGroup
    INTEGER(INTG),INTENT(IN) :: numberComputationalNodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_ComputationalWorkGroup_SubgroupAdd",ERR,error,*999)

    CALL COMPUTATIONAL_WORK_GROUP_SUBGROUP_ADD(parentWorkGroup%computationalWorkGroup,numberComputationalNodes, &
    & addedWorkGroup%computationalWorkGroup, err,error,*999)

    EXITS("cmfe_ComputationalWorkGroup_SubgroupAdd")
    RETURN
999 ERRORSEXITS("cmfe_ComputationalWorkGroup_SubgroupAdd",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ComputationalWorkGroup_SubgroupAdd  !
  !================================================================================================================================
  !

  !>Set the working group tree in order to performe mesh decomposition
  SUBROUTINE cmfe_Decomposition_WorldWorkGroupSet(decomposition, worldWorkGroup, err)
    !Argument Variables
    TYPE(cmfe_DecompositionType), INTENT(INOUT) :: decomposition
    TYPE(cmfe_ComputationalWorkGroupType),INTENT(IN) :: worldWorkGroup
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_Decomposition_WorldWorkGroupSet",err,error,*999)

    ! todo
    CALL FlagError('not implemented yet', err,error, *999)

    EXITS("cmfe_Decomposition_WorldWorkGroupSet")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_WorldWorkGroupSet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_WorldWorkGroupSet

!!==================================================================================================================================
!!
!! CONTROL_LOOP_ROUTINES
!!
!!==================================================================================================================================

  !>Gets the current time parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_CurrentTimesGetNumber0(problemUserNumber,controlLoopIdentifier,currentTime,timeIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_CurrentTimesGetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_CURRENT_TIMES_GET(CONTROL_LOOP,currentTime,timeIncrement,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_CurrentTimesGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_CurrentTimesGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_CurrentTimesGetNumber0

  !
  !================================================================================================================================
  !

  !>Gets the current time parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_CurrentTimesGetNumber1(problemUserNumber,controlLoopIdentifiers,currentTime,timeIncrement,err)

    !Argument variables
     INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_CurrentTimesGetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_CURRENT_TIMES_GET(CONTROL_LOOP,currentTime,timeIncrement,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_CurrentTimesGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_CurrentTimesGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_CurrentTimesGetNumber1

  !
  !================================================================================================================================
  !

  !>Gets the current time parameters for a time control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_CurrentTimesGetObj(controlLoop,currentTime,timeIncrement,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the current times for.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_CurrentTimesGetObj",err,error,*999)

    CALL CONTROL_LOOP_CURRENT_TIMES_GET(controlLoop%controlLoop,currentTime,timeIncrement,err,error,*999)

    EXITS("cmfe_ControlLoop_CurrentTimesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_CurrentTimesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_CurrentTimesGetObj

  !
  !================================================================================================================================
  !

  !>Destroys a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_DestroyNumber0(problemUserNumber,controlLoopIdentifier,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_DestroyNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_DESTROY(CONTROL_LOOP,err,error,*999)
   ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_DestroyNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_DestroyNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_DestroyNumber0

  !
  !================================================================================================================================
  !

  !>Destroys a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_DestroyNumber1(problemUserNumber,controlLoopIdentifiers,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_DestroyNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_DESTROY(CONTROL_LOOP,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_DestroyNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_DestroyNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_DestroyNumber1

  !
  !================================================================================================================================
  !

  !>Destroys a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_DestroyObj(controlLoop,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_DestroyObj",err,error,*999)

    CALL CONTROL_LOOP_DESTROY(controlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_ControlLoop_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_ControlLoopGetNumber00(problemUserNumber,controlLoopRootIdentifier,controlLoopIdentifier, &
      & controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifier !<The root control loop identifier.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: ROOT_CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_ControlLoopGetNumber00",err,error,*999)

    NULLIFY(ROOT_CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopRootIdentifier,ROOT_CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_GET(ROOT_CONTROL_LOOP,controlLoopIdentifier,controlLoop%controlLoop,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_ControlLoopGetNumber00")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_ControlLoopGetNumber00",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_ControlLoopGetNumber00

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_ControlLoopGetNumber10(problemUserNumber,controlLoopRootIdentifiers,controlLoopIdentifier, &
      & controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifiers(:) !<The root control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: ROOT_CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_ControlLoopGetNumber10",err,error,*999)

    NULLIFY(ROOT_CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopRootIdentifiers,ROOT_CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_GET(ROOT_CONTROL_LOOP,controlLoopIdentifier,controlLoop%controlLoop,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_ControlLoopGetNumber10")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_ControlLoopGetNumber10",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_ControlLoopGetNumber10

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_ControlLoopGetNumber01(problemUserNumber,controlLoopRootIdentifier,controlLoopIdentifiers, &
      & controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifier !<The root control loop identifier.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: ROOT_CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_ControlLoopGetNumber01",err,error,*999)

    NULLIFY(ROOT_CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopRootIdentifier,ROOT_CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_GET(ROOT_CONTROL_LOOP,controlLoopIdentifiers,controlLoop%controlLoop,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_ControlLoopGetNumber01")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_ControlLoopGetNumber01",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_ControlLoopGetNumber01

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_ControlLoopGetNumber11(problemUserNumber,controlLoopRootIdentifiers,controlLoopIdentifiers, &
      & controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifiers(:) !<The root control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: ROOT_CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_ControlLoopGetNumber11",err,error,*999)

    NULLIFY(ROOT_CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopRootIdentifiers,ROOT_CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_GET(ROOT_CONTROL_LOOP,controlLoopIdentifiers,controlLoop%controlLoop,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_ControlLoopGetNumber11")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_ControlLoopGetNumber11",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_ControlLoopGetNumber11

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root.
  SUBROUTINE cmfe_ControlLoop_ControlLoopGetObj0(controlLoopRoot,controlLoopIdentifier,controlLoop,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoopRoot !<The root control loop.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_ControlLoopGetObj0",err,error,*999)

    CALL CONTROL_LOOP_GET(controlLoopRoot%controlLoop,controlLoopIdentifier,controlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_ControlLoop_ControlLoopGetObj0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_ControlLoopGetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_ControlLoopGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifiers from the control loop root.
  SUBROUTINE cmfe_ControlLoop_ControlLoopGetObj1(controlLoopRoot,controlLoopIdentifiers,controlLoop,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoopRoot !<The root control loop.
    INTEGER(INTG), INTENT(INOUT) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(cmfe_ControlLoopType), INTENT(OUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_ControlLoopGetObj1",err,error,*999)

    CALL CONTROL_LOOP_GET(controlLoopRoot%controlLoop,controlLoopIdentifiers,controlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_ControlLoop_ControlLoopGetObj1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_ControlLoopGetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_ControlLoopGetObj1

  !
  !================================================================================================================================
  !

  !>Sets/changes the iteration parameters for a fixed control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_IterationsSetNumber0(problemUserNumber,controlLoopIdentifier,startIteration,stopIteration, &
    & iterationIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: startIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: stopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: iterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_IterationsSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_ITERATIONS_SET(CONTROL_LOOP,startIteration,stopIteration,iterationIncrement,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_IterationsSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_IterationsSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_IterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the iteration parameters for a fixed control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_IterationsSetNumber1(problemUserNumber,controlLoopIdentifiers,startIteration,stopIteration, &
    & iterationIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: startIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: stopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: iterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_IterationsSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_ITERATIONS_SET(CONTROL_LOOP,startIteration,stopIteration,iterationIncrement,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_IterationsSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_IterationsSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_IterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the iteration parameters for a fixed control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_IterationsSetObj(controlLoop,startIteration,stopIteration,iterationIncrement,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: startIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: stopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: iterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_IterationsSetObj",err,error,*999)

    CALL CONTROL_LOOP_ITERATIONS_SET(controlLoop%controlLoop,startIteration,stopIteration,iterationIncrement,err,error,*999)

    EXITS("cmfe_ControlLoop_IterationsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_IterationsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_IterationsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a control loop identified by an user number.
  SUBROUTINE cmfe_ControlLoop_LabelGetCNumber0(problemUserNumber,controlLoopIdentifier,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_LabelGetCNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_GET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_LabelGetCNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelGetCNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelGetCNumber0

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a control loop identified by an user number.
  SUBROUTINE cmfe_ControlLoop_LabelGetCNumber1(problemUserNumber,controlLoopIdentifiers,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_LabelGetCNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_GET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_LabelGetCNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelGetCNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelGetCNumber1

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_LabelGetCObj(controlLoop,label,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_LabelGetCObj",err,error,*999)

    CALL CONTROL_LOOP_LABEL_GET(controlLoop%controlLoop,label,err,error,*999)

    EXITS("cmfe_ControlLoop_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a control loop identified by an user number.
  SUBROUTINE cmfe_ControlLoop_LabelGetVSNumber0(problemUserNumber,controlLoopIdentifier,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_LabelGetVSNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_GET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_LabelGetVSNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelGetVSNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelGetVSNumber0

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a control loop identified by an user number.
  SUBROUTINE cmfe_ControlLoop_LabelGetVSNumber1(problemUserNumber,controlLoopIdentifiers,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_LabelGetVSNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_GET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_LabelGetVSNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelGetVSNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelGetVSNumber1

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_LabelGetVSObj(controlLoop,label,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_LabelGetVSObj",err,error,*999)

    CALL CONTROL_LOOP_LABEL_GET(controlLoop%controlLoop,label,err,error,*999)

    EXITS("cmfe_ControlLoop_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a control loop identified by an user number.
  SUBROUTINE cmfe_ControlLoop_LabelSetCNumber0(problemUserNumber,controlLoopIdentifier,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_LabelSetCNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_SET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_LabelSetCNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelSetCNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelSetCNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a control loop identified by an user number.
  SUBROUTINE cmfe_ControlLoop_LabelSetCNumber1(problemUserNumber,controlLoopIdentifiers,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_LabelSetCNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_SET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_LabelSetCNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelSetCNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelSetCNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_LabelSetCObj(controlLoop,label,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_LabelSetCObj",err,error,*999)

    CALL CONTROL_LOOP_LABEL_SET(controlLoop%controlLoop,label,err,error,*999)

    EXITS("cmfe_ControlLoop_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a control loop identified by an user number.
  SUBROUTINE cmfe_ControlLoop_LabelSetVSNumber0(problemUserNumber,controlLoopIdentifier,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_LabelSetVSNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_SET(CONTROL_LOOP,CHAR(label),err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoopLabelStVSNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelSetVSNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelSetVSNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a control loop identified by an user number.
  SUBROUTINE cmfe_ControlLoop_LabelSetVSNumber1(problemUserNumber,controlLoopIdentifiers,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_LabelSetVSNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_SET(CONTROL_LOOP,CHAR(label),err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoopLabelStVSNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelSetVSNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelSetVSNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_LabelSetVSObj(controlLoop,label,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_LabelSetVSObj",err,error,*999)

    CALL CONTROL_LOOP_LABEL_SET(controlLoop%controlLoop,CHAR(label),err,error,*999)

    EXITS("cmfe_ControlLoop_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_MaximumIterationsSetNumber0(problemUserNumber,controlLoopIdentifier,maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_MaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_MAXIMUM_ITERATIONS_SET(CONTROL_LOOP,maximumIterations,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_MaximumIterationsSetNumber0")
    RETURN
999 ERRORS("cmfe_ControlLoop_MaximumIterationsSetNumber0",err,error)
    EXITS("cmfe_ControlLoop_MaximumIterationsSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_MaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_MaximumIterationsSetNumber1(problemUserNumber,controlLoopIdentifiers,maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_MaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_MAXIMUM_ITERATIONS_SET(CONTROL_LOOP,maximumIterations,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_MaximumIterationsSetNumber1")
    RETURN
999 ERRORS("cmfe_ControlLoop_MaximumIterationsSetNumber1",err,error)
    EXITS("cmfe_ControlLoop_MaximumIterationsSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_MaximumIterationsSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_MaximumIterationsSetObj(controlLoop,maximumIterations,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_MaximumIterationsSetObj",err,error,*999)

    CALL CONTROL_LOOP_MAXIMUM_ITERATIONS_SET(controlLoop%controlLoop,maximumIterations,err,error,*999)

    EXITS("cmfe_ControlLoop_MaximumIterationsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_MaximumIterationsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_MaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a load control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_LoadOutputSet(controlLoop,outputFrequency,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the output parameters for.
    INTEGER(INTG), INTENT(IN) ::  outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_LoadOutputSet",err,error,*999)

    CALL CONTROL_LOOP_LOAD_OUTPUT_SET(controlLoop%controlLoop,outputFrequency,err,error,*999)

    EXITS("cmfe_ControlLoop_LoadOutputSet")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_LoadOutputSet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_LoadOutputSet

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_AbsoluteToleranceSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL ControlLoop_AbsoluteToleranceSet(CONTROL_LOOP,absoluteTolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_AbsoluteToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_ControlLoop_AbsoluteToleranceSetNumber0",err,error)
    EXITS("cmfe_ControlLoop_AbsoluteToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_AbsoluteToleranceSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL ControlLoop_AbsoluteToleranceSet(CONTROL_LOOP,absoluteTolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_AbsoluteToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_ControlLoop_AbsoluteToleranceSetNumber1",err,error)
    EXITS("cmfe_ControlLoop_AbsoluteToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceSetObj(controlLoop,absoluteTolerance,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the maximum iterations for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance value for a control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_AbsoluteToleranceSetObj",err,error,*999)

    CALL ControlLoop_AbsoluteToleranceSet(controlLoop%controlLoop,absoluteTolerance,err,error,*999)

    EXITS("cmfe_ControlLoop_AbsoluteToleranceSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_AbsoluteToleranceSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_AbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !
  
  !>Returns the number of sub-control loops for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsGetNumber0(problemUserNumber,controlLoopIdentifier,numberOfSubLoops,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(OUT) :: numberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_NumberOfSubLoopsGetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_GET(CONTROL_LOOP,numberOfSubLoops,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_NumberOfSubLoopsGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_NumberOfSubLoopsGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the number of sub-control loops for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsGetNumber1(problemUserNumber,controlLoopIdentifiers,numberOfSubLoops,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(OUT) :: numberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_NumberOfSubLoopsGetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_GET(CONTROL_LOOP,numberOfSubLoops,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_NumberOfSubLoopsGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_NumberOfSubLoopsGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the number of sub-control loops for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsGetObj(controlLoop,numberOfSubLoops,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the number of sub loops for.
    INTEGER(INTG), INTENT(OUT) :: numberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_NumberOfSubLoopsGetObj",err,error,*999)

    CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_GET(controlLoop%controlLoop,numberOfSubLoops,err,error,*999)

    EXITS("cmfe_ControlLoop_NumberOfSubLoopsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_NumberOfSubLoopsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of sub-control loops for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsSetNumber0(problemUserNumber,controlLoopIdentifier,numberOfSubLoops,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: numberOfSubLoops !<The number of sub loops for the specified control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoopNumberOfSubLoopsSetNumber",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_SET(CONTROL_LOOP,numberOfSubLoops,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_NumberOfSubLoopsSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_NumberOfSubLoopsSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of sub-control loops for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsSetNumber1(problemUserNumber,controlLoopIdentifiers,numberOfSubLoops,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the number of sub loops for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: numberOfSubLoops !<The number of sub loops for the specified control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_NumberOfSubLoopsSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_SET(CONTROL_LOOP,numberOfSubLoops,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_NumberOfSubLoopsSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_NumberOfSubLoopsSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of sub-control loops for a control loop identified by an object. \todo is this really public???
  SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsSetObj(controlLoop,numberOfSubLoops,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the number of sub loops for.
    INTEGER(INTG), INTENT(IN) :: numberOfSubLoops !<The number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_NumberOfSubLoopsSetObj",err,error,*999)

    CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_SET(controlLoop%controlLoop,numberOfSubLoops,err,error,*999)

    EXITS("cmfe_ControlLoop_NumberOfSubLoopsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_NumberOfSubLoopsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_NumberOfSubLoopsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the output type for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_OutputTypeGetNumber0(problemUserNumber,controlLoopIdentifier,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the control loop \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_OutputTypeGetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_OUTPUT_TYPE_GET(CONTROL_LOOP,outputType,err,error,*999)
   ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_OutputTypeGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_OutputTypeGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_OutputTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the output type for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_OutputTypeGetNumber1(problemUserNumber,controlLoopIdentifiers,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the control loop \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_OutputTypeGetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_OUTPUT_TYPE_GET(CONTROL_LOOP,outputType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_OutputTypeGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_OutputTypeGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_OutputTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the output type for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_OutputTypeGetObj(controlLoop,outputType,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the control loop \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_OutputTypeGetObj",err,error,*999)

    CALL CONTROL_LOOP_OUTPUT_TYPE_GET(controlLoop%controlLoop,outputType,err,error,*999)

    EXITS("cmfe_ControlLoop_OutputTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_OutputTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets the output type for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_OutputTypeSetNumber0(problemUserNumber,controlLoopIdentifier,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type to set \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_OutputTypeSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_OUTPUT_TYPE_SET(CONTROL_LOOP,outputType,err,error,*999)
   ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_OutputTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_OutputTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_OutputTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the output type for a control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_OutputTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type to set \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_OutputTypeSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_OUTPUT_TYPE_SET(CONTROL_LOOP,outputType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_OutputTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_OutputTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_OutputTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the output type for a control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_OutputTypeSetObj(controlLoop,outputType,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type to set \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_OutputTypeSetObj",err,error,*999)

    CALL CONTROL_LOOP_OUTPUT_TYPE_SET(controlLoop%controlLoop,outputType,err,error,*999)

    EXITS("cmfe_ControlLoop_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_OutputTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_TimeOutputSetNumber0(problemUserNumber,controlLoopIdentifier,outputFrequency,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_TimeOutputSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIME_OUTPUT_SET(CONTROL_LOOP,outputFrequency,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_TimeOutputSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimeOutputSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimeOutputSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_TimeOutputSetNumber1(problemUserNumber,controlLoopIdentifiers,outputFrequency,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(VARYING_STRING) :: localError
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM

    ENTERS("cmfe_ControlLoop_TimeOutputSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIME_OUTPUT_SET(CONTROL_LOOP,outputFrequency,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_TimeOutputSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimeOutputSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimeOutputSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a time control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_TimeOutputSetObj(controlLoop,outputFrequency,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the output parameters for.
    INTEGER(INTG), INTENT(IN) ::  outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_TimeOutputSetObj",err,error,*999)

    CALL CONTROL_LOOP_TIME_OUTPUT_SET(controlLoop%controlLoop,outputFrequency,err,error,*999)

    EXITS("cmfe_ControlLoop_TimeOutputSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimeOutputSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimeOutputSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the input parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_TimeInputSetNumber0(problemUserNumber,controlLoopIdentifier,inputOption,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: inputOption !<The input option modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_TimeInputSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIME_OUTPUT_SET(CONTROL_LOOP,inputOption,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_TimeInputSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimeInputSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimeInputSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the input parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_TimeInputSetNumber1(problemUserNumber,controlLoopIdentifiers,inputOption,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: inputOption !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(VARYING_STRING) :: localError
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM

    ENTERS("cmfe_ControlLoop_TimeInputSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIME_OUTPUT_SET(CONTROL_LOOP,inputOption,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_TimeInputSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimeInputSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimeInputSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the input parameters for a time control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_TimeInputSetObj(controlLoop,inputOption,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the output parameters for.
    INTEGER(INTG), INTENT(IN) ::  inputOption !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_TimeInputSetObj",err,error,*999)

    CALL CONTROL_LOOP_TIME_INPUT_SET(controlLoop%controlLoop,inputOption,err,error,*999)

    EXITS("cmfe_ControlLoop_TimeInputSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimeInputSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimeInputSetObj


  !
  !================================================================================================================================
  !

  !>Returns the time parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_TimesGetNumber0(problemUserNumber,controlLoopIdentifier,startTime,stopTime,timeIncrement, &
    & currentTime,currentLoopIteration,outputIterationNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: startTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: stopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: currentLoopIteration !<On return, the iteration number for the current loop.
    INTEGER(INTG), INTENT(OUT) :: outputIterationNumber !<On return, the iteration number for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_TimesGetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIMES_GET(CONTROL_LOOP,startTime,stopTime,timeIncrement,currentTime, &
        & currentLoopIteration,outputIterationNumber,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_TimesGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimesGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimesGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the time parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_TimesGetNumber1(problemUserNumber,controlLoopIdentifiers,startTime,stopTime,timeIncrement, &
    & currentTime,currentLoopIteration,outputIterationNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: startTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: stopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: currentLoopIteration !<On return, the iteration number for the current loop.
    INTEGER(INTG), INTENT(OUT) :: outputIterationNumber !<On return, the iteration number for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_TimesGetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIMES_GET(CONTROL_LOOP,startTime,stopTime,timeIncrement,currentTime, &
        & currentLoopIteration,outputIterationNumber,err,error,*999)
   ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_TimesGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimesGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimesGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the time parameters for a time control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_TimesGetObj(controlLoop,startTime,stopTime,timeIncrement,currentTime, &
    & currentLoopIteration,outputIterationNumber,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the times for.
    REAL(DP), INTENT(OUT) :: startTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: stopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: currentLoopIteration !<On return, the iteration number for the current loop.
    INTEGER(INTG), INTENT(OUT) :: outputIterationNumber !<On return, the iteration number for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_TimesGetObj",err,error,*999)

    CALL CONTROL_LOOP_TIMES_GET(controlLoop%controlLoop,startTime,stopTime,timeIncrement,currentTime, &
      & currentLoopIteration,outputIterationNumber,err,error,*999)

    EXITS("cmfe_ControlLoop_TimesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the time parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_TimesSetNumber0(problemUserNumber,controlLoopIdentifier,startTime,stopTime,timeIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: stopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_TimesSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIMES_SET(CONTROL_LOOP,startTime,stopTime,timeIncrement,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_TimesSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimesSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimesSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the time parameters for a time control loop identified by user numbers.
  SUBROUTINE cmfe_ControlLoop_TimesSetNumber1(problemUserNumber,controlLoopIdentifiers,startTime,stopTime,timeIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: stopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(VARYING_STRING) :: localError
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM

    ENTERS("cmfe_ControlLoop_TimesSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIMES_SET(CONTROL_LOOP,startTime,stopTime,timeIncrement,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_TimesSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimesSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimesSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the time parameters for a time control loop identified by an object.
  SUBROUTINE cmfe_ControlLoop_TimesSetObj(controlLoop,startTime,stopTime,timeIncrement,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: stopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_TimesSetObj",err,error,*999)

    CALL CONTROL_LOOP_TIMES_SET(controlLoop%controlLoop,startTime,stopTime,timeIncrement,err,error,*999)

    EXITS("cmfe_ControlLoop_TimesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TimesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TimesSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the loop type for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE cmfe_ControlLoop_TypeSetNumber0(problemUserNumber,controlLoopIdentifier,loopType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: loopType !<The type of control loop to set. \see OPENCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_TypeSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TYPE_SET(CONTROL_LOOP,loopType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_TypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the loop type for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE cmfe_ControlLoop_TypeSetNumber1(problemUserNumber,controlLoopIdentifiers,loopType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: loopType !<The type of control loop to set. \see OPENCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_ControlLoop_TypeSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TYPE_SET(CONTROL_LOOP,loopType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_ControlLoop_TypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the loop type for a control loop identified by an object. \todo is this really public???
  SUBROUTINE cmfe_ControlLoop_TypeSetObj(controlLoop,loopType,err)

    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: loopType !<The type of control loop to set. \see OPENCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_ControlLoop_TypeSetObj",err,error,*999)

    CALL CONTROL_LOOP_TYPE_SET(controlLoop%controlLoop,loopType,err,error,*999)

    EXITS("cmfe_ControlLoop_TypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_ControlLoop_TypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_ControlLoop_TypeSetObj

!!==================================================================================================================================
!!
!! COORDINATE_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the creation of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_CreateFinishNumber(coordinateSystemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CoordinateSystem_CreateFinishNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_CREATE_FINISH(COORDINATE_SYSTEM,err,error,*999)
    ELSE
      localError="A coordinate system with an user number of "// &
        & TRIM(NumberToVString(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Coordinate System Create')
#endif

    EXITS("cmfe_CoordinateSystem_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_CreateFinishObj(coordinateSystem,err)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_CreateFinishObj",err,error,*999)

    CALL COORDINATE_SYSTEM_CREATE_FINISH(coordinateSystem%coordinateSystem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Coordinate System Create')
#endif

    EXITS("cmfe_CoordinateSystem_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_CreateStartNumber(coordinateSystemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM

    ENTERS("cmfe_CoordinateSystem_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Coordinate System Create')
#endif

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_CREATE_START(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)

    EXITS("cmfe_CoordinateSystem_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_CreateStartObj(coordinateSystemUserNumber,coordinateSystem,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to start creating.
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<On return, the coordinate system that has been created.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Coordinate System Create')
#endif

    CALL COORDINATE_SYSTEM_CREATE_START(coordinateSystemUserNumber,coordinateSystem%coordinateSystem,err,error,*999)

    EXITS("cmfe_CoordinateSystem_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_DestroyNumber(coordinateSystemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CoordinateSystem_DestroyNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_DESTROY(COORDINATE_SYSTEM,err,error,*999)
    ELSE
      localError="A coordinate system with an user number of "// &
        & TRIM(NumberToVString(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CoordinateSystem_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_DestroyObj(coordinateSystem,err)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSysteDestroyObj",err,error,*999)

    CALL COORDINATE_SYSTEM_DESTROY(coordinateSystem%coordinateSystem,err,error,*999)

    EXITS("cmfe_CoordinateSystem_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the dimension of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_DimensionGetNumber(coordinateSystemUserNumber,coordinateSystemDimension,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the dimension for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemDimension !<On return, the dimension of the coordinate system
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CoordinateSystem_DimensionGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_DIMENSION_GET(COORDINATE_SYSTEM,coordinateSystemDimension,err,error,*999)
    ELSE
      localError="A coordinate system with an user number of "// &
        & TRIM(NumberToVString(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CoordinateSystem_DimensionGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_DimensionGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_DimensionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the dimension of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_DimensionGetObj(coordinateSystem,coordinateSystemDimension,err)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the dimension for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemDimension !<On return, the dimension of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_DimensionGetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_DIMENSION_GET(coordinateSystem%coordinateSystem,coordinateSystemDimension,err,error,*999)

    EXITS("cmfe_CoordinateSystem_DimensionGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_DimensionGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_DimensionGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_DimensionSetNumber(coordinateSystemUserNumber,coordinateSystemDimension,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemDimension !<The dimension of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CoordinateSystem_DimensionSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_DIMENSION_SET(COORDINATE_SYSTEM,coordinateSystemDimension,err,error,*999)
    ELSE
      localError="A coordinate system with an user number of "// &
        & TRIM(NumberToVString(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CoordinateSystem_DimensionSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_DimensionSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_DimensionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_DimensionSetObj(coordinateSystem,coordinateSystemDimension,err)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT)  :: coordinateSystem !<The coordinate system to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemDimension !<The dimension of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_DimensionSetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_DIMENSION_SET(coordinateSystem%coordinateSystem,coordinateSystemDimension,err,error,*999)

    EXITS("cmfe_CoordinateSystem_DimensionSetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_DimensionSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_DimensionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the focus of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_FocusGetNumber(coordinateSystemUserNumber,focus,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the focus for.
    REAL(DP), INTENT(OUT) :: focus !<On return, the focus of the coordinate system
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CoordinateSystem_FocusGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_FOCUS_GET(COORDINATE_SYSTEM,focus,err,error,*999)
    ELSE
      localError="A coordinate system with an user number of "// &
        & TRIM(NumberToVString(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CoordinateSystem_FocusGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_FocusGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_FocusGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the focus of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_FocusGetObj(coordinateSystem,focus,err)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the focus for.
    REAL(DP), INTENT(OUT) :: focus !<On return, the focus of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_FocusGetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_FOCUS_GET(coordinateSystem%coordinateSystem,focus,err,error,*999)

    EXITS("cmfe_CoordinateSystem_FocusGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_FocusGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_FocusGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the focus of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_FocusSetNumber(coordinateSystemUserNumber,focus,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the focus for.
    REAL(DP), INTENT(IN) :: focus !<The focus of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CoordinateSystem_FocusSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_FOCUS_SET(COORDINATE_SYSTEM,focus,err,error,*999)
    ELSE
      localError="A coordinate system with an user number of "// &
        & TRIM(NumberToVString(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CoordinateSystem_FocusSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_FocusSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_FocusSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the focus of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_FocusSetObj(coordinateSystem,focus,err)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to set the focus for.
    REAL(DP), INTENT(IN) :: focus !<The focus of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_FocusSetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_FOCUS_SET(coordinateSystem%coordinateSystem,focus,err,error,*999)

    EXITS("cmfe_CoordinateSystem_FocusSetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_FocusSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_FocusSetObj

  !
  !================================================================================================================================
  !

  !>Returns the radial interpolation type of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_RadialInterpolationGetNumber(coordinateSystemUserNumber,radialInterpolationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the radial interpolation for.
    INTEGER(INTG), INTENT(OUT) :: radialInterpolationType !<On return, the radial interpolation type of the coordinate system \see OPENCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CoordinateSystem_RadialInterpolationGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL Coordinates_RadialInterpolationTypeGet(COORDINATE_SYSTEM,radialInterpolationType,err,error,*999)
    ELSE
      localError="A coordinate system with an user number of "// &
        & TRIM(NumberToVString(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CoordinateSystem_RadialInterpolationGetNumber")
    RETURN
999 ERRORS("cmfe_CoordinateSystem_RadialInterpolationGetNumber",err,error)
    EXITS("cmfe_CoordinateSystem_RadialInterpolationGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_RadialInterpolationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the radial interpolation type of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_RadialInterpolationGetObj(coordinateSystem,radialInterpolationType,err)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to get the radial interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: radialInterpolationType !<On return, the radial interpolation type of the coordinate system. \see OPENCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_RadialInterpolationGetObj",err,error,*999)

    CALL Coordinates_RadialInterpolationTypeGet(coordinateSystem%coordinateSystem,radialInterpolationType,err,error,*999)

    EXITS("cmfe_CoordinateSystem_RadialInterpolationGetObj")
    RETURN
999 ERRORS("cmfe_CoordinateSystem_RadialInterpolationGetObj",err,error)
    EXITS("cmfe_CoordinateSystem_RadialInterpolationGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_RadialInterpolationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the radial interpolation type of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_RadialInterpolationSetNumber(coordinateSystemUserNumber,radialInterpolationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the radial interpolation for.
    INTEGER(INTG), INTENT(IN) :: radialInterpolationType !<The radial interpolation type of the coordinate system to set.\see OPENCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CoordinateSystem_RadialInterpolationSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL Coordinates_RadialInterpolationTypeSet(COORDINATE_SYSTEM,radialInterpolationType,err,error,*999)
    ELSE
      localError="A coordinate system with an user number of "// &
        & TRIM(NumberToVString(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CoordinateSystem_RadialInterpolationSetNumber")
    RETURN
999 ERRORS("cmfe_CoordinateSystem_RadialInterpolationSetNumber",err,error)
    EXITS("cmfe_CoordinateSystem_RadialInterpolationSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_RadialInterpolationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the radial interpolation type of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_RadialInterpolationSetObj(coordinateSystem,radialInterpolationType,err)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT)  :: coordinateSystem !<The coordinate system to set the radial interpolation type for.
    INTEGER(INTG), INTENT(IN) :: radialInterpolationType !<The radial interpolation type of the coordinate system to set. \see OPENCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_RadialInterpolationSetObj",err,error,*999)

    CALL Coordinates_RadialInterpolationTypeSet(coordinateSystem%coordinateSystem,radialInterpolationType,err,error,*999)

    EXITS("cmfe_CoordinateSystem_RadialInterpolationSetObj")
    RETURN
999 ERRORS("cmfe_CoordinateSystem_RadialInterpolationSetObj",err,error)
    EXITS("cmfe_CoordinateSystem_RadialInterpolationSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_RadialInterpolationSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_TypeGetNumber(coordinateSystemUserNumber,coordinateSystemType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the type for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemType !<On return, the type of the coordinate system. \see OPENCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CoordinateSystem_TypeGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_TYPE_GET(COORDINATE_SYSTEM,coordinateSystemType,err,error,*999)
    ELSE
      localError="A coordinate system with an user number of "// &
        & TRIM(NumberToVString(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CoordinateSystem_TypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_TypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_TypeGetObj(coordinateSystem,coordinateSystemType,err)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the type for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemType !<On return, the type of the coordinate system. \see OPENCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_TypeGetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_TYPE_GET(coordinateSystem%coordinateSystem,coordinateSystemType,err,error,*999)

    EXITS("cmfe_CoordinateSystem_TypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_TypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_TypeSetNumber(coordinateSystemUserNumber,coordinateSystemType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the type for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemType !<The type of the coordinate system to set. \see OPENCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CoordinateSystem_TypeSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_TYPE_SET(COORDINATE_SYSTEM,coordinateSystemType,err,error,*999)
    ELSE
      localError="A coordinate system with an user number of "// &
        & TRIM(NumberToVString(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CoordinateSystem_TypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_TypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_TypeSetObj(coordinateSystem,coordinateSystemType,err)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to set the type for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemType !<The type of the coordinate system to set. \see OPENCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_TypeSetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_TYPE_SET(coordinateSystem%coordinateSystem,coordinateSystemType,err,error,*999)

    EXITS("cmfe_CoordinateSystem_TypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_TypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_TypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the origin of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_OriginGetNumber(coordinateSystemUserNumber,origin,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<On return, the orign of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CoordinateSystem_OriginGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_ORIGIN_GET(COORDINATE_SYSTEM,origin,err,error,*999)
    ELSE
      localError="A coordinate system with an user number of "// &
        & TRIM(NumberToVString(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CoordinateSystem_OriginGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_OriginGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_OriginGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the origin of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_OriginGetObj(coordinateSystem,origin,err)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<On return, the origin of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_OriginGetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_ORIGIN_GET(coordinateSystem%coordinateSystem,origin,err,error,*999)

    EXITS("cmfe_CoordinateSystem_OriginGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_OriginGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_OriginGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_OriginSetNumber(coordinateSystemUserNumber,origin,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<The orign of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CoordinateSystem_OriginSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_ORIGIN_SET(COORDINATE_SYSTEM,origin,err,error,*999)
    ELSE
      localError="A coordinate system with an user number of "// &
        & TRIM(NumberToVString(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CoordinateSystem_OriginSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_OriginSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_OriginSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_OriginSetObj(coordinateSystem,origin,err)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<The origin of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_OriginSetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_ORIGIN_SET(coordinateSystem%coordinateSystem,origin,err,error,*999)

    EXITS("cmfe_CoordinateSystem_OriginSetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_OriginSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_OriginSetObj

  !
  !================================================================================================================================
  !

  !>Returns the orientation of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_OrientationGetNumber(coordinateSystemUserNumber,orientation,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the orientation for.
    REAL(DP), INTENT(OUT) :: orientation(:,:) !<On return, the orientation of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CoordinateSystem_OrientationGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_ORIENTATION_GET(COORDINATE_SYSTEM,ORIENTATION,err,error,*999)
    ELSE
      localError="A coordinate system with an user number of "// &
        & TRIM(NumberToVString(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CoordinateSystem_OrientationGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_OrientationGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_OrientationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the orientation of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_OrientationGetObj(coordinateSystem,orientation,err)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the orientation for.
    REAL(DP), INTENT(OUT) :: orientation(:,:) !<On return, the orientation of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_OrientationGetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_ORIENTATION_GET(coordinateSystem%coordinateSystem,orientation,err,error,*999)

    EXITS("cmfe_CoordinateSystem_OrientationGetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_OrientationGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_OrientationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the orientation of a coordinate system identified by a user number.
  SUBROUTINE cmfe_CoordinateSystem_OrientationSetNumber(coordinateSystemUserNumber,orientation,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the orientation for.
    REAL(DP), INTENT(IN) :: orientation(:,:) !<The orientation of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CoordinateSystem_OrientationSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_ORIENTATION_SET(COORDINATE_SYSTEM,ORIENTATION,err,error,*999)
    ELSE
      localError="A coordinate system with an user number of "// &
        & TRIM(NumberToVString(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CoordinateSystem_OrientationSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_OrientationSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_OrientationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the orientation of a coordinate system identified by an object.
  SUBROUTINE cmfe_CoordinateSystem_OrientationSetObj(coordinateSystem,orientation,err)

    !Argument variables
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to set the orientation for.
    REAL(DP), INTENT(IN) :: orientation(:,:) !<The orientation of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CoordinateSystem_OrientationSetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_ORIENTATION_SET(coordinateSystem%coordinateSystem,orientation,err,error,*999)

    EXITS("cmfe_CoordinateSystem_OrientationSetObj")
    RETURN
999 ERRORSEXITS("cmfe_CoordinateSystem_OrientationSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CoordinateSystem_OrientationSetObj

!!==================================================================================================================================
!!
!! DATA_POINT_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the process of creating data points in a region for data points identified by user number.
  SUBROUTINE cmfe_DataPoints_CreateFinishNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataPoints_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_CREATE_FINISH(DATA_POINTS,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataPoints_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a data points in a region for data points identified by an object.
  SUBROUTINE cmfe_DataPoints_CreateFinishObj(dataPoints,err)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_CreateFinishObj",err,error,*999)

    CALL DATA_POINTS_CREATE_FINISH(dataPoints%dataPoints,err,error,*999)

    EXITS("cmfe_DataPoints_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating data points in a region for data points identified by user number.
  SUBROUTINE cmfe_DataPoints_CreateStartNumber(regionUserNumber,numberOfDataPoints,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDataPoints !<The number of data points to create.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataPoints_CreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL DATA_POINTS_CREATE_START(REGION,numberOfDataPoints,DATA_POINTS,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataPoints_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a data points in a region for data points identified by an object.
  SUBROUTINE cmfe_DataPoints_CreateStartObj(region,numberOfDataPoints,dataPoints,err)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to start the creation of data points on.
    INTEGER(INTG), INTENT(IN) :: numberOfDataPoints !<The number of data points to create.
    TYPE(cmfe_DataPointsType), INTENT(INOUT) :: dataPoints !<On return, the created data points.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_CreateStartObj",err,error,*999)

    CALL DATA_POINTS_CREATE_START(region%region,numberOfDataPoints,dataPoints%dataPoints,err,error,*999)

    EXITS("cmfe_DataPoints_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a data points in a region for data points identified by an object.
  SUBROUTINE cmfe_DataPoints_CreateStartInterfaceObj(interface,numberOfDataPoints,dataPoints,err)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to start the creation of data points on.
    INTEGER(INTG), INTENT(IN) :: numberOfDataPoints !<The number of data points to create.
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<On return, the created data points.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_CreateStartInterfaceObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('dataPoints Create')
#endif

    CALL DATA_POINTS_CREATE_START(interface%interface,numberOfDataPoints,dataPoints%dataPoints,err,error,*999)

    EXITS("cmfe_DataPoints_CreateStartInterfaceObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_CreateStartInterfaceObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_CreateStartInterfaceObj


  !
  !================================================================================================================================
  !

  !>Destroys the data points in a region for data points identified by user number.
  SUBROUTINE cmfe_DataPoints_DestroyNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataPoints_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DESTROY(DATA_POINTS,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataPoints_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the data points in a region for data points identified by an object.
  SUBROUTINE cmfe_DataPoints_DestroyObj(dataPoints,err)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_DestroyObj",err,error,*999)

    CALL DATA_POINTS_DESTROY(dataPoints%dataPoints,err,error,*999)

    EXITS("cmfe_DataPoints_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the number of data points
  SUBROUTINE cmfe_DataPoints_NumberOfDataPointsGetNumber(regionUserNumber,numberOfDataPoints,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get data point count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDataPoints !<On return, the number of data points
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataPoints_NumberOfDataPointsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_NUMBER_OF_DATA_POINTS_GET(DATA_POINTS,numberOfDataPoints,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataPoints_NumberOfDataPointsGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_NumberOfDataPointsGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_NumberOfDataPointsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of data points
  SUBROUTINE cmfe_DataPoints_NumberOfDataPointsGetObj(dataPoints,numberOfDataPoints,err)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points get data point count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDataPoints !<The number of data points
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_NumberOfDataPointsGetObj",err,error,*999)

    CALL DATA_POINTS_NUMBER_OF_DATA_POINTS_GET(dataPoints%dataPoints,numberOfDataPoints,err,error,*999)

    EXITS("cmfe_DataPoints_NumberOfDataPointsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_NumberOfDataPointsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_NumberOfDataPointsGetObj


  !
  !================================================================================================================================
  !

  !>Returns the character label for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_LabelGetCNumber(regionUserNumber,dataPointGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataPoints_LabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_LABEL_GET(DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataPoints_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_LabelGetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character label for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataPoints_LabelGetCObj(dataPoints,dataPointGlobalNumber,label,err)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_LabelGetCObj",err,error,*999)

    CALL DATA_POINTS_LABEL_GET(dataPoints%dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("cmfe_DataPoints_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_LabelGetVSNumber(regionUserNumber,dataPointGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataPoints_LabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_LABEL_GET(DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataPoints_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_LabelGetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataPoints_LabelGetVSObj(dataPoints,dataPointGlobalNumber,label,err)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_LabelGetVSObj",err,error,*999)

    CALL DATA_POINTS_LABEL_GET(dataPoints%dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("cmfe_DataPoints_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_LabelSetCNumber(regionUserNumber,dataPointGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataPoints_LabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_LABEL_SET(DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataPoints_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_LabelSetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataPoints_LabelSetCObj(dataPoints,dataPointGlobalNumber,label,err)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_LabelSetCObj",err,error,*999)

    CALL DATA_POINTS_LABEL_SET(dataPoints%dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("cmfe_DataPoints_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_LabelSetVSNumber(regionUserNumber,dataPointGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataPoints_LabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_LABEL_SET(DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataPoints_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_LabelSetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataPoints_LabelSetVSObj(dataPoints,dataPointGlobalNumber,label,err)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_LabelSetVSObj",err,error,*999)

    CALL DATA_POINTS_LABEL_SET(dataPoints%dataPoints,dataPointGlobalNumber,label,err,error,*999)

    EXITS("cmfe_DataPoints_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the user number for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_UserNumberGetNumber(regionUserNumber,dataPointGlobalNumber,dataPointUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointUserNumber !<On return, the user number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataPoints_UserNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_USER_NUMBER_GET(DATA_POINTS,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataPoints_UserNumberGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_UserNumberGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_UserNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the user number for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataPoints_UserNumberGetObj(dataPoints,dataPointGlobalNumber,dataPointUserNumber,err)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointUserNumber !<On return, the user number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_UserNumberGetObj",err,error,*999)

    CALL DATA_POINTS_USER_NUMBER_GET(dataPoints%dataPoints,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)

    EXITS("cmfe_DataPoints_UserNumberGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_UserNumberGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_UserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_UserNumberSetNumber(regionUserNumber,dataPointGlobalNumber,dataPointUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataPoints_UserNumberSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_USER_NUMBER_SET(DATA_POINTS,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataPoints_UserNumberSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_UserNumberSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_UserNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataPoints_UserNumberSetObj(dataPoints,dataPointGlobalNumber,dataPointUserNumber,err)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_UserNumberSetObj",err,error,*999)

    CALL DATA_POINTS_USER_NUMBER_SET(dataPoints%dataPoints,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)

    EXITS("cmfe_DataPoints_UserNumberSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_UserNumberSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_UserNumberSetObj

  !
  !================================================================================================================================
  !

  !>Returns the values for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_ValuesGetNumber(regionUserNumber,dataPointGlobalNumber,dataPointValues,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point values for.
    REAL(DP), INTENT(OUT) :: dataPointValues(:) !<On return, the values for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataPoints_ValuesGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_VALUES_GET(DATA_POINTS,dataPointGlobalNumber,dataPointValues,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataPoints_ValuesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_ValuesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_ValuesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the values for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataPoints_ValuesGetObj(dataPoints,dataPointGlobalNumber,dataPointValues,err)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    REAL(DP), INTENT(OUT) :: dataPointValues(:) !<On return, the values for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_ValuesGetObj",err,error,*999)

    CALL DATA_POINTS_VALUES_GET(dataPoints%dataPoints,dataPointGlobalNumber,dataPointValues,err,error,*999)

    EXITS("cmfe_DataPoints_ValuesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_ValuesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_ValuesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the values for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_ValuesSetNumber(regionUserNumber,dataPointGlobalNumber,dataPointValues,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    REAL(DP), INTENT(IN) :: dataPointValues(:) !<The values for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataPoints_ValuesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_VALUES_SET(DATA_POINTS,dataPointGlobalNumber,dataPointValues,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataPoints_ValuesSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_ValuesSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_ValuesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the values for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataPoints_ValuesSetObj(dataPoints,dataPointGlobalNumber,dataPointValues,err)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    REAL(DP), INTENT(IN) :: dataPointValues(:) !<The values for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_ValuesSetObj",err,error,*999)

    CALL DATA_POINTS_VALUES_SET(dataPoints%dataPoints,dataPointGlobalNumber,dataPointValues,err,error,*999)

    EXITS("cmfe_DataPoints_ValuesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_ValuesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_ValuesSetObj

  !
  !================================================================================================================================
  !

  !>Returns the weights for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_WeightsGetNumber(regionUserNumber,dataPointGlobalNumber,dataPointWeights,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    REAL(DP), INTENT(OUT) :: dataPointWeights(:) !<On return, the weights for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataPoints_WeightsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_WEIGHTS_GET(DATA_POINTS,dataPointGlobalNumber,dataPointWeights,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataPoints_WeightsGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_WeightsGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_WeightsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the weights for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataPoints_WeightsGetObj(dataPoints,dataPointGlobalNumber,dataPointWeights,err)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    REAL(DP), INTENT(OUT) :: dataPointWeights(:) !<On return, the weights for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_WeightsGetObj",err,error,*999)

    CALL DATA_POINTS_WEIGHTS_GET(dataPoints%dataPoints,dataPointGlobalNumber,dataPointWeights,err,error,*999)

    EXITS("cmfe_DataPoints_WeightsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_WeightsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_WeightsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the weights for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataPoints_WeightsSetNumber(regionUserNumber,dataPointGlobalNumber,dataPointWeights,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    REAL(DP), INTENT(IN) :: dataPointWeights(:) !<The weights for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataPoints_WeightsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_WEIGHTS_SET(DATA_POINTS,dataPointGlobalNumber,dataPointWeights,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataPoints_WeightsSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_WeightsSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_WeightsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the weights for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataPoints_WeightsSetObj(dataPoints,dataPointGlobalNumber,dataPointWeights,err)

    !Argument variables
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    REAL(DP), INTENT(IN) :: dataPointWeights(:) !<The weights for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataPoints_WeightsSetObj",err,error,*999)

    CALL DATA_POINTS_WEIGHTS_SET(dataPoints%dataPoints,dataPointGlobalNumber,dataPointWeights,err,error,*999)

    EXITS("cmfe_DataPoints_WeightsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataPoints_WeightsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataPoints_WeightsSetObj

!!==================================================================================================================================
!!
!! DATA_PROJECTION_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the absolute tolerance of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_AbsoluteToleranceGetNumber(dataProjectionUserNumber,regionUserNumber,absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get tolerance for.
    REAL(DP), INTENT(OUT) :: absoluteTolerance !<On exit, the absolute tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    ENTERS("cmfe_DataProjection_AbsoluteToleranceGetNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      CALL DATA_PROJECTION_ABSOLUTE_TOLERANCE_GET(DATA_PROJECTION,absoluteTolerance,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_AbsoluteToleranceGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_AbsoluteToleranceGetNumber",err,error)
    EXITS("cmfe_DataProjection_AbsoluteToleranceGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_AbsoluteToleranceGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the absolute tolerance of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_AbsoluteToleranceGetObj(dataProjection,absoluteTolerance,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get tolerance for.
    REAL(DP), INTENT(OUT) :: absoluteTolerance !<On exit, the absolute tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_AbsoluteToleranceGetObj",err,error,*999)

    CALL DATA_PROJECTION_ABSOLUTE_TOLERANCE_GET(dataProjection%dataProjection,absoluteTolerance,err,error,*999)

    EXITS("cmfe_DataProjection_AbsoluteToleranceGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_AbsoluteToleranceGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_AbsoluteToleranceGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_AbsoluteToleranceSetNumber(dataProjectionUserNumber,regionUserNumber,absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<the absolute tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    ENTERS("cmfe_DataProjection_AbsoluteToleranceSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      CALL DATA_PROJECTION_ABSOLUTE_TOLERANCE_SET(DATA_PROJECTION,absoluteTolerance,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_AbsoluteToleranceSetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_AbsoluteToleranceSetNumber",err,error)
    EXITS("cmfe_DataProjection_AbsoluteToleranceSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_AbsoluteToleranceSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_AbsoluteToleranceSetObj(dataProjection,absoluteTolerance,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<the absolute tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_AbsoluteToleranceSetObj",err,error,*999)

    CALL DATA_PROJECTION_ABSOLUTE_TOLERANCE_SET(dataProjection%dataProjection,absoluteTolerance,err,error,*999)

    EXITS("cmfe_DataProjection_AbsoluteToleranceSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_AbsoluteToleranceSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_AbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a new data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_CreateFinishNumber(dataProjectionUserNumber,regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points which associates to the data projection to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    ENTERS("cmfe_DataProjection_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      CALL DATA_PROJECTION_CREATE_FINISH(DATA_PROJECTION,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a new data projection identified by an object.
  SUBROUTINE cmfe_DataProjection_CreateFinishObj(dataProjection,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_DataProjection_CreateFinishObj",err,error,*999)

    CALL DATA_PROJECTION_CREATE_FINISH(dataProjection%dataProjection,err,error,*999)

    EXITS("cmfe_DataProjection_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new data projection for a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_CreateStartNumber(dataProjectionUserNumber,dataPointRegionUserNumber,meshUserNumber, &
    & meshRegionUserNumber,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number.
    INTEGER(INTG), INTENT(IN) :: dataPointRegionUserNumber !<The region user number of the data points to be projected.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The field user number of the geometric field data points are be projected on.
    INTEGER(INTG), INTENT(IN) :: meshRegionUserNumber !<The region user number of the geometric field data points are be projected on.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: DATA_POINTS_REGION
    TYPE(REGION_TYPE), POINTER :: MESH_REGION
    TYPE(VARYING_STRING) :: localError    

    ENTERS("cmfe_DataProjection_CreateStartNumber",err,error,*999)

    NULLIFY(DATA_PROJECTION)
    NULLIFY(DATA_POINTS) 
    NULLIFY(MESH)   
    NULLIFY(DATA_POINTS_REGION)
    NULLIFY(MESH_REGION)
    CALL REGION_USER_NUMBER_FIND(dataPointRegionUserNumber,DATA_POINTS_REGION,err,error,*999)
    CALL REGION_USER_NUMBER_FIND(meshRegionUserNumber,MESH_REGION,err,error,*999)
    IF(ASSOCIATED(DATA_POINTS_REGION)) THEN
      IF(ASSOCIATED(MESH_REGION)) THEN
        CALL MESH_USER_NUMBER_FIND(meshUserNumber,MESH_REGION,MESH,err,error,*999)
        IF(ASSOCIATED(MESH)) THEN
          CALL REGION_DATA_POINTS_GET(DATA_POINTS_REGION,DATA_POINTS,err,error,*999)
          CALL DATA_PROJECTION_CREATE_START_DATA_POINTS(dataProjectionUserNumber,DATA_POINTS,MESH,DATA_PROJECTION,err, &
            & ERROR,*999)
        ELSE
          localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="A region with an user number of "//TRIM(NumberToVString(meshRegionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(dataPointRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_DataProjection_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN
    
  END SUBROUTINE cmfe_DataProjection_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new data projection for a data projection identified by an object.
  SUBROUTINE cmfe_DataProjection_CreateStartObj(dataProjectionUserNumber,dataPoints,mesh,dataProjection,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number.
    TYPE(cmfe_DataPointsType), INTENT(IN) :: dataPoints !<The data points to be projected
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh where data points is projected on
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<On exit, the newly created data projection.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_CreateStartObj",err,error,*999)

    CALL DATA_PROJECTION_CREATE_START_DATA_POINTS(dataProjectionUserNumber,dataPoints%dataPoints,mesh%mesh, &
      & dataProjection%dataProjection,err,error,*999)

    EXITS("cmfe_DataProjection_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a data projection identified by region user number.
  SUBROUTINE cmfe_DataProjection_DestroyNumber(dataProjectionUserNumber,regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    ENTERS("cmfe_DataProjection_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      CALL DATA_PROJECTION_DESTROY(DATA_PROJECTION,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a data projection identified by an object.
  SUBROUTINE cmfe_DataProjection_DestroyObj(dataProjection,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_DestroyObj",err,error,*999)

    CALL DATA_PROJECTION_DESTROY(dataProjection%dataProjection,err,error,*999)

    EXITS("cmfe_DataProjection_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_DestroyObj
  
  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection in a region, identified by user number
  SUBROUTINE cmfe_DataProjection_DataPointsPositionEvaluateRegionNumber(dataProjectionUserNumber,regionUserNumber, &
    & fieldUserNumber,fieldVariableType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection 
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection and field
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field user number of the field to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The field variable type to be interpolated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: dataProjection
    TYPE(DATA_POINTS_TYPE), POINTER :: dataPoints
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    INTEGER(INTG) :: dataProjectionGlobalNumber !<The data projection global number.
    TYPE(VARYING_STRING) :: localError      

    ENTERS("cmfe_DataProjection_DataPointsPositionEvaluateRegionNumber",err,error,*999)
    
    NULLIFY(dataProjection)
    NULLIFY(dataPoints) 
    NULLIFY(field)   
    NULLIFY(region)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL REGION_DATA_POINTS_GET(region,dataPoints,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(dataPoints,dataProjectionUserNumber,dataProjectionGlobalNumber, &
        & err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(dataPoints,dataProjectionGlobalNumber,dataProjection,err,error,*999)
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL DataProjection_DataPointsPositionEvaluate(dataProjection,field,fieldVariableType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_DataPointsPositionEvaluateRegionNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_DataPointsPositionEvaluateRegionNumber",err,error)
    EXITS("cmfe_DataProjection_DataPointsPositionEvaluateRegionNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_DataPointsPositionEvaluateRegionNumber

  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection in an interface, identified by user number
  SUBROUTINE cmfe_DataProjection_DataPointsPositionEvaluateInterfaceNumber(dataProjectionUserNumber, &
      & parentRegionUserNumber,interfaceUserNumber,fieldUserNumber,fieldVariableType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection 
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection 
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field user number of the field to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The field variable type to be interpolated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: dataProjection
    TYPE(DATA_POINTS_TYPE), POINTER :: dataPoints
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: parentRegion
    TYPE(INTERFACE_TYPE), POINTER :: interface
    INTEGER(INTG) :: dataProjectionGlobalNumber !<The data projection global number.
    TYPE(VARYING_STRING) :: localError      

    ENTERS("cmfe_DataProjection_DataPointsPositionEvaluateInterfaceNumber",err,error,*999)
    
    NULLIFY(dataProjection)
    NULLIFY(dataPoints) 
    NULLIFY(field)   
    NULLIFY(parentRegion)
    NULLIFY(interface)  
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,parentRegion,err,error,*999)
    IF(ASSOCIATED(parentRegion)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,parentRegion,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL INTERFACE_DATA_POINTS_GET(interface,dataPoints,err,error,*999)
        CALL DataPoints_DataProjectionGlobalNumberGet(dataPoints,dataProjectionUserNumber,dataProjectionGlobalNumber, &
          & err,error,*999)
        CALL DATA_POINTS_DATA_PROJECTION_GET(dataPoints,dataProjectionGlobalNumber,dataProjection,err,error,*999)
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,error,*999)
        IF(ASSOCIATED(field)) THEN
          CALL DataProjection_DataPointsPositionEvaluate(dataProjection,field,fieldVariableType,err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentregionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    EXITS("cmfe_DataProjection_DataPointsPositionEvaluateInterfaceNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_DataPointsPositionEvaluateInterfaceNumber",err,error)
    EXITS("cmfe_DataProjection_DataPointsPositionEvaluateInterfaceNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_DataPointsPositionEvaluateInterfaceNumber
  
  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection, identified by object
  SUBROUTINE cmfe_DataProjection_DataPointsPositionEvaluateObj(dataProjection,field,fieldVariableType,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to interpolate
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The field variable type to be interpolated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables 

    ENTERS("cmfe_DataProjection_DataPointsPositionEvaluateObj",err,error,*999)
    
    CALL DataProjection_DataPointsPositionEvaluate(dataProjection%dataProjection,field%field,fieldVariableType,err,error,*999)
    
    EXITS("cmfe_DataProjection_DataPointsPositionEvaluateObj")
    RETURN
999 ERRORS("cmfe_DataProjection_DataPointsPositionEvaluateObj",err,error)
    EXITS("cmfe_DataProjection_DataPointsPositionEvaluateObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_DataPointsPositionEvaluateObj
  
  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection in a region, identified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidatesSetRegionNumber(dataProjectionUserNumber,regionUserNumber, &
    & candidateElements,localFaceLineNumbers,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection 
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection and field
    INTEGER(INTG), INTENT(IN) :: candidateElements(:) !<The candidate element for the projection
    INTEGER(INTG), INTENT(IN) :: localFaceLineNumbers(:) !<The local face/line number for the candidate elements
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: dataProjection
    TYPE(DATA_POINTS_TYPE), POINTER :: dataPoints
    TYPE(REGION_TYPE), POINTER :: region
    INTEGER(INTG) :: dataProjectionGlobalNumber !<The data projection global number.
    TYPE(VARYING_STRING) :: localError      

    ENTERS("cmfe_DataProjection_ProjectionCandidatesSetRegionNumber",err,error,*999)
    
    NULLIFY(dataProjection)
    NULLIFY(dataPoints) 
    NULLIFY(region)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL REGION_DATA_POINTS_GET(region,dataPoints,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(dataPoints,dataProjectionUserNumber,dataProjectionGlobalNumber, &
        & err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(dataPoints,dataProjectionGlobalNumber,dataProjection,err,error,*999)
      CALL DataProjection_ProjectionCandidatesSet(dataProjection,candidateElements,localFaceLineNumbers,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_ProjectionCandidatesSetRegionNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidatesSetRegionNumber",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidatesSetRegionNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidatesSetRegionNumber

  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection in an interface, identified by user number
  SUBROUTINE cmfe_DataProjection_ProjectionCandidatesSetInterfaceNumber(dataProjectionUserNumber, &
      & parentRegionUserNumber,interfaceUserNumber,candidateElements,localFaceLineNumbers,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection 
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection 
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElements(:) !<The candidate element for the projection
    INTEGER(INTG), INTENT(IN) :: localFaceLineNumbers(:) !<The local face/line number for the candidate elements
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: dataProjection
    TYPE(DATA_POINTS_TYPE), POINTER :: dataPoints
    TYPE(REGION_TYPE), POINTER :: parentRegion
    TYPE(INTERFACE_TYPE), POINTER :: interface
    INTEGER(INTG) :: dataProjectionGlobalNumber !<The data projection global number.
    TYPE(VARYING_STRING) :: localError      

    ENTERS("cmfe_DataProjection_ProjectionCandidatesSetInterfaceNumber",err,error,*999)
    
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)  
    NULLIFY(parentRegion)
    NULLIFY(interface)  
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,parentRegion,err,error,*999)
    IF(ASSOCIATED(parentRegion)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,parentRegion,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL INTERFACE_DATA_POINTS_GET(interface,dataPoints,err,error,*999)
        CALL DataPoints_DataProjectionGlobalNumberGet(dataPoints,dataProjectionUserNumber,dataProjectionGlobalNumber, &
          & err,error,*999)
        CALL DATA_POINTS_DATA_PROJECTION_GET(dataPoints,dataProjectionGlobalNumber,dataProjection,err,error,*999)
        CALL DataProjection_ProjectionCandidatesSet(dataProjection,candidateElements,localFaceLineNumbers,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentregionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF
    
    EXITS("cmfe_DataProjection_ProjectionCandidatesSetInterfaceNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidatesSetInterfaceNumber",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidatesSetInterfaceNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidatesSetInterfaceNumber
  
  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection, identified by object
  SUBROUTINE cmfe_DataProjection_ProjectionCandidatesSetObj(dataProjection,candidateElements,localFaceLineNumbers,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElements(:) !<The candidate element for the projection
    INTEGER(INTG), INTENT(IN) :: localFaceLineNumbers(:) !<The local face/line number for the candidate elements
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables 

    ENTERS("cmfe_DataProjection_ProjectionCandidatesSetObj",err,error,*999)
    
    CALL DataProjection_ProjectionCandidatesSet(dataProjection%dataProjection,candidateElements,localFaceLineNumbers, &
      & err,error,*999)
    
    EXITS("cmfe_DataProjection_ProjectionCandidatesSetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_ProjectionCandidatesSetObj",err,error)
    EXITS("cmfe_DataProjection_ProjectionCandidatesSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionCandidatesSetObj

  !
  !================================================================================================================================
  !

  !>Evaluate a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_DataPointsProjectionEvaluateNumber(dataProjectionUserNumber,dataPointsRegionUserNumber, &
    & projectionFieldUserNumber,projectionFieldRegionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointsRegionUserNumber !<The region user number of the data projection to evaluate.
    INTEGER(INTG), INTENT(IN) :: projectionFieldUserNumber !<The field user number of the field data points are be projected on.
    INTEGER(INTG), INTENT(IN) :: projectionFieldRegionUserNumber !<The region user number of the field data points are be projected on.    
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(FIELD_TYPE), POINTER :: PROJECTION_FIELD
    TYPE(REGION_TYPE), POINTER :: DATA_POINTS_REGION
    TYPE(REGION_TYPE), POINTER :: PROJECTION_FIELD_REGION
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.
    TYPE(VARYING_STRING) :: localError      

    ENTERS("cmfe_DataProjection_DataPointsProjectionEvaluateNumber",err,error,*999)
    
    NULLIFY(DATA_PROJECTION)
    NULLIFY(DATA_POINTS) 
    NULLIFY(PROJECTION_FIELD)   
    NULLIFY(DATA_POINTS_REGION)
    NULLIFY(PROJECTION_FIELD_REGION)
    CALL REGION_USER_NUMBER_FIND(dataPointsRegionUserNumber,DATA_POINTS_REGION,err,error,*999)
    CALL REGION_USER_NUMBER_FIND(projectionFieldRegionUserNumber,PROJECTION_FIELD_REGION,err,error,*999)
    IF(ASSOCIATED(DATA_POINTS_REGION)) THEN
      CALL REGION_DATA_POINTS_GET(DATA_POINTS_REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,dataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      IF(ASSOCIATED(PROJECTION_FIELD_REGION)) THEN
        CALL FIELD_USER_NUMBER_FIND(projectionFieldUserNumber,PROJECTION_FIELD_REGION,PROJECTION_FIELD,err,error,*999)
        IF(ASSOCIATED(PROJECTION_FIELD)) THEN
          CALL DataProjection_DataPointsProjectionEvaluate(DATA_PROJECTION,PROJECTION_FIELD,err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NumberToVString(projectionFieldUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="A region with an user number of "//TRIM(NumberToVString(projectionFieldRegionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(dataPointsRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_DataPointsProjectionEvaluateNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_DataPointsProjectionEvaluateNumber",err,error)
    EXITS("cmfe_DataProjection_DataPointsProjectionEvaluateNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_DataPointsProjectionEvaluateNumber


  !
  !================================================================================================================================
  !

  !>Evaluate a data projection identified by an object.
  SUBROUTINE cmfe_DataProjection_DataPointsProjectionEvaluateObj(dataProjection,projectionField,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to evaluate.
    TYPE(cmfe_FieldType), INTENT(IN) :: projectionField !<The field data points is projected on
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_DataPointsProjectionEvaluateObj",err,error,*999)

    CALL DataProjection_DataPointsProjectionEvaluate(dataProjection%dataProjection,projectionField%field,err,error,*999)

    EXITS("cmfe_DataProjection_DataPointsProjectionEvaluateObj")
    RETURN
999 ERRORS("cmfe_DataProjection_DataPointsProjectionEvaluateObj",err,error)
    EXITS("cmfe_DataProjection_DataPointsProjectionEvaluateObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_DataPointsProjectionEvaluateObj

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_MaximumIterationUpdateGetNumber(dataProjectionUserNumber,regionUserNumber, &
      & maximumIterationUpdate,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get tolerance for.
    REAL(DP), INTENT(OUT) :: maximumIterationUpdate !<On exit, the maximum iteration update of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    ENTERS("cmfe_DataProjection_MaximumIterationUpdateGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      CALL DataProjection_MaximumInterationUpdateGet(DATA_PROJECTION,maximumIterationUpdate,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_MaximumIterationUpdateGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_MaximumIterationUpdateGetNumber",err,error)
    EXITS("cmfe_DataProjection_MaximumIterationUpdateGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_MaximumIterationUpdateGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_MaximumIterationUpdateGetObj(dataProjection,maximumIterationUpdate,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get tolerance for.
    REAL(DP), INTENT(OUT) :: maximumIterationUpdate !<On exit, the maximum iteration update of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_MaximumIterationUpdateGetObj",err,error,*999)

    CALL DataProjection_MaximumInterationUpdateGet(dataProjection%dataProjection,maximumIterationUpdate,err,error,*999)

    EXITS("cmfe_DataProjection_MaximumIterationUpdateGetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_MaximumIterationUpdateGetObj",err,error)
    EXITS("cmfe_DataProjection_MaximumIterationUpdateGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_MaximumIterationUpdateGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_MaximumIterationUpdateSetNumber(dataProjectionUserNumber,regionUserNumber, &
      & maximumIterationUpdate,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set tolerance for.
    REAL(DP), INTENT(IN) :: maximumIterationUpdate !<the maximum iteration update to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    ENTERS("cmfe_DataProjection_MaximumIterationUpdateSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      CALL DataProjection_MaximumInterationUpdateSet(DATA_PROJECTION,maximumIterationUpdate,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_MaximumIterationUpdateSetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_MaximumIterationUpdateSetNumber",err,error)
    EXITS("cmfe_DataProjection_MaximumIterationUpdateSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_MaximumIterationUpdateSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_MaximumIterationUpdateSetObj(dataProjection,maximumIterationUpdate,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set tolerance for.
    REAL(DP), INTENT(IN) :: maximumIterationUpdate !<the maximum iteration update to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_MaximumIterationUpdateSetObj",err,error,*999)

    CALL DataProjection_MaximumInterationUpdateSet(dataProjection%dataProjection,maximumIterationUpdate,err,error,*999)

    EXITS("cmfe_DataProjection_MaximumIterationUpdateSetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_MaximumIterationUpdateSetObj",err,error)
    EXITS("cmfe_DataProjection_MaximumIterationUpdateSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_MaximumIterationUpdateSetObj

  !
  !================================================================================================================================
  !

  !>Returns the maximum number of iterations of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_MaximumNumberOfIterationsGetNumber(dataProjectionUserNumber,regionUserNumber, &
      & maximumNumberOfIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get maximum number of iterations for.
    INTEGER(INTG), INTENT(OUT) :: maximumNumberOfIterations !<On exit, the maximum number of iterations of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    ENTERS("cmfe_DataProjection_MaximumNumberOfIterationsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      CALL DataProjection_MaximumNumberOfIterationsGet(DATA_PROJECTION,maximumNumberOfIterations,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_MaximumNumberOfIterationsGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_MaximumNumberOfIterationsGetNumber",err,error)
    EXITS("cmfe_DataProjection_MaximumNumberOfIterationsGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_MaximumNumberOfIterationsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection distance for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataProjection_ResultDistanceGetNumber(regionUserNumber,dataProjectionUserNumber,dataPointUserNumber, &
    & ProjectionDistance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: ProjectionDistance !<On return, the projection distance for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    INTEGER(INTG) :: DATA_PROJECTION_GLOBAL_NUMBER    
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError 

    ENTERS("cmfe_DataProjection_ResultDistanceGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)    
    NULLIFY(DATA_PROJECTION) 
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,dataProjectionUserNumber,DATA_PROJECTION_GLOBAL_NUMBER,ERR, &
        & error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION_GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      IF(ASSOCIATED(DATA_PROJECTION)) THEN
        CALL DATA_PROJECTION_RESULT_DISTANCE_GET(DATA_PROJECTION,dataPointUserNumber,ProjectionDistance,err,error,*999)
      ELSE
        localError="A data projection with an user number of "//TRIM(NumberToVString(dataProjectionUserNumber,"*",err,error)) &
          & //" does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_DataProjection_ResultDistanceGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultDistanceGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultDistanceGetNumber


   !
   !================================================================================================================================
   !

  !>Returns the projection distance for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataProjection_ResultDistanceGetObj(dataProjection,dataPointUserNumber,ProjectionDistance,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: ProjectionDistance !<On return, the projection distance for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ResultDistanceGetObj",err,error,*999)

    CALL DATA_PROJECTION_RESULT_DISTANCE_GET(dataProjection%dataProjection,dataPointUserNumber,ProjectionDistance, &
      & err,error,*999)

    EXITS("cmfe_DataProjection_ResultDistanceGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultDistanceGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultDistanceGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection element number for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataProjection_ResultElementNumberGetNumber(regionUserNumber,dataProjectionUserNumber,dataPointUserNumber, &
    & ProjectionElementNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: ProjectionElementNumber !<On return, the projection element number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    INTEGER(INTG) :: DATA_PROJECTION_GLOBAL_NUMBER  
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataProjection_ResultElementNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)    
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,dataProjectionUserNumber,DATA_PROJECTION_GLOBAL_NUMBER,ERR, &
        & error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION_GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      IF(ASSOCIATED(DATA_PROJECTION)) THEN
        CALL DATA_PROJECTION_RESULT_ELEMENT_NUMBER_GET(DATA_PROJECTION,dataPointUserNumber,ProjectionElementNumber,err,error,*999)
      ELSE
        localError="A data projection with an user number of "//TRIM(NumberToVString(dataProjectionUserNumber,"*",err,error)) &
          & //" does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF    

    EXITS("cmfe_DataProjection_ResultElementNumberGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultElementNumberGetNumber",err,error)
    EXITS("cmfe_DataProjection_ResultElementNumberGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultElementNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection element number for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataProjection_ResultElementNumberGetObj(dataProjection,dataPointUserNumber,ProjectionElementNumber,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: ProjectionElementNumber !<On return, the projection element number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ResultElementNumberGetObj",err,error,*999)

    CALL DATA_PROJECTION_RESULT_ELEMENT_NUMBER_GET(dataProjection%dataProjection,dataPointUserNumber,ProjectionElementNumber, &
      & err,error,*999)

    EXITS("cmfe_DataProjection_ResultElementNumberGetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultElementNumberGetObj",err,error)
    EXITS("cmfe_DataProjection_ResultElementNumberGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultElementNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection element face number for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataProjection_ResultElementFaceNumberGetNumber(regionUserNumber,dataProjectionUserNumber,dataPointUserNumber, &
    & ProjectionElementFaceNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: ProjectionElementFaceNumber !<On return, the projection element face number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    INTEGER(INTG) :: DATA_PROJECTION_GLOBAL_NUMBER  
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataProjection_ResultElementFaceNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)    
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,dataProjectionUserNumber,DATA_PROJECTION_GLOBAL_NUMBER,ERR, &
        & error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION_GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      IF(ASSOCIATED(DATA_PROJECTION)) THEN
        CALL DataProjection_ResultElementFaceNumberGet(DATA_PROJECTION,dataPointUserNumber,ProjectionElementFaceNumber,err, &
          & error,*999)
      ELSE
        localError="A data projection with an user number of "//TRIM(NumberToVString(dataProjectionUserNumber,"*",err,error)) &
          & //" does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF    

    EXITS("cmfe_DataProjection_ResultElementFaceNumberGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultElementFaceNumberGetNumber",err,error)
    EXITS("cmfe_DataProjection_ResultElementFaceNumberGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultElementFaceNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection element face number for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataProjection_ResultElementFaceNumberGetObj(dataProjection,dataPointUserNumber, &
    & ProjectionElementFaceNumber,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: ProjectionElementFaceNumber !<On return, the projection element face number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ResultElementFaceNumberGetObj",err,error,*999)

    CALL DataProjection_ResultElementFaceNumberGet(dataProjection%dataProjection,dataPointUserNumber, &
      & ProjectionElementFaceNumber,err,error,*999)

    EXITS("cmfe_DataProjection_ResultElementFaceNumberGetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultElementFaceNumberGetObj",err,error)
    EXITS("cmfe_DataProjection_ResultElementFaceNumberGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultElementFaceNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection element line number for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataProjection_ResultElementLineNumberGetNumber(regionUserNumber,dataProjectionUserNumber,dataPointUserNumber, &
    & ProjectionElementLineNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: ProjectionElementLineNumber !<On return, the projection element line number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    INTEGER(INTG) :: DATA_PROJECTION_GLOBAL_NUMBER  
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataProjection_ResultElementLineNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)    
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,dataProjectionUserNumber,DATA_PROJECTION_GLOBAL_NUMBER,ERR, &
        & error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION_GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      IF(ASSOCIATED(DATA_PROJECTION)) THEN
        CALL DataProjection_ResultElementLineNumberGet(DATA_PROJECTION,dataPointUserNumber,ProjectionElementLineNumber,err, &
          & error,*999)
      ELSE
        localError="A data projection with an user number of "//TRIM(NumberToVString(dataProjectionUserNumber,"*",err,error)) &
          & //" does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF    

    EXITS("cmfe_DataProjection_ResultElementLineNumberGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultElementLineNumberGetNumber",err,error)
    EXITS("cmfe_DataProjection_ResultElementLineNumberGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultElementLineNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection element line number for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataProjection_ResultElementLineNumberGetObj(dataProjection,dataPointUserNumber, &
    & ProjectionElementLineNumber,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: ProjectionElementLineNumber !<On return, the projection element line number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ResultElementLineNumberGetObj",err,error,*999)

    CALL DataProjection_ResultElementLineNumberGet(dataProjection%dataProjection,dataPointUserNumber, &
      & ProjectionElementLineNumber,err,error,*999)

    EXITS("cmfe_DataProjection_ResultElementLineNumberGetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_ResultElementLineNumberGetObj",err,error)
    EXITS("cmfe_DataProjection_ResultElementLineNumberGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultElementLineNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection exit tag for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataProjection_ResultExitTagGetNumber(regionUserNumber,dataProjectionUserNumber,dataPointUserNumber, &
    & ProjectionExitTag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: ProjectionExitTag !<On return, the projection exit tag for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    INTEGER(INTG) :: DATA_PROJECTION_GLOBAL_NUMBER  
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataProjection_ResultExitTagGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)    
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,dataProjectionUserNumber,DATA_PROJECTION_GLOBAL_NUMBER,ERR, &
        & error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION_GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      IF(ASSOCIATED(DATA_PROJECTION)) THEN
        CALL DATA_PROJECTION_RESULT_EXIT_TAG_GET(DATA_PROJECTION,dataPointUserNumber,ProjectionExitTag,err,error,*999)
      ELSE
        localError="A data projection with an user number of "//TRIM(NumberToVString(dataProjectionUserNumber,"*",err,error)) &
          & //" does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF    

    EXITS("cmfe_DataProjection_ResultExitTagGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultExitTagGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultExitTagGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection exit tag for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataProjection_ResultExitTagGetObj(dataProjection,dataPointUserNumber,ProjectionExitTag,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: ProjectionExitTag !<On return, the projection exit tag for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ResultExitTagGetObj",err,error,*999)

    CALL DATA_PROJECTION_RESULT_EXIT_TAG_GET(dataProjection%dataProjection,dataPointUserNumber,ProjectionExitTag, &
      & err,error,*999)

    EXITS("cmfe_DataProjection_ResultExitTagGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultExitTagGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultExitTagGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection xi for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataProjection_ResultXiGetNumber(regionUserNumber,dataProjectionUserNumber,dataPointUserNumber,ProjectionXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: ProjectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    INTEGER(INTG) :: DATA_PROJECTION_GLOBAL_NUMBER  
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataProjection_ResultXiGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)    
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,dataProjectionUserNumber,DATA_PROJECTION_GLOBAL_NUMBER,ERR, &
        & error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION_GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      IF(ASSOCIATED(DATA_PROJECTION)) THEN
        CALL DATA_PROJECTION_RESULT_XI_GET(DATA_PROJECTION,dataPointUserNumber,ProjectionXi,err,error,*999)
      ELSE
        localError="A data projection with an user number of "//TRIM(NumberToVString(dataProjectionUserNumber,"*",err,error)) &
          & //" does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_DataProjection_ResultXiGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultXiGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection xi for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataProjection_ResultXiGetObj(dataProjection,dataPointUserNumber,ProjectionXi,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.        
    REAL(DP), INTENT(OUT) :: ProjectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ResultXiGetObj",err,error,*999)

    CALL DATA_PROJECTION_RESULT_XI_GET(dataProjection%dataProjection,dataPointUserNumber,ProjectionXi,err,error,*999)

    EXITS("cmfe_DataProjection_ResultXiGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultXiGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets the projection xi for a data point in a set of data points identified by user number.
  SUBROUTINE cmfe_DataProjection_ResultXiSetNumber(regionUserNumber,dataProjectionUserNumber,dataPointUserNumber,ProjectionXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set attributes for.
    REAL(DP), INTENT(IN) :: ProjectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    INTEGER(INTG) :: DATA_PROJECTION_GLOBAL_NUMBER  
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataProjection_ResultXiSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)    
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,dataProjectionUserNumber,DATA_PROJECTION_GLOBAL_NUMBER,ERR, &
        & error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION_GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      IF(ASSOCIATED(DATA_PROJECTION)) THEN
        CALL DATA_PROJECTION_RESULT_XI_SET(DATA_PROJECTION,dataPointUserNumber,ProjectionXi,err,error,*999)
      ELSE
        localError="A data projection with an user number of "//TRIM(NumberToVString(dataProjectionUserNumber,"*",err,error)) &
          & //" does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_DataProjection_ResultXiSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultXiSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the projection xi for a data point in a set of data points identified by an object.
  SUBROUTINE cmfe_DataProjection_ResultXiSetObj(dataProjection,dataPointUserNumber,ProjectionXi,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set attributes for 
    REAL(DP), INTENT(IN) :: ProjectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ResultXiSetObj",err,error,*999)

    CALL DATA_PROJECTION_RESULT_XI_SET(dataProjection%dataProjection,dataPointUserNumber,ProjectionXi,err,error,*999)

    EXITS("cmfe_DataProjection_ResultXiSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ResultXiSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ResultXiSetObj

  !
  !================================================================================================================================
  !

  !>Returns the maximum number of iterations of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_MaximumNumberOfIterationsGetObj(dataProjection,maximumNumberOfIterations,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get maximum number of iterations for.
    INTEGER(INTG), INTENT(OUT) :: maximumNumberOfIterations !<On exit, the maximum number of iterations of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_MaximumNumberOfIterationsGetObj",err,error,*999)

    CALL DataProjection_MaximumNumberOfIterationsGet(dataProjection%dataProjection,maximumNumberOfIterations,err,error,*999)

    EXITS("cmfe_DataProjection_MaximumNumberOfIterationsGetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_MaximumNumberOfIterationsGetObj",err,error)
    EXITS("cmfe_DataProjection_MaximumNumberOfIterationsGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_MaximumNumberOfIterationsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_MaximumNumberOfIterationsSetNumber(dataProjectionUserNumber,regionUserNumber, &
      & maximumNumberOfIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumNumberOfIterations !<the maximum number of iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    ENTERS("cmfe_DataProjection_MaximumNumberOfIterationsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      CALL DataProjection_MaximumNumberOfIterationsSet(DATA_PROJECTION,maximumNumberOfIterations,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_MaximumNumberOfIterationsSetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_MaximumNumberOfIterationsSetNumber",err,error)
    EXITS("cmfe_DataProjection_MaximumNumberOfIterationsSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_MaximumNumberOfIterationsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_MaximumNumberOfIterationsSetObj(dataProjection,maximumNumberOfIterations,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumNumberOfIterations !<the maximum number of iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_MaximumNumberOfIterationsSetObj",err,error,*999)

    CALL DataProjection_MaximumNumberOfIterationsSet(dataProjection%dataProjection,maximumNumberOfIterations,err,error,*999)

    EXITS("cmfe_DataProjection_MaximumNumberOfIterationsSetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_MaximumNumberOfIterationsSetObj",err,error)
    EXITS("cmfe_DataProjection_MaximumNumberOfIterationsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_MaximumNumberOfIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of closest elements of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_NumberOfClosestElementsGetNumber(dataProjectionUserNumber,regionUserNumber, &
      & numberOfClosestElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get number of closest elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfClosestElements !<On exit, the number of closest elements of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    ENTERS("cmfe_DataProjection_NumberOfClosestElementsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      CALL DataProjection_NumberOfClosestElementsGet(DATA_PROJECTION,numberOfClosestElements,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_NumberOfClosestElementsGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_NumberOfClosestElementsGetNumber",err,error)
    EXITS("cmfe_DataProjection_NumberOfClosestElementsGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_NumberOfClosestElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of closest elements of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_NumberOfClosestElementsGetObj(dataProjection,numberOfClosestElements,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get number of closest elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfClosestElements !<On exit, the number of closest elements of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_NumberOfClosestElementsGetObj",err,error,*999)

    CALL DataProjection_NumberOfClosestElementsGet(dataProjection%dataProjection,numberOfClosestElements,err,error,*999)

    EXITS("cmfe_DataProjection_NumberOfClosestElementsGetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_NumberOfClosestElementsGetObj",err,error)
    EXITS("cmfe_DataProjection_NumberOfClosestElementsGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_NumberOfClosestElementsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of closest elements of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_NumberOfClosestElementsSetNumber(dataProjectionUserNumber,regionUserNumber, &
      & numberOfClosestElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set number of closest elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfClosestElements !<the number of closest elements to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    ENTERS("cmfe_DataProjection_NumberOfClosestElementsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      CALL DataProjection_NumberOfClosestElementsSet(DATA_PROJECTION,numberOfClosestElements,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_NumberOfClosestElementsSetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_NumberOfClosestElementsSetNumber",err,error)
    EXITS("cmfe_DataProjection_NumberOfClosestElementsSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_NumberOfClosestElementsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of closest elements of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_NumberOfClosestElementsSetObj(dataProjection,numberOfClosestElements,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set number of closest elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfClosestElements !<the number of closest elements to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_NumberOfClosestElementsSetObj",err,error,*999)

    CALL DataProjection_NumberOfClosestElementsSet(dataProjection%dataProjection,numberOfClosestElements,err,error,*999)

    EXITS("cmfe_DataProjection_NumberOfClosestElementsSetObj")
    RETURN
999 ERRORS("cmfe_DataProjection_NumberOfClosestElementsSetObj",err,error)
    EXITS("cmfe_DataProjection_NumberOfClosestElementsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_NumberOfClosestElementsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection type of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_ProjectionTypeGetNumber(dataProjectionUserNumber,regionUserNumber,projectionType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get projection type for.
    INTEGER(INTG), INTENT(OUT) :: projectionType !<On exit, the projection type of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    ENTERS("cmfe_DataProjection_ProjectionTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      CALL DATA_PROJECTION_PROJECTION_TYPE_GET(DATA_PROJECTION,projectionType,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_ProjectionTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ProjectionTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection type of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_ProjectionTypeGetObj(dataProjection,projectionType,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get projection type for.
    INTEGER(INTG), INTENT(OUT) :: projectionType !<On exit, the projection type of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionTypeGetObj",err,error,*999)

    CALL DATA_PROJECTION_PROJECTION_TYPE_GET(dataProjection%dataProjection,projectionType,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ProjectionTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the projection type of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_ProjectionTypeSetNumber(dataProjectionUserNumber,regionUserNumber,projectionType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set projection type for.
    INTEGER(INTG), INTENT(IN) :: projectionType !<the projection type to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    ENTERS("cmfe_DataProjection_ProjectionTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      CALL DATA_PROJECTION_PROJECTION_TYPE_SET(DATA_PROJECTION,projectionType,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_ProjectionTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ProjectionTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the projection type of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_ProjectionTypeSetObj(dataProjection,projectionType,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set projection type for.
    INTEGER(INTG), INTENT(IN) :: projectionType !<the projection type to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ProjectionTypeSetObj",err,error,*999)

    CALL DATA_PROJECTION_PROJECTION_TYPE_SET(dataProjection%dataProjection,projectionType,err,error,*999)

    EXITS("cmfe_DataProjection_ProjectionTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ProjectionTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ProjectionTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified by a data projection user number and a region user number.
  SUBROUTINE cmfe_DataProjection_RelativeToleranceGetNumber(dataProjectionUserNumber,regionUserNumber,relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get relative tolerance for.
    REAL(DP), INTENT(OUT) :: relativeTolerance !<On exit, the absolute relative tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    ENTERS("cmfe_DataProjection_RelativeToleranceGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      CALL DATA_PROJECTION_RELATIVE_TOLERANCE_GET(DATA_PROJECTION,relativeTolerance,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_RelativeToleranceGetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_RelativeToleranceGetNumber",err,error)
    EXITS("cmfe_DataProjection_RelativeToleranceGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_RelativeToleranceGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_RelativeToleranceGetObj(dataProjection,relativeTolerance,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get relative tolerance for.
    REAL(DP), INTENT(OUT) :: relativeTolerance !<On exit, the absolute relative tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_RelativeToleranceGetObj",err,error,*999)

    CALL DATA_PROJECTION_RELATIVE_TOLERANCE_GET(dataProjection%dataProjection,relativeTolerance,err,error,*999)

    EXITS("cmfe_DataProjection_RelativeToleranceGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_RelativeToleranceGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_RelativeToleranceGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified by a data projection user number and a region user number.
  SUBROUTINE cmfe_DataProjection_RelativeToleranceSetNumber(dataProjectionUserNumber,regionUserNumber,relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<the absolute relative tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    ENTERS("cmfe_DataProjection_RelativeToleranceSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      CALL DATA_PROJECTION_RELATIVE_TOLERANCE_SET(DATA_PROJECTION,relativeTolerance,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_RelativeToleranceSetNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_RelativeToleranceSetNumber",err,error)
    EXITS("cmfe_DataProjection_RelativeToleranceSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_RelativeToleranceSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_RelativeToleranceSetObj(dataProjection,relativeTolerance,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<the absolute relative tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_RelativeToleranceSetObj",err,error,*999)

    CALL DATA_PROJECTION_RELATIVE_TOLERANCE_SET(dataProjection%dataProjection,relativeTolerance,err,error,*999)

    EXITS("cmfe_DataProjection_RelativeToleranceSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_RelativeToleranceSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_RelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Returns the starting xi of data projection identified by a data projection user number and region user number.
  SUBROUTINE cmfe_DataProjection_StartingXiGetNumber(dataProjectionUserNumber,regionUserNumber,startingXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get starting xi for.
    REAL(DP), INTENT(OUT) :: startingXi(:) !<On exit, the absolute starting xi of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    ENTERS("cmfe_DataProjection_StartingXiGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      CALL DATA_PROJECTION_STARTING_XI_GET(DATA_PROJECTION,startingXi,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_StartingXiGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_StartingXiGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_StartingXiGetNumber


  !
  !================================================================================================================================
  !

  !>Returns the starting xi of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_StartingXiGetObj(dataProjection,startingXi,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get starting xi for.
    REAL(DP), INTENT(OUT) :: startingXi(:) !<On exit, the absolute starting xi of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_StartingXiGetObj",err,error,*999)

    CALL DATA_PROJECTION_STARTING_XI_GET(dataProjection%dataProjection,startingXi,err,error,*999)

    EXITS("cmfe_DataProjection_StartingXiGetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_StartingXiGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_StartingXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_StartingXiSetNumber(dataProjectionUserNumber,regionUserNumber,startingXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set starting xi for.
    REAL(DP), INTENT(IN) :: startingXi(:) !<the absolute starting xi to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<data projection global number

    ENTERS("cmfe_DataProjection_StartingXiSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      CALL DATA_PROJECTION_STARTING_XI_SET(DATA_PROJECTION,startingXi,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_StartingXiSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_StartingXiSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_StartingXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_StartingXiSetObj(dataProjection,startingXi,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set starting xi for.
    REAL(DP), INTENT(IN) :: startingXi(:) !<the absolute starting xi to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_StartingXiSetObj",err,error,*999)

    CALL DATA_PROJECTION_STARTING_XI_SET(dataProjection%dataProjection,startingXi,err,error,*999)

    EXITS("cmfe_DataProjection_StartingXiSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_StartingXiSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_StartingXiSetObj
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_ElementSetInterfaceNumber(dataProjectionUserNumber,parentRegionUserNumber,interfaceUserNumber, &
      & dataPointNumber,elementNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The data point number to set xi position for
    INTEGER(INTG), INTENT(IN) :: elementNumber !<the element number to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<data projection global number

    ENTERS("cmfe_DataProjection_ElementSetInterfaceNumber",ERR,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_DATA_POINTS_GET(INTERFACE,DATA_POINTS,err,error,*999)
        CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
        CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
        CALL DATA_PROJECTION_ELEMENT_SET(DATA_PROJECTION,dataPointNumber,elementNumber,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentregionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_DataProjection_ElementSetInterfaceNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_ElementSetInterfaceNumber",err,error)
    EXITS("cmfe_DataProjection_ElementSetInterfaceNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ElementSetInterfaceNumber
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_ElementSetRegionNumber(dataProjectionUserNumber,regionUserNumber,dataPointNumber,elementNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to set starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The data point number to set xi position for
    INTEGER(INTG), INTENT(IN) :: elementNumber !<the element number to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: GLOBAL_NUMBER !<data projection global number

    ENTERS("cmfe_DataProjection_ElementSetRegionNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      CALL DATA_PROJECTION_ELEMENT_SET(DATA_PROJECTION,dataPointNumber,elementNumber,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_ElementSetRegionNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ElementSetRegionNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ElementSetRegionNumber
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified an object.
  SUBROUTINE cmfe_DataProjection_ElementSetObj(dataProjection,dataPointNumber,elementNumber,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The data point number to set xi position for
    INTEGER(INTG), INTENT(IN) :: elementNumber !<the element number to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_ElementSetObj",err,error,*999)

    CALL DATA_PROJECTION_ELEMENT_SET(dataProjection%dataProjection,dataPointNumber,elementNumber,err,error,*999)

    EXITS("cmfe_DataProjection_ElementSetObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_ElementSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_ElementSetObj

  !
  !================================================================================================================================
  !

  !>Get the character string label of a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_LabelGetCInterfaceNumber(dataProjectionUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get the label for.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataProjection_LabelGetCInterfaceNumber",ERR,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL DATA_PROJECTION_LABEL_GET(DATA_PROJECTION,label,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentregionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_DataProjection_LabelGetCInterfaceNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_LabelGetCInterfaceNumber",err,error)
    EXITS("cmfe_DataProjection_LabelGetCInterfaceNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelGetCInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Get the varying string label of a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_LabelGetVSInterfaceNumber(dataProjectionUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get the label for.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataProjection_LabelGetVSInterfaceNumber",ERR,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL DATA_PROJECTION_LABEL_GET(DATA_PROJECTION,label,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentregionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_DataProjection_LabelGetVSInterfaceNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_LabelGetVSInterfaceNumber",err,error)
    EXITS("cmfe_DataProjection_LabelGetVSInterfaceNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelGetVSInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Get the character string label of a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_LabelGetCRegionNumber(dataProjectionUserNumber,regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get the label for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataProjection_LabelGetCRegionNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL DATA_PROJECTION_LABEL_GET(DATA_PROJECTION,label,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_LabelGetRegionNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_LabelGetCRegionNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelGetCRegionNumber

  !
  !================================================================================================================================
  !

  !>Get the varying string label of a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_LabelGetVSRegionNumber(dataProjectionUserNumber,regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get the label for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataProjection_LabelGetVSRegionNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL DATA_PROJECTION_LABEL_GET(DATA_PROJECTION,label,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_LabelGetVSRegionNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_LabelGetVSRegionNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelGetVSRegionNumber

  !
  !================================================================================================================================
  !

  !>Gets the character string label of a data projection identified an object.
  SUBROUTINE cmfe_DataProjection_LabelGetCObj(dataProjection,label,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_LabelGetCObj",err,error,*999)

    CALL DATA_PROJECTION_LABEL_GET(dataProjection%dataProjection,label,err,error,*999)

    EXITS("cmfe_DataProjection_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Gets the varying string label of a data projection identified an object.
  SUBROUTINE cmfe_DataProjection_LabelGetVSObj(dataProjection,label,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_LabelGetVSObj",err,error,*999)

    CALL DATA_PROJECTION_LABEL_GET(dataProjection%dataProjection,label,err,error,*999)

    EXITS("cmfe_DataProjection_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label of a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_LabelSetCInterfaceNumber(dataProjectionUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to set the label for.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    CHARACTER(LEN=*), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataProjection_LabelSetCInterfaceNumber",ERR,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL DATA_PROJECTION_LABEL_SET(DATA_PROJECTION,label,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentregionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_DataProjection_LabelSetCInterfaceNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_LabelSetCInterfaceNumber",err,error)
    EXITS("cmfe_DataProjection_LabelSetCInterfaceNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelSetCInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label of a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_LabelSetVSInterfaceNumber(dataProjectionUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to set the label for.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataProjection_LabelSetVSInterfaceNumber",ERR,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL DATA_PROJECTION_LABEL_SET(DATA_PROJECTION,label,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentregionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_DataProjection_LabelSetVSInterfaceNumber")
    RETURN
999 ERRORS("cmfe_DataProjection_LabelSetVSInterfaceNumber",err,error)
    EXITS("cmfe_DataProjection_LabelSetVSInterfaceNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelSetVSInterfaceNumber
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label of a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_LabelSetCRegionNumber(dataProjectionUserNumber,regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to set the label for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataProjection_LabelSetCRegionNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL DATA_PROJECTION_LABEL_SET(DATA_PROJECTION,label,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_LabelSetRegionNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_LabelSetCRegionNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelSetCRegionNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label of a data projection identified by a region user number.
  SUBROUTINE cmfe_DataProjection_LabelSetVSRegionNumber(dataProjectionUserNumber,regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to set the label for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_DataProjection_LabelSetVSRegionNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL DATA_PROJECTION_LABEL_SET(DATA_PROJECTION,label,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_DataProjection_LabelSetVSRegionNumber")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_LabelSetVSRegionNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelSetVSRegionNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label of a data projection identified an object.
  SUBROUTINE cmfe_DataProjection_LabelSetCObj(dataProjection,label,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_LabelSetCObj",err,error,*999)

    CALL DATA_PROJECTION_LABEL_SET(dataProjection%dataProjection,label,err,error,*999)

    EXITS("cmfe_DataProjection_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label of a data projection identified an object.
  SUBROUTINE cmfe_DataProjection_LabelSetVSObj(dataProjection,label,err)

    !Argument variables
    TYPE(cmfe_DataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_DataProjection_LabelSetVSObj",err,error,*999)

    CALL DATA_PROJECTION_LABEL_SET(dataProjection%dataProjection,label,err,error,*999)

    EXITS("cmfe_DataProjection_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_DataProjection_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DataProjection_LabelSetVSObj

!!==================================================================================================================================
!!
!! EQUATIONS_ROUTINES
!!
!!==================================================================================================================================

  !>Destroys equations for equations identified by a user number.
  SUBROUTINE cmfe_Equations_DestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to destroy.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Equations_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_DESTROY(EQUATIONS,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Equations_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy equations for equations identified by an object.
  SUBROUTINE cmfe_Equations_DestroyObj(equations,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(INOUT) :: equations !<The equations to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_DestroyObj",err,error,*999)

    CALL EQUATIONS_DESTROY(equations%equations,err,error,*999)

    EXITS("cmfe_Equations_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_DestroyObj

  !
  !================================================================================================================================
  !

  !>Gets the linearity type for equations identified by a user number.
  SUBROUTINE cmfe_Equations_LinearityTypeGetNumber(regionUserNumber,equationsSetUserNumber,linearityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the linearity type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the linearity type of the equations \see OPENCMISS_EquationsLinearityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Equations_LinearityTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_LINEARITY_TYPE_GET(EQUATIONS,linearityType,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Equations_LinearityTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_LinearityTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_LinearityTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the linearity type for equations identified by an object.
  SUBROUTINE cmfe_Equations_LinearityTypeGetObj(equations,linearityType,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the linearity type of the equations \see OPENCMISS_EquationsLinearityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_LinearityTypeGetObj",err,error,*999)

    CALL EQUATIONS_LINEARITY_TYPE_GET(equations%equations,linearityType,err,error,*999)

    EXITS("cmfe_Equations_LinearityTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_LinearityTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_LinearityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Gets the lumping type for equations identified by a user number.
  SUBROUTINE cmfe_Equations_LumpingTypeGetNumber(regionUserNumber,equationsSetUserNumber,lumpingType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the lumping type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the lumping type for.
    INTEGER(INTG), INTENT(OUT) :: lumpingType !<On return, the lumping type of the equations \see OPENCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Equations_LumpingTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_LUMPING_TYPE_GET(EQUATIONS,lumpingType,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Equations_LumpingTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_LumpingTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_LumpingTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the lumping type for equations identified by an object.
  SUBROUTINE cmfe_Equations_LumpingTypeGetObj(equations,lumpingType,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the lumping type for.
    INTEGER(INTG), INTENT(OUT) :: lumpingType !<On return, the lumping type of the equations \see OPENCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_LumpingTypeGetObj",err,error,*999)

    CALL EQUATIONS_LUMPING_TYPE_GET(equations%equations,lumpingType,err,error,*999)

    EXITS("cmfe_Equations_LumpingTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_LumpingTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_LumpingTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the lumping type for equations identified by a user number.
  SUBROUTINE cmfe_Equations_LumpingTypeSetNumber(regionUserNumber,equationsSetUserNumber,lumpingType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: lumpingType !<The lumping type of the equations to set\see OPENCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Equations_LumpingTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_LUMPING_TYPE_SET(EQUATIONS,lumpingType,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Equations_LumpingTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_LumpingTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_LumpingTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the lumping type for equations identified by an object.
  SUBROUTINE cmfe_Equations_LumpingTypeSetObj(equations,lumpingType,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(INOUT) :: equations !<The equations to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: lumpingType !<The lumping type of the equations to set\see OPENCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_LumpingTypeSetObj",err,error,*999)

    CALL EQUATIONS_LUMPING_TYPE_SET(equations%equations,lumpingType,err,error,*999)

    EXITS("cmfe_Equations_LumpingTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_LumpingTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_LumpingTypeSetObj

  !
  !================================================================================================================================
  !

  !>Gets the output type for equations identified by a user number.
  SUBROUTINE cmfe_Equations_OutputTypeGetNumber(regionUserNumber,equationsSetUserNumber,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the output type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the equations \see OPENCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Equations_OutputTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_OUTPUT_TYPE_GET(EQUATIONS,outputType,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Equations_OutputTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_OutputTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_OutputTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the output type for equations identified by an object.
  SUBROUTINE cmfe_Equations_OutputTypeGetObj(equations,outputType,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the equations \see OPENCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_OutputTypeGetObj",err,error,*999)

    CALL EQUATIONS_OUTPUT_TYPE_GET(equations%equations,outputType,err,error,*999)

    EXITS("cmfe_Equations_OutputTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_OutputTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for equations identified by a user number.
  SUBROUTINE cmfe_Equations_OutputTypeSetNumber(regionUserNumber,equationsSetUserNumber,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the equations to set \see OPENCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Equations_OutputTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_OUTPUT_TYPE_SET(EQUATIONS,outputType,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Equations_OutputTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_OutputTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_OutputTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for equations identified by an object.
  SUBROUTINE cmfe_Equations_OutputTypeSetObj(equations,outputType,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(INOUT) :: equations !<The equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the equations to set \see OPENCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_OutputTypeSetObj",err,error,*999)

    CALL EQUATIONS_OUTPUT_TYPE_SET(equations%equations,outputType,err,error,*999)

    EXITS("cmfe_Equations_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_OutputTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for equations identified by a user number.
  SUBROUTINE cmfe_Equations_SparsityTypeGetNumber(regionUserNumber,equationsSetUserNumber,sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the sparsity type of the equations \see OPENCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Equations_SparsityTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_SPARSITY_TYPE_GET(EQUATIONS,sparsityType,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Equations_SparsityTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_SparsityTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_SparsityTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for equations identified by an object.
  SUBROUTINE cmfe_Equations_SparsityTypeGetObj(equations,sparsityType,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the sparsity type of the equations \see OPENCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_SparsityTypeGetObj",err,error,*999)

    CALL EQUATIONS_SPARSITY_TYPE_GET(equations%equations,sparsityType,err,error,*999)

    EXITS("cmfe_Equations_SparsityTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_SparsityTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_SparsityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for equations identified by a user number.
  SUBROUTINE cmfe_Equations_SparsityTypeSetNumber(regionUserNumber,equationsSetUserNumber,sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type of the equations to set \see OPENCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Equations_SparsityTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_SPARSITY_TYPE_SET(EQUATIONS,sparsityType,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Equations_SparsityTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_SparsityTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_SparsityTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for equations identified by an object.
  SUBROUTINE cmfe_Equations_SparsityTypeSetObj(equations,sparsityType,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(INOUT) :: equations !<The equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type of the equations to set \see OPENCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_SparsityTypeSetObj",err,error,*999)

    CALL EQUATIONS_SPARSITY_TYPE_SET(equations%equations,sparsityType,err,error,*999)

    EXITS("cmfe_Equations_SparsityTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_SparsityTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_SparsityTypeSetObj

  !
  !================================================================================================================================
  !

  !>Gets the time dependence type for equations identified by a user number.
  SUBROUTINE cmfe_Equations_TimeDependenceTypeGetNumber(regionUserNumber,equationsSetUserNumber,timeDependenceType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the time dependence type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the time dependence type of the equations \see OPENCMISS_EquationsTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Equations_TimeDependenceTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_TIME_DEPENDENCE_TYPE_GET(EQUATIONS,timeDependenceType,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Equations_TimeDependenceTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Equations_TimeDependenceTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_TimeDependenceTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the time dependence type for equations identified by an object.
  SUBROUTINE cmfe_Equations_TimeDependenceTypeGetObj(equations,timeDependenceType,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the time dependence type of the equations \see OPENCMISS_EquationsTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Equations_TimeDependenceTypeGetObj",err,error,*999)

    CALL EQUATIONS_TIME_DEPENDENCE_TYPE_GET(equations%equations,timeDependenceType,err,error,*999)

    EXITS("cmfe_Equations_TimeDependenceTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Equations_TimeDependenceTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_TimeDependenceTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get the number of linear matrices in the equations
  SUBROUTINE cmfe_Equations_NumberOfLinearMatricesGet(equations,numberOfMatrices,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the number of linear matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of linear matrices
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_Equations_NumberOfLinearMatricesGet",err,error,*999)

    CALL Equations_NumberOfLinearMatricesGet(equations%equations,numberOfMatrices,err,error,*999)

    EXITS("cmfe_Equations_NumberOfLinearMatricesGet")
    RETURN
999 ERRORSEXITS("cmfe_Equations_NumberOfLinearMatricesGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_NumberOfLinearMatricesGet

  !
  !================================================================================================================================
  !

  !>Get the number of Jacobian matrices in the equations
  SUBROUTINE cmfe_Equations_NumberOfJacobianMatricesGet(equations,numberOfMatrices,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the number of Jacobian matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of Jacobian matrices
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_Equations_NumberOfLinearMatricesGet",err,error,*999)

    CALL Equations_NumberOfJacobianMatricesGet(equations%equations,numberOfMatrices,err,error,*999)

    EXITS("cmfe_Equations_NumberOfJacobianMatricesGet")
    RETURN
999 ERRORSEXITS("cmfe_Equations_NumberOfJacobianMatricesGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_NumberOfJacobianMatricesGet

  !
  !================================================================================================================================
  !

  !>Get the number of dynamic matrices in the equations
  SUBROUTINE cmfe_Equations_NumberOfDynamicMatricesGet(equations,numberOfMatrices,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the number of dynamic matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of dynamic matrices
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_Equations_NumberOfDynamicMatricesGet",err,error,*999)

    CALL Equations_NumberOfDynamicMatricesGet(equations%equations,numberOfMatrices,err,error,*999)

    EXITS("cmfe_Equations_NumberOfDynamicMatricesGet")
    RETURN
999 ERRORSEXITS("cmfe_Equations_NumberOfDynamicMatricesGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_NumberOfDynamicMatricesGet

  !
  !================================================================================================================================
  !

  !>Get a linear equations matrix from the equations
  SUBROUTINE cmfe_Equations_LinearMatrixGet(equations,matrixIndex,matrix,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the linear matrix for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The number of the linear matrix to get
    TYPE(cmfe_DistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested linear matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_Equations_LinearMatrixGet",err,error,*999)

    CALL Equations_LinearMatrixGet(equations%equations,matrixIndex,matrix%distributedMatrix,err,error,*999)

    EXITS("cmfe_Equations_LinearMatrixGet")
    RETURN
999 ERRORSEXITS("cmfe_Equations_LinearMatrixGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_LinearMatrixGet

  !
  !================================================================================================================================
  !

  !>Finish the creation of derived variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_DerivedCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to finish the creation of derived variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of derived variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: equationsSet
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_DerivedCreateFinishNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,region,equationsSet,err,error,*999)
      IF(ASSOCIATED(equationsSet)) THEN
        CALL EquationsSet_DerivedCreateFinish(equationsSet,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_DerivedCreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DerivedCreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DerivedCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of derived variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_DerivedCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of derived variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_DerivedCreateFinishObj",err,error,*999)

    CALL EquationsSet_DerivedCreateFinish(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_DerivedCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DerivedCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DerivedCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of derived variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_DerivedCreateStartNumber(regionUserNumber,equationsSetUserNumber,derivedFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to start the creation of derived variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of derived variables for.
    INTEGER(INTG), INTENT(IN) :: derivedFieldUserNumber !<The user number of the derived field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: equationsSet
    TYPE(FIELD_TYPE), POINTER :: derivedField
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_DerivedCreateStartNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(equationsSet)
    NULLIFY(derivedField)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,region,equationsSet,err,error,*999)
      IF(ASSOCIATED(equationsSet)) THEN
        CALL FIELD_USER_NUMBER_FIND(derivedFieldUserNumber,region,derivedField,err,error,*999)
        CALL EquationsSet_DerivedCreateStart(equationsSet,derivedFieldUserNumber,derivedField,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_DerivedCreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DerivedCreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DerivedCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of derived variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_DerivedCreateStartObj(equationsSet,derivedFieldUserNumber,derivedField,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of derived variables on.
    INTEGER(INTG), INTENT(IN) :: derivedFieldUserNumber !<The user number of the derived field.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: derivedField !<If associated on entry, the user created derived field which has the same user number as the specified derived field user number. If not associated on entry, on return, the created derived field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_DerivedCreateStartObj",err,error,*999)

    CALL EquationsSet_DerivedCreateStart(equationsSet%equationsSet,derivedFieldUserNumber,derivedField%field, &
      & err,error,*999)

    EXITS("cmfe_EquationsSet_DerivedCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DerivedCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DerivedCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the derived variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_DerivedDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to destroy the derived variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the derived variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: equationsSet
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_DerivedDestroyNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,region,equationsSet,err,error,*999)
      IF(ASSOCIATED(equationsSet)) THEN
        CALL EquationsSet_DerivedDestroy(equationsSet,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_DerivedDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DerivedDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DerivedDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the derived variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_DerivedDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the derived variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_DerivedDestroyObj",err,error,*999)

    CALL EquationsSet_DerivedDestroy(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_DerivedDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DerivedDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DerivedDestroyObj

  !
  !================================================================================================================================
  !

  !>Calculates a derived field value for the equations set and stores the result in the derived field previously set up
  SUBROUTINE cmfe_EquationsSet_DerivedVariableCalculateNumber(regionUserNumber,equationsSetUserNumber,derivedType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to calculate the output for.
    INTEGER(INTG), INTENT(IN) :: derivedType !<The derived variable type to calculate. \see OPENCMISS_EquationsSetDerivedTypes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: equationsSet
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_DerivedVariableCalculateNumber",err,error,*999)

    NULLIFY(equationsSet)
    NULLIFY(region)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,region,equationsSet,err,error,*999)
      IF(ASSOCIATED(equationsSet)) THEN
        CALL EquationsSet_DerivedVariableCalculate(equationsSet,derivedType,err,error,*999)
      ELSE
        localError="An equations set with a user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*", &
          & err,error))//" does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_DerivedVariableCalculateNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_DerivedVariableCalculateNumber",err,error)
    EXITS("cmfe_EquationsSet_DerivedVariableCalculateNumber")
    CALL cmfe_HandleError(err,error)
    RETURN
    
  END SUBROUTINE cmfe_EquationsSet_DerivedVariableCalculateNumber

  !
  !================================================================================================================================
  !

  !>Calculates a derived field value for the equations set and stores the result in the derived field previously set up
  SUBROUTINE cmfe_EquationsSet_DerivedVariableCalculateObj(equationsSet,derivedType,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to calculate the output for.
    INTEGER(INTG), INTENT(IN) :: derivedType !<The derived field type to calculate. \see OPENCMISS_EquationsSetDerivedTypes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_EquationsSet_DerivedVariableCalculateObj",err,error,*999)

    CALL EquationsSet_DerivedVariableCalculate(equationsSet%equationsSet,derivedType,err,error,*999)

    EXITS("cmfe_EquationsSet_DerivedVariableCalculateObj")
    RETURN
999 ERRORS("cmfe_EquationsSet_DerivedVariableCalculateObj",err,error)
    EXITS("cmfe_EquationsSet_DerivedVariableCalculateObj")
    CALL cmfe_HandleError(err,error)
    
  END SUBROUTINE cmfe_EquationsSet_DerivedVariableCalculateObj

  !
  !================================================================================================================================
  !

  !>Sets the field variable type of the derived field to be used to store a derived variable
  SUBROUTINE cmfe_EquationsSet_DerivedVariableSetNumber(regionUserNumber,equationsSetUserNumber,derivedType,fieldVariableType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to calculate the output for.
    INTEGER(INTG), INTENT(IN) :: derivedType !<The derived variable type to calculate. \see OPENCMISS_EquationsSetDerivedTypes.
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The field variable type to store the calculated values in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: equationsSet
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_DerivedVariableSetNumber",err,error,*999)

    NULLIFY(equationsSet)
    NULLIFY(region)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,region,equationsSet,err,error,*999)
      IF(ASSOCIATED(equationsSet)) THEN
        CALL EquationsSet_DerivedVariableSet(equationsSet,derivedType,fieldVariableType,err,error,*999)
      ELSE
        localError="An equations set with a user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*", &
          & err,error))//" does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_DerivedVariableSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DerivedVariableSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    
  END SUBROUTINE cmfe_EquationsSet_DerivedVariableSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the field variable type of the derived field to be used to store a derived variable
  SUBROUTINE cmfe_EquationsSet_DerivedVariableSetObj(equationsSet,derivedType,fieldVariableType,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to calculate the output for.
    INTEGER(INTG), INTENT(IN) :: derivedType !<The derived field type to calculate. \see OPENCMISS_EquationsSetDerivedTypes.
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The field variable type to store the calculated values in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_EquationsSet_DerivedVariableSetObj",err,error,*999)

    CALL EquationsSet_DerivedVariableSet(equationsSet%equationsSet,derivedType,fieldVariableType,err,error,*999)

    EXITS("cmfe_EquationsSet_DerivedVariableSetObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DerivedVariableSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    
  END SUBROUTINE cmfe_EquationsSet_DerivedVariableSetObj

  !
  !================================================================================================================================
  !

  !>Get a Jacobian matrix from the equations
  SUBROUTINE cmfe_Equations_JacobianMatrixGet(equations,residualIndex,variableType,matrix,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the Jacobian matrix for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get the Jacobian matrix for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type that the residual is differentiated with respect to for this Jacobian. \see OPENCMISS_FieldVariableTypes
    TYPE(cmfe_DistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested Jacobian matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_Equations_JacobianMatrixGet",err,error,*999)

    CALL Equations_JacobianMatrixGet(equations%equations, &
      & residualIndex,variableType,matrix%distributedMatrix,err,error,*999)

    EXITS("cmfe_Equations_JacobianMatrixGet")
    RETURN
999 ERRORSEXITS("cmfe_Equations_JacobianMatrixGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_JacobianMatrixGet

  !
  !================================================================================================================================
  !

  !>Get a dynamic equations matrix from equations using the dynamic matrix index
  SUBROUTINE cmfe_Equations_DynamicMatrixGet(equations,matrixIndex,matrix,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the dynamic matrix for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The number of the dynamic matrix to get
    TYPE(cmfe_DistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested dynamic matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_Equations_DynamicMatrixGet",err,error,*999)

    CALL Equations_DynamicMatrixGet(equations%equations,matrixIndex,matrix%distributedMatrix,err,error,*999)

    EXITS("cmfe_Equations_DynamicMatrixGet")
    RETURN
999 ERRORSEXITS("cmfe_Equations_DynamicMatrixGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_DynamicMatrixGet

  !
  !================================================================================================================================
  !

  !>Get a dynamic equations matrix from equations using the dynamic matrix type
  SUBROUTINE cmfe_Equations_DynamicMatrixGetByType(equations,matrixType,matrix,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the dynamic matrix for
    INTEGER(INTG), INTENT(IN) :: matrixType !<The type of the dynamic matrix to get. \see OPENCMISS_EquationsSetDynamicMatrixTypes
    TYPE(cmfe_DistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested dynamic matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_Equations_DynamicMatrixGetByType",err,error,*999)

    CALL Equations_DynamicMatrixGetByType(equations%equations,matrixType,matrix%distributedMatrix,err,error,*999)

    EXITS("cmfe_Equations_DynamicMatrixGetByType")
    RETURN
999 ERRORSEXITS("cmfe_Equations_DynamicMatrixGetByType",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_DynamicMatrixGetByType

  !
  !================================================================================================================================
  !

  !>Get the type of a dynamic matrix from equations set equations
  SUBROUTINE cmfe_Equations_DynamicMatrixTypeGet(equations,matrixIndex,matrixType,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the dynamic matrix type from
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The number of the dynamic matrix to get the type of
    INTEGER(INTG), INTENT(OUT) :: matrixType !<On return, the dynamic matrix type. \see OPENCMISS_EquationsSetDynamicMatrixTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_Equations_DynamicMatrixTypeGet",err,error,*999)

    CALL Equations_DynamicMatrixTypeGet(equations%equations,matrixIndex,matrixType,err,error,*999)

    EXITS("cmfe_Equations_DynamicMatrixTypeGet")
    RETURN
999 ERRORSEXITS("cmfe_Equations_DynamicMatrixTypeGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_DynamicMatrixTypeGet

  !
  !================================================================================================================================
  !

  !>Get the right hand side vector for equations
  SUBROUTINE cmfe_Equations_RhsVectorGet(equations,rhsVector,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the right hand side vector for
    TYPE(cmfe_DistributedVectorType), INTENT(INOUT) :: rhsVector !<On return, the right hand side vector for the equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_Equations_RhsVectorGet",err,error,*999)

    CALL Equations_RhsVectorGet(equations%equations,rhsVector%distributedVector,err,error,*999)

    EXITS("cmfe_Equations_RhsVectorGet")
    RETURN
999 ERRORSEXITS("cmfe_Equations_RhsVectorGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_RhsVectorGet

  !
  !================================================================================================================================
  !

  !>Get the source vector for equations
  SUBROUTINE cmfe_Equations_SourceVectorGet(equations,sourceVector,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the source vector for
    TYPE(cmfe_DistributedVectorType), INTENT(INOUT) :: sourceVector !<On return, the source vector for the equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_Equations_SourceVectorGet",err,error,*999)

    CALL Equations_SourceVectorGet(equations%equations,sourceVector%distributedVector,err,error,*999)

    EXITS("cmfe_Equations_SourceVectorGet")
    RETURN
999 ERRORSEXITS("cmfe_Equations_SourceVectorGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_SourceVectorGet

  !
  !================================================================================================================================
  !

  !>Get a residual vector for equations
  SUBROUTINE cmfe_Equations_ResidualVectorGet(equations,residualIndex,residualVector,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the residual vector for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get
    TYPE(cmfe_DistributedVectorType), INTENT(INOUT) :: residualVector !<On return, the residual vector for the equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_Equations_ResidualVectorGet",err,error,*999)

    CALL Equations_ResidualVectorGet(equations%equations,residualIndex,residualVector%distributedVector,err,error,*999)

    EXITS("cmfe_Equations_ResidualVectorGet")
    RETURN
999 ERRORSEXITS("cmfe_Equations_ResidualVectorGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_ResidualVectorGet

  !
  !================================================================================================================================
  !

  !>Get the number of field variables that contribute to the residual vector
  SUBROUTINE cmfe_Equations_ResidualNumberOfVariablesGet(equations,residualIndex,numberOfVariables,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the residual vector number of variables for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get the number of variables for
    INTEGER(INTG), INTENT(OUT) :: numberOfVariables !<On return, the number of variables that contribute to the residual vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_Equations_ResidualNumberOfVariablesGet",err,error,*999)

    CALL Equations_ResidualNumberOfVariablesGet(equations%equations,residualIndex,numberOfVariables,err,error,*999)

    EXITS("cmfe_Equations_ResidualNumberOfVariablesGet")
    RETURN
999 ERRORSEXITS("cmfe_Equations_ResidualNumberOfVariablesGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_ResidualNumberOfVariablesGet

  !
  !================================================================================================================================
  !

  !>Get the field variables that contribute to the residual vector
  SUBROUTINE cmfe_Equations_ResidualVariablesGet(equations,residualIndex,residualVariables,err)

    !Argument variables
    TYPE(cmfe_EquationsType), INTENT(IN) :: equations !<The equations to get the residual vector variables for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get the variables for
    INTEGER(INTG), INTENT(OUT) :: residualVariables(:) !<residualVariables(varIdx). On return, the field variable type for the varIdx'th residual variable. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_Equations_ResidualVariablesGet",err,error,*999)

    CALL Equations_ResidualVariablesGet(equations%equations,residualIndex,residualVariables,err,error,*999)

    EXITS("cmfe_Equations_ResidualVariablesGet")
    RETURN
999 ERRORSEXITS("cmfe_Equations_ResidualVariablesGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Equations_ResidualVariablesGet

!!==================================================================================================================================
!!
!! EQUATIONS_SET_ROUTINES
!!
!!==================================================================================================================================

  !>Finish the creation of a analytic solution for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_AnalyticCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_AnalyticCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_ANALYTIC_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_AnalyticCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_AnalyticCreateFinishNumber",err,error)
    EXITS("cmfe_EquationsSet_AnalyticCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of a analytic solution for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_AnalyticCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_AnalyticCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_CREATE_FINISH(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of a analytic solution for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_AnalyticCreateStartNumber(regionUserNumber,equationsSetUserNumber,analyticFunctionType, &
    & analyticFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: analyticFunctionType !<The analytic function type to use. \see OPENCMISS_EquationsSetAnalyticFunctionTypes
    INTEGER(INTG), INTENT(IN) :: analyticFieldUserNumber !<The user number of the field for the analytic function
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: ANALYTIC_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_AnalyticCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(ANALYTIC_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(analyticFieldUserNumber,REGION,ANALYTIC_FIELD,ERR,error,*999)
        CALL EQUATIONS_SET_ANALYTIC_CREATE_START(EQUATIONS_SET,analyticFunctionType,analyticFieldUserNumber,ANALYTIC_FIELD, &
          & err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_AnalyticCreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticCreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of an analytic solution for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_AnalyticCreateStartObj(equationsSet,analyticFunctionType,analyticFieldUserNumber,analyticField,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the analytic creation on.
    INTEGER(INTG), INTENT(IN) :: analyticFunctionType !<The analytic function type to use. \see OPENCMISS_EquationsSetAnalyticFunctionTypes
    INTEGER(INTG), INTENT(IN) :: analyticFieldUserNumber !<The user number of the field for the analytic function
    TYPE(cmfe_FieldType), INTENT(INOUT) :: analyticField !<If associated on entry, the user created analytic field which has the same user number as the specified analytic field user number. If not associated on entry, on return, the created analytic field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_AnalyticCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_CREATE_START(equationsSet%equationsSet,analyticFunctionType,analyticFieldUserNumber, &
      & analyticField%field,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the analytic solution for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_AnalyticDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
     TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_AnalyticDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_ANALYTIC_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_AnalyticDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the analytic solution for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_AnalyticDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the analytic for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_AnalyticDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_DESTROY(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticDestroyObj


  !
  !================================================================================================================================
  !

  !>Evaluates the current analytic solution for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_AnalyticEvaluateNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to evaluate.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to evaluate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
     TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_AnalyticEvaluateNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_ANALYTIC_EVALUATE(EQUATIONS_SET,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_AnalyticEvaluateNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticEvaluateNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticEvaluateNumber

  !
  !================================================================================================================================
  !

  !>Evaluates the current analytic solution for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_AnalyticEvaluateObj(equationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to evaluate the current analytic solution for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_AnalyticEvaluateObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_EVALUATE(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticEvaluateObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticEvaluateObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticEvaluateObj

  !
  !================================================================================================================================
  !

  !>Returns the analytic time for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_AnalyticTimeGetNumber(regionUserNumber,equationsSetUserNumber,time,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set get the analytic time for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the analytic time get.
    REAL(DP), INTENT(OUT) :: time !<On return, the analytic time for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_AnalyticTimeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_ANALYTIC_TIME_GET(EQUATIONS_SET,time,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_AnalyticTimeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticTimeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticTimeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the analytic time for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_AnalyticTimeGetObj(equationsSet,time,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to get the analytic time for.
    REAL(DP), INTENT(OUT) :: time !<On return, the analytic time for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_AnalyticTimeGetObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_TIME_GET(equationsSet%equationsSet,time,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticTimeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticTimeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticTimeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the analytic time for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_AnalyticTimeSetNumber(regionUserNumber,equationsSetUserNumber,time,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set get the analytic time for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the analytic time get.
    REAL(DP), INTENT(IN) :: time !<The analytic time to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_AnalyticTimeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_ANALYTIC_TIME_SET(EQUATIONS_SET,time,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_AnalyticTimeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticTimeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticTimeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the analytic time for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_AnalyticTimeSetObj(equationsSet,time,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the analytic time for.
    REAL(DP), INTENT(IN) :: time !<The analytic time to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_AnalyticTimeSetObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_TIME_SET(equationsSet%equationsSet,time,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticTimeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticTimeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticTimeSetObj


  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE cmfe_EquationsSet_AnalyticUserParamSetNumber(regionUserNumber,equationsSetUserNumber,paramIdx,param,err)
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(IN) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_AnalyticUserParamSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        IF(ASSOCIATED(EQUATIONS_SET%ANALYTIC)) THEN
          CALL EQUATIONS_SET_ANALYTIC_USER_PARAM_SET(EQUATIONS_SET,paramIdx,param,err,error,*999)
        ELSE
          localError="Equations set analytic is not associated for equations set with a user number of " &
            & //TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_AnalyticUserParamSetNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_AnalyticUserParamSetNumber",err,error)
    EXITS("cmfe_EquationsSet_AnalyticUserParamSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticUserParamSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE cmfe_EquationsSet_AnalyticUserParamSetObj(equationsSet,paramIdx,param,err)
    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the analytic user parameter.
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(IN) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_AnalyticUserParamSetObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_USER_PARAM_SET(equationsSet%equationsSet,paramIdx,param,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticUserParamSetObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticUserParamSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticUserParamSetObj

  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE cmfe_EquationsSet_AnalyticUserParamGetNumber(regionUserNumber,equationsSetUserNumber,paramIdx,param,err)
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(OUT) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_AnalyticUserParamGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        IF(ASSOCIATED(EQUATIONS_SET%ANALYTIC)) THEN
          CALL EQUATIONS_SET_ANALYTIC_USER_PARAM_GET(EQUATIONS_SET,paramIdx,param,err,error,*999)
        ELSE
          localError="Equations set analytic is not associated for equations set with a user number of " &
            & //TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_AnalyticUserParamGetNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_AnalyticUserParamGetNumber",err,error)
    EXITS("cmfe_EquationsSet_AnalyticUserParamGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticUserParamGetNumber

  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE cmfe_EquationsSet_AnalyticUserParamGetObj(equationsSet,paramIdx,param,err)
    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the analytic user parameter.
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(OUT) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_AnalyticUserParamGetObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_USER_PARAM_GET(equationsSet%equationsSet,paramIdx,param,err,error,*999)

    EXITS("cmfe_EquationsSet_AnalyticUserParamGetObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_AnalyticUserParamGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_AnalyticUserParamGetObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_CreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Equations Set Create')
#endif

    EXITS("cmfe_EquationsSet_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_CreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_CreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_CREATE_FINISH(equationsSet%equationsSet,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Equations Set Create')
#endif

    EXITS("cmfe_EquationsSet_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_CreateStartNumber(equationsSetUserNumber,regionUserNumber,geomFibreFieldUserNumber,&
      & equationsSetSpecification,equationsSetFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to be created.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to start the creation of an equations set on.
    INTEGER(INTG), INTENT(IN) :: geomFibreFieldUserNumber !<The user number of the Geometric/Fibre field for the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetSpecification(:) !<The equations set specification array, containing the equations class, type etc
    INTEGER(INTG), INTENT(IN) :: equationsSetFieldUserNumber !<The user number of the equations set field
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: EQUATIONS_SET_FIELD
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: GEOM_FIBRE_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Equations Set Create')
#endif

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(GEOM_FIBRE_FIELD)
    NULLIFY(EQUATIONS_SET_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(geomFibreFieldUserNumber,REGION,GEOM_FIBRE_FIELD,err,error,*999)

      !Equations set field may not be created
      CALL FIELD_USER_NUMBER_FIND(equationsSetFieldUserNumber,REGION,EQUATIONS_SET_FIELD,err,error,*999)

      IF(ASSOCIATED(GEOM_FIBRE_FIELD)) THEN
        CALL EQUATIONS_SET_CREATE_START(equationsSetUserNumber,REGION,GEOM_FIBRE_FIELD,&
          & equationsSetSpecification,equationsSetFieldUserNumber,&
          & EQUATIONS_SET_FIELD,EQUATIONS_SET,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(geomFibreFieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_CreateStartObj(equationsSetUserNumber,region,geomFibreField,&
      & equationsSetSpecification,equationsSetFieldUserNumber,&
      & equationsSetFieldField,equationsSet,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to be created.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to create the equations set on.
    TYPE(cmfe_FieldType), INTENT(IN) :: geomFibreField !<The Geometric/Fibre field for the creation of the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetSpecification(:) !<The equations set specification array, containing the equations class, type etc
    INTEGER(INTG), INTENT(IN) :: equationsSetFieldUserNumber !<The user number of the equations set field
    TYPE(cmfe_FieldType), INTENT(INOUT) :: equationsSetFieldField !<On return, a pointer to the equations set field
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<On return, the created equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Equations Set Create')
#endif

    CALL EQUATIONS_SET_CREATE_START(equationsSetUserNumber,region%region,geomFibreField%field, &
      & equationsSetSpecification,equationsSetFieldUserNumber,equationsSetFieldField%field,equationsSet%equationsSet, &
      & err,error,*999)

    EXITS("cmfe_EquationsSet_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_DestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destory.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
     TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_DestroyObj(equationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_DestroyObj",err,error,*999)

    CALL EQUATIONS_SET_DESTROY(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DestroyObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of dependent variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_DependentCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_DependentCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_DEPENDENT_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_DependentCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_DependentCreateFinishNumber",err,error)
    EXITS("cmfe_EquationsSet_DependentCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DependentCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of dependent variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_DependentCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_DependentCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_DEPENDENT_CREATE_FINISH(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_DependentCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DependentCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DependentCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of dependent variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_DependentCreateStartNumber(regionUserNumber,equationsSetUserNumber,dependentFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: dependentFieldUserNumber !<The user number of the dependent field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_DependentCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(dependentFieldUserNumber,REGION,DEPENDENT_FIELD,ERR,error,*999)
        CALL EQUATIONS_SET_DEPENDENT_CREATE_START(EQUATIONS_SET,dependentFieldUserNumber,DEPENDENT_FIELD,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_DependentCreateStartNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_DependentCreateStartNumber",err,error)
    EXITS("cmfe_EquationsSet_DependentCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DependentCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of dependent variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_DependentCreateStartObj(equationsSet,dependentFieldUserNumber,dependentField,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of dependent variables on.
    INTEGER(INTG), INTENT(IN) :: dependentFieldUserNumber !<The user number of the dependent field.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: dependentField !<If associated on entry, the user created dependent field which has the same user number as the specified dependent field user number. If not associated on entry, on return, the created dependent field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_DependentCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_DEPENDENT_CREATE_START(equationsSet%equationsSet,dependentFieldUserNumber,dependentField%field, &
      & err,error,*999)

    EXITS("cmfe_EquationsSet_DependentCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DependentCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DependentCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the dependent variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_DependentDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_DependentDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_DEPENDENT_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_DependentDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DependentDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DependentDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the dependent variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_DependentDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_DependentDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_DEPENDENT_DESTROY(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_DependentDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_DependentDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_DependentDestroyObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of equations for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_EquationsCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_EquationsCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_EquationsCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_EquationsCreateFinishNumber",err,error)
    EXITS("cmfe_EquationsSet_EquationsCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_EquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of equations for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_EquationsCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_EquationsCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_EQUATIONS_CREATE_FINISH(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_EquationsCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_EquationsCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_EquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of equations for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_EquationsCreateStartNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of equations for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_EquationsCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_CREATE_START(EQUATIONS_SET,EQUATIONS,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_EquationsCreateStartNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_EquationsCreateStartNumber",err,error)
    EXITS("cmfe_EquationsSet_EquationsCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_EquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of equations for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_EquationsCreateStartObj(equationsSet,equations,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of equations on.
    TYPE(cmfe_EquationsType), INTENT(INOUT) :: equations !<On return, the created equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_EquationsCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_EQUATIONS_CREATE_START(equationsSet%equationsSet,equations%equations,err,error,*999)

    EXITS("cmfe_EquationsSet_EquationsCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_EquationsCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_EquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the equations for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_EquationsDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_EquationsDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_EquationsDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_EquationsDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_EquationsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the equations for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_EquationsDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_EquationsDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_EQUATIONS_DESTROY(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_EquationsDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_EquationsDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_EquationsDestroyObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of independent variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_IndependentCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_IndependentCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_INDEPENDENT_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_IndependentCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_IndependentCreateFinishNumber",err,error)
    EXITS("cmfe_EquationsSet_IndependentCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_IndependentCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of independent variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_IndependentCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_IndependentCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_INDEPENDENT_CREATE_FINISH(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_IndependentCreateFinishObj")
    RETURN
999 ERRORS("cmfe_EquationsSet_IndependentCreateFinishObj",err,error)
    EXITS("cmfe_EquationsSet_IndependentCreateFinishObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_IndependentCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of independent variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_IndependentCreateStartNumber(regionUserNumber,equationsSetUserNumber,independentFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: independentFieldUserNumber !<The user number of the independent field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: INDEPENDENT_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_DependentCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(INDEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(independentFieldUserNumber,REGION,INDEPENDENT_FIELD,ERR,error,*999)
        CALL EQUATIONS_SET_DEPENDENT_CREATE_START(EQUATIONS_SET,independentFieldUserNumber,INDEPENDENT_FIELD,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_IndependentCreateStartNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_IndependentCreateStartNumber",err,error)
    EXITS("cmfe_EquationsSet_IndependentCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_IndependentCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of independent variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_IndependentCreateStartObj(equationsSet,independentFieldUserNumber,independentField,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of independent variables on.
    INTEGER(INTG), INTENT(IN) :: independentFieldUserNumber !<The user number of the dependent field.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: independentField !<If associated on entry, the user created independent field which has the same user number as the specified independent field user number. If not associated on entry, on return, the created independent field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_IndependentCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_INDEPENDENT_CREATE_START(equationsSet%equationsSet,independentFieldUserNumber,independentField%field, &
      & err,error,*999)

    EXITS("cmfe_EquationsSet_IndependentCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_IndependentCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_IndependentCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the independent variables for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_IndependentDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_IndependentDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_INDEPENDENT_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_IndependentDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_IndependentDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_IndependentDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the independent variables for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_IndependentDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_IndependentDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_INDEPENDENT_DESTROY(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_IndependentDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_IndependentDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_IndependentDestroyObj

  !
  !================================================================================================================================
  !

  !
  !================================================================================================================================
  !

  !>Finish the creation of materials for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_MaterialsCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_MaterialsCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_MATERIALS_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_MaterialsCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_MaterialsCreateFinishNumber",err,error)
    EXITS("cmfe_EquationsSet_MaterialsCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_MaterialsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of materials for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_MaterialsCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_MaterialsCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_MATERIALS_CREATE_FINISH(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_MaterialsCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_MaterialsCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_MaterialsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of materials for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_MaterialsCreateStartNumber(regionUserNumber,equationsSetUserNumber,materialsFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: materialsFieldUserNumber !<The user number of the materials field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: MATERIALS_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_MaterialsCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(MATERIALS_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(materialsFieldUserNumber,REGION,MATERIALS_FIELD,ERR,error,*999)
        CALL EQUATIONS_SET_MATERIALS_CREATE_START(EQUATIONS_SET,materialsFieldUserNumber,MATERIALS_FIELD,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_MaterialsCreateStartNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_MaterialsCreateStartNumber",err,error)
    EXITS("cmfe_EquationsSet_MaterialsCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_MaterialsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of materials for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_MaterialsCreateStartObj(equationsSet,materialsFieldUserNumber,materialsField,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of materials on.
    INTEGER(INTG), INTENT(IN) :: materialsFieldUserNumber !<The user number of the materials field.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: materialsField !<If associated on entry, the user created materials field which has the same user number as the specified materials field user number. If not associated on entry, on return, the created materials field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_MaterialsCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_MATERIALS_CREATE_START(equationsSet%equationsSet,materialsFieldUserNumber,materialsField%field, &
      & err,error,*999)

    EXITS("cmfe_EquationsSet_MaterialsCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_MaterialsCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_MaterialsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the materials for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_MaterialsDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the materials for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_MaterialsDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_MATERIALS_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_MaterialsDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_MaterialsDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_MaterialsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the materials for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_MaterialsDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_MaterialsDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_MATERIALS_DESTROY(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_MaterialsDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_MaterialsDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_MaterialsDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the solution method for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_SolutionMethodGetNumber(regionUserNumber,equationsSetUserNumber,solutionMethod,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to get the solution method for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the solution method for.
    INTEGER(INTG), INTENT(OUT) :: solutionMethod !<On return, the solution method. \see OPENCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_SolutionMethodGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SOLUTION_METHOD_GET(EQUATIONS_SET,solutionMethod,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_SolutionMethodGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SolutionMethodGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SolutionMethodGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the solution method for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_SolutionMethodGetObj(equationsSet,solutionMethod,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to get the solution method for.
    INTEGER(INTG), INTENT(OUT) :: solutionMethod !<On Return, the solution method. \see OPENCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_SolutionMethodGetObj",err,error,*999)

    CALL EQUATIONS_SET_SOLUTION_METHOD_GET(equationsSet%equationsSet,solutionMethod,err,error,*999)

    EXITS("cmfe_EquationsSet_SolutionMethodGetObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SolutionMethodGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SolutionMethodGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution method for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_SolutionMethodSetNumber(regionUserNumber,equationsSetUserNumber,solutionMethod,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: solutionMethod !<The solution method to set. \see OPENCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_SolutionMethodSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SOLUTION_METHOD_SET(EQUATIONS_SET,solutionMethod,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_SolutionMethodSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SolutionMethodSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SolutionMethodSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution method for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_SolutionMethodSetObj(equationsSet,solutionMethod,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: solutionMethod !<The solution method to set. \see OPENCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_SolutionMethodSetObj",err,error,*999)

    CALL EQUATIONS_SET_SOLUTION_METHOD_SET(equationsSet%equationsSet,solutionMethod,err,error,*999)

    EXITS("cmfe_EquationsSet_SolutionMethodSetObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SolutionMethodSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SolutionMethodSetObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of a source for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_SourceCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_SourceCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SOURCE_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_SourceCreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SourceCreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SourceCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of a source for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_SourceCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_SourceCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_SOURCE_CREATE_FINISH(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_SourceCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SourceCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SourceCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of a source for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_SourceCreateStartNumber(regionUserNumber,equationsSetUserNumber,sourceFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: sourceFieldUserNumber !<The user number of the source field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: SOURCE_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_SourceCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(SOURCE_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(sourceFieldUserNumber,REGION,SOURCE_FIELD,ERR,error,*999)
        CALL EQUATIONS_SET_SOURCE_CREATE_START(EQUATIONS_SET,sourceFieldUserNumber,SOURCE_FIELD,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_SourceCreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SourceCreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SourceCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of a source for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_SourceCreateStartObj(equationsSet,sourceFieldUserNumber,sourceField,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of a source on.
    INTEGER(INTG), INTENT(IN) :: sourceFieldUserNumber !<The user number of the source field.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: sourceField !<If associated on entry, the user created source field which has the same user number as the specified source field user number. If not associated on entry, on return, the created source field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_SourceCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_SOURCE_CREATE_START(equationsSet%equationsSet,sourceFieldUserNumber,sourceField%field,err,error,*999)

    EXITS("cmfe_EquationsSet_SourceCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SourceCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SourceCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the source for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_SourceDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the source for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_SourceDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SOURCE_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_SourceDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SourceDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SourceDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the source for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_SourceDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_SourceDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_SOURCE_DESTROY(equationsSet%equationsSet,err,error,*999)

    EXITS("cmfe_EquationsSet_SourceDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_SourceDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SourceDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the equations set specification array for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_SpecificationGetNumber(regionUserNumber,equationsSetUserNumber,equationsSetSpecification,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to get the specification for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the specification for.
    INTEGER(INTG), INTENT(INOUT) :: equationsSetSpecification(:) !<On return, the equations set specification array. Must be allocated and large enough to contain the specification on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: equationsSet
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_SpecificationGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,region,equationsSet,err,error,*999)
      IF(ASSOCIATED(equationsSet)) THEN
        CALL EquationsSet_SpecificationGet(equationsSet,equationsSetSpecification,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_SpecificationGetNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_SpecificationGetNumber",err,error)
    EXITS("cmfe_EquationsSet_SpecificationGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SpecificationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the equations set specification array for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_SpecificationGetObj(equationsSet,equationsSetSpecification,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to get the specification for.
    INTEGER(INTG), INTENT(INOUT) :: equationsSetSpecification(:) !<On return, the equations set specification array. Must be allocated and large enough to contain the specification on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_SpecificationGetObj",err,error,*999)

    CALL EquationsSet_SpecificationGet(equationsSet%equationsSet,equationsSetSpecification,err,error,*999)

    EXITS("cmfe_EquationsSet_SpecificationGetObj")
    RETURN
999 ERRORS("cmfe_EquationsSet_SpecificationGetObj",err,error)
    EXITS("cmfe_EquationsSet_SpecificationGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SpecificationGetObj

  !
  !================================================================================================================================
  !

  !>Returns the size of the equations set specification array for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_SpecificationSizeGetNumber(regionUserNumber,equationsSetUserNumber,specificationSize,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to get the specification size for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the specification size for.
    INTEGER(INTG), INTENT(OUT) :: specificationSize !<On return, the size of the equations set specification array. 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: equationsSet
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_SpecificationSizeGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(equationsSet)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,region,equationsSet,err,error,*999)
      IF(ASSOCIATED(equationsSet)) THEN
        CALL EquationsSet_SpecificationSizeGet(equationsSet,specificationSize,err,error,*999)
      ELSE
        localError="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_EquationsSet_SpecificationSizeGetNumber")
    RETURN
999 ERRORS("cmfe_EquationsSet_SpecificationSizeGetNumber",err,error)
    EXITS("cmfe_EquationsSet_SpecificationSizeGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SpecificationSizeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the size of the equations set specification array for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_SpecificationSizeGetObj(equationsSet,specificationSize,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to get the specification size for.
    INTEGER(INTG), INTENT(OUT) :: specificationSize !<On return, the size of the equations set specification array. 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_EquationsSet_SpecificationSizeGetObj",err,error,*999)

    CALL EquationsSet_SpecificationSizeGet(equationsSet%equationsSet,specificationSize,err,error,*999)

    EXITS("cmfe_EquationsSet_SpecificationSizeGetObj")
    RETURN
999 ERRORS("cmfe_EquationsSet_SpecificationSizeGetObj",err,error)
    EXITS("cmfe_EquationsSet_SpecificationSizeGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_SpecificationSizeGetObj

  !
  !================================================================================================================================
  !

  !>Calculate the strain tensor at a given element xi location, for an equations set identified by a user number.
  SUBROUTINE cmfe_EquationsSet_StrainInterpolateXiNumber(regionUserNumber,equationsSetUserNumber,userElementNumber,xi,values,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to calculate the strain for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:) !<The element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(6) !<The interpolated strain tensor values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: equationsSet
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_EquationsSet_StrainInterpolateXiNumber",err,error,*999)

    NULLIFY(equationsSet)
    NULLIFY(region)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,region,equationsSet,err,error,*999)
      IF(ASSOCIATED(equationsSet)) THEN
        CALL EquationsSet_StrainInterpolateXi(equationsSet,userElementNumber,xi, &
          & values,err,error,*999)
      ELSE
        localError="An equations set with a user number of "//TRIM(NumberToVstring(equationsSetUserNumber,"*", &
          & err,error))//" does not exist on region number "//TRIM(NumberToVstring(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVstring(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_EquationsSet_StrainInterpolateXiNumber")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_StrainInterpolateXiNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_StrainInterpolateXiNumber

  !
  !================================================================================================================================
  !

  !>Calculate the strain tensor at a given element xi location, for an equations set identified by an object.
  SUBROUTINE cmfe_EquationsSet_StrainInterpolateXiObj(equationsSet,userElementNumber,xi,values,err)

    !Argument variables
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<A pointer to the equations set to interpolate strain for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:) !<The element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(6) !<The interpolated strain tensor values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_EquationsSet_StrainInterpolateXiObj",err,error,*999)

    CALL EquationsSet_StrainInterpolateXi(equationsSet%equationsSet,userElementNumber,xi, &
      & values,err,error,*999)

    EXITS("cmfe_EquationsSet_StrainInterpolateXiObj")
    RETURN
999 ERRORSEXITS("cmfe_EquationsSet_StrainInterpolateXiObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_EquationsSet_StrainInterpolateXiObj

!!==================================================================================================================================
!!
!! FIELD_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the interpolation type for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentInterpolationGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & interpolationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: interpolationType !<On return, the interpolation type. \see OPENCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ComponentInterpolationGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_INTERPOLATION_GET(FIELD,variableType,componentNumber,interpolationType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ComponentInterpolationGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentInterpolationGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentInterpolationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the interpolation type for a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentInterpolationGetObj(field,variableType,componentNumber,interpolationType,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: interpolationType !<On return, the interpolation type. \see OPENCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentInterpolationGetObj",err,error,*999)

    CALL FIELD_COMPONENT_INTERPOLATION_GET(field%field,variableType,componentNumber,interpolationType,err,error,*999)

    EXITS("cmfe_Field_ComponentInterpolationGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentInterpolationGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentInterpolationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentInterpolationSetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & interpolationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: interpolationType !<The interpolation type to set. \see OPENCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ComponentInterpolationSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_INTERPOLATION_SET(FIELD,variableType,componentNumber,interpolationType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ComponentInterpolationSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentInterpolationSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentInterpolationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentInterpolationSetObj(field,variableType,componentNumber,interpolationType,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: interpolationType !<The interpolation type to set. \see OPENCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentInterpolationSetObj",err,error,*999)

    CALL FIELD_COMPONENT_INTERPOLATION_SET(field%field,variableType,componentNumber,interpolationType,err,error,*999)

    EXITS("cmfe_Field_ComponentInterpolationSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentInterpolationSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentInterpolationSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentLabelGetCNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ComponentLabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_LABEL_GET(FIELD,variableType,componentNumber,label,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ComponentLabelGetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentLabelGetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentLabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentLabelGetCObj(field,variableType,componentNumber,label,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentLabelGetCObj",err,error,*999)

    CALL FIELD_COMPONENT_LABEL_GET(field%field,variableType,componentNumber,label,err,error,*999)

    EXITS("cmfe_Field_ComponentLabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentLabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentLabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentLabelGetVSNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ComponentLabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_LABEL_GET(FIELD,variableType,componentNumber,label,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ComponentLabelGetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentLabelGetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentLabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentLabelGetVSObj(field,variableType,componentNumber,label,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentLabelGetVSObj",err,error,*999)

    CALL FIELD_COMPONENT_LABEL_GET(field%field,variableType,componentNumber,label,err,error,*999)

    EXITS("cmfe_Field_ComponentLabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentLabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentLabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentLabelSetCNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ComponentLabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_LABEL_SET(FIELD,variableType,componentNumber,label,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ComponentLabelSetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentLabelSetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentLabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentLabelSetCObj(field,variableType,componentNumber,label,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentLabelSetCObj",err,error,*999)

    CALL FIELD_COMPONENT_LABEL_SET(field%field,variableType,componentNumber,label,err,error,*999)

    EXITS("cmfe_Field_ComponentLabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentLabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentLabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentLabelSetVSNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ComponentLabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_LABEL_SET(FIELD,variableType,componentNumber,label,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ComponentLabelSetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentLabelSetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentLabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentLabelSetVSObj(field,variableType,componentNumber,label,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentLabelSetVSObj",err,error,*999)

    CALL FIELD_COMPONENT_LABEL_SET(field%field,variableType,componentNumber,label,err,error,*999)

    EXITS("cmfe_Field_ComponentLabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentLabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentLabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentMeshComponentGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & meshComponent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the mesh component number for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the mesh component number for.
    INTEGER(INTG), INTENT(OUT) :: meshComponent !<On return, the mesh component number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ComponentMeshComponentGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_MESH_COMPONENT_GET(FIELD,variableType,componentNumber,meshComponent,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ComponentMeshComponentGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentMeshComponentGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentMeshComponentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number for a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentMeshComponentGetObj(field,variableType,componentNumber,meshComponent,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the mesh component number for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the mesh component number for.
    INTEGER(INTG), INTENT(OUT) :: meshComponent !<On return, the mesh component number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentMeshComponentGetObj",err,error,*999)

    CALL FIELD_COMPONENT_MESH_COMPONENT_GET(field%field,variableType,componentNumber,meshComponent,err,error,*999)

    EXITS("cmfe_Field_ComponentMeshComponentGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentMeshComponentGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentMeshComponentGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentMeshComponentSetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & meshComponent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the mesh component number for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ComponentMeshComponentSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_MESH_COMPONENT_SET(FIELD,variableType,componentNumber,meshComponent,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ComponentMeshComponentSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentMeshComponentSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentMeshComponentSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentMeshComponentSetObj(field,variableType,componentNumber,meshComponent,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the mesh component number for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentMeshComponentSetObj",err,error,*999)

    CALL FIELD_COMPONENT_MESH_COMPONENT_SET(field%field,variableType,componentNumber,meshComponent,err,error,*999)

    EXITS("cmfe_Field_ComponentMeshComponentSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentMeshComponentSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentMeshComponentSetObj

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to an integer constant value for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentValuesInitialiseIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ComponentValuesInitialiseIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_VALUES_INITIALISE(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ComponentValuesInitialiseIntgNumber")
    RETURN
999 ERRORS("cmfe_Field_ComponentValuesInitialiseIntgNumber",err,error)
    EXITS("cmfe_Field_ComponentValuesInitialiseIntgNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentValuesInitialiseIntgNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to an integer constant value for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentValuesInitialiseIntgObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentValuesInitialiseIntgObj",err,error,*999)

    CALL FIELD_COMPONENT_VALUES_INITIALISE(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ComponentValuesInitialiseIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentValuesInitialiseIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentValuesInitialiseIntgObj
  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a single precision constant value for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentValuesInitialiseSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(SP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ComponentValuesInitialiseSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_VALUES_INITIALISE(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ComponentValuesInitialiseSPNumber")
    RETURN
999 ERRORS("cmfe_Field_ComponentValuesInitialiseSPNumber",err,error)
    EXITS("cmfe_Field_ComponentValuesInitialiseSPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentValuesInitialiseSPNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a single precision constant value for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentValuesInitialiseSPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(SP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentValuesInitialiseSPObj",err,error,*999)

    CALL FIELD_COMPONENT_VALUES_INITIALISE(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ComponentValuesInitialiseSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentValuesInitialiseSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentValuesInitialiseSPObj
  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a double precision constant value for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentValuesInitialiseDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(DP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ComponentValuesInitialiseDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_VALUES_INITIALISE(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ComponentValuesInitialiseDPNumber")
    RETURN
999 ERRORS("cmfe_Field_ComponentValuesInitialiseDPNumber",err,error)
    EXITS("cmfe_Field_ComponentValuesInitialiseDPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentValuesInitialiseDPNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a double precision constant value for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentValuesInitialiseDPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(DP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentValuesInitialiseDPObj",err,error,*999)

    CALL FIELD_COMPONENT_VALUES_INITIALISE(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ComponentValuesInitialiseDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentValuesInitialiseDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentValuesInitialiseDPObj
  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a logical constant value for a field identified by a user number.
  SUBROUTINE cmfe_Field_ComponentValuesInitialiseLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    LOGICAL, INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ComponentValuesInitialiseLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_VALUES_INITIALISE(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ComponentValuesInitialiseLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentValuesInitialiseLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentValuesInitialiseLNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a logical constant value for a field identified by an object.
  SUBROUTINE cmfe_Field_ComponentValuesInitialiseLObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    LOGICAL, INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ComponentValuesInitialiseLObj",err,error,*999)

    CALL FIELD_COMPONENT_VALUES_INITIALISE(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ComponentValuesInitialiseLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ComponentValuesInitialiseLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ComponentValuesInitialiseLObj

  !
  !================================================================================================================================
  !

  !>Returns the data type for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_DataTypeGetNumber(regionUserNumber,fieldUserNumber,variableType,dataType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the field variable data type. \see OPENCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_DataTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DATA_TYPE_GET(FIELD,variableType,dataType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_DataTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DataTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DataTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the data type for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_DataTypeGetObj(field,variableType,dataType,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the field variable data type. \see OPENCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DataTypeGetObj",err,error,*999)

    CALL FIELD_DATA_TYPE_GET(field%field,variableType,dataType,err,error,*999)

    EXITS("cmfe_Field_DataTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DataTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DataTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_DataTypeSetNumber(regionUserNumber,fieldUserNumber,variableType,dataType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the data type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: dataType !<The field variable data type to set. \see OPENCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_DataTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DATA_TYPE_SET(FIELD,variableType,dataType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_DataTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DataTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DataTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_DataTypeSetObj(field,variableType,dataType,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the data type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: dataType !<The field variable data type to set. \see OPENCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DataTypeSetObj",err,error,*999)

    CALL FIELD_DATA_TYPE_SET(field%field,variableType,dataType,err,error,*999)

    EXITS("cmfe_Field_DataTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DataTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DataTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the DOF order type for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_DOFOrderTypeGetNumber(regionUserNumber,fieldUserNumber,variableType,DOFOrderType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the DOF Order type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: DOFOrderType !<On return, the field variable DOF Order type. \see OPENCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_DOFOrderTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DOF_ORDER_TYPE_GET(FIELD,variableType,DOFOrderType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_DOFOrderTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DOFOrderTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DOFOrderTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the DOF Order type for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_DOFOrderTypeGetObj(field,variableType,DOFOrderType,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the DOF order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the DOF order type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: DOFOrderType !<On return, the field variable DOF order type. \see OPENCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DOFOrderTypeGetObj",err,error,*999)

    CALL FIELD_DOF_ORDER_TYPE_GET(field%field,variableType,DOFOrderType,err,error,*999)

    EXITS("cmfe_Field_DOFOrderTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DOFOrderTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DOFOrderTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF order type for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_DOFOrderTypeSetNumber(regionUserNumber,fieldUserNumber,variableType,DOFOrderType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the DOF Order type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: DOFOrderType !<The field variable DOF Order type to set. \see OPENCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_DOFOrderTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DOF_ORDER_TYPE_SET(FIELD,variableType,DOFOrderType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_DOFOrderTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DOFOrderTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DOFOrderTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF Order type for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_DOFOrderTypeSetObj(field,variableType,DOFOrderType,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the DOF order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the DOF order type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: DOFOrderType !<The field variable DOF order type to set. \see OPENCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DOFOrderTypeSetObj",err,error,*999)

    CALL FIELD_DOF_ORDER_TYPE_SET(field%field,variableType,DOFOrderType,err,error,*999)

    EXITS("cmfe_Field_DOFOrderTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DOFOrderTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DOFOrderTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a field identified by a user number.
  SUBROUTINE cmfe_Field_CreateFinishNumber(regionUserNumber,fieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_CREATE_FINISH(FIELD,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Field Create')
#endif

    EXITS("cmfe_Field_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a field identified by an object.
  SUBROUTINE cmfe_Field_CreateFinishObj(field,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<The field to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_CreateFinishObj",err,error,*999)

    CALL FIELD_CREATE_FINISH(field%field,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('field Create')
#endif

    EXITS("cmfe_Field_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field identified by a user number.
  SUBROUTINE cmfe_Field_CreateStartNumber(fieldUserNumber,regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the creation of.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Field Create')
#endif

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_CREATE_START(fieldUserNumber,REGION,FIELD,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field on an interface identified by an object.
  SUBROUTINE cmfe_Field_CreateStartInterfaceObj(fieldUserNumber,interface,field,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the creation of.
    TYPE(cmfe_InterfaceType), INTENT(IN) :: Interface !<The interface to create the field on.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the created field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_CreateStartInterfaceObj",err,error,*999)

    CALL FIELD_CREATE_START(fieldUserNumber,interface%interface,field%field,err,error,*999)

    EXITS("cmfe_Field_CreateStartInterfaceObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_CreateStartInterfaceObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_CreateStartInterfaceObj

  !
  !================================================================================================================================
  !

   !>Starts the creation of a field on a region identified by an object.
  SUBROUTINE cmfe_Field_CreateStartRegionObj(fieldUserNumber,region,field,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the creation of.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to create the field on.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<On return, the created field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_CreateStartRegionObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('field Create')
#endif

    CALL FIELD_CREATE_START(fieldUserNumber,region%region,field%field,err,error,*999)

    EXITS("cmfe_Field_CreateStartRegionObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_CreateStartRegionObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_CreateStartRegionObj

  !
  !================================================================================================================================
  !

  !>Returns the dependent type for a field identified by a user number.
  SUBROUTINE cmfe_Field_DependentTypeGetNumber(regionUserNumber,fieldUserNumber,dependentType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the dependent type for.
    INTEGER(INTG), INTENT(OUT) :: dependentType !<On return, the field dependent type. \see OPENCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_DependentTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DEPENDENT_TYPE_GET(FIELD,dependentType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_DependentTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DependentTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DependentTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the dependent type for a field identified by an object.
  SUBROUTINE cmfe_Field_DependentTypeGetObj(field,dependentType,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the dependent type for.
    INTEGER(INTG), INTENT(OUT) :: dependentType !<On return, the field dependent type. \see OPENCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DependentTypeGetObj",err,error,*999)

    CALL FIELD_DEPENDENT_TYPE_GET(field%field,dependentType,err,error,*999)

    EXITS("cmfe_Field_DependentTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DependentTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DependentTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field identified by a user number.
  SUBROUTINE cmfe_Field_DependentTypeSetNumber(regionUserNumber,fieldUserNumber,dependentType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: dependentType !<The field dependent type to set. \see OPENCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_DependentTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DEPENDENT_TYPE_SET(FIELD,dependentType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_DependentTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DependentTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DependentTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field identified by an object.
  SUBROUTINE cmfe_Field_DependentTypeSetObj(field,dependentType,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the dependent type for.
    INTEGER(INTG), INTENT(IN) :: dependentType !<The field dependent type to set. \see OPENCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DependentTypeSetObj",err,error,*999)

    CALL FIELD_DEPENDENT_TYPE_SET(field%field,dependentType,err,error,*999)

    EXITS("cmfe_Field_DependentTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DependentTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DependentTypeSetObj

  !
  !================================================================================================================================
  !

  !>Destroys a field identified by a user number.
  SUBROUTINE cmfe_Field_DestroyNumber(regionUserNumber,fieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to destroy.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DESTROY(FIELD,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a field identified by an object.
  SUBROUTINE cmfe_Field_DestroyObj(field,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DestroyObj",err,error,*999)

    CALL FIELD_DESTROY(field%field,err,error,*999)

    EXITS("cmfe_Field_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the dimension for a field identified by a user number.
  SUBROUTINE cmfe_Field_DimensionGetNumber(regionUserNumber,fieldUserNumber,variableType,dimension,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: dimension !<On return, the field dimension. \see OPENCMISS_FieldDimensionTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_DimensionGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DIMENSION_GET(FIELD,variableType,dimension,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_DimensionGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DimensionGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DimensionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the dimension for a field identified by an object.
  SUBROUTINE cmfe_Field_DimensionGetObj(field,variableType,dimension,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: Dimension !<On return, the field dimension. \see OPENCMISS_FieldDimension
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DimensionGetObj",err,error,*999)

    CALL FIELD_DIMENSION_GET(field%field,variableType,dimension,err,error,*999)

    EXITS("cmfe_Field_DimensionGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DimensionGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DimensionGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension for a field identified by a user number.
  SUBROUTINE cmfe_Field_DimensionSetNumber(regionUserNumber,fieldUserNumber,variableType,dimension,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: Dimension !<The field dimension to set. \see OPENCMISS_FieldDimensionTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_DimensionSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DIMENSION_SET(FIELD,variableType,dimension,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_DimensionSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DimensionSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DimensionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension for a field identified by an object.
  SUBROUTINE cmfe_Field_DimensionSetObj(field,variableType,dimension,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: dimension !<The field dimension to set. \see OPENCMISS_FieldDimension
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DimensionSetObj",err,error,*999)

    CALL FIELD_DIMENSION_SET(field%field,variableType,DIMENSION,err,error,*999)

    EXITS("cmfe_Field_DimensionSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DimensionSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DimensionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the geometric field for a field identified by a user number.
  SUBROUTINE cmfe_Field_GeometricFieldGetNumber(regionUserNumber,fieldUserNumber,geometricFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the geometric field for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the geometric field for.
    INTEGER(INTG), INTENT(OUT) :: geometricFieldUserNumber !<On return, the field geometric field user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD,GEOMETRIC_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_GeometricFieldGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(GEOMETRIC_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_GEOMETRIC_FIELD_GET(FIELD,GEOMETRIC_FIELD,err,error,*999)
        geometricFieldUserNumber=GEOMETRIC_FIELD%USER_NUMBER
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_GeometricFieldGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_GeometricFieldGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_GeometricFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the geometric field for a field identified by an object.
  SUBROUTINE cmfe_Field_GeometricFieldGetObj(field,geometricField,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the geometric field for.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: geometricField !<On return, the geometric field for the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_GeometricFieldGetObj",err,error,*999)

    CALL FIELD_GEOMETRIC_FIELD_GET(field%field,geometricField%field,err,error,*999)

    EXITS("cmfe_Field_GeometricFieldGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_GeometricFieldGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_GeometricFieldGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field identified by a user number.
  SUBROUTINE cmfe_Field_GeometricFieldSetNumber(regionUserNumber,fieldUserNumber,geometricFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the geometric field for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the geometric field for.
    INTEGER(INTG), INTENT(IN) :: geometricFieldUserNumber !<The field geometric field user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD,GEOMETRIC_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_GeometricFieldSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(GEOMETRIC_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_USER_NUMBER_FIND(geometricFieldUserNumber,REGION,GEOMETRIC_FIELD,err,error,*999)
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          CALL FIELD_GEOMETRIC_FIELD_SET(FIELD,GEOMETRIC_FIELD,err,error,*999)
        ELSE
          localError="A geometric field with an user number of "// &
            & TRIM(NumberToVString(geometricFieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_GeometricFieldSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_GeometricFieldSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_GeometricFieldSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field identified by an object.
  SUBROUTINE cmfe_Field_GeometricFieldSetObj(field,geometricField,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the geometric field for.
    TYPE(cmfe_FieldType), INTENT(IN) :: geometricField !<The geometric field for the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_GeometricFieldSetObj",err,error,*999)

    CALL FIELD_GEOMETRIC_FIELD_SET(field%field,geometricField%field,err,error,*999)

    EXITS("cmfe_Field_GeometricFieldSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_GeometricFieldSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_GeometricFieldSetObj

  !
  !================================================================================================================================
  !

  !>Gets the line length between nodes of a geometric field for a given element number and element basis line number by a user number.
  SUBROUTINE cmfe_Field_GeometricParametersElementLineLengthGetNumber(regionUserNumber,geometricFieldUserNumber,elementNumber, &
    & elementLineNumber,lineLength,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to obtain the line length from
    INTEGER(INTG), INTENT(IN) :: geometricFieldUserNumber !<The geometric field user number to obtain the line length from
    INTEGER(INTG),  INTENT(IN) :: elementNumber !<The element to get the line length for
    INTEGER(INTG), INTENT(IN) :: elementLineNumber !<The element basis line to get the length for
    REAL(DP), INTENT(OUT) :: lineLength !<The line length of the chosen element line number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: geometricField
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_GeometricParametersElementLineLengthGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(geometricField)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(geometricFieldUserNumber,region,geometricField,err,error,*999)
      IF(ASSOCIATED(geometricField)) THEN
        CALL Field_GeometricParametersElementLineLengthGet(geometricField,elementNumber,elementLineNumber,lineLength, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(geometricFieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_GeometricParametersElementLineLengthGetNumber")
    RETURN
999 ERRORS("cmfe_Field_GeometricParametersElementLineLengthGetNumber",err,error)
    EXITS("cmfe_Field_GeometricParametersElementLineLengthGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_GeometricParametersElementLineLengthGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the line length between nodes of a geometric field for a given element number and element basis line number by an object.
  SUBROUTINE cmfe_Field_GeometricParametersElementLineLengthGetObj(geometricField,elementNumber,elementLineNumber,lineLength,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: geometricField !<The geometric field to obtain the line length from
    INTEGER(INTG),  INTENT(IN) :: elementNumber !<The element to get the line length for
    INTEGER(INTG), INTENT(IN) :: elementLineNumber !<The element basis line to get the length for
    REAL(DP), INTENT(OUT) :: lineLength !<The line length of the chosen element line number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_GeometricParametersElementLineLengthGetObj",err,error,*999)

    CALL Field_GeometricParametersElementLineLengthGet(geometricField%field,elementNumber,elementLineNumber,lineLength, &
      & err,error,*999)

    EXITS("cmfe_Field_GeometricParametersElementLineLengthGetObj")
    RETURN
999 ERRORS("cmfe_Field_GeometricParametersElementLineLengthGetObj",err,error)
    EXITS("cmfe_Field_GeometricParametersElementLineLengthGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_GeometricParametersElementLineLengthGetObj

  !
  !================================================================================================================================
  !

  !>Gets the scale factor for a particular node identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorGetNumber(regionUserNumber,fieldUserNumber,variableType, &
    & versionNumber,derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the scalefactor for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to get scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to get the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetNodeScaleFactorGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetNodeScaleFactorGet(field,variableType,versionNumber, &
          & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetNodeScaleFactorGetNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeScaleFactorGetNumber",err,error)
    EXITS("cmfe_Field_ParameterSetNodeScaleFactorGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the scale factor for a particular node identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorGetObj(field,variableType, &
    & versionNumber,derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to get the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetNodeScaleFactorGetObj",err,error,*999)

    CALL Field_ParameterSetNodeScaleFactorGet(field%field,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*999)

    EXITS("cmfe_Field_ParameterSetNodeScaleFactorGetObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeScaleFactorGetObj",err,error)
    EXITS("cmfe_Field_ParameterSetNodeScaleFactorGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorGetObj


  !
  !================================================================================================================================
  !

  !>Gets the scale factors for all nodes identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorsGetNumber(regionUserNumber,fieldUserNumber,variableType, &
    & meshComponentNumber,scaleFactors,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the scalefactor for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to get scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh omponent number of the field to set the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactors(:) !<The scale factors
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetNodeScaleFactorsGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetNodeScaleFactorsGet(field,variableType,meshComponentNumber,scaleFactors,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetNodeScaleFactorsGetNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeScaleFactorsGetNumber",err,error)
    EXITS("cmfe_Field_ParameterSetNodeScaleFactorsGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorsGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the scale factors for all nodes identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorsGetObj(field,variableType,meshComponentNumber,scaleFactors,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh omponent number of the field to set the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactors(:) !<The scale factors
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetNodeScaleFactorsGetObj",err,error,*999)

    CALL Field_ParameterSetNodeScaleFactorsGet(field%field,variableType,meshComponentNumber,scaleFactors,err,error,*999)

    EXITS("cmfe_Field_ParameterSetNodeScaleFactorsGetObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeScaleFactorsGetObj",err,error)
    EXITS("cmfe_Field_ParameterSetNodeScaleFactorsGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorsGetObj
  !
  !================================================================================================================================
  !

  !>Gets the number of scale factor dofs, identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber(regionUserNumber,fieldUserNumber,variableType, &
    & meshComponentNumber,numberOfScaleFactorsDofs,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the number of scalefactors for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(OUT) :: numberOfScaleFactorsDofs !<The number of scale factor dofs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetNodeNumberOfScaleFactorDofsGet(field,variableType,meshComponentNumber,numberOfScaleFactorsDofs, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber",err,error)
    EXITS("cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the number of scale factor dofs, identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj(field,variableType,meshComponentNumber, &
    & numberOfScaleFactorsDofs,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(OUT) :: numberOfScaleFactorsDofs !<The number of scale factor dofs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj",err,error,*999)

    CALL Field_ParameterSetNodeNumberOfScaleFactorDofsGet(field%field,variableType,meshComponentNumber,numberOfScaleFactorsDofs, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj",err,error)
    EXITS("cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeNumberOfScaleFactorDofsGetObj

  !
  !================================================================================================================================
  !

  !>Sets the scale factor for a particular node identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorSetNumber(regionUserNumber,fieldUserNumber,variableType, &
    & versionNumber,derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the scalefactor for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to set scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetNodeScaleFactorSetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetNodeScaleFactorSet(field,variableType,versionNumber, &
          & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetNodeScaleFactorSetNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeScaleFactorSetNumber",err,error)
    EXITS("cmfe_Field_ParameterSetNodeScaleFactorSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the scale factor for a particular node identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorSetObj(field,variableType, &
    & versionNumber,derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetNodeScaleFactorSetObj",err,error,*999)

    CALL Field_ParameterSetNodeScaleFactorSet(field%field,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*999)

    EXITS("cmfe_Field_ParameterSetNodeScaleFactorSetObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeScaleFactorSetObj",err,error)
    EXITS("cmfe_Field_ParameterSetNodeScaleFactorSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorSetObj

  !
  !================================================================================================================================
  !

  !>Sets the scale factors for all nodes identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorsSetNumber(regionUserNumber,fieldUserNumber,variableType, &
    & meshComponentNumber,scaleFactors,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the scalefactor for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to set scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh omponent number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactors(:) !<The scale factors
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetNodeScaleFactorsSetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetNodeScaleFactorsSet(field,variableType,meshComponentNumber,scaleFactors,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetNodeScaleFactorsSetNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeScaleFactorsSetNumber",err,error)
    EXITS("cmfe_Field_ParameterSetNodeScaleFactorsSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the scale factors for all nodes identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorsSetObj(field,variableType,meshComponentNumber,scaleFactors,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactors(:) !<The scale factors
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetNodeScaleFactorsSetObj",err,error,*999)

    CALL Field_ParameterSetNodeScaleFactorsSet(field%field,variableType,meshComponentNumber,scaleFactors,err,error,*999)

    EXITS("cmfe_Field_ParameterSetNodeScaleFactorsSetObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetNodeScaleFactorsSetObj",err,error)
    EXITS("cmfe_Field_ParameterSetNodeScaleFactorsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetNodeScaleFactorsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field identified by a user number.
  SUBROUTINE cmfe_Field_LabelGetCNumber(regionUserNumber,fieldUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_LabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_LABEL_GET(FIELD,label,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_LabelGetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field identified by an object.
  SUBROUTINE cmfe_Field_LabelGetCObj(field,label,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_LabelGetCObj",err,error,*999)

    CALL FIELD_LABEL_GET(field%field,label,err,error,*999)

    EXITS("cmfe_Field_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field identified by a user number.
  SUBROUTINE cmfe_Field_LabelGetVSNumber(regionUserNumber,fieldUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_LabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_LABEL_GET(FIELD,label,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_LabelGetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field identified by an object.
  SUBROUTINE cmfe_Field_LabelGetVSObj(field,label,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_LabelGetVSObj",err,error,*999)

    CALL FIELD_LABEL_GET(field%field,label,err,error,*999)

    EXITS("cmfe_Field_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field identified by a user number.
  SUBROUTINE cmfe_Field_LabelSetCNumber(regionUserNumber,fieldUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_LabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_LABEL_SET(FIELD,label,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_LabelSetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field identified by an object.
  SUBROUTINE cmfe_Field_LabelSetCObj(field,label,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_LabelSetCObj",err,error,*999)

    CALL FIELD_LABEL_SET(field%field,label,err,error,*999)

    EXITS("cmfe_Field_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field identified by a user number.
  SUBROUTINE cmfe_Field_LabelSetVSNumber(regionUserNumber,fieldUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_LabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_LABEL_SET(FIELD,label,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_LabelSetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field identified by an object.
  SUBROUTINE cmfe_Field_LabelSetVSObj(field,label,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_LabelSetVSObj",err,error,*999)

    CALL FIELD_LABEL_SET(field%field,label,err,error,*999)

    EXITS("cmfe_Field_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the interpolation type for a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_PositionNormalTangentCalculateNodeNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & localNodeNumber,position,normal,tangents,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number of the field variable to get the data type for.
    REAL(DP), INTENT(OUT) :: position(:),normal(:),tangents(:,:) !<Actual useful outputs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_PositionNormalTangentCalculateNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL Field_PositionNormalTangentsCalculateNode(FIELD,variableType,componentNumber,localNodeNumber, &
          & position,normal,tangents,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_PositionNormalTangentCalculateNodeNumber")
    RETURN
999 ERRORS("cmfe_Field_PositionNormalTangentCalculateNodeNumber",err,error)
    EXITS("cmfe_Field_PositionNormalTangentCalculateNodeNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_PositionNormalTangentCalculateNodeNumber

  !
  !================================================================================================================================
  !

  !>Returns the position, normal and tangents for a field node for a field identified by an object.
  SUBROUTINE cmfe_Field_PositionNormalTangentCalculateNodeObj(field,variableType,componentNumber,localNodeNumber, &
    & position,normal,tangents,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data type for.
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number of the field variable to get the data type for.
    REAL(DP), INTENT(OUT) :: position(:),normal(:),tangents(:,:) !<Actual useful outputs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_PositionNormalTangentCalculateNodeObj",err,error,*999)

    CALL Field_PositionNormalTangentsCalculateNode(field%field,variableType,componentNumber,localNodeNumber, &
    & position,normal,tangents,err,error,*999)

    EXITS("cmfe_Field_PositionNormalTangentCalculateNodeObj")
    RETURN
999 ERRORS("cmfe_Field_PositionNormalTangentCalculateNodeObj",err,error)
    EXITS("cmfe_Field_PositionNormalTangentCalculateNodeObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_PositionNormalTangentCalculateNodeObj



  !
  !================================================================================================================================
  !

  !>Returns the mesh decomposition for a field identified by a user number.
  SUBROUTINE cmfe_Field_MeshDecompositionGetNumber(regionUserNumber,fieldUserNumber,decompositionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the mesh decomposition for.
    INTEGER(INTG), INTENT(OUT) :: decompositionUserNumber !<On return, the field decomposition user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_MeshDecompositionGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_MESH_DECOMPOSITION_GET(FIELD,DECOMPOSITION,err,error,*999)
        decompositionUserNumber=DECOMPOSITION%USER_NUMBER
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_MeshDecompositionGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_MeshDecompositionGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_MeshDecompositionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the mesh decomposition for a field identified by an object.
  SUBROUTINE cmfe_Field_MeshDecompositionGetObj(field,meshDecomposition,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the mesh decomposition for.
    TYPE(cmfe_DecompositionType), INTENT(INOUT) :: meshDecomposition !<On return, the mesh decomposition for the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_MeshDecompositionGetObj",err,error,*999)

    CALL FIELD_MESH_DECOMPOSITION_GET(field%field,meshDecomposition%decomposition,err,error,*999)

    EXITS("cmfe_Field_MeshDecompositionGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_MeshDecompositionGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_MeshDecompositionGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh decomposition for a field identified by a user number.
  SUBROUTINE cmfe_Field_MeshDecompositionSetNumber(regionUserNumber,fieldUserNumber,meshUserNumber,decompositionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The field mesh decomposition user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_MeshDecompositionSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(DECOMPOSITION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
        IF(ASSOCIATED(MESH)) THEN
          CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
          IF(ASSOCIATED(DECOMPOSITION)) THEN
            CALL FIELD_MESH_DECOMPOSITION_SET(FIELD,DECOMPOSITION,err,error,*999)
          ELSE
            localError="A decomposition with a user number of "//TRIM(NumberToVString(decompositionUserNumber,"*",err,error))// &
              & " does not exist on mesh number "//TRIM(NumberToVString(meshUserNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          END IF
        ELSE
          localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_MeshDecompositionSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_MeshDecompositionSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_MeshDecompositionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh decomposition for a field identified by an object.
  SUBROUTINE cmfe_Field_MeshDecompositionSetObj(field,meshDecomposition,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the mesh decomposition for.
    TYPE(cmfe_DecompositionType), INTENT(IN) :: meshDecomposition !<The mesh decomposition for the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_MeshDecompositionSetObj",err,error,*999)

    CALL FIELD_MESH_DECOMPOSITION_SET(field%field,meshDecomposition%decomposition,err,error,*999)

    EXITS("cmfe_Field_MeshDecompositionSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_MeshDecompositionSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_MeshDecompositionSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the data projection for a field identified by a user number.
  SUBROUTINE cmfe_Field_DataProjectionSetNumber(regionUserNumber,fieldUserNumber,dataProjectionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The field data projection user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    INTEGER(INTG) :: DATA_PROJECTION_NUMBER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_DataProjectionSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
        IF(ASSOCIATED(DATA_POINTS)) THEN
          CALL DataPoints_DataProjectionGlobalNumberGet(DATA_POINTS,dataProjectionUserNumber,DATA_PROJECTION_NUMBER,&
           & err,error,*999)
          CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION_NUMBER,DATA_PROJECTION,err,error,*999)
          IF(ASSOCIATED(DATA_PROJECTION)) THEN
            CALL Field_DataProjectionSet(FIELD,DATA_PROJECTION,err,error,*999)
          ELSE
            localError="A data projection does not exist for the data points on region number "// &
             & TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          END IF
        ELSE
          localError="Data points do not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_DataProjectionSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_DataProjectionSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DataProjectionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the data projection for a field identified by an object.
  SUBROUTINE cmfe_Field_DataProjectionSetObj(field,dataProjection,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the mesh decomposition for.
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection for the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_DataProjectionSetObj",err,error,*999)

    CALL Field_DataProjectionSet(field%field,dataProjection%dataProjection,err,error,*999)

    EXITS("cmfe_Field_DataProjectionSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_DataProjectionSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_DataProjectionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of componenets for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_NumberOfComponentsGetNumber(regionUserNumber,fieldUserNumber,variableType,numberOfComponents,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to get the number of components for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the field variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_NumberOfComponentsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_NUMBER_OF_COMPONENTS_GET(FIELD,variableType,numberOfComponents,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_NumberOfComponentsGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_NumberOfComponentsGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_NumberOfComponentsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of components for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_NumberOfComponentsGetObj(field,variableType,numberOfComponents,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to get the number of components for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the field variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_NumberOfComponentsGetObj",err,error,*999)

    CALL FIELD_NUMBER_OF_COMPONENTS_GET(field%field,variableType,numberOfComponents,err,error,*999)

    EXITS("cmfe_Field_NumberOfComponentsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_NumberOfComponentsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_NumberOfComponentsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of componenets for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_NumberOfComponentsSetNumber(regionUserNumber,fieldUserNumber,variableType,numberOfComponents,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the number of components for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the field variable to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_NumberOfComponentsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_NUMBER_OF_COMPONENTS_SET(FIELD,variableType,numberOfComponents,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_NumberOfComponentsSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_NumberOfComponentsSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_NumberOfComponentsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of components for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_NumberOfComponentsSetObj(field,variableType,numberOfComponents,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the number of components for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the field variable to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_NumberOfComponentsSetObj",err,error,*999)

    CALL FIELD_NUMBER_OF_COMPONENTS_SET(field%field,variableType,numberOfComponents,err,error,*999)

    EXITS("cmfe_Field_NumberOfComponentsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_NumberOfComponentsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_NumberOfComponentsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of variables for a field identified by a user number.
  SUBROUTINE cmfe_Field_NumberOfVariablesGetNumber(regionUserNumber,fieldUserNumber,numberOfVariables,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the number of variables for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the number of variables for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVariables !<On return, the number of variables in the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_NumberOfVariablesGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_NUMBER_OF_VARIABLES_GET(FIELD,numberOfVariables,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_NumberOfVariablesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_NumberOfVariablesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_NumberOfVariablesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of variables for a field identified by an object.
  SUBROUTINE cmfe_Field_NumberOfVariablesGetObj(field,numberOfVariables,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the number of variables for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVariables !<On return, the number of variables in the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_NumberOfVariablesGetObj",err,error,*999)

    CALL FIELD_NUMBER_OF_VARIABLES_GET(field%field,numberOfVariables,err,error,*999)

    EXITS("cmfe_Field_NumberOfVariablesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_NumberOfVariablesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_NumberOfVariablesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/chnages the number of variables for a field identified by a user number.
  SUBROUTINE cmfe_Field_NumberOfVariablesSetNumber(regionUserNumber,fieldUserNumber,numberOfVariables,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: numberOfVariables !<The number of variables in the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_NumberOfVariablesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_NUMBER_OF_VARIABLES_SET(FIELD,numberOfVariables,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_NumberOfVariablesSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_NumberOfVariablesSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_NumberOfVariablesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of variables for a field identified by an object.
  SUBROUTINE cmfe_Field_NumberOfVariablesSetObj(field,numberOfVariables,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: numberOfVariables !<The number of variables in the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_NumberOfVariablesSetObj",err,error,*999)

    CALL FIELD_NUMBER_OF_VARIABLES_SET(field%field,numberOfVariables,err,error,*999)

    EXITS("cmfe_Field_NumberOfVariablesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_NumberOfVariablesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_NumberOfVariablesSetObj

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddConstantIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetAddConstantIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetAddConstantIntgNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetAddConstantIntgNumber",err,error)
    EXITS("cmfe_Field_ParameterSetAddConstantIntgNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddConstantIntgNumber

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddConstantIntgObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the field parameter set.
     INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddConstantIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_CONSTANT(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddConstantIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddConstantIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddConstantIntgObj

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddConstantSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(SP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetAddConstantSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetAddConstantSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddConstantSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddConstantSPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddConstantSPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(SP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddConstantSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_CONSTANT(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddConstantSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddConstantSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddConstantSPObj

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddConstantDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(DP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetAddConstantDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetAddConstantDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddConstantDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddConstantDPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddConstantDPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(DP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddConstantDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_CONSTANT(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddConstantDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddConstantDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddConstantDPObj

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddConstantLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    LOGICAL, INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetAddConstantLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetAddConstantLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddConstantLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddConstantLNumber

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddConstantLObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    LOGICAL, INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddConstantLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_CONSTANT(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_FieldParameterSetAddConstantLbj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddConstantLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddConstantLObj

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddElementIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetAddElementIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetAddElementIntgNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddElementIntgNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddElementIntgNumber

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddElementIntgObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddElementIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_ELEMENT(field%field,variableType,fieldSetType,UserElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddElementIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddElementIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddElementIntgObj

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddElementSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetAddElementSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetAddElementSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddElementSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddElementSPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddElementSPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddElementSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_ELEMENT(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddElementSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddElementSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddElementSPObj

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddElementDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetAddElementDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetAddElementDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddElementDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddElementDPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddElementDPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddElementDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_ELEMENT(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddElementDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddElementDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddElementDPObj

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddElementLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetAddElementLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetAddElementLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddElementLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddElementLNumber

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddElementLObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddElementLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_ELEMENT(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddElementLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddElementLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddElementLObj

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddNodeIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,versionNumber, &
    & derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetAddNodeIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetAddNodeIntgNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddNodeIntgNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddNodeIntgNumber

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddNodeIntgObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddNodeIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_NODE(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddNodeIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddNodeIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddNodeIntgObj

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddNodeSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,versionNumber, &
    & derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetAddNodeSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetAddNodeSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddNodeSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddNodeSPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddNodeSPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddNodeSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_NODE(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddNodeSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddNodeSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddNodeSPObj

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddNodeDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,versionNumber, &
    & derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetAddNodeDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetAddNodeDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddNodeDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddNodeDPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddNodeDPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddNodeDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_NODE(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddNodeDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddNodeDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddNodeDPObj

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetAddNodeLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,versionNumber, &
    & derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetAddNodeLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetAddNodeLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddNodeLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddNodeLNumber

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetAddNodeLObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber, value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetAddNodeLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_NODE(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber, value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetAddNodeLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetAddNodeLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetAddNodeLObj

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type set type for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetCreateNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to create the parameter set on.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to create the parameter set on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to create the parameter set on. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to create. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetCreateNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_CREATE(FIELD,variableType,fieldSetType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetCreateNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetCreateNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetCreateNumber

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type set type for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetCreateObj(field,variableType,fieldSetType,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to create the field parameter set on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to create the parameter set on. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to create. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetCreateObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_CREATE(field%field,variableType,fieldSetType,err,error,*999)

    EXITS("cmfe_Field_ParameterSetCreateObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetCreateObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetCreateObj

  !
  !================================================================================================================================
  !

  !>Destroys the specified parameter set type for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetDestroyNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to destroy the parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to destroy the parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to destroy the parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to destroy. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DESTROY(FIELD,variableType,fieldSetType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the specified parameter set type for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetDestroyObj(field,variableType,fieldSetType,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to destroy the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to destroy the parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to destroy. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDestroyObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DESTROY(field%field,variableType,fieldSetType,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local integer data array for a field identified by an user number. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE cmfe_Field_ParameterSetDataGetIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetDataGetIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_GET(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetDataGetIntgNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataGetIntgNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataGetIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local integer data array for a field identified by an object. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE cmfe_Field_ParameterSetDataGetIntgObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDataGetIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_GET(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataGetIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataGetIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataGetIntgObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local single precision data array for a field identified by an user number. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE cmfe_Field_ParameterSetDataGetSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetDataGetSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_GET(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetDataGetSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataGetSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataGetSPNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local single precision data array for a field identified by an object. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE cmfe_Field_ParameterSetDataGetSPObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDataGetSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_GET(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataGetSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataGetSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataGetSPObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local double precision data array for a field identified by an user number. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE cmfe_Field_ParameterSetDataGetDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetDataGetDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_GET(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetDataGetDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataGetDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataGetDPNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local double precision data array for a field identified by an object. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE cmfe_Field_ParameterSetDataGetDPObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDataGetDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_GET(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataGetDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataGetDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataGetDPObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local logical data array for a field identified by an user number. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE cmfe_Field_ParameterSetDataGetLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetDataGetLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_GET(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetDataGetLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataGetLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataGetLNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local logical data array for a field identified by an object. The pointer must be restored with a call to OpenCMISS::Iron::cmfe_Field_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE cmfe_Field_ParameterSetDataGetLObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDataGetLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_GET(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataGetLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataGetLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataGetLObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local integer array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE cmfe_Field_ParameterSetDataRestoreIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetDataRestoreIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetDataRestoreIntgNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetDataRestoreIntgNumber",err,error)
    EXITS("cmfe_Field_ParameterSetDataRestoreIntgNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataRestoreIntgNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local integer array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE cmfe_Field_ParameterSetDataRestoreIntgObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDataRestoreIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_RESTORE(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataRestoreIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataRestoreIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataRestoreIntgObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local single precision array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE cmfe_Field_ParameterSetDataRestoreSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetDataRestoreSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetDataRestoreSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataRestoreSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataRestoreSPNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local single precision array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE cmfe_Field_ParameterSetDataRestoreSPObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDataRestoreSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_RESTORE(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataRestoreSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataRestoreSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataRestoreSPObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local double precision array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE cmfe_Field_ParameterSetDataRestoreDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetDataRestoreDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetDataRestoreDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataRestoreDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataRestoreDPNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local double precision array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE cmfe_Field_ParameterSetDataRestoreDPObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDataRestoreDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_RESTORE(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataRestoreDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataRestoreDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataRestoreDPObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local logical array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE cmfe_Field_ParameterSetDataRestoreLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetDataRestoreLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetDataRestoreLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataRestoreLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataRestoreLNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local logical array that was obtained with an OpenCMISS::Iron::cmfe_Field_ParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE cmfe_Field_ParameterSetDataRestoreLObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetDataRestoreLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_RESTORE(field%field,variableType,fieldSetType,parameters,err,error,*999)

    EXITS("cmfe_Field_ParameterSetDataRestoreLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetDataRestoreLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetDataRestoreLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetConstantIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetConstantIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,Value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetConstantIntgNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetGetConstantIntgNumber",err,error)
    EXITS("cmfe_Field_ParameterSetGetConstantIntgNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetConstantIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetConstantIntgObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetConstantIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_CONSTANT(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetConstantIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetConstantIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetConstantIntgObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetConstantSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetConstantSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetConstantSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetConstantSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetConstantSPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetConstantSPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetConstantSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_CONSTANT(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetConstantSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetConstantSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetConstantSPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetConstantDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetConstantDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetConstantDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetConstantDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetConstantDPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetConstantDPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetConstantDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_CONSTANT(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetConstantDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetConstantDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetConstantDPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetConstantLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetConstantLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetConstantLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetConstantLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetConstantLNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetConstantLObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetConstantLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_CONSTANT(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetConstantLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetConstantLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetConstantLObj
  
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a integer value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointIntgNumberI(parentRegionUserNumber,interfaceUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetDataPointIntgNumberI",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,error,*999)
        IF(ASSOCIATED(field)) THEN
          CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
            & err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetDataPointIntgNumberI")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetGetDataPointIntgNumberI",err,error)
    EXITS("cmfe_Field_ParameterSetGetDataPointIntgNumberI")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointIntgNumberI
  
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a integer value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointIntgNumberR(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetDataPointIntgNumberR",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetDataPointIntgNumberR")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetGetDataPointIntgNumberR",err,error)
    EXITS("cmfe_Field_ParameterSetGetDataPointIntgNumberR")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointIntgNumberR

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a integer value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointIntgObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetDataPointIntgObj",err,error,*999)

    CALL Field_ParameterSetGetDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetDataPointIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetDataPointIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointIntgObj
  
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointSPNumberI(parentRegionUserNumber,interfaceUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetDataPointSPNumberI",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,error,*999)
        IF(ASSOCIATED(field)) THEN
          CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
            & err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetDataPointSPNumberI")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetGetDataPointSPNumberI",err,error)
    EXITS("cmfe_Field_ParameterSetGetDataPointSPNumberI")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointSPNumberI
  
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointSPNumberR(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetDataPointSPNumberR",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetDataPointSPNumberR")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetGetDataPointSPNumberR",err,error)
    EXITS("cmfe_Field_ParameterSetGetDataPointSPNumberR")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointSPNumberR

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointSPObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetDataPointSPObj",err,error,*999)

    CALL Field_ParameterSetGetDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetDataPointSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetDataPointSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointSPObj
  
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointDPNumberI(parentRegionUserNumber,interfaceUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetDataPointDPNumberI",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,error,*999)
        IF(ASSOCIATED(field)) THEN
          CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
            & err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetDataPointDPNumberI")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetGetDataPointDPNumberI",err,error)
    EXITS("cmfe_Field_ParameterSetGetDataPointDPNumberI")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointDPNumberI
  
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointDPNumberR(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetDataPointDPNumberR",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetDataPointDPNumberR")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetGetDataPointDPNumberR",err,error)
    EXITS("cmfe_Field_ParameterSetGetDataPointDPNumberR")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointDPNumberR

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointDPObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetDataPointDPObj",err,error,*999)

    CALL Field_ParameterSetGetDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetDataPointDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetDataPointDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointDPObj
  
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointLNumberI(parentRegionUserNumber,interfaceUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetDataPointLNumberI",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,error,*999)
        IF(ASSOCIATED(field)) THEN
          CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
            & err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetDataPointLNumberI")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetDataPointLNumberI",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointLNumberI
  
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointLNumberR(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetDataPointLNumberR",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetDataPointLNumberR")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetDataPointLNumberR",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointLNumberR

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetDataPointLObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetDataPointLObj",err,error,*999)

    CALL Field_ParameterSetGetDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetDataPointLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetDataPointLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetDataPointLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetElementIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetElementIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetElementIntgNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetElementIntgNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetElementIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetElementIntgObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetElementIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_ELEMENT(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetElementIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetElementIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetElementIntgObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetElementSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetElementSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetElementSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetElementSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetElementSPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetElementSPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetElementSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_ELEMENT(field%field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetElementSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetElementSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetElementSPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetElementDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetElementDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetElementDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetElementDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetElementDPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetElementDPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetElementDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_ELEMENT(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetElementDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetElementDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetElementDPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetElementLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetElementLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetElementLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetElementLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetElementLNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetElementLObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetElementLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_ELEMENT(field%field,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetElementLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetElementLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetElementLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetNodeIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetNodeIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetNodeIntgNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetNodeIntgNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetNodeIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetNodeIntgObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetNodeIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_NODE(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetNodeIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetNodeIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetNodeIntgObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetNodeSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetNodeSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetNodeSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetNodeSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetNodeSPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetNodeSPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetNodeSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_NODE(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetNodeSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetNodeSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetNodeSPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetNodeDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetNodeDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetNodeDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetNodeDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetNodeDPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetNodeDPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetNodeDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_NODE(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber, value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetNodeDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetNodeDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetNodeDPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetGetNodeLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetGetNodeLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber, value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetGetNodeLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetNodeLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetNodeLNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetNodeLObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetNodeLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_NODE(field%field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetNodeLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetNodeLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetNodeLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetGetGaussPointDPObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,VALUE,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetGaussPointDPObj",err,error,*999)

    CALL Field_ParameterSetGetGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetGetGaussPointDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetGetGaussPointDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetGaussPointDPObj
  !
  !================================================================================================================================
  !


  !>Updates the given parameter set with the given integer value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateConstantIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateConstantIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateConstantIntgNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateConstantIntgNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateConstantIntgNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateConstantIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateConstantIntgObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateConstantIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateConstantIntgObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateConstantIntgObj",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateConstantIntgObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateConstantIntgObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateConstantSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateConstantSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateConstantSPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateConstantSPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateConstantSPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateConstantSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateConstantSPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateConstantSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(field%field,variableType,fieldSetType,componentNumber,Value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateConstantSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateConstantSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateConstantSPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateConstantDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateConstantDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateConstantDPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateConstantDPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateConstantDPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateConstantDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateConstantDPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateConstantDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateConstantDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateConstantDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateConstantDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateConstantLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateConstantLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateConstantLNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateConstantLNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateConstantLNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateConstantLNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateConstantLObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateConstantLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(field%field,variableType,fieldSetType,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateConstantLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateConstantLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateConstantLObj
  
  !
  !================================================================================================================================
  !

  !>Update the given parameter set a integer value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointIntgNumberI(parentRegionUserNumber,interfaceUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointIntgNumberI",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,error,*999)
        IF(ASSOCIATED(field)) THEN
          CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
            & err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateDataPointIntgNumberI")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointIntgNumberI",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointIntgNumberI")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointIntgNumberI
  
  !
  !================================================================================================================================
  !

  !>Update the given parameter set a integer value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointIntgNumberR(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointIntgNumberR",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateDataPointIntgNumberR")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointIntgNumberR",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointIntgNumberR")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointIntgNumberR

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a integer value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointIntgObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointIntgObj",err,error,*999)

    CALL Field_ParameterSetUpdateDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateDataPointIntgObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointIntgObj",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointIntgObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointIntgObj
  
  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointSPNumberI(parentRegionUserNumber,interfaceUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointSPNumberI",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,error,*999)
        IF(ASSOCIATED(field)) THEN
          CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
            & err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateDataPointSPNumberI")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointSPNumberI",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointSPNumberI")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointSPNumberI
  
  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointSPNumberR(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointSPNumberR",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateDataPointSPNumberR")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointSPNumberR",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointSPNumberR")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointSPNumberR

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointSPObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointSPObj",err,error,*999)

    CALL Field_ParameterSetUpdateDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateDataPointSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateDataPointSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointSPObj
  
  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointDPNumberI(parentRegionUserNumber,interfaceUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointDPNumberI",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,error,*999)
        IF(ASSOCIATED(field)) THEN
          CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
            & err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateDataPointDPNumberI")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointDPNumberI",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointDPNumberI")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointDPNumberI
  
  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointDPNumberR(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointDPNumberR",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateDataPointDPNumberR")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointDPNumberR",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointDPNumberR")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointDPNumberR

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointDPObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointDPObj",err,error,*999)

    CALL Field_ParameterSetUpdateDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateDataPointDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateDataPointDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointDPObj
  
  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointLNumberI(parentRegionUserNumber,interfaceUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointLNumberI",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,error,*999)
        IF(ASSOCIATED(field)) THEN
          CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
            & err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateDataPointLNumberI")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointLNumberI",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointLNumberI")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointLNumberI
  
  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointLNumberR(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointLNumberR",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateDataPointLNumberR")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateDataPointLNumberR",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateDataPointLNumberR")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointLNumberR

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointLObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateDataPointLObj",err,error,*999)

    CALL Field_ParameterSetUpdateDataPoint(field%field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateDataPointLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateDataPointLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateDataPointLObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateElementIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateElementIntgNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateElementIntgNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateElementIntgNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the element of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementIntgObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateElementIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateElementIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateElementIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementIntgObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateElementSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateElementSPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateElementSPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateElementSPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the element of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementSPObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateElementSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateElementSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateElementSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementSPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    REAL(DP), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateElementDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,Value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateElementDPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateElementDPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateElementDPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementDPObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: VALUE !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateElementDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateElementDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateElementDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateElementLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateElementLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateElementLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementLNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the element of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementLObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateElementLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(field%field,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateElementLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateElementLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementLObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element data point of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateElementDataPointDPObj(field,variableType,fieldSetType,elementNumber,dataPointIndex, &
       & componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The user element number to update the data point for.
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The index of the data point for the data points projected on this element.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateElementDataPointDPObj",err,error,*999)

    CALL Field_ParameterSetUpdateElementDataPoint(field%field,variableType,fieldSetType,elementNumber,&
    & dataPointIndex,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateElementDataPointDPObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateElementDataPointDPObj",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateElementDataPointDPObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateElementDataPointDPObj

  !
  !================================================================================================================================
  !

  !>Finishes the parameter set update for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateFinishNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to finish the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to finish the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to finish the parameter set update for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to finish the update for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_FINISH(FIELD,variableType,fieldSetType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the parameter set update for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateFinishObj(field,variableType,fieldSetType,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to finishe the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to finish the parameter set update for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to finish the update for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateFinishObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_FINISH(field%field,variableType,fieldSetType,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateFinishObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateNodeIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateNodeIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateNodeIntgNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateNodeIntgNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateNodeIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE cmfe_Field_ParameterSetUpdateNodeIntgObj(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateNodeIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_NODE(field%field,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber, value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateNodeIntgObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateNodeIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateNodeIntgObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateNodeSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateNodeSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber, value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateNodeSPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateNodeSPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateNodeSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE cmfe_Field_ParameterSetUpdateNodeSPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber, componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateNodeSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_NODE(field%field,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber, value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateNodeSPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateNodeSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateNodeSPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateNodeDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateNodeDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber, &
          & userNodeNumber,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateNodeDPNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateNodeDPNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateNodeDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE cmfe_Field_ParameterSetUpdateNodeDPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateNodeDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_NODE(field%field,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateNodeDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateNodeDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateNodeDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateNodeLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateNodeLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber, &
          & userNodeNumber,componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateNodeLNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateNodeLNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateNodeLNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE cmfe_Field_ParameterSetUpdateNodeLObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateNodeLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_NODE(field%field,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber, value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateNodeLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateNodeLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateNodeLObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given values for all local dofs of the field variable identified by an object..
  SUBROUTINE cmfe_Field_ParameterSetUpdateLocalDofsDPObj(field,variableType,fieldSetType,values,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the values for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update values for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update values for. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(IN) :: values(:) !<The values to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateLocalDofsDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS(field%field,variableType,fieldSetType,values,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateLocalDofsDPObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateLocalDofsDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateLocalDofsDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the element Gauss point of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & gaussPointNumber,userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateGaussPointIntgNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetUpdateGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVstring(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Field_ParameterSetUpdateGaussPointIntgNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateGaussPointIntgNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateGaussPointIntgNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the element Gauss point of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointIntgObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber, value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateGaussPointIntgObj",err,error,*999)

    CALL Field_ParameterSetUpdateGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateGaussPointIntgObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateGaussPointIntgObj",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateGaussPointIntgObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointIntgObj

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given single precision value for the element Gauss point of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & gaussPointNumber,userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateGaussPointSPNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetUpdateGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Field_ParameterSetUpdateGaussPointSPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateGaussPointSPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateGaussPointSPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the element Gauss point of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointSPObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateGaussPointSPObj",err,error,*999)

    CALL Field_ParameterSetUpdateGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateGaussPointSPObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateGaussPointSPObj",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateGaussPointSPObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointSPObj

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given double precision value for the element Gauss point of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & gaussPointNumber,userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateGaussPointDPNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL Field_ParameterSetUpdateGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Field_ParameterSetUpdateGaussPointDPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateGaussPointDPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateGaussPointDPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element Gauss point of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointDPObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber, value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateGaussPointDPObj",err,error,*999)

    CALL Field_ParameterSetUpdateGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateGaussPointDPObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateGaussPointDPObj",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateGaussPointDPObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointDPObj

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given logical value for the element Gauss point of the field variable component for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & gaussPointNumber,userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateGaussPointLNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetUpdateGaussPoint(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Field_ParameterSetUpdateGaussPointLNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetUpdateGaussPointLNumber",err,error)
    EXITS("cmfe_Field_ParameterSetUpdateGaussPointLNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointLNumber

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given logical value for the element Gauss point of the field variable component for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointLObj(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateGaussPointLObj",err,error,*999)

    CALL Field_ParameterSetUpdateGaussPoint(field%field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
      & componentNumber,value,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateGaussPointLObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateGaussPointLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateGaussPointLObj

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative and returns double precision values for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetInterpolateSingleXiDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & derivativeNumber,userElementNumber,xi,values,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:) !<The element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<The interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetInterpolateSingleXiDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_XI(FIELD,variableType,fieldSetType,derivativeNumber,userElementNumber, &
          & xi,values,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetInterpolateSingleXiDPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetInterpolateSingleXiDPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetInterpolateSingleXiDPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetInterpolateSingleXiDPNumber

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative and returns double precision values for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetInterpolateSingleXiDPObj(field,variableType,fieldSetType,derivativeNumber,userElementNumber, &
    & xi,values,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:) !<The element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<The interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetInterpolateSingleXiDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_XI(field%field,variableType,fieldSetType,derivativeNumber,userElementNumber,xi, &
      & values,err,error,*999)

    EXITS("cmfe_Field_ParameterSetInterpolateSingleXiDPObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetInterpolateSingleXiDPObj",err,error)
    EXITS("cmfe_Field_ParameterSetInterpolateSingleXiDPObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetInterpolateSingleXiDPObj

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of xi locations for the specified element and derviative and returns double precision values for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetInterpolateMultipleXiDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & derivativeNumber,userElementNumber,xi,values,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:,:) !<The sets of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<The interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetInterpolateMultipleXiDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_XI(FIELD,variableType,fieldSetType,derivativeNumber,userElementNumber, &
          & xi,values,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetInterpolateMultipleXiDPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetInterpolateMultipleXiDPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetInterpolateMultipleXiDPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetInterpolateMultipleXiDPNumber

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of xi locations for the specified element and derviative and returns double precision values for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetInterpolateMultipleXiDPObj(field,variableType,fieldSetType,derivativeNumber,userElementNumber, &
    & xi,values,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:,:) !<The sets of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<The interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetInterpolateMultipleXiDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_XI(field%field,variableType,fieldSetType,derivativeNumber,userElementNumber,xi, &
      & values,err,error,*999)

    EXITS("cmfe_Field_ParameterSetInterpolateMultipleXiDPObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetInterpolateMultipleXiDPObj",err,error)
    EXITS("cmfe_Field_ParameterSetInterpolateMultipleXiDPObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetInterpolateMultipleXiDPObj

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified Gauss point for the specified element and derviative and returns double precision values for a or a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetInterpolateSingleGaussDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & derivativeNumber,userElementNumber,quadratureScheme,GaussPoint,values,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for.
    INTEGER(INTG), INTENT(IN) :: GaussPoint !<The Gauss point to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<The interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetInterpolateSingleGaussDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_GAUSS(FIELD,variableType,fieldSetType,derivativeNumber,userElementNumber, &
          & quadratureScheme,GaussPoint,values,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetInterpolateSingleGaussDPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetInterpolateSingleGaussDPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetInterpolateSingleGaussDPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetInterpolateSingleGaussDPNumber

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified Gauss point for the specified element and derviative and returns double precision values for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetInterpolateSingleGaussDPObj(field,variableType,fieldSetType,derivativeNumber, &
    & userElementNumber,quadratureScheme, GaussPoint,values,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for.
    INTEGER(INTG), INTENT(IN) :: GaussPoint !<The Gauss point to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<The interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetInterpolateSingleGaussDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_GAUSS(field%field,variableType,fieldSetType,derivativeNumber,userElementNumber, &
      & quadratureScheme,GaussPoint,values,err,error,*999)

    EXITS("cmfe_Field_ParameterSetInterpolateSingleGaussDPObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetInterpolateSingleGaussDPObj",err,error)
    EXITS("cmfe_Field_ParameterSetInterpolateSingleGaussDPObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetInterpolateSingleGaussDPObj

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of Gauss points for the specified element and derviative and returns double precision values for a or a field identified by a user number. If no Gauss points are specified then all Gauss points are interpolated.
  SUBROUTINE cmfe_Field_ParameterSetInterpolateMultipleGaussDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & derivativeNumber,userElementNumber,quadratureScheme,GaussPoints,values,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for.
    INTEGER(INTG), INTENT(IN) :: GaussPoints(:) !<The Gauss points to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<The interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetInterpolateMultipleGaussDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_GAUSS(FIELD,variableType,fieldSetType,derivativeNumber,userElementNumber, &
          & quadratureScheme,GaussPoints,values,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetInterpolateMultipleGaussDPNumber")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetInterpolateMultipleGaussDPNumber",err,error)
    EXITS("cmfe_Field_ParameterSetInterpolateMultipleGaussDPNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetInterpolateMultipleGaussDPNumber

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of Gauss points for the specified element and derviative and returns double precision values for a field identified by an object. If no Gauss points are specified then all Gauss points are interpolated.
  SUBROUTINE cmfe_Field_ParameterSetInterpolateMultipleGaussDPObj(field,variableType,fieldSetType,derivativeNumber, &
    & userElementNumber,quadratureScheme, GaussPoints,values,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for.
    INTEGER(INTG), INTENT(IN) :: GaussPoints(:) !<The Gauss points to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<The interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetInterpolateMultipleGaussDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_GAUSS(field%field,variableType,fieldSetType,derivativeNumber,userElementNumber, &
      & quadratureScheme,GaussPoints,values,err,error,*999)

    EXITS("cmfe_Field_ParameterSetInterpolateMultipleGaussDPObj")
    RETURN
999 ERRORS("cmfe_Field_ParameterSetInterpolateMultipleGaussDPObj",err,error)
    EXITS("cmfe_Field_ParameterSetInterpolateMultipleGaussDPObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetInterpolateMultipleGaussDPObj

  !
  !================================================================================================================================
  !

  !>Starts the parameter set update for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_ParameterSetUpdateStartNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to start the parameter set update for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to start the update for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParameterSetUpdateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_START(FIELD,variableType,fieldSetType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ParameterSetUpdateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the parameter set update for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_ParameterSetUpdateStartObj(field,variableType,fieldSetType,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to start the parameter set update for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to start the update for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ParameterSetUpdateStartObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_START(field%field,variableType,fieldSetType,err,error,*999)

    EXITS("cmfe_Field_ParameterSetUpdateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ParameterSetUpdateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParameterSetUpdateStartObj

  !
  !================================================================================================================================
  !

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable, where both fields are identified by user numbers.
  SUBROUTINE cmfe_Field_ParametersToFieldParametersComponentCopyNumber(fromRegionUserNumber,fromFieldUserNumber,fromVariableType, &
      & fromParameterSetType, fromComponentNumber,toRegionUserNumber,toFieldUserNumber,toVariableType,toParameterSetType, &
      & toComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fromRegionUserNumber !<The user number of the region containing the field to copy from
    INTEGER(INTG), INTENT(IN) :: fromFieldUserNumber !<The field to copy from
    INTEGER(INTG), INTENT(IN) :: fromVariableType !<The field variable type to copy from
    INTEGER(INTG), INTENT(IN) :: fromParameterSetType !<The field parameter set type to copy from
    INTEGER(INTG), INTENT(IN) :: fromComponentNumber !<The field variable component number to copy from
    INTEGER(INTG), INTENT(IN) :: toRegionUserNumber !<The user number of the region containing the field to copy to
    INTEGER(INTG), INTENT(IN) :: toFieldUserNumber !<The field to copy to
    INTEGER(INTG), INTENT(IN) :: toVariableType !<The field variable type to copy to
    INTEGER(INTG), INTENT(IN) :: toParameterSetType !<The parameter set type to copy to
    INTEGER(INTG), INTENT(IN) :: toComponentNumber !<The field variable component to copy to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(REGION_TYPE), POINTER :: FROM_REGION
    TYPE(FIELD_TYPE), POINTER :: FROM_FIELD
    TYPE(REGION_TYPE), POINTER :: TO_REGION
    TYPE(FIELD_TYPE), POINTER :: TO_FIELD
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ParametersToFieldParametersComponentCopyNumber",err,error,*999)

    NULLIFY(FROM_REGION)
    NULLIFY(FROM_FIELD)
    NULLIFY(TO_REGION)
    NULLIFY(TO_FIELD)
    CALL REGION_USER_NUMBER_FIND(fromRegionUserNumber,FROM_REGION,err,error,*999)
    IF(ASSOCIATED(FROM_REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fromFieldUserNumber,FROM_REGION,FROM_FIELD,err,error,*999)
      IF(ASSOCIATED(FROM_FIELD)) THEN
        CALL REGION_USER_NUMBER_FIND(toRegionUserNumber,TO_REGION,err,error,*999)
        IF(ASSOCIATED(TO_REGION)) THEN
          CALL FIELD_USER_NUMBER_FIND(toFieldUserNumber,TO_REGION,TO_FIELD,err,error,*999)
          IF(ASSOCIATED(TO_FIELD)) THEN
            CALL Field_ParametersToFieldParametersCopy(FROM_FIELD,fromVariableType,fromParameterSetType, &
              & fromComponentNumber,TO_FIELD,toVariableType,toParameterSetType,toComponentNumber,err,error,*999)
          ELSE
            localError="A field with an user number of "//TRIM(NumberToVString(toFieldUserNumber,"*",err,error))// &
              & " does not exist on region number "//TRIM(NumberToVString(toRegionUserNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          END IF
        ELSE
          localError="A region with an user number of "//TRIM(NumberToVString(toRegionUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fromFieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(fromRegionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(fromRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    RETURN
999 ERRORS("cmfe_Field_ParametersToFieldParametersComponentCopyNumber",err,error)
    EXITS("cmfe_Field_ParametersToFieldParametersComponentCopyNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParametersToFieldParametersComponentCopyNumber

  !
  !================================================================================================================================
  !

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable, where both fields are objects.
  SUBROUTINE cmfe_Field_ParametersToFieldParametersComponentCopyObj(fromField,fromVariableType,fromParameterSetType, &
    & fromComponentNumber,toField,toVariableType,toParameterSetType,toComponentNumber,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: fromField !<The field to copy from
    INTEGER(INTG), INTENT(IN) :: fromVariableType !<The field variable type to copy from
    INTEGER(INTG), INTENT(IN) :: fromParameterSetType !<The field parameter set type to copy from
    INTEGER(INTG), INTENT(IN) :: fromComponentNumber !<The field variable component number to copy from
    TYPE(cmfe_FieldType), INTENT(IN) :: toField !<The field to copy to
    INTEGER(INTG), INTENT(IN) :: toVariableType !<The field variable type to copy to
    INTEGER(INTG), INTENT(IN) :: toParameterSetType !<The parameter set type to copy to
    INTEGER(INTG), INTENT(IN) :: toComponentNumber !<The field variable component to copy to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    ENTERS("cmfe_Field_ParametersToFieldParametersComponentCopyObj",err,error,*999)

    CALL Field_ParametersToFieldParametersCopy(fromField%field,fromVariableType,fromParameterSetType, &
      & fromComponentNumber,toField%field,toVariableType,toParameterSetType,toComponentNumber,err,error,*999)

    RETURN
999 ERRORS("cmfe_Field_ParametersToFieldParametersComponentCopyObj",err,error)
    EXITS("cmfe_Field_ParametersToFieldParametersComponentCopyObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ParametersToFieldParametersComponentCopyObj

  !
  !================================================================================================================================
  !

  !>Returns the scaling type for a field identified by a user number.
  SUBROUTINE cmfe_Field_ScalingTypeGetNumber(regionUserNumber,fieldUserNumber,scalingType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the scaling type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the scaling type for.
    INTEGER(INTG), INTENT(OUT) :: scalingType !<On return, the field scaling type. \see OPENCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ScalingTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_SCALING_TYPE_GET(FIELD,scalingType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ScalingTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ScalingTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ScalingTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the scaling type for a field identified by an object.
  SUBROUTINE cmfe_Field_ScalingTypeGetObj(field,scalingType,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the scaling type for.
    INTEGER(INTG), INTENT(OUT) :: scalingType !<On return, the field scaling type. \see OPENCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ScalingTypeGetObj",err,error,*999)

    CALL FIELD_SCALING_TYPE_GET(field%field,scalingType,err,error,*999)

    EXITS("cmfe_Field_ScalingTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ScalingTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ScalingTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field identified by a user number.
  SUBROUTINE cmfe_Field_ScalingTypeSetNumber(regionUserNumber,fieldUserNumber,scalingType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: scalingType !<The field scaling type to set. \see OPENCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_ScalingTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_SCALING_TYPE_SET(FIELD,scalingType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_ScalingTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_ScalingTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ScalingTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field identified by an object.
  SUBROUTINE cmfe_Field_ScalingTypeSetObj(field,scalingType,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: scalingType !<The field scaling type to set. \see OPENCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_ScalingTypeSetObj",err,error,*999)

    CALL FIELD_SCALING_TYPE_SET(field%field,scalingType,err,error,*999)

    EXITS("cmfe_Field_ScalingTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_ScalingTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_ScalingTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the field type for a field identified by a user number.
  SUBROUTINE cmfe_Field_TypeGetNumber(regionUserNumber,fieldUserNumber,fieldType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the field type for.
    INTEGER(INTG), INTENT(OUT) :: fieldType !<On return, the field type. \see OPENCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_TypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_TYPE_GET(FIELD,fieldType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_TypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_TypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type for a field identified by an object.
  SUBROUTINE cmfe_Field_TypeGetObj(field,fieldType,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the field type for.
    INTEGER(INTG), INTENT(OUT) :: fieldType !<On return, the field type. \see OPENCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_TypeGetObj",err,error,*999)

    CALL FIELD_TYPE_GET(field%field,fieldType,err,error,*999)

    EXITS("cmfe_Field_TypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_TypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the field type for a field identified by a user number.
  SUBROUTINE cmfe_Field_TypeSetNumber(regionUserNumber,fieldUserNumber,fieldType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldType !<The field type to set. \see OPENCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_TypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_TYPE_SET(FIELD,fieldType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_TypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_TypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for a field identified by an object.
  SUBROUTINE cmfe_Field_TypeSetObj(field,fieldType,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldType !<The field type to set. \see OPENCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_TypeSetObj",err,error,*999)

    CALL FIELD_TYPE_SET(field%field,fieldType,err,error,*999)

    EXITS("cmfe_Field_TypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_TypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_TypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_VariableLabelGetCNumber(regionUserNumber,fieldUserNumber,variableType,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OPENCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_VariableLabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_LABEL_GET(FIELD,variableType,label,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_VariableLabelGetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableLabelGetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableLabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_VariableLabelGetCObj(field,variableType,label,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OPENCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_VariableLabelGetCObj",err,error,*999)

    CALL FIELD_VARIABLE_LABEL_GET(field%field,variableType,label,err,error,*999)

    EXITS("cmfe_Field_VariableLabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableLabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableLabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_VariableLabelGetVSNumber(regionUserNumber,fieldUserNumber,variableType,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OPENCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_VariableLabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_LABEL_GET(FIELD,variableType,label,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_VariableLabelGetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableLabelGetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableLabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_VariableLabelGetVSObj(field,variableType,label,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OPENCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_VariableLabelGetVSObj",err,error,*999)

    CALL FIELD_VARIABLE_LABEL_GET(field%field,variableType,label,err,error,*999)

    EXITS("cmfe_Field_VariableLabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableLabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableLabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_VariableLabelSetCNumber(regionUserNumber,fieldUserNumber,variableType,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OPENCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_VariableLabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_LABEL_SET(FIELD,variableType,label,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_VariableLabelSetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableLabelSetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableLabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_VariableLabelSetCObj(field,variableType,label,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OPENCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_VariableLabelSetCObj",err,error,*999)

    CALL FIELD_VARIABLE_LABEL_SET(field%field,variableType,label,err,error,*999)

    EXITS("cmfe_Field_VariableLabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableLabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableLabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable for a field identified by a user number.
  SUBROUTINE cmfe_Field_VariableLabelSetVSNumber(regionUserNumber,fieldUserNumber,variableType,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OPENCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_VariableLabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_LABEL_SET(FIELD,variableType,label,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_VariableLabelSetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableLabelSetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableLabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable for a field identified by an object.
  SUBROUTINE cmfe_Field_VariableLabelSetVSObj(field,variableType,label,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OPENCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_VariableLabelSetVSObj",err,error,*999)

    CALL FIELD_VARIABLE_LABEL_SET(field%field,variableType,label,err,error,*999)

    EXITS("cmfe_Field_VariableLabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableLabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableLabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the field variable types for a field identified by a user number.
  SUBROUTINE cmfe_Field_VariableTypesGetNumber(regionUserNumber,fieldUserNumber,variableTypes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the field variable types for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the field variable types for.
    INTEGER(INTG), INTENT(OUT) :: variableTypes(:) !<variableTypes(variable_idx). On return, the field variable types for the variable_idx'th field variable. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_VariableTypesGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_TYPES_GET(FIELD,variableTypes,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_VariableTypesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableTypesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableTypesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the variable types for a field identified by an object.
  SUBROUTINE cmfe_Field_VariableTypesGetObj(field,variableTypes,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to get the field variable types for.
    INTEGER(INTG), INTENT(OUT) :: variableTypes(:) !<variableTypes(variable_idx). On return, the field variable types for the variable_idx'th field variable. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_VariableTypesGetObj",err,error,*999)

    CALL FIELD_VARIABLE_TYPES_GET(field%field,variableTypes,err,error,*999)

    EXITS("cmfe_Field_VariableTypesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableTypesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableTypesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the field variable types for a field identified by a user number.
  SUBROUTINE cmfe_Field_VariableTypesSetNumber(regionUserNumber,fieldUserNumber,variableTypes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: variableTypes(:) !<variableTypes(variable_idx). The field variable types for the variable_idx'th field variable to set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Field_VariableTypesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_TYPES_SET(FIELD,variableTypes,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Field_VariableTypesSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableTypesSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableTypesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the variable types for a field identified by an object.
  SUBROUTINE cmfe_Field_VariableTypesSetObj(field,variableTypes,err)

    !Argument variables
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: variableTypes(:) !<variableTypes(variable_idx). The field variable types for the variable_idx'th field variable to set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Field_VariableTypesSetObj",err,error,*999)

    CALL FIELD_VARIABLE_TYPES_SET(field%field,variableTypes,err,error,*999)

    EXITS("cmfe_Field_VariableTypesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Field_VariableTypesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Field_VariableTypesSetObj

!!==================================================================================================================================
!!
!! FIELD_IO_ROUTINES
!!
!!==================================================================================================================================

  !>Export element information for fields set identified by an object. \todo number method
  SUBROUTINE cmfe_Fields_ElementsExportCCObj(fields,fileName,method,err)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the elements to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: FileNameLength
    INTEGER(INTG) :: MethodLength

    ENTERS("cmfe_Fields_ElementsExportCCObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%fields,VFileName,VMethod,err,error,*999)

    EXITS("cmfe_Fields_ElementsExportCCObj")
    RETURN
999 ERRORSEXITS("cmfe_Fields_ElementsExportCCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_ElementsExportCCObj

  !
  !================================================================================================================================
  !


  !>Export element information for fields set identified by an object. \todo number method
  SUBROUTINE cmfe_Fields_ElementsExportVSCObj(fields,fileName,method,err)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the elements to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: MethodLength

    ENTERS("cmfe_Fields_ElementsExportVSCObj",err,error,*999)

    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%fields,fileName,VMethod,err,error,*999)

    EXITS("cmfe_Fields_ElementsExportVSCObj")
    RETURN
999 ERRORSEXITS("cmfe_Fields_ElementsExportVSCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_ElementsExportVSCObj

  !
  !================================================================================================================================
  !


  !>Export element information for fields set identified by an object. \todo number method
  SUBROUTINE cmfe_Fields_ElementsExportCVSObj(fields,fileName,method,err)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the elements to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    INTEGER(INTG) :: FileNameLength

    ENTERS("cmfe_Fields_ElementsExportCVSObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%fields,VFileName,method,err,error,*999)

    EXITS("cmfe_Fields_ElementsExportCVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Fields_ElementsExportCVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_ElementsExportCVSObj

  !
  !================================================================================================================================
  !

  !>Export element information for fields set identified by an object. \todo number method
  SUBROUTINE cmfe_Fields_ElementsExportVSVSObj(fields,fileName,method,err)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the elements to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Fields_ElementsExportVSVSObj",err,error,*999)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%fields,fileName,method,err,error,*999)

    EXITS("cmfe_Fields_ElementsExportVSVSObj")
    RETURN
999 ERRORSEXITS("cmfe_FieldIOElementsExportVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_ElementsExportVSVSObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object. \todo number method
  SUBROUTINE cmfe_Fields_NodesExportCCObj(fields,fileName,method,err)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the nodes to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: FileNameLength
    INTEGER(INTG) :: MethodLength

    ENTERS("cmfe_Fields_NodesExportCCObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_NODES_EXPORT(fields%fields,VFileName,VMethod,err,error,*999)

    EXITS("cmfe_Fields_NodesExportCCObj")
    RETURN
999 ERRORSEXITS("cmfe_Fields_NodesExportCCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_NodesExportCCObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object. \todo number method
  SUBROUTINE cmfe_Fields_NodesExportVSCObj(fields,fileName,method,err)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the nodes to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: MethodLength

    ENTERS("cmfe_Fields_NodesExportVSCObj",err,error,*999)

    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_NODES_EXPORT(fields%fields,fileName,VMethod,err,error,*999)

    EXITS("cmfe_Fields_NodesExportVSCObj")
    RETURN
999 ERRORSEXITS("cmfe_Fields_NodesExportVSCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_NodesExportVSCObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object. \todo number method
  SUBROUTINE cmfe_Fields_NodesExportCVSObj(fields,fileName,method,err)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the nodes to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    INTEGER(INTG) :: FileNameLength

    ENTERS("cmfe_Fields_NodesExportCVSObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)

    CALL FIELD_IO_NODES_EXPORT(fields%fields,VFileName,method,err,error,*999)

    EXITS("cmfe_Fields_NodesExportCVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Fields_NodesExportCVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_NodesExportCVSObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object. \todo number method
  SUBROUTINE cmfe_Fields_NodesExportVSVSObj(fields,fileName,method,err)

    !Argument variables
    TYPE(cmfe_FieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the nodes to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Fields_NodesExportVSVSObj",err,error,*999)

    CALL FIELD_IO_NODES_EXPORT(fields%fields,fileName,method,err,error,*999)

    EXITS("cmfe_Fields_NodesExportVSVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Fields_NodesExportVSVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Fields_NodesExportVSVSObj

!!==================================================================================================================================
!!
!! GENERATED_MESH_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the basis for a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_BasisGetNumber(regionUserNumber,generatedMeshUserNumber,basisUserNumbers,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the basis for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the basis for.
    INTEGER(INTG), INTENT(INOUT) :: basisUserNumbers(:) !<On return, the user numbers of the bases.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_PTR_TYPE), POINTER :: BASES(:)
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: basis_idx,NumBases

    ENTERS("cmfe_GeneratedMesh_BasisGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    NULLIFY(BASES)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_BASIS_GET(GENERATED_MESH,BASES,err,error,*999)
        IF(ASSOCIATED(BASES)) THEN
          NumBases=SIZE(BASES)
          IF(SIZE(basisUserNumbers)<NumBases) THEN
            localError="The basis user numbers array must have a size of at least "// &
                & TRIM(NumberToVString(NumBases,"*",err,error))// &
                & ". However, it has a size of " &
                & //TRIM(NumberToVString(SIZE(basisUserNumbers),"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          END IF
          DO basis_idx=1,NumBases
            IF(ASSOCIATED(BASES(basis_idx)%PTR)) THEN
              basisUserNumbers(basis_idx)=BASES(basis_idx)%PTR%USER_NUMBER
            ELSE
              localError="The basis with index "//TRIM(NumberToVString(basis_idx,"*",err,error))// &
                & " is not associated for the generated mesh with a user number of "// &
                & TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            END IF
          END DO
        ELSE
          localError="The bases are not associated for the generated mesh with a user number of "// &
            & TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A generated mesh with an user number of "//TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_BasisGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_BasisGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_BasisGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the basis for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_BasisGetObj(generatedMesh,bases,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the basis for.
    TYPE(cmfe_BasisType), INTENT(INOUT) :: bases(:) !<On return, the array of bases.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_PTR_TYPE), POINTER :: BASIS_PTRS(:)
    INTEGER(INTG) :: basis_idx,NumBases
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_BasisGetObj",err,error,*999)

    NULLIFY(BASIS_PTRS)

    CALL GENERATED_MESH_BASIS_GET(generatedMesh%generatedMesh,BASIS_PTRS,err,error,*999)
    IF(ASSOCIATED(BASIS_PTRS)) THEN
      NumBases=SIZE(BASIS_PTRS)
      IF(SIZE(bases)<NumBases) THEN
        localError="The bases array must have a size of at least "// &
            & TRIM(NumberToVString(NumBases,"*",err,error))// &
            & ". However, it has a size of " &
            & //TRIM(NumberToVString(SIZE(bases),"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
      DO basis_idx=1,NumBases
        bases(basis_idx)%basis=>BASIS_PTRS(basis_idx)%PTR
      END DO
    ELSE
      localError="The bases are not associated for the generated mesh."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_BasisGetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_BasisGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_BasisGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_BasisSetNumber0(regionUserNumber,generatedMeshUserNumber,basisUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_PTR_TYPE), POINTER :: BASES(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_BasisSetNumber0",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    NULLIFY(BASIS)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL BASIS_USER_NUMBER_FIND(basisUserNumber,BASIS,err,error,*999)
        IF(ASSOCIATED(BASIS)) THEN
          ALLOCATE(BASES(1),STAT=err)
          IF(err/=0) CALL FlagError("Could not allocate bases.",err,error,*999)
          BASES(1)%PTR=>BASIS
          CALL GENERATED_MESH_BASIS_SET(GENERATED_MESH,BASES,err,error,*999)
        ELSE
          localError="A basis with an user number of "//TRIM(NumberToVString(basisUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A generated mesh with an user number of "//TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_BasisSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_BasisSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_BasisSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_BasisSetNumber1(regionUserNumber,generatedMeshUserNumber,basisUserNumbers,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumbers(:) !<The user numbers of the bases to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_PTR_TYPE), POINTER :: BASES(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: basis_idx,NumBases

    ENTERS("cmfe_GeneratedMesh_BasisSetNumber1",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    NULLIFY(BASES)

    NumBases=SIZE(basisUserNumbers)
    ALLOCATE(BASES(NumBases),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate bases.",err,error,*999)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        DO basis_idx=1,NumBases
          NULLIFY(BASIS)
          CALL BASIS_USER_NUMBER_FIND(basisUserNumbers(basis_idx),BASIS,err,error,*999)
          IF(ASSOCIATED(BASIS)) THEN
            BASES(basis_idx)%PTR=>BASIS
          ELSE
            localError="A basis with an user number of "//TRIM(NumberToVString(basisUserNumbers(basis_idx),"*",err,error))// &
              & " does not exist."
            CALL FlagError(localError,err,error,*999)
          END IF
        END DO
        CALL GENERATED_MESH_BASIS_SET(GENERATED_MESH,BASES,err,error,*999)
      ELSE
        localError="A generated mesh with an user number of "//TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_BasisSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_BasisSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_BasisSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_BasisSetObj0(generatedMesh,basis,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the basis for.
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_BasisSetObj0",err,error,*999)

    CALL cmfe_GeneratedMesh_BasisSetObj1(generatedMesh,[basis],err)

    EXITS("cmfe_GeneratedMesh_BasisSetObj0")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_BasisSetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_BasisSetObj0

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_BasisSetObj1(generatedMesh,bases,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the basis for.
    TYPE(cmfe_BasisType), INTENT(IN) :: bases(:) !<The bases to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: basis_idx
    TYPE(BASIS_PTR_TYPE), ALLOCATABLE :: BASIS_PTRS(:)
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_BasisSetObj1",err,error,*999)

    ALLOCATE(BASIS_PTRS(SIZE(bases,1)),STAT=err)
    IF(err/=0) CALL FlagError("Could not allocate bases.",err,error,*999)
    DO basis_idx=1,SIZE(bases,1)
      IF(ASSOCIATED(bases(basis_idx)%basis)) THEN
        BASIS_PTRS(basis_idx)%PTR=>bases(basis_idx)%basis
      ELSE
        localError="The basis for index "//TRIM(NumberToVString(basis_idx,"*",err,error))//" is not associated."
        CALL FlagError(localError,err,error,*999)
      END IF
    END DO

    CALL GENERATED_MESH_BASIS_SET(generatedMesh%generatedMesh,BASIS_PTRS,err,error,*999)

    EXITS("cmfe_GeneratedMesh_BasisSetObj1")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_BasisSetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_BasisSetObj1

  !
  !================================================================================================================================
  !

  !>Sets/changes the base vectors for a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_BaseVectorsSetNumber(regionUserNumber,generatedMeshUserNumber,baseVectors,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the base vectors for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the base vectors for.
    REAL(DP), INTENT(IN) :: baseVectors(:,:) !<baseVectors(coordinate_idx,xi_idx). The base vectors to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_BaseVectorsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_BASE_VECTORS_SET(GENERATED_MESH,baseVectors,err,error,*999)
      ELSE
        localError="A generated mesh with an user number of "//TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_BaseVectorsSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_BaseVectorsSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_BaseVectorsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the base vectors for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_BaseVectorsSetObj(generatedMesh,baseVectors,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the base vectors for.
    REAL(DP), INTENT(IN) :: baseVectors(:,:) !<baseVectors(coordinate_idx,xi_idx). The base vectors to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_BaseVectorsSetObj",err,error,*999)

    CALL GENERATED_MESH_BASE_VECTORS_SET(generatedMesh%generatedMesh,baseVectors,err,error,*999)

    EXITS("cmfe_GeneratedMesh_BaseVectorsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_BaseVectorsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_BaseVectorsSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_CreateFinishNumber(regionUserNumber,generatedMeshUserNumber,meshUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to generate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_CREATE_FINISH(GENERATED_MESH,meshUserNumber,MESH,err,error,*999)
      ELSE
        localError="A generated mesh with an user number of "//TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Generated Mesh Create')
#endif

    EXITS("cmfe_GeneratedMesh_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_CreateFinishObj(generatedMesh,meshUserNumber,mesh,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to generate.
    TYPE(cmfe_MeshType), INTENT(INOUT) :: mesh !<On return, the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_CreateFinishObj",err,error,*999)

    CALL GENERATED_MESH_CREATE_FINISH(generatedMesh%generatedMesh,meshUserNumber,mesh%mesh,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Generated Mesh Create')
#endif

    EXITS("cmfe_GeneratedMesh_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_CreateStartNumber(generatedMeshUserNumber,regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to create.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to create the generated mesh in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Generated Mesh Create')
#endif

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_CREATE_START(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a generated mesh on an interface identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_CreateStartInterfaceObj(generatedMeshUserNumber,interface,generatedMesh,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to create.
    TYPE(cmfe_InterfaceType), INTENT(INOUT) :: interface !<The interface to created generated mesh in.
    TYPE(cmfe_GeneratedMeshType), INTENT(INOUT) :: generatedMesh !<On return, the created generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_CreateStartInterfaceObj",err,error,*999)

    CALL GENERATED_MESH_CREATE_START(generatedMeshUserNumber,interface%interface,generatedMesh%generatedMesh,err,error,*999)

    EXITS("cmfe_GeneratedMesh_CreateStartInterfaceObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_CreateStartInterfaceObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_CreateStartInterfaceObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a generated mesh on a region identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_CreateStartRegionObj(generatedMeshUserNumber,region,generatedMesh,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to create.
    TYPE(cmfe_RegionType), INTENT(INOUT) :: region !<The region to created generated mesh in.
    TYPE(cmfe_GeneratedMeshType), INTENT(INOUT) :: generatedMesh !<On return, the created generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_CreateStartRegionObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Generated Mesh Create')
#endif

    CALL GENERATED_MESH_CREATE_START(generatedMeshUserNumber,REGION%region,generatedMesh%generatedMesh,err,error,*999)

    EXITS("cmfe_GeneratedMesh_CreateStartRegionObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_CreateStartRegionObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_CreateStartRegionObj

  !
  !================================================================================================================================
  !

  !>Destroys a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_DestroyNumber(regionUserNumber,generatedMeshUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to destroy.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_DESTROY(GENERATED_MESH,err,error,*999)
      ELSE
        localError="A generated mesh with an user number of "//TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_DestroyObj(generatedMesh,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(INOUT) :: generatedMesh !<The generated mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_DestroyObj",err,error,*999)

    CALL GENERATED_MESH_DESTROY(generatedMesh%generatedMesh,err,error,*999)

    EXITS("cmfe_GeneratedMesh_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_DestroyObj
  !
  !================================================================================================================================
  !

  !>Returns the extent for a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_ExtentGetNumber(regionUserNumber,generatedMeshUserNumber,extent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the extent for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the extent for.
    REAL(DP), INTENT(OUT) :: extent(:) !<extent(i). On return, the extent for the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_ExtentGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_EXTENT_GET(GENERATED_MESH,extent,err,error,*999)
      ELSE
        localError="A generated mesh with an user number of "//TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_ExtentGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_ExtentGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_ExtentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the extent for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_ExtentGetObj(generatedMesh,extent,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the extent for.
    REAL(DP), INTENT(OUT) :: extent(:) !<extent(i). On return, the extent for the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_ExtentGetObj",err,error,*999)

    CALL GENERATED_MESH_EXTENT_GET(generatedMesh%generatedMesh,extent,err,error,*999)

    EXITS("cmfe_GeneratedMesh_ExtentGetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_ExtentGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_ExtentGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the extent for a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_ExtentSetNumber(regionUserNumber,generatedMeshUserNumber,extent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the extent for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the extent for.
    REAL(DP), INTENT(IN) :: extent(:) !<extent(i). The extent for the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_ExtentSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_EXTENT_SET(GENERATED_MESH,extent,err,error,*999)
      ELSE
        localError="A generated mesh with an user number of "//TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_ExtentSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_ExtentSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_ExtentSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the extent for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_ExtentSetObj(generatedMesh,extent,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the extent for.
    REAL(DP), INTENT(IN) :: extent(:) !<extent(i). the extent for the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_ExtentSetObj",err,error,*999)

    CALL GENERATED_MESH_EXTENT_SET(generatedMesh%generatedMesh,extent,err,error,*999)

    EXITS("cmfe_GeneratedMesh_ExtentSetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_ExtentSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_ExtentSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of elements for a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_NumberOfElementsGetNumber(regionUserNumber,generatedMeshUserNumber,numberOfElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the number of elements for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements(:) !<numberOfElements(i). On return, the number of elements in the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_NumberOfElementsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_NUMBER_OF_ELEMENTS_GET(GENERATED_MESH,numberOfElements,err,error,*999)
      ELSE
        localError="A generated mesh with an user number of "//TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_NumberOfElementsGetNumber")
    RETURN
999 ERRORS("cmfe_GeneratedMesh_NumberOfElementsGetNumber",err,error)
    EXITS("cmfe_GeneratedMesh_NumberOfElementsGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_NumberOfElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of elements for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_NumberOfElementsGetObj(generatedMesh,numberOfElements,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements(:) !<numberOfElements(i). On return, the number of elements in the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_NumberOfElementsGetObj",err,error,*999)

    CALL GENERATED_MESH_NUMBER_OF_ELEMENTS_GET(generatedMesh%generatedMesh,numberOfElements,err,error,*999)

    EXITS("cmfe_GeneratedMesh_NumberOfElementsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_NumberOfElementsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_NumberOfElementsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements for a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_NumberOfElementsSetNumber(regionUserNumber,generatedMeshUserNumber,numberOfElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements(:) !<numberOfElements(i). The number of elements in the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_NumberOfElementsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_NUMBER_OF_ELEMENTS_SET(GENERATED_MESH,numberOfElements,err,error,*999)
      ELSE
        localError="A generated mesh with an user number of "//TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_NumberOfElementsSetNumber")
    RETURN
999 ERRORS("cmfe_GeneratedMesh_NumberOfElementsSetNumber",err,error)
    EXITS("cmfe_GeneratedMesh_NumberOfElementsSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_NumberOfElementsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_NumberOfElementsSetObj(generatedMesh,numberOfElements,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements(:) !<numberOfElements(i). The number of elements in the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_NumberOfElementsSetObj",err,error,*999)

    CALL GENERATED_MESH_NUMBER_OF_ELEMENTS_SET(generatedMesh%generatedMesh,numberOfElements,err,error,*999)

    EXITS("cmfe_GeneratedMesh_NumberOfElementsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_NumberOfElementsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_NumberOfElementsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the origin of a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_OriginGetNumber(regionUserNumber,generatedMeshUserNumber,origin,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the origin for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<origin(i). On return, the origin of the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_OriginGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_ORIGIN_GET(GENERATED_MESH,origin,err,error,*999)
      ELSE
        localError="A generated mesh with an user number of "//TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_OriginGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_OriginGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_OriginGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the origin of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_OriginGetObj(generatedMesh,origin,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<origin(i). On return, the origin of the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_OriginGetObj",err,error,*999)

    CALL GENERATED_MESH_ORIGIN_GET(generatedMesh%generatedMesh,origin,err,error,*999)

    EXITS("cmfe_GeneratedMesh_OriginGetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_OriginGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_OriginGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_OriginSetNumber(regionUserNumber,generatedMeshUserNumber,origin,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the origin for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<origin(i). The origin of the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_OriginSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_ORIGIN_SET(GENERATED_MESH,origin,err,error,*999)
      ELSE
        localError="A generated mesh with an user number of "//TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_OriginSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_OriginSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_OriginSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_OriginSetObj(generatedMesh,origin,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<origin(i). The origin of the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_OriginSetObj",err,error,*999)

    CALL GENERATED_MESH_ORIGIN_SET(generatedMesh%generatedMesh,origin,err,error,*999)

    EXITS("cmfe_GeneratedMesh_OriginSetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_OriginSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_OriginSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_TypeGetNumber(regionUserNumber,generatedMeshUserNumber,generatedMeshType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the type for.
    INTEGER(INTG), INTENT(OUT) :: generatedMeshType !<On return, the type of the generated mesh. \see OPENCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_TypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_TYPE_GET(GENERATED_MESH,generatedMeshType,err,error,*999)
      ELSE
        localError="A generated mesh with an user number of "//TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_TypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_TypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_TypeGetObj(generatedMesh,generatedMeshType,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the generated mesh type for.
    INTEGER(INTG), INTENT(OUT) :: generatedMeshType !<On return, the type of the generated mesh. \see OPENCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_TypeGetObj",err,error,*999)

    CALL GENERATED_MESH_TYPE_GET(generatedMesh%generatedMesh,generatedMeshType,err,error,*999)

    EXITS("cmfe_GeneratedMesh_TypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_TypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a generated mesh on a region identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_TypeSetNumber(regionUserNumber,generatedMeshUserNumber,generatedMeshType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshType !<The type of the generated mesh to set. \see OPENCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_TypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_TYPE_SET(GENERATED_MESH,generatedMeshType,err,error,*999)
      ELSE
        localError="A generated mesh with an user number of "//TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on a region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_TypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_TypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_TypeSetObj(generatedMesh,generatedMeshType,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the generated mesh type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshType !<The type of the generated mesh to set. \see OPENCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_TypeSetObj",err,error,*999)

    CALL GENERATED_MESH_TYPE_SET(generatedMesh%generatedMesh,generatedMeshType,err,error,*999)

    EXITS("cmfe_GeneratedMesh_TypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_TypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_TypeSetObj

  !
  !================================================================================================================================
  !

  !>Calculates and sets the geometric field parameters for a generated mesh identified by a user number.
  SUBROUTINE cmfe_GeneratedMesh_GeometricParametersCalculateNumber(regionUserNumber,generatedMeshUserNumber, &
      & fieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_GeometricParametersCalculateNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
        IF(ASSOCIATED(GENERATED_MESH)) THEN
          CALL GeneratedMesh_GeometricParametersCalculate(FIELD,GENERATED_MESH,err,error,*999)
        ELSE
          localError="A generated mesh with an user number of "//TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An field with an user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_GeometricParametersCalculateNumber")
    RETURN
999 ERRORS("cmfe_GeneratedMesh_GeometricParametersCalculateNumber",err,error)
    EXITS("cmfe_GeneratedMesh_GeometricParametersCalculateNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_GeometricParametersCalculateNumber

  !
  !================================================================================================================================
  !

  !>Calculates and sets the geometric field parameters for a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_GeometricParametersCalculateObj(generatedMesh,field,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to calculate the geometric parameters for.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !<The field to calculate the geometric parameters for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_GeneratedMesh_GeometricParametersCalculateObj",err,error,*999)

    CALL GeneratedMesh_GeometricParametersCalculate(field%field,generatedMesh%generatedMesh,err,error,*999)

    EXITS("cmfe_GeneratedMesh_GeometricParametersCalculateObj")
    RETURN
999 ERRORS("cmfe_GeneratedMesh_GeometricParametersCalculateObj",err,error)
    EXITS("cmfe_GeneratedMesh_GeometricParametersCalculateObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_GeneratedMesh_GeometricParametersCalculateObj

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_SurfaceGetNumber0(regionUserNumber,generatedMeshUserNumber,surfaceType,surfaceNodes,normalXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber  !<Guess what this is.
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted.
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_SurfaceGetNumber0",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
          CALL GENERATED_MESH_SURFACE_GET(GENERATED_MESH,1,surfaceType,surfaceNodes,normalXi,err,error,*999)
      ELSE
        localError="A generated mesh with an user number of "//TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))// &
            & " does not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_SurfaceGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_SurfaceGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN
  END SUBROUTINE cmfe_GeneratedMesh_SurfaceGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_SurfaceGetNumber1(regionUserNumber,meshComponent,generatedMeshUserNumber,surfaceType, &
      & surfaceNodes,normalXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component/basis number to use
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber  !<Guess what this is.
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted.
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_GeneratedMesh_SurfaceGetNumber1",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
          CALL GENERATED_MESH_SURFACE_GET(GENERATED_MESH,meshComponent,surfaceType,surfaceNodes,normalXi,err,error,*999)
      ELSE
        localError="A generated mesh with an user number of "//TRIM(NumberToVString(generatedMeshUserNumber,"*",err,error))// &
            & " does not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_GeneratedMesh_SurfaceGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_SurfaceGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN
  END SUBROUTINE cmfe_GeneratedMesh_SurfaceGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_SurfaceGetObj0(generatedMesh,surfaceType,surfaceNodes,normalXi,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh from which to extract surface nodes.
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted .
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_GeneratedMesh_SurfaceGetObj0",err,error,*999)

    CALL GENERATED_MESH_SURFACE_GET(generatedMesh%generatedMesh,1,surfaceType,surfaceNodes,normalXi,err,error,*999)

    EXITS("cmfe_GeneratedMesh_SurfaceGetObj0")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_SurfaceGetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN
  END SUBROUTINE cmfe_GeneratedMesh_SurfaceGetObj0

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE cmfe_GeneratedMesh_SurfaceGetObj1(generatedMesh,meshComponent,surfaceType,surfaceNodes,normalXi,err)

    !Argument variables
    TYPE(cmfe_GeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh from which to extract surface nodes.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component/basis number to use
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted .
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_GeneratedMesh_SurfaceGetObj1",err,error,*999)

    CALL GENERATED_MESH_SURFACE_GET(generatedMesh%generatedMesh,meshComponent,surfaceType,surfaceNodes,normalXi,err,error,*999)

    EXITS("cmfe_GeneratedMesh_SurfaceGetObj1")
    RETURN
999 ERRORSEXITS("cmfe_GeneratedMesh_SurfaceGetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN
  END SUBROUTINE cmfe_GeneratedMesh_SurfaceGetObj1


!!==================================================================================================================================
!!
!! MESH EMBEDDING ROUTINES
!!
!!==================================================================================================================================
  !
  !================================================================================================================================
  !

  !>Initialises a EmbeddedMeshType object.
  SUBROUTINE cmfe_MeshEmbedding_Initialise(meshEmbedding,err)
    !Argument variables
    TYPE(cmfe_MeshEmbeddingType), INTENT(OUT) ::  meshEmbedding !<The  MeshEmbeddingType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshEmbedding_Initialise",err,error,*999)

    NULLIFY(meshEmbedding%meshEmbedding)

    EXITS("cmfe_MeshEmbedding_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_MeshEmbedding_Initialise",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshEmbedding_Initialise

  !
  !================================================================================================================================
  !
!>Creates a mesh embedding
  SUBROUTINE cmfe_MeshEmbedding_CreateNumber(regionOneUserNumber,regionTwoUserNumber,meshEmbedding,parentMeshUserNumber, &
    & childMeshUserNumber,err)

    TYPE(cmfe_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(REGION_TYPE), POINTER :: REGION1, REGION2
    TYPE(VARYING_STRING) :: localError
    TYPE(MESH_TYPE), POINTER :: PARENTMESH,CHILDMESH
    INTEGER(INTG), INTENT(IN) :: parentMeshUserNumber, childMeshUserNumber  !<The user number of the mesh.
    INTEGER(INTG), INTENT(IN) :: regionOneUserNumber, regionTwoUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.


    ENTERS("cmfe_MeshEmbedding_CreateNumber",err,error,*999)

    NULLIFY(REGION1)
    NULLIFY(REGION2)
    NULLIFY(PARENTMESH)
    NULLIFY(CHILDMESH)

    CALL REGION_USER_NUMBER_FIND(regionOneUserNumber,REGION1,err,error,*999)
    CALL REGION_USER_NUMBER_FIND(regionTwoUserNumber,REGION2,err,error,*999)
    IF(ASSOCIATED(REGION1)) THEN
      CALL MESH_USER_NUMBER_FIND(parentMeshUserNumber,REGION1,PARENTMESH,err,error,*999)
      IF(ASSOCIATED(REGION2)) THEN
        CALL MESH_USER_NUMBER_FIND(childMeshUserNumber,REGION2,CHILDMESH,err,error,*999)
        IF(ASSOCIATED(PARENTMESH).AND.ASSOCIATED(CHILDMESH)) THEN
          CALL MESH_EMBEDDING_CREATE(meshEmbedding%meshEmbedding,PARENTMESH,CHILDMESH,err,error,*999)
        ELSE
          localError="Meshes with user number of "//TRIM(NumberToVString(parentMeshUserNumber,"*",err,error))// &
              & " and "//TRIM(NumberToVString(childMeshUserNumber,"*",err,error))//  " do not exist."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionTwoUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionOneUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshEmbedding_CreateNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshEmbedding_CreateNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshEmbedding_CreateNumber

  !
  !================================================================================================================================
  !

  !>Creates a mesh embedding
  SUBROUTINE cmfe_MeshEmbedding_CreateObj(meshEmbedding, parentMesh, childMesh, err)
    TYPE(cmfe_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(cmfe_MeshType), INTENT(IN) :: parentMesh, childMesh   !<The parent and child meshes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    CALL MESH_EMBEDDING_CREATE(meshEmbedding%meshEmbedding,parentMesh%mesh,childMesh%mesh,err,error,*999)
999 RETURN
  END SUBROUTINE cmfe_MeshEmbedding_CreateObj

  !
  !================================================================================================================================
  !

  !>Sets the embedded nodes for one parent element
  SUBROUTINE cmfe_MeshEmbedding_SetChildNodePositionObj(meshEmbedding, elementNumber, nodeNumbers, xiCoords, err)
    TYPE(cmfe_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    INTEGER(INTG), INTENT(IN) :: elementNumber   !<Parent element number
    INTEGER(INTG), INTENT(IN) :: nodeNumbers(:)  !<Node numbers in child mesh
    REAL(DP), INTENT(IN)      :: xiCoords(:,:)   !<Xi coordinates of embedded nodes wrt parent element
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    CALL MESH_EMBEDDING_SET_CHILD_NODE_POSITION(meshEmbedding%meshEmbedding,elementNumber, nodeNumbers, xiCoords, err, error, *999)
999 RETURN
  END SUBROUTINE cmfe_MeshEmbedding_SetChildNodePositionObj

  !
  !================================================================================================================================
  !

  !>Pushes data to embedded mesh. Will generally be used at library and not API level. /TODO: Parameter set etc, function name?
  SUBROUTINE cmfe_MeshEmbedding_PushDataObj(meshEmbedding, parentField, parentComponent, childField, childComponent, err)
    TYPE(cmfe_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(cmfe_FieldType), INTENT(IN) :: parentField, childField  !<Fields associated with parent and child mesh to get/set data from
!    TYPE(cmfe_FieldType), POINTER, INTENT(IN) :: parentField, childField  !<Fields associated with parent and child mesh to get/set data from

    INTEGER(INTG), INTENT(IN) :: parentComponent, childComponent  !<Component numbers in respective fields
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    CALL MESH_EMBEDDING_PUSH_DATA(meshEmbedding%meshEmbedding,parentField%field, parentComponent, childField%field, &
      & childComponent, err, error, *999)
999 RETURN
  END SUBROUTINE cmfe_MeshEmbedding_PushDataObj

!
  !================================================================================================================================
  !
!   !>Sets the positions of a Gauss point of the parent mesh in terms of element/xi coordinated in the child mesh
    SUBROUTINE cmfe_MeshEmbedding_SetGaussPointDataObj(meshEmbedding, parentElementNumber,gaussPointNumber, &
       & parentXiCoords,childElementNumber,childXiCoords, err)
     TYPE(cmfe_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
     INTEGER(INTG), INTENT(IN) :: parentElementNumber   !<Parent element number
     INTEGER(INTG), INTENT(IN) :: childElementNumber   !<Child element number
     INTEGER(INTG), INTENT(IN) :: gaussPointNumber  !<Gauss point number in this element
     REAL(DP), INTENT(IN)      :: parentXiCoords(:)   !<Xi coordinates of embedded nodes wrt parent element
     REAL(DP), INTENT(IN)      :: childXiCoords(:)   !<Xi coordinates of embedded nodes wrt Child element
     INTEGER(INTG), INTENT(OUT) :: err           !<The error code
!
     CALL MESH_EMBEDDING_SET_GAUSS_POINT_DATA(meshEmbedding%meshEmbedding, parentElementNumber, gaussPointNumber,&
     & parentXiCoords, childElementNumber, childXiCoords,err,error,*999)
 999 RETURN
    END SUBROUTINE cmfe_MeshEmbedding_SetGaussPointDataObj
! !
  !================================================================================================================================
  !
!   !>Sets the positions of a Gauss point of the parent mesh in terms of element/xi coordinated in the child mesh
    SUBROUTINE cmfe_MeshEmbedding_PullGaussPointDataObj(meshEmbedding, parentField, parentComponent, childField, &
      & childComponent, err)
    TYPE(cmfe_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(cmfe_FieldType), INTENT(IN) :: parentField, childField  !<Fields associated with parent and child mesh to get/set data from
    INTEGER(INTG), INTENT(IN) :: parentComponent, childComponent  !<Component numbers in respective fields
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL MESH_EMBEDDING_PULL_GAUSS_POINT_DATA(meshEmbedding%meshEmbedding,parentField%field, parentComponent, &
      &  childField%field,childComponent, err, error, *999)
999 RETURN
    END SUBROUTINE cmfe_MeshEmbedding_PullGaussPointDataObj
! !
  !================================================================================================================================
  !
   SUBROUTINE cmfe_Field_ParameterSetGetGaussPointCoordObj(meshEmbedding,componentNumber,numberOfGaussPoints, &
     & coords,err)

    !Argument variables
    TYPE(cmfe_MeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    INTEGER(INTG), INTENT(IN) :: componentNumber
    INTEGER(INTG), INTENT(OUT) :: numberOfGaussPoints
    REAL(DP), INTENT(OUT)      :: coords(:)   !<Xi coordinates of embedded nodes wrt Child element
    INTEGER(INTG), INTENT(OUT) :: err           !<The error code
    !Local variables

    ENTERS("cmfe_Field_ParameterSetGetGaussPointCoordObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD(meshEmbedding%meshEmbedding,componentNumber, &
      & NumberofGaussPoints,COORDS,ERR,error,*999)

    EXITS("cmfe_Field_ParameterSetGetGaussPointCoordObj")

999 RETURN

  END SUBROUTINE cmfe_Field_ParameterSetGetGaussPointCoordObj
!!==================================================================================================================================
!!
!! INTERFACE_ROUTINES
!!
!!==================================================================================================================================

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface identified by a user number.
  SUBROUTINE cmfe_Interface_CreateFinishNumber(regionUserNumber,interfaceUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Interface_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CREATE_FINISH(INTERFACE,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Interface_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface identified by an object.
  SUBROUTINE cmfe_Interface_CreateFinishObj(interface,err)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_CreateFinishObj",err,error,*999)

    CALL INTERFACE_CREATE_FINISH(interface%interface,err,error,*999)

    EXITS("cmfe_Interface_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface identified by a user number.
  SUBROUTINE cmfe_Interface_CreateStartNumber(interfaceUserNumber,regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Interface_CreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_CREATE_START(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Interface_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface identified by an object.
  SUBROUTINE cmfe_Interface_CreateStartObj(interfaceUserNumber,region,interface,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the field to start the creation of.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to create the interface on.
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<On return, the created interface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_CreateStartObj",err,error,*999)

    CALL INTERFACE_CREATE_START(interfaceUserNumber,region%region,interface%interface,err,error,*999)

    EXITS("cmfe_Interface_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN
    
  END SUBROUTINE cmfe_Interface_CreateStartObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the coordinate system for an interface identified by an user number.
  SUBROUTINE cmfe_Interface_CoordinateSystemSetNumber(parentRegionUserNumber,interfaceUserNumber,coordinateSystemUserNumber,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region where interface was created.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to set the coordinate system for.    
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("cmfe_Interface_CoordinateSystemSetNumber",err,error,*999)
 
    NULLIFY(INTERFACE)
    NULLIFY(REGION)
    NULLIFY(COORDINATE_SYSTEM)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,REGION,err,error,*999)
    CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
    
    IF(ASSOCIATED(INTERFACE)) THEN
      CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
      IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
        CALL INTERFACE_COORDINATE_SYSTEM_SET(INTERFACE,COORDINATE_SYSTEM,err,error,*999)
      ELSE
        localError="A coordinate system with an user number of "// &
          & TRIM(NumberToVString(CoordinateSystemUserNumber,"*",err,error))//" does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Interface_CoordinateSystemSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_CoordinateSystemSetNumber",err,error)
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_Interface_CoordinateSystemSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the coordinate system for an interface identified by an object.
  SUBROUTINE cmfe_Interface_CoordinateSystemSetObj(interface,coordinateSystem,err)
  
    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to set the coordinate system for
    TYPE(cmfe_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    ENTERS("cmfe_Interface_CoordinateSystemSetObj",err,error,*999)
 
    CALL INTERFACE_COORDINATE_SYSTEM_SET(interface%interface,coordinateSystem%coordinateSystem,err,error,*999)

    EXITS("cmfe_Interface_CoordinateSystemSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_CoordinateSystemSetObj",err,error)
    CALL cmfe_HandleError(Err,error)
    RETURN
  END SUBROUTINE cmfe_Interface_CoordinateSystemSetObj

  !
  !================================================================================================================================
  !   
  
  !>Returns the coordinate system for an interface identified by an user number.
  SUBROUTINE cmfe_Interface_CoordinateSystemGetNumber(parentRegionUserNumber,interfaceUserNumber,coordinateSystemUserNumber,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the region to get the coordinate system for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to get the coordinate system for. 
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemUserNumber !<On return, the coordinate system user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("cmfe_Interface_CoordinateSystemGetNumber",err,error,*999)
 
    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(COORDINATE_SYSTEM)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,REGION,err,error,*999)
    CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
    IF(ASSOCIATED(INTERFACE)) THEN
      CALL INTERFACE_COORDINATE_SYSTEM_GET(INTERFACE,COORDINATE_SYSTEM,err,error,*999)
      IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
        coordinateSystemUserNumber = COORDINATE_SYSTEM%USER_NUMBER
      ELSE
        localError="The coordinate system is not associated for interface number "// &
          & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))//" does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="An interface with an user number of "//TRIM(NumberToVString(InterfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Interface_CoordinateSystemGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_CoordinateSystemGetNumber",err,error)
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_Interface_CoordinateSystemGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the coordinate system for an interface identified by an object. 
  SUBROUTINE cmfe_Interface_CoordinateSystemGetObj(Interface,CoordinateSystem,err)
  
    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: Interface !<The interface to get the coordinate system for.
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: CoordinateSystem !<On return, the interface coordinate system.
   INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    ENTERS("cmfe_Interface_CoordinateSystemGetObj",err,error,*999)
 
    CALL INTERFACE_COORDINATE_SYSTEM_GET(Interface%interface,CoordinateSystem%coordinateSystem,err,error,*999)

    EXITS("cmfe_Interface_CoordinateSystemGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_CoordinateSystemGetObj",err,error)
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_Interface_CoordinateSystemGetObj
  
  !  
  !================================================================================================================================
  !

  !>Destroys an interface identified by a user number.
  SUBROUTINE cmfe_Interface_DestroyNumber(regionUserNumber,interfaceUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to destroy.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_FInterfaceDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_DESTROY(INTERFACE,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Interface_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface identified by an object.
  SUBROUTINE cmfe_Interface_DestroyObj(interface,err)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: Interface !<The interface to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_DestroyObj",err,error,*999)

    CALL INTERFACE_DESTROY(interface%interface,err,error,*999)

    EXITS("cmfe_Interface_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an interface identified by an user number.
  SUBROUTINE cmfe_Interface_LabelGetCNumber(parentRegionUserNumber,interfaceUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Interface_LabelGetCNumber",err,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_LABEL_GET(INTERFACE,label,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on a parent region with a user number of "// &
          & TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Interface_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_LabelGetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an interface identified by an object.
  SUBROUTINE cmfe_Interface_LabelGetCObj(interface,label,err)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_LabelGetCObj",err,error,*999)

    CALL INTERFACE_LABEL_GET(interface%interface,label,err,error,*999)

    EXITS("cmfe_Interface_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an interface identified by an user number.
  SUBROUTINE cmfe_Interface_LabelGetVSNumber(parentRegionUserNumber,interfaceUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Interface_LabelGetVSNumber",err,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_LABEL_GET(INTERFACE,label,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on a parent region with a user number of "// &
          & TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Interface_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_LabelGetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an interface identified by an object.
  SUBROUTINE cmfe_Interface_LabelGetVSObj(interface,label,err)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: Interface !<The interface to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the interface label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_LabelGetVSObj",err,error,*999)

    CALL INTERFACE_LABEL_GET(interface%interface,label,err,error,*999)

    EXITS("cmfe_Interface_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an interface identified by an user number.
  SUBROUTINE cmfe_Interface_LabelSetCNumber(parentRegionUserNumber,interfaceUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Interface_LabelSetCNumber",err,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_LABEL_SET(INTERFACE,label,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on a parent region with a user number of "// &
          & TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Interface_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_LabelSetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an interface identified by an object.
  SUBROUTINE cmfe_Interface_LabelSetCObj(interface,label,err)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: Interface !<The interface to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_LabelSetCObj",err,error,*999)

    CALL INTERFACE_LABEL_SET(interface%interface,label,err,error,*999)

    EXITS("cmfe_Interface_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for an interface identified by an user number.
  SUBROUTINE cmfe_Interface_LabelSetVSNumber(parentRegionUserNumber,interfaceUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Interface_LabelSetVSNumber",err,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_LABEL_SET(INTERFACE,CHAR(label),err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on a parent region with a user number of "// &
          & TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceLabelStVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_LabelSetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for an interface identified by an object.
  SUBROUTINE cmfe_Interface_LabelSetVSObj(interface,label,err)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: Interface !<The interface to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_LabelSetVSObj",err,error,*999)

    CALL INTERFACE_LABEL_SET(interface%interface,CHAR(label),err,error,*999)

    EXITS("cmfe_Interface_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the nodes for a interface identified by an object.
  SUBROUTINE cmfe_Interface_NodesGetObj(interface,nodes,err)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to get the nodes for.
    TYPE(cmfe_NodesType), INTENT(INOUT) :: nodes !<On return, the interfaces nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_NodesGetObj",err,error,*999)

    CALL INTERFACE_NODES_GET(interface%interface,nodes%nodes,err,error,*999)

    EXITS("cmfe_Interface_NodesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_NodesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_NodesGetObj

  !
  !================================================================================================================================
  !

  !>Adds a mesh to be coupled in an interface identified by a user number.
  SUBROUTINE cmfe_Interface_MeshAddNumber(interfaceRegionUserNumber,interfaceUserNumber,meshRegionUserNumber, &
    & meshUserNumber,meshIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the parent region containing the interface to add a coupled mesh to.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to add a coupled mesh to.
    INTEGER(INTG), INTENT(IN) :: meshRegionUserNumber !<The user number of the region containing the mesh to add to the interface.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to add to the interface.
    INTEGER(INTG), INTENT(OUT) :: meshIndex !<On return, the mesh index of the mesh in the list of coupled meshes in the interface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: MESH_REGION,PARENT_REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Interface_MeshAddNumber",err,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(MESH_REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(interfaceRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL REGION_USER_NUMBER_FIND(meshRegionUserNumber,MESH_REGION,err,error,*999)
        IF(ASSOCIATED(MESH_REGION)) THEN
          CALL MESH_USER_NUMBER_FIND(meshUserNumber,MESH_REGION,MESH,err,error,*999)
          IF(ASSOCIATED(MESH)) THEN
            CALL INTERFACE_MESH_ADD(INTERFACE,MESH,meshIndex,err,error,*999)
          ELSE
            localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
              & " does not exist on the region with an user number of "// &
              & TRIM(NumberToVString(meshRegionUserNumber,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          END IF
        ELSE
          localError="The mesh region with an user number of "//TRIM(NumberToVString(meshRegionUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "// &
          & TRIM(NumberToVString(interfaceRegionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="The interface parent region with an user number of "// &
        & TRIM(NumberToVString(interfaceRegionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Interface_MeshAddNumber")
    RETURN
999 ERRORSEXITS("cmfe_Interface_MeshAddNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_MeshAddNumber

  !
  !================================================================================================================================
  !

  !>Adds a mesh to be coupled in an interface identified by an object.
  SUBROUTINE cmfe_Interface_MeshAddObj(interface,mesh,meshIndex,err)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to finish creating.
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to add to the interface.
    INTEGER(INTG), INTENT(OUT) :: meshIndex !<On return, the mesh index of the mesh in the list of coupled meshes in the interface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Interface_MeshAddObj",err,error,*999)

    CALL INTERFACE_MESH_ADD(interface%interface,mesh%mesh,meshIndex,err,error,*999)

    EXITS("cmfe_Interface_MeshAddObj")
    RETURN
999 ERRORSEXITS("cmfe_Interface_MeshAddObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Interface_MeshAddObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface coupled mesh connectivity identified by a user number.
  SUBROUTINE cmfe_InterfaceMeshConnectivity_CreateFinishNumber(regionUserNumber,interfaceUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to finish creating the meshes connectivity.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceMeshConnectivity_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,interface,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_MESH_CONNECTIVITY_CREATE_FINISH(interface%MESH_CONNECTIVITY,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_InterfaceMeshConnectivity_CreateFinishNumber")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_CreateFinishNumber",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_CreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface meshes connectivity identified by an object.
  SUBROUTINE cmfe_InterfaceMeshConnectivity_CreateFinishObj(interfaceMeshConnectivity,err)

    !Argument variables
    TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface meshes connectivity to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceMeshConnectivity_CreateFinishObj",err,error,*999)

    CALL INTERFACE_MESH_CONNECTIVITY_CREATE_FINISH(interfaceMeshConnectivity%meshConnectivity,err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_CreateFinishObj")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_CreateFinishObj",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_CreateFinishObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface meshes connectivity identified by a user number.
  SUBROUTINE cmfe_InterfaceMeshConnectivity_CreateStartNumber(regionUserNumber,interfaceUserNumber,meshNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the meshes connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: meshNumber !<The user number of the interface mesh
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: INTERFACE_MESH_CONNECTIVITY
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceMeshConnectivity_CreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_MESH_CONNECTIVITY)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL MESH_USER_NUMBER_FIND(meshNumber,INTERFACE,MESH,ERR,error,*999)
        IF(ASSOCIATED(MESH)) THEN
          CALL INTERFACE_MESH_CONNECTIVITY_CREATE_START(INTERFACE,MESH,INTERFACE_MESH_CONNECTIVITY,err,error,*999)
        ELSE
          localError="A mesh with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
           & " does not exist on the interface with user number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceMeshConnectivity_CreateStartNumber")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_CreateStartNumber",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_CreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface meshes connectivity identified by an object.
  SUBROUTINE cmfe_InterfaceMeshConnectivity_CreateStartObj(interface,interfaceMesh,interfaceMeshConnectivity,err)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to start the creation of the meshes connectivity for
    TYPE(cmfe_MeshType), INTENT(IN) :: interfaceMesh
    TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(INOUT) :: interfaceMeshConnectivity !<On return, the created meshes connectivity
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceMeshConnectivity_CreateStartObj",err,error,*999)

    CALL INTERFACE_MESH_CONNECTIVITY_CREATE_START(interface%interface,interfaceMesh%mesh, &
      & interfaceMeshConnectivity%meshConnectivity,err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_CreateStartObj")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_CreateStartObj",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_CreateStartObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_CreateStartObj


  !
  !================================================================================================================================
  !

  !>Sets the connectivity between an element in a coupled mesh to an element in the interface mesh
  SUBROUTINE cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber(regionUserNumber,interfaceUserNumber, &
     &  interfaceElementNumber,coupledMeshIndexNumber,coupledMeshElementNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface meshe connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledMeshElementNumber !<The coupled mesh element to be connected to the interface
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL InterfaceMeshConnectivity_ElementNumberSet(interface%MESH_CONNECTIVITY,interfaceElementNumber, &
         & coupledMeshIndexNumber,coupledMeshElementNumber,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the connectivity between an element in a coupled mesh to an element in the interface mesh
  SUBROUTINE cmfe_InterfaceMeshConnectivity_ElementNumberSetObj(interfaceMeshConnectivity,interfaceElementNumber, &
     &  coupledMeshIndexNumber,coupledMeshElementNumber,err)

    !Argument variables
    TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface mesh connectivity for the interface mesh
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber  !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledMeshElementNumber !<The coupled mesh element to be connected to the interface
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceMeshConnectivity_ElementNumberSetObj",err,error,*999)

    CALL InterfaceMeshConnectivity_ElementNumberSet(interfaceMeshConnectivity%meshConnectivity, &
      & interfaceElementNumber,coupledMeshIndexNumber,coupledMeshElementNumber,err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_ElementNumberSetObj")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_ElementNumberSetObj",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_ElementNumberSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_ElementNumberSetObj


  !
  !================================================================================================================================
  !

  !>Sets the connectivity between an element in a coupled mesh to an element in the interface mesh
  SUBROUTINE cmfe_InterfaceMeshConnectivity_NodeNumberSetNumber(regionUserNumber,interfaceUserNumber, &
     &  interfaceElementNumber,coupledMeshIndexNumber,coupledMeshElementNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface meshe connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledMeshElementNumber !<The coupled mesh element to be connected to the interface
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
 
    ENTERS("cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber",err,error,*999)

    CALL FlagError("Not implemented yet.",err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_ElementNumberSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_NodeNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the connectivity between nodes in coupled meshes to nodes in the interface mesh
  SUBROUTINE cmfe_InterfaceMeshConnectivity_NodeNumberSetObj(interfaceMeshConnectivity,interfaceNodeNumbers, &
     &  firstCoupledMeshIndexNumber,firstCoupledMeshNodeNumbers,secondCoupledMeshIndexNumber,secondCoupledMeshNodeNumbers,err)

    !Argument variables
    TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface mesh connectivity for the interface mesh
    INTEGER(INTG), INTENT(IN) :: interfaceNodeNumbers(:)  !<The interface mesh node numbers to which the specified coupled mesh nodes would be connected
    INTEGER(INTG), INTENT(IN) :: firstCoupledMeshIndexNumber,secondCoupledMeshIndexNumber !<The index of the coupled meshes at the interface to set the node connectivity for
    INTEGER(INTG), INTENT(IN) :: firstCoupledMeshNodeNumbers(:),secondCoupledMeshNodeNumbers(:) !<The coupled meshes nodes to be connected to the interface
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceMeshConnectivity_NodeNumberSetObj",err,error,*999)
    
    IF(SIZE(interfaceNodeNumbers(:))==SIZE(firstCoupledMeshNodeNumbers(:)) &
      & .AND.SIZE(interfaceNodeNumbers(:))==SIZE(secondCoupledMeshNodeNumbers(:))) THEN
      !TODO Check pointers
      !Set interface mesh connectivity node connectivity
      CALL INTERFACE_MESH_CONNECTIVITY_NODE_NUMBER_SET(interfaceMeshConnectivity%meshConnectivity%interface%nodes, &
        & interfaceNodeNumbers,firstCoupledMeshIndexNumber,firstCoupledMeshNodeNumbers, &
        & secondCoupledMeshIndexNumber,secondCoupledMeshNodeNumbers,err,error,*999)
    ELSE
      localError="Interface number of nodes does not match coupled meshes number of nodes."
        CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_InterfaceMeshConnectivity_NodeNumberSetObj")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_NodeNumberSetObj",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_NodeNumberSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_NodeNumberSetObj

  !
  !================================================================================================================================
  !

  !>Sets the mapping from an xi position of a coupled mesh element to a node of an interface mesh element
  SUBROUTINE cmfe_InterfaceMeshConnectivity_ElementXiSetNumber(regionUserNumber,interfaceUserNumber,interfaceElementNumber, &
     &  coupledMeshIndexNumber,coupledMeshElementNumber,interfaceMeshLocalNodeNumber,interfaceMeshComponentNodeNumber,xi,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the meshes connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledMeshElementNumber !<The coupled mesh element to define the element xi connectivity from
    INTEGER(INTG), INTENT(IN) :: interfaceMeshLocalNodeNumber !<The interface mesh node to assign the coupled mesh element xi to
    INTEGER(INTG), INTENT(IN) :: interfaceMeshComponentNodeNumber !<The interface mesh node's component to assign the coupled mesh element xi to
    REAL(DP), INTENT(IN) :: xi(:) !<The xi value for the xi_idx'th xi direction in the coupled mesh element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceMeshConnectivity_ElementXiSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_MESH_CONNECTIVITY_ELEMENT_XI_SET(interface%MESH_CONNECTIVITY,interfaceElementNumber, &
         & coupledMeshIndexNumber,coupledMeshElementNumber,interfaceMeshLocalNodeNumber,interfaceMeshComponentNodeNumber,xi, &
         & err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceMeshConnectivity_ElementXiSetNumber")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_ElementXiSetNumber",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_ElementXiSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_ElementXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the mapping from an xi position of a coupled mesh element to a node of an interface mesh element
  SUBROUTINE cmfe_InterfaceMeshConnectivity_ElementXiSetObj(interfaceMeshConnectivity,interfaceElementNumber, &
     &  coupledMeshIndexNumber,coupledMeshElementNumber,interfaceMeshLocalNodeNumber,interfaceMeshComponentNodeNumber,xi,err)

    !Argument variables
    TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface to start the creation of the meshes connectivity for
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledMeshElementNumber !<The coupled mesh element to define the element xi connectivity from
    INTEGER(INTG), INTENT(IN) :: interfaceMeshLocalNodeNumber !<The interface mesh node to assign the coupled mesh element xi to
    INTEGER(INTG), INTENT(IN) :: interfaceMeshComponentNodeNumber !<The interface mesh node's component to assign the coupled mesh element xi to
    REAL(DP), INTENT(IN) :: xi(:) !<The xi value for the xi_idx'th xi direction in the coupled mesh element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceMeshConnectivity_ElementXiSetObj",err,error,*999)

    CALL INTERFACE_MESH_CONNECTIVITY_ELEMENT_XI_SET(interfaceMeshConnectivity%meshConnectivity,interfaceElementNumber, &
      & coupledMeshIndexNumber,coupledMeshElementNumber,interfaceMeshLocalNodeNumber,interfaceMeshComponentNodeNumber,xi, &
      & err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_ElementXiSetObj")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_ElementXiSetObj",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_ElementXiSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_ElementXiSetObj

  !
  !================================================================================================================================
  !

  SUBROUTINE cmfe_InterfaceMeshConnectivity_BasisSetNumber(regionUserNumber,interfaceUserNumber,interfaceBasisNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceBasisNumber !<The user number of the basis to denote the interface mesh connectivity basis
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceMeshConnectivity_BasisSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(BASIS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL BASIS_USER_NUMBER_FIND(interfaceBasisNumber,BASIS,err,error,*999)
        IF (ASSOCIATED(BASIS)) THEN
          CALL INTERFACE_MESH_CONNECTIVITY_BASIS_SET(interface%MESH_CONNECTIVITY,BASIS,err,error,*999)
        ELSE
          localError="A basis with the user number "//TRIM(NumberToVString(interfaceBasisNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
     ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceMeshConnectivity_BasisSetNumber")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_BasisSetNumber",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_BasisSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_BasisSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the basis for the mesh connectivity
  SUBROUTINE cmfe_InterfaceMeshConnectivity_BasisSetObj(interfaceMeshConnectivity,interfaceMappingBasis,err)

    !Argument variables
    TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface to start the creation of the meshes connectivity for
    TYPE(cmfe_BasisType), INTENT(INOUT) :: interfaceMappingBasis !<The interface mesh connectivity basis
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceMeshConnectivity_BasisSetObj",err,error,*999)

    CALL INTERFACE_MESH_CONNECTIVITY_BASIS_SET(interfaceMeshConnectivity%meshConnectivity,interfaceMappingBasis%basis, &
      & err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_BasisSetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceMeshConnectivity_BasisSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_BasisSetObj

  !
  !================================================================================================================================
  !

  !>Destroys an interface meshes connectivity identified by a user number.
  SUBROUTINE cmfe_InterfaceMeshConnectivity_DestroyNumber(regionUserNumber,interfaceUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_FInterfaceMeshConnectivityDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_MESH_CONNECTIVITY_DESTROY(interface%MESH_CONNECTIVITY,err,error,*999)
     ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceMeshConnectivity_DestroyNumber")
    RETURN
999 ERRORS("cmfe_InterfaceMeshConnectivity_DestroyNumber",err,error)
    EXITS("cmfe_InterfaceMeshConnectivity_DestroyNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface meshes connectivity identified by an object.
  SUBROUTINE cmfe_InterfaceMeshConnectivity_DestroyObj(interfaceMeshConnectivity,err)

    !Argument variables
    TYPE(cmfe_InterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface meshes connectivity to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceMeshConnectivity_DestroyObj",err,error,*999)

    IF(ASSOCIATED(interfaceMeshConnectivity%meshConnectivity)) &
      &  CALL INTERFACE_MESH_CONNECTIVITY_DESTROY(interfaceMeshConnectivity%meshConnectivity,err,error,*999)

    EXITS("cmfe_InterfaceMeshConnectivity_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceMeshConnectivity_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceMeshConnectivity_DestroyObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface coupled mesh points connectivity identified by a user number.
  SUBROUTINE cmfe_InterfacePointsConnectivity_CreateFinishNumber(regionUserNumber,interfaceUserNumber,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface points connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to finish creating the points connectivity.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("cmfe_InterfacePointsConnectivity_CreateFinishNumber",err,error,*999)
 
    NULLIFY(region)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL interface_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL InterfacePointsConnectivity_CreateFinish(interface%pointsConnectivity,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_InterfacePointsConnectivity_CreateFinishNumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_CreateFinishNumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_CreateFinishNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfacePointsConnectivity_CreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of an interface meshes connectivity identified by an object.
  SUBROUTINE cmfe_InterfacePointsConnectivity_CreateFinishObj(interfacePointsConnectivity,err)
  
    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(IN) :: interfacePointsConnectivity !<The interface points connectivity to finish creating.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    ENTERS("cmfe_InterfacePointsConnectivity_CreateFinishObj",err,error,*999)
 
    CALL InterfacePointsConnectivity_CreateFinish(interfacePointsConnectivity%pointsConnectivity,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_CreateFinishObj")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_CreateFinishObj",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_CreateFinishObj")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfacePointsConnectivity_CreateFinishObj
  
  !  
  !================================================================================================================================
  !   
  
  !>Starts the creation of an interface points connectivity identified by a user number.
  SUBROUTINE cmfe_InterfacePointsConnectivity_CreateStartNumber(regionUserNumber,interfaceUserNumber,MeshNumber,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the meshes connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: MeshNumber !<The user number of the interface mesh
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(InterfacePointsConnectivityType), POINTER :: interfacePointsConnectivity
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("cmfe_InterfacePointsConnectivity_CreateStartNumber",err,error,*999)
 
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfacePointsConnectivity)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL MESH_USER_NUMBER_FIND(MeshNumber,interface,mesh,ERR,error,*999)
        IF(ASSOCIATED(mesh)) THEN
          CALL InterfacePointsConnectivity_CreateStart(interface,mesh,interfacePointsConnectivity,err,error,*999)
        ELSE
          localError="A mesh with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
           & " does not exist on the interface with user number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FLAG_error(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FLAG_error(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_InterfacePointsConnectivity_CreateStartNumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_CreateStartNumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_CreateStartNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfacePointsConnectivity_CreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Starts the creation of an interface points connectivity identified by an object.
  SUBROUTINE cmfe_InterfacePointsConnectivity_CreateStartObj(interface,interfaceMesh,interfacePointsConnectivity,err)
  
    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to start the creation of the meshes connectivity for
    TYPE(cmfe_MeshType), INTENT(IN) :: interfaceMesh
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(INOUT) :: interfacePointsConnectivity !<On return, the created meshes connectivity
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfacePointsConnectivity_CreateStartObj",err,error,*999)

    CALL InterfacePointsConnectivity_CreateStart(interface%interface,interfaceMesh%mesh, &
      & InterfacePointsConnectivity%pointsConnectivity,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_CreateStartObj")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_CreateStartObj",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_CreateStartObj")
    CALL cmfe_HandleError(err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfacePointsConnectivity_CreateStartObj
  
  !
  !================================================================================================================================
  !

  !>Destroys an interface points connectivity identified by a user number.
  SUBROUTINE cmfe_InterfacePointsConnectivity_DestroyNumber(regionUserNumber,interfaceUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to destroy the points connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to destroy the points connectivity for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfacePointsConnectivity_DestroyNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL InterfacePointsConnectivity_Destroy(interface%pointsConnectivity,err,error,*999)
     ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfacePointsConnectivity_DestroyNumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_DestroyNumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_DestroyNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface points connectivity identified by an object.
  SUBROUTINE cmfe_InterfacePointsConnectivity_DestroyObj(interfacePointsConnectivity,err)

    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(IN) :: interfacePointsConnectivity !<The interface points connectivity to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfacePointsConnectivity_DestroyObj",err,error,*999)

    CALL InterfacePointsConnectivity_Destroy(interfacePointsConnectivity%pointsConnectivity,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfacePointsConnectivity_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfacePointsConnectivity_DestroyObj
  
  !  
  !================================================================================================================================
  ! 

  !>Gets coupled mesh element number that the data point in the interface is connected to
  SUBROUTINE cmfe_InterfacePointsConnectivity_ElementNumberGetNumber(regionUserNumber,interfaceUserNumber, &
     &  interfaceDataPointIndexNumber,coupledMeshIndexNumber,meshComponentNumber,coupledMeshElementNumber,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface 
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the interface mesh that points connectivity is associated to
    INTEGER(INTG), INTENT(OUT) :: coupledMeshElementNumber !<The element number where the data point is connected to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("cmfe_InterfacePointsConnectivity_ElementNumberGetNumber",err,error,*999)
 
    NULLIFY(region)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL InterfacePointsConnectivity_ElementNumberGet(interface%pointsConnectivity,interfaceDataPointIndexNumber, &
         & coupledMeshIndexNumber,meshComponentNumber,coupledMeshElementNumber,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_InterfacePointsConnectivity_ElementNumberGetNumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_ElementNumberGetNumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_ElementNumberGetNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfacePointsConnectivity_ElementNumberGetNumber
  
  !  
  !================================================================================================================================
  !   

  !>Gets coupled mesh element number that the data point in the interface is connected to
  SUBROUTINE cmfe_InterfacePointsConnectivity_ElementNumberGetObj(interfacePointsConnectivity,interfaceDataPointIndexNumber, &
      & coupledMeshIndexNumber,meshComponentNumber,coupledMeshElementNumber,err)
  
    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(IN) :: InterfacePointsConnectivity !<The interface points connectivity to set the element number for
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the interface mesh that points connectivity is associated to
    INTEGER(INTG), INTENT(OUT) :: coupledMeshElementNumber !<The element number where the data point is projected to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
  
    ENTERS("cmfe_InterfacePointsConnectivity_ElementNumberGetObj",err,error,*999)
 
    CALL InterfacePointsConnectivity_ElementNumberGet(InterfacePointsConnectivity%pointsConnectivity, &
      & interfaceDataPointIndexNumber,coupledMeshIndexNumber,meshComponentNumber,coupledMeshElementNumber,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_ElementNumberGetObj")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_ElementNumberGetObj",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_ElementNumberGetObj")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfacePointsConnectivity_ElementNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets coupled mesh element number that the data point in the interface is connected to
  SUBROUTINE cmfe_InterfacePointsConnectivity_ElementNumberSetNumber(regionUserNumber,interfaceUserNumber, &
     &  interfaceDataPointIndexNumber,coupledMeshIndexNumber,coupledMeshElementNumber,meshComponentNumber,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface 
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(IN) :: coupledMeshElementNumber !<The element number where the data point is projected to.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the points connectivity element number for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("cmfe_InterfacePointsConnectivity_ElementNumberSetNumber",err,error,*999)
 
    NULLIFY(region)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL InterfacePointsConnectivity_ElementNumberSet(interface%pointsConnectivity,interfaceDataPointIndexNumber, &
         & coupledMeshIndexNumber,coupledMeshElementNumber,meshComponentNumber,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_InterfacePointsConnectivity_ElementNumberSetNumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_ElementNumberSetNumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_ElementNumberSetNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfacePointsConnectivity_ElementNumberSetNumber
  
  !  
  !================================================================================================================================
  !   

  !>Sets coupled mesh element number that the data point in the interface is connected to
  SUBROUTINE cmfe_InterfacePointsConnectivity_ElementNumberSetObj(interfacePointsConnectivity,interfaceDataPointIndexNumber, &
      & coupledMeshIndexNumber,coupledMeshElementNumber,meshComponentNumber,err)
  
    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(IN) :: InterfacePointsConnectivity !<The interface points connectivity to set the element number for
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(IN) :: coupledMeshElementNumber !<The element number where the data point is projected to.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the points connectivity element number for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
  
    ENTERS("cmfe_InterfacePointsConnectivity_ElementNumberSetObj",err,error,*999)
 
    CALL InterfacePointsConnectivity_ElementNumberSet(InterfacePointsConnectivity%pointsConnectivity, &
      & interfaceDataPointIndexNumber,coupledMeshIndexNumber,coupledMeshElementNumber,meshComponentNumber,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_ElementNumberSetObj")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_ElementNumberSetObj",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_ElementNumberSetObj")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfacePointsConnectivity_ElementNumberSetObj
  
  !
  !================================================================================================================================
  !

  !>Gets the xi coordinate mapping between the data points in interface and xi coordinates in a coupled region mesh
  SUBROUTINE cmfe_InterfacePointsConnectivity_PointXiGetNumber(regionUserNumber,interfaceUserNumber, &
      & interfaceDataPointIndexNumber,coupledMeshIndexNumber,xi,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface 
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    REAL(DP), INTENT(OUT) :: xi(:) !<xi(xiIdx). The full xi location in the coupled mesh that the data point is connected to 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("cmfe_InterfacePointsConnectivity_PointXiGetNumber",err,error,*999)
 
    NULLIFY(region)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,INTERFACE,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL InterfacePointsConnectivity_PointXiGet(interface%pointsConnectivity,interfaceDataPointIndexNumber, &
         & coupledMeshIndexNumber,xi,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_InterfacePointsConnectivity_PointXiGetNumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_PointXiGetNumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_PointXiGetNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfacePointsConnectivity_PointXiGetNumber

  !
  !================================================================================================================================
  !
 
  !>Gets the xi coordinate mapping between the interface data points and xi coordinates in a coupled region mesh
  SUBROUTINE cmfe_InterfacePointsConnectivity_PointXiGetObj(interfacePointsConnectivity,interfaceDataPointIndexNumber, & 
     &  coupledMeshIndexNumber,xi,err)
  
    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(IN) :: InterfacePointsConnectivity !<The interface to start the creation of the meshes connectivity for
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    REAL(DP), INTENT(OUT) :: xi(:) !<xi(xiIdx). The full xi location in the coupled mesh that the data point is connected to 
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    ENTERS("cmfe_InterfacePointsConnectivity_PointXiGetObj",err,error,*999)
 
    CALL InterfacePointsConnectivity_PointXiGet(InterfacePointsConnectivity%pointsConnectivity, &
      & interfaceDataPointIndexNumber,coupledMeshIndexNumber,xi,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_PointXiGetObj")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_PointXiGetObj",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_PointXiGetObj")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfacePointsConnectivity_PointXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets the xi coordinate mapping between the data points in interface and xi coordinates in a coupled region mesh
  SUBROUTINE cmfe_InterfacePointsConnectivity_PointXiSetNumber(regionUserNumber,interfaceUserNumber, &
      & interfaceDataPointIndexNumber,coupledMeshIndexNumber,xi,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface 
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    REAL(DP), INTENT(IN) :: xi(:) !<xi(xiIdx). The full xi location in the coupled mesh that the data point is connected to 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("cmfe_InterfacePointsConnectivity_PointXiSetNumber",err,error,*999)
 
    NULLIFY(region)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL InterfacePointsConnectivity_PointXiSet(interface%pointsConnectivity,interfaceDataPointIndexNumber, &
         & coupledMeshIndexNumber,xi,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_InterfacePointsConnectivity_PointXiSetNumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_PointXiSetNumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_PointXiSetNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfacePointsConnectivity_PointXiSetNumber

  !
  !================================================================================================================================
  !
 
  !>Sets the xi coordinate mapping between the interface data points and xi coordinates in a coupled region mesh
  SUBROUTINE cmfe_InterfacePointsConnectivity_PointXiSetObj(interfacePointsConnectivity,interfaceDataPointIndexNumber, & 
     &  coupledMeshIndexNumber,xi,err)
  
    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(IN) :: InterfacePointsConnectivity !<The interface to start the creation of the meshes connectivity for
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    REAL(DP), INTENT(IN) :: xi(:) !<xi(xiIdx). The full xi location in the coupled mesh that the data point is connected to 
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    ENTERS("cmfe_InterfacePointsConnectivity_PointXiSetObj",err,error,*999)
 
    CALL InterfacePointsConnectivity_PointXiSet(InterfacePointsConnectivity%pointsConnectivity, &
      & interfaceDataPointIndexNumber,coupledMeshIndexNumber,xi,err,error,*999)

    EXITS("cmfe_InterfacePointsConnectivity_PointXiSetObj")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_PointXiSetObj",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_PointXiSetObj")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfacePointsConnectivity_PointXiSetObj
  
  !  
  !================================================================================================================================
  !  

  !>Update points connectivity with projection results, data projection identified by region user number
  SUBROUTINE cmfe_InterfacePointsConnectivity_UpdateFromProjectionRNumber(regionUserNumber,interfaceUserNumber, &
      & dataPointsRegionUserNumber,dataProjectionUserNumber,coupledMeshIndex,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface 
    INTEGER(INTG), INTENT(IN) :: dataPointsRegionUserNumber !<The region number of the data points which the data projection is associated with
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to update points connectivity with
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndex !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataProjectionGlobalNumber
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(REGION_TYPE), POINTER :: ParentRegion,dataPointsRegion
    TYPE(DATA_POINTS_TYPE), POINTER :: dataPoints
    TYPE(DATA_PROJECTION_TYPE), POINTER :: dataProjection
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionRNumber",err,error,*999)
 
    NULLIFY(ParentRegion)
    NULLIFY(dataPointsRegion)
    NULLIFY(interface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,ParentRegion,err,error,*999)
    IF(ASSOCIATED(ParentRegion)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,ParentRegion,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL REGION_USER_NUMBER_FIND(dataPointsRegionUserNumber,dataPointsRegion,err,error,*999)
        CALL REGION_DATA_POINTS_GET(dataPointsRegion,dataPoints,err,error,*999)
        CALL DataPoints_DataProjectionGlobalNumberGet(dataPoints,DataProjectionUserNumber,dataProjectionGlobalNumber, &
          & err,error,*999)
        CALL DATA_POINTS_DATA_PROJECTION_GET(dataPoints,dataProjectionGlobalNumber,dataProjection,err,error,*999)
        CALL InterfacePointsConnectivity_UpdateFromProjection(Interface%PointsConnectivity, &
          & dataProjection,coupledMeshIndex,err,error,*999) 
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionRNumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionRNumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionRNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfacePointsConnectivity_UpdateFromProjectionRNumber
  
  !  
  !================================================================================================================================
  !  

  !>Update points connectivity with projection results, data projection identified by interface user number
  SUBROUTINE cmfe_InterfacePointsConnectivity_UpdateFromProjectionINumber(regionUserNumber,interfaceUserNumber, &
    & dataPointsRegionUserNumber,dataPointsInterfaceUserNumber,dataProjectionUserNumber,coupledMeshIndex,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface 
    INTEGER(INTG), INTENT(IN) :: dataPointsRegionUserNumber !<The parent region number of the interface for the data points which the data projection is associated with
    INTEGER(INTG), INTENT(IN) :: dataPointsInterfaceUserNumber !<The interface number of the data points which the data projection is associated with
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to update points connectivity with
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndex !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataProjectionGlobalNumber
    TYPE(INTERFACE_TYPE), POINTER :: interface,dataPointsInterface
    TYPE(REGION_TYPE), POINTER :: ParentRegion,dataPointsRegion
    TYPE(DATA_POINTS_TYPE), POINTER :: dataPoints
    TYPE(DATA_PROJECTION_TYPE), POINTER :: dataProjection
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionINumber",err,error,*999)
 
    NULLIFY(ParentRegion)
    NULLIFY(dataPointsRegion)
    NULLIFY(interface)
    NULLIFY(dataPointsInterface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,ParentRegion,err,error,*999)
    IF(ASSOCIATED(ParentRegion)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,ParentRegion,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL REGION_USER_NUMBER_FIND(dataPointsRegionUserNumber,dataPointsRegion,err,error,*999)
        CALL INTERFACE_USER_NUMBER_FIND(dataPointsInterfaceUserNumber,dataPointsRegion,dataPointsInterface,err,error,*999)
        CALL INTERFACE_DATA_POINTS_GET(dataPointsInterface,dataPoints,err,error,*999)
        CALL DataPoints_DataProjectionGlobalNumberGet(dataPoints,DataProjectionUserNumber,dataProjectionGlobalNumber, &
          & err,error,*999)
        CALL DATA_POINTS_DATA_PROJECTION_GET(dataPoints,dataProjectionGlobalNumber,dataProjection,err,error,*999)
        CALL InterfacePointsConnectivity_UpdateFromProjection(Interface%PointsConnectivity, &
          & dataProjection,coupledMeshIndex,err,error,*999) 
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionINumber")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionINumber",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionINumber")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfacePointsConnectivity_UpdateFromProjectionINumber
  
  !  
  !================================================================================================================================
  !  

  !>Update points connectivity with projection results, data projection identified by object
  SUBROUTINE cmfe_InterfacePointsConnectivity_UpdateFromProjectionObj(pointsConnectivity,dataProjection, &
      & coupledMeshIndex,err)
  
    !Argument variables
    TYPE(cmfe_InterfacePointsConnectivityType), INTENT(IN) :: pointsConnectivity !<A pointer to the interface points connectivity to finish creating
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: dataProjection !<The data projection to update points connectivity with
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndex !<The mesh index of the the points connectivity to be updated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    
    ENTERS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionObj",err,error,*999)
 
    CALL InterfacePointsConnectivity_UpdateFromProjection(pointsConnectivity%pointsConnectivity, &
      & dataProjection%dataProjection,coupledMeshIndex,err,error,*999) 

    EXITS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionObj")
    RETURN
999 ERRORS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionObj",err,error)
    EXITS("cmfe_InterfacePointsConnectivity_UpdateFromProjectionObj")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfacePointsConnectivity_UpdateFromProjectionObj

!!==================================================================================================================================
!!
!! INTERFACE_CONDITIONS_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the creation of an interface condition identified by an user number.
  SUBROUTINE cmfe_InterfaceCondition_CreateFinishNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containg the interface condition to finish creating for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceCondition_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_CREATE_FINISH(INTERFACE_CONDITION,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceCondition_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_CreateFinishObj(interfaceCondition,err)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_CreateFinishObj",err,error,*999)

    CALL INTERFACE_CONDITION_CREATE_FINISH(interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_CreateStartNumber(interfaceConditionUserNumber,regionUserNumber,interfaceUserNumber, &
    & geometricFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to start the creation of.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of.
    INTEGER(INTG), INTENT(IN) :: geometricFieldUserNumber !<The user number of the geometric field on the interface for the interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: GEOMETRIC_FIELD
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceCondition_CreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(GEOMETRIC_FIELD)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL FIELD_USER_NUMBER_FIND(geometricFieldUserNumber,INTERFACE,GEOMETRIC_FIELD,err,error,*999)
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          CALL INTERFACE_CONDITION_CREATE_START(interfaceConditionUserNumber,INTERFACE,GEOMETRIC_FIELD,INTERFACE_CONDITION, &
            & err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NumberToVString(geometricFieldUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " in the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceCondition_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_CreateStartObj(interfaceConditionUserNumber,interface,geometricField,interfaceCondition,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface conditon to start the creation of.
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to create the interface on.
    TYPE(cmfe_FieldType), INTENT(IN) :: geometricField !<The geometric field for the interface condition.
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<On return, the created interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_CreateStartObj",err,error,*999)

    CALL INTERFACE_CONDITION_CREATE_START(interfaceConditionUserNumber,interface%interface,geometricField%field, &
      & interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Adds a dependent variable to an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_DependentVariableAddNumber(interfaceRegionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,meshIndex,equationsSetRegionUserNumber,equationsSetUserNumber,variableType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the region containing the interface containing the interface condition to add the dependent variable for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to add the dependent variable for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to add the dependent variable for.
    INTEGER(INTG), INTENT(IN) :: meshIndex !<The mesh index of the interface condition interface for which the dependent variable is added.
    INTEGER(INTG), INTENT(IN) :: equationsSetRegionUserNumber !<The user number of the region containing the equations set containing the dependent field varible to add.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set containing the dependent field to add the variable for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent variable to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: EQUATIONS_SET_REGION,INTERFACE_REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceCondition_DependentVariableAddNumber",err,error,*999)

    NULLIFY(INTERFACE_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(EQUATIONS_SET_REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(interfaceRegionUserNumber,INTERFACE_REGION,err,error,*999)
    IF(ASSOCIATED(INTERFACE_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,INTERFACE_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL REGION_USER_NUMBER_FIND(EquationsSetRegionuserNumber,EQUATIONS_SET_REGION,err,error,*999)
          IF(ASSOCIATED(EQUATIONS_SET_REGION)) THEN
            CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,EQUATIONS_SET_REGION,EQUATIONS_SET,err,error,*999)
            IF(ASSOCIATED(EQUATIONS_SET)) THEN
              CALL INTERFACE_CONDITION_DEPENDENT_VARIABLE_ADD(INTERFACE_CONDITION,meshIndex,EQUATIONS_SET,variableType, &
                & err,error,*999)
            ELSE
              localError="An equations set with an user number of "// &
                & TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
                & " does not exist on region number "//TRIM(NumberToVString(equationsSetRegionUserNumber,"*",err,error))//"."
              CALL FlagError(localError,err,error,*999)
            END IF
          ELSE
            localError="The equations set region with an user number of "// &
              & TRIM(NumberToVString(equationsSetRegionUserNumber,"*",err,error))//" does not exist."
            CALL FlagError(localError,err,error,*999)
          END IF
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(interfaceRegionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(interfaceRegionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="The interface region with an user number of "// &
        & TRIM(NumberToVString(interfaceRegionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceCondition_DependentVariableAddNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_DependentVariableAddNumber",err,error)
    EXITS("cmfe_InterfaceCondition_DependentVariableAddNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_DependentVariableAddNumber

  !
  !================================================================================================================================
  !

  !>Adds a dependent field variable to an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_DependentVariableAddObj(interfaceCondition,meshIndex,equationsSet,variableType,err)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to add the dependent variable to.
    INTEGER(INTG), INTENT(IN) :: meshIndex !<The mesh index of the interface condition interface for which the dependent variable is added.
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set containg the dependent variable to add.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent variable to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_DependentVariableAddObj",err,error,*999)

    CALL INTERFACE_CONDITION_DEPENDENT_VARIABLE_ADD(interfaceCondition%interfaceCondition,meshIndex,equationsSet%equationsSet, &
      & variableType,err,error,*999)

    EXITS("cmfe_InterfaceCondition_DependentVariableAddObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_DependentVariableAddObj",err,error)
    EXITS("cmfe_InterfaceCondition_DependentVariableAddObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_DependentVariableAddObj

  !
  !================================================================================================================================
  !

  !>Destroys an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_DestroyNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to destroy.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_FInterfaceConditionDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_DESTROY(INTERFACE_CONDITION,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceCondition_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_DestroyObj(interfaceCondition,err)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_DestroyObj",err,error,*999)

    CALL INTERFACE_CONDITION_DESTROY(interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_DestroyObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of equations for an interface condition identified by an user number.
  SUBROUTINE cmfe_InterfaceCondition_EquationsCreateFinishNumber(regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containg the interface condition to finish the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to finish creating the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceCondition_EquationsCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_CREATE_FINISH(INTERFACE_CONDITION,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceCondition_EquationsCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_EquationsCreateFinishNumber",err,error)
    EXITS("cmfe_InterfaceCondition_EquationsCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_EquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of interface equations for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_EquationsCreateFinishObj(interfaceCondition,err)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to finish creating the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_EquationsCreateFinishObj",err,error,*999)

    CALL INTERFACE_CONDITION_EQUATIONS_CREATE_FINISH(interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_EquationsCreateFinishObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_EquationsCreateFinishObj",err,error)
    EXITS("cmfe_InterfaceCondition_EquationsCreateFinishObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_EquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of interface equations for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_EquationsCreateStartNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to start the creation of the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to start the creation of the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceCondition_EquationsCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(INTERFACE_EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_CREATE_START(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceCondition_EquationsCreateStartNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_EquationsCreateStartNumber",err,error)
    EXITS("cmfe_InterfaceCondition_EquationsCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_EquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of interface equations for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_EquationsCreateStartObj(interfaceCondition,interfaceEquations,err)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to start the creation of interface equations for
    TYPE(cmfe_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<On return, the created interface equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_EquationsCreateStartObj",err,error,*999)

    CALL INTERFACE_CONDITION_EQUATIONS_CREATE_START(interfaceCondition%interfaceCondition,interfaceEquations% &
      & interfaceEquations,err,error,*999)

    EXITS("cmfe_InterfaceCondition_EquationsCreateStartObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_EquationsCreateStartObj",err,error)
    EXITS("cmfe_InterfaceCondition_EquationsCreateStartObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_EquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys interface equations for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_EquationsDestroyNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_FInterfaceConditionEquationsDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_DESTROY(INTERFACE_CONDITION,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceCondition_EquationsDestroyNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_EquationsDestroyNumber",err,error)
    EXITS("cmfe_InterfaceCondition_EquationsDestroyNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_EquationsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the interface equations for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_EquationsDestroyObj(interfaceCondition,err)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_EquationsDestroyObj",err,error,*999)

    CALL INTERFACE_CONDITION_EQUATIONS_DESTROY(interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_EquationsDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_EquationsDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_EquationsDestroyObj
  
  !
  !================================================================================================================================
  !

  !>Returns the integration type for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_IntegrationTypeGetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & interfaceConditionIntegrationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIntegrationType !<On return, the interface condition integration type. \see OPENCMISS_InterfaceConditionIntegrationTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: interfaceCondition
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceCondition_IntegrationTypeGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,interface,interfaceCondition,err,error,*999)
        IF(ASSOCIATED(interfaceCondition)) THEN
          CALL InterfaceCondition_IntegrationTypeGet(interfaceCondition,interfaceConditionIntegrationType,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceCondition_IntegrationTypeGetNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_IntegrationTypeGetNumber",err,error)
    EXITS("cmfe_InterfaceCondition_IntegrationTypeGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_IntegrationTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the integration type for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_IntegrationTypeGetObj(interfaceCondition,interfaceConditionIntegrationType,err)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIntegrationType !<On return, the interface condition integration type. \see OPENCMISS_InterfaceConditionIntegrationTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_IntegrationTypeGetObj",err,error,*999)

    CALL InterfaceCondition_IntegrationTypeGet(interfaceCondition%interfaceCondition,interfaceConditionIntegrationType, &
      & err,error,*999)

    EXITS("cmfe_InterfaceCondition_IntegrationTypeGetObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_IntegrationTypeGetObj",err,error)
    EXITS("cmfe_InterfaceCondition_IntegrationTypeGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_IntegrationTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the integration type for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_IntegrationTypeSetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & interfaceConditionIntegrationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionIntegrationType !<On return, the interface condition integration type. \see OPENCMISS_InterfaceConditionIntegrationTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: interfaceCondition
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceCondition_IntegrationTypeSetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,interface,interfaceCondition,err,error,*999)
        IF(ASSOCIATED(interfaceCondition)) THEN
          CALL InterfaceCondition_IntegrationTypeSet(interfaceCondition,interfaceConditionIntegrationType,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceCondition_IntegrationTypeSetNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_IntegrationTypeSetNumber",err,error)
    EXITS("cmfe_InterfaceCondition_IntegrationTypeSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_IntegrationTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the integration type for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_IntegrationTypeSetObj(interfaceCondition,interfaceConditionIntegrationType,err)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionIntegrationType !<On return, the interface condition integration type. \see OPENCMISS_InterfaceConditionIntegrationTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_MethodSetObj",err,error,*999)

    CALL InterfaceCondition_IntegrationTypeSet(interfaceCondition%interfaceCondition,interfaceConditionIntegrationType, &
      & err,error,*999)

    EXITS("cmfe_InterfaceCondition_IntegrationTypeSetObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_IntegrationTypeSetObj",err,error)
    EXITS("cmfe_InterfaceCondition_IntegrationTypeSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_IntegrationTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a Lagrange Multiplier Field for an interface condition identified by an user number.
  SUBROUTINE cmfe_InterfaceCondition_LagrangeFieldCreateFinishNumber(regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to finish the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containg the interface condition to finish the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to finish creating the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceCondition_LagrangeFieldCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL InterfaceCondition_LagrangeFieldCreateFinish(INTERFACE_CONDITION,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceCondition_LagrangeFieldCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_LagrangeFieldCreateFinishNumber",err,error)
    EXITS("cmfe_InterfaceCondition_LagrangeFieldCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_LagrangeFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a Lagrange multiplier field for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_LagrangeFieldCreateFinishObj(interfaceCondition,err)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to finish creating the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_LagrangeFieldCreateFinishObj",err,error,*999)

    CALL InterfaceCondition_LagrangeFieldCreateFinish(interfaceCondition%interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_LagrangeFieldCreateFinishObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_LagrangeFieldCreateFinishObj",err,error)
    EXITS("cmfe_InterfaceCondition_LagrangeFieldCreateFinishObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_LagrangeFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a Lagrange multiplier field for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_LagrangeFieldCreateStartNumber(regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,lagrangeFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: lagrangeFieldUserNumber !<The user number of the Lagrange field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: LAGRANGE_FIELD
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceCondition_LagrangeFieldCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(LAGRANGE_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL InterfaceCondition_LagrangeFieldCreateStart(INTERFACE_CONDITION,lagrangeFieldUserNumber,LAGRANGE_FIELD, &
            & err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceCondition_LagrangeFieldCreateStartNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_LagrangeFieldCreateStartNumber",err,error)
    EXITS("cmfe_InterfaceCondition_LagrangeFieldCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_LagrangeFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a Lagrange multiplier field for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_LagrangeFieldCreateStartObj(interfaceCondition,lagrangeFieldUserNumber,lagrangeField,err)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: lagrangeFieldUserNumber !<The user number of the Lagrange field.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: lagrangeField !<If associated on entry, the user created Lagrange field which has the same user number as the specified Lagrange field user number. If not associated on entry, on return, the created Lagrange field for the interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_LagrangeFieldCreateStartObj",err,error,*999)

    CALL InterfaceCondition_LagrangeFieldCreateStart(interfaceCondition%interfaceCondition,lagrangeFieldUserNumber, &
      & lagrangeField%field,err,error,*999)

    EXITS("cmfe_InterfaceCondition_LagrangeFieldCreateStartObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_LagrangeFieldCreateStartObj",err,error)
    EXITS("cmfe_InterfaceCondition_LagrangeFieldCreateStartObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_LagrangeFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a penalty Field for an interface condition identified by an user number.
  SUBROUTINE cmfe_InterfaceCondition_PenaltyFieldCreateFinishNumber(RegionUserNumber,InterfaceUserNumber, &
    & InterfaceConditionUserNumber,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the interface and interface condition to finish the penalty field for.
    INTEGER(INTG), INTENT(IN) :: InterfaceUserNumber !<The user number of the interface containg the interface condition to finish the penalty  field for.
    INTEGER(INTG), INTENT(IN) :: InterfaceConditionUserNumber !<The user number of the interface condition to finish creating the penalty field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("cmfe_InterfaceCondition_PenaltyFieldCreateFinishNumber",err,error,*999)
 
    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(InterfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(InterfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL InterfaceCondition_PenaltyFieldCreateFinish(INTERFACE_CONDITION,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(InterfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(InterfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(RegionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(InterfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(RegionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(RegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_InterfaceCondition_PenaltyFieldCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_PenaltyFieldCreateFinishNumber",err,error)
    EXITS("cmfe_InterfaceCondition_PenaltyFieldCreateFinishNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfaceCondition_PenaltyFieldCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of a penalty field for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_PenaltyFieldCreateFinishObj(InterfaceCondition,err)
  
    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: InterfaceCondition !<The interface condition to finish creating the penalty field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    ENTERS("cmfe_InterfaceCondition_PenaltyFieldCreateFinishObj",err,error,*999)
 
    CALL InterfaceCondition_PenaltyFieldCreateFinish(InterfaceCondition%interfaceCondition,err,error,*999)

    EXITS("cmfe_InterfaceCondition_PenaltyFieldCreateFinishObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_PenaltyFieldCreateFinishObj",err,error)
    EXITS("cmfe_InterfaceCondition_PenaltyFieldCreateFinishObj")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfaceCondition_PenaltyFieldCreateFinishObj

  !  
  !================================================================================================================================
  !  
 
  !>Starts the creation of a penalty field for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_PenaltyFieldCreateStartNumber(RegionUserNumber,InterfaceUserNumber, &
    & InterfaceConditionUserNumber,PenaltyFieldUserNumber,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the interface and interface condition to start the creation of the penalty field for.
    INTEGER(INTG), INTENT(IN) :: InterfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of the penalty field for.
    INTEGER(INTG), INTENT(IN) :: InterfaceConditionUserNumber !<The user number of the interface condition to start the creation of the penalty field for.
    INTEGER(INTG), INTENT(IN) :: PenaltyFieldUserNumber !<The user number of the penalty field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: PENALTY_FIELD
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("cmfe_InterfaceCondition_PenaltyFieldCreateStartNumber",err,error,*999)
 
    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(PENALTY_FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(InterfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(InterfaceUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL InterfaceCondition_PenaltyFieldCreateStart(INTERFACE_CONDITION,PenaltyFieldUserNumber,PENALTY_FIELD, &
            & Err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(InterfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(InterfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(RegionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(InterfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(RegionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(RegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_InterfaceCondition_PenaltyFieldCreateStartNumber")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_PenaltyFieldCreateStartNumber",err,error)
    EXITS("cmfe_InterfaceCondition_PenaltyFieldCreateStartNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfaceCondition_PenaltyFieldCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Starts the creation of a penalty field for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_PenaltyFieldCreateStartObj(InterfaceCondition,PenaltyFieldUserNumber,PenaltyField,err)
  
    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: InterfaceCondition !<The interface condition to start the creation of the penalty field for.
    INTEGER(INTG), INTENT(IN) :: PenaltyFieldUserNumber !<The user number of the penalty field.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: PenaltyField !<If associated on entry, the user created penalty field which has the same user number as the specified penalty field user number. If not associated on entry, on return, the created penalty field for the interface condition.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    ENTERS("cmfe_InterfaceCondition_PenaltyFieldCreateStartObj",err,error,*999)
 
    CALL InterfaceCondition_PenaltyFieldCreateStart(InterfaceCondition%interfaceCondition,PenaltyFieldUserNumber, &
      & PenaltyField%field,err,error,*999)

    EXITS("cmfe_InterfaceCondition_PenaltyFieldCreateStartObj")
    RETURN
999 ERRORS("cmfe_InterfaceCondition_PenaltyFieldCreateStartObj",err,error)
    EXITS("cmfe_InterfaceCondition_PenaltyFieldCreateStartObj")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfaceCondition_PenaltyFieldCreateStartObj

  !  
  !================================================================================================================================
  !   

  !>Returns the method for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_MethodGetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & interfaceConditionMethod,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionMethod !<On return, the interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceCondition_MethodGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_METHOD_GET(INTERFACE_CONDITION,interfaceConditionMethod,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceCondition_MethodGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_MethodGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_MethodGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the method for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_MethodGetObj(interfaceCondition,interfaceConditionMethod,err)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionMethod !<On return, the interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_MethodGetObj",err,error,*999)

    CALL INTERFACE_CONDITION_METHOD_GET(interfaceCondition%interfaceCondition,interfaceConditionMethod,err,error,*999)

    EXITS("cmfe_InterfaceCondition_MethodGetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_MethodGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_MethodGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the method for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_MethodSetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & interfaceConditionMethod,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionMethod !<The interface condition method to set. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceCondition_MethodSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_METHOD_SET(INTERFACE_CONDITION,interfaceConditionMethod,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceCondition_MethodSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_MethodSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_MethodSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the method for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_MethodSetObj(interfaceCondition,interfaceConditionMethod,err)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionMethod !<The interface condition method to set. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_MethodSetObj",err,error,*999)

    CALL INTERFACE_CONDITION_METHOD_SET(interfaceCondition%interfaceCondition,interfaceConditionMethod,err,error,*999)

    EXITS("cmfe_InterfaceCondition_MethodSetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_MethodSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_MethodSetObj

  !
  !================================================================================================================================
  !

  !>Returns the operator for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_OperatorGetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & interfaceConditionOperator,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to get the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the operator for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionOperator !<On return, the interface condition operator. \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceCondition_OperatorGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_OPERATOR_GET(INTERFACE_CONDITION,interfaceConditionOperator,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceCondition_OperatorGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_OperatorGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_OperatorGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the operator for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_OperatorGetObj(interfaceCondition,interfaceConditionOperator,err)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the operator for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionOperator !<On return, the interface condition operator. \see OPENCMISS_InterfaceConditionOperator,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_OperatorGetObj",err,error,*999)

    CALL INTERFACE_CONDITION_OPERATOR_GET(interfaceCondition%interfaceCondition,interfaceConditionOperator, &
      & err,error,*999)

    EXITS("cmfe_InterfaceCondition_OperatorGetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_OperatorGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_OperatorGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the operator for an interface condition identified by a user number.
  SUBROUTINE cmfe_InterfaceCondition_OperatorSetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & interfaceConditionOperator,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionOperator !<The interface condition operator to set. \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceCondition_OperatorSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_OPERATOR_SET(INTERFACE_CONDITION,interfaceConditionOperator,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceCondition_OperatorSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_OperatorSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_OperatorSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the operator for an interface condition identified by an object.
  SUBROUTINE cmfe_InterfaceCondition_OperatorSetObj(interfaceCondition,interfaceConditionOperator,err)

    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionOperator !<The interface condition operator to set. \see OPENCMISS_InterfaceConditionOperator,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceCondition_OperatorSetObj",err,error,*999)

    CALL INTERFACE_CONDITION_OPERATOR_SET(interfaceCondition%interfaceCondition,interfaceConditionOperator, &
      & err,error,*999)

    EXITS("cmfe_InterfaceCondition_OperatorSetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceCondition_OperatorSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceCondition_OperatorSetObj

  !
  !================================================================================================================================
  !

  !>Returns the output type for an interface equations identified by a user number.
  SUBROUTINE cmfe_InterfaceEquations_OutputTypeGetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the ouput type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the interface equations output type. \see OPENCMISS_EquationsOutputType,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceEquations_OutputTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(INTERFACE_EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_GET(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*999)
          CALL INTERFACE_EQUATIONS_OUTPUT_TYPE_GET(INTERFACE_EQUATIONS,outputType,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceEquations_OutputTypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_OutputTypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_OutputTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the output type for an interface equations identified by an object.
  SUBROUTINE cmfe_InterfaceEquations_OutputTypeGetObj(interfaceEquations,outputType,err)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the interface equations output type. \see OPENCMISS_EquationsOutputType,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_OutputTypeGetObj",err,error,*999)

    CALL INTERFACE_EQUATIONS_OUTPUT_TYPE_GET(interfaceEquations%interfaceEquations,outputType,err,error,*999)

    EXITS("cmfe_InterfaceEquations_OutputTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_OutputTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an interface equations identified by a user number.
  SUBROUTINE cmfe_InterfaceEquations_OutputTypeSetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The interface equations output type to set. \see OPENCMISS_EquationsOutputTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceEquations_OutputTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(INTERFACE_EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_GET(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*999)
          CALL INTERFACE_EQUATIONS_OUTPUT_TYPE_SET(INTERFACE_EQUATIONS,outputType,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceEquations_OutputTypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_OutputTypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_OutputTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an interface equations identified by an object.
  SUBROUTINE cmfe_InterfaceEquations_OutputTypeSetObj(interfaceEquations,outputType,err)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The interface equations output type to set. \see OPENCMISS_EquationsOutputTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_OutputTypeSetObj",err,error,*999)

    CALL INTERFACE_EQUATIONS_OUTPUT_TYPE_SET(interfaceEquations%interfaceEquations,outputType,err,error,*999)

    EXITS("cmfe_InterfaceEquations_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_OutputTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the sparsity type for an interface equations identified by a user number.
  SUBROUTINE cmfe_InterfaceEquations_SparsityGetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the interface equations sparsity type. \see OPENCMISS_EquationsSparsityType,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceEquations_SparsityGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(INTERFACE_EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_GET(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*999)
          CALL INTERFACE_EQUATIONS_SPARSITY_TYPE_GET(INTERFACE_EQUATIONS,sparsityType,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceEquations_SparsityGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_SparsityGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_SparsityGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for an interface equations identified by an object.
  SUBROUTINE cmfe_InterfaceEquations_SparsityGetObj(interfaceEquations,sparsityType,err)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the interface equations sparsity type. \see OPENCMISS_EquationsSparsityType,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_SparsityGetObj",err,error,*999)

    CALL INTERFACE_EQUATIONS_SPARSITY_TYPE_GET(interfaceEquations%interfaceEquations,sparsityType,err,error,*999)

    EXITS("cmfe_InterfaceEquations_SparsityGetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_SparsityGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_SparsityGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for an interface equations identified by a user number.
  SUBROUTINE cmfe_InterfaceEquations_SparsitySetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The interface equations sparsity type to set. \see OPENCMISS_EquationsSparsityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_InterfaceEquations_SparsitySetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(INTERFACE_EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_GET(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*999)
          CALL INTERFACE_EQUATIONS_SPARSITY_TYPE_SET(INTERFACE_EQUATIONS,sparsityType,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_InterfaceEquations_SparsitySetNumber")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_SparsitySetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_SparsitySetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for an interface equations identified by an object.
  SUBROUTINE cmfe_InterfaceEquations_SparsitySetObj(interfaceEquations,sparsityType,err)

    !Argument variables
    TYPE(cmfe_InterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The interface equations sparsity type to set. \see OPENCMISS_EquationsSparsityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_InterfaceEquations_SparsitySetObj",err,error,*999)

    CALL INTERFACE_EQUATIONS_SPARSITY_TYPE_SET(interfaceEquations%interfaceEquations,sparsityType,err,error,*999)

    EXITS("cmfe_InterfaceEquations_SparsitySetObj")
    RETURN
999 ERRORSEXITS("cmfe_InterfaceEquations_SparsitySetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_InterfaceEquations_SparsitySetObj

!!==================================================================================================================================
!!
!! MESH_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the creation of a domain decomposition for a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_CreateFinishNumber(regionUserNumber,meshUserNumber,decompositionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to finish the decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to finish the decomposition for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to finish.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Decomposition_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_CREATE_FINISH(DECOMPOSITION,err,error,*999)
        ELSE
          localError="A decomposition with an user number of "//TRIM(NumberToVString(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Decomposition Create')
#endif

    EXITS("cmfe_Decomposition_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a domain decomposition for a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_CreateFinishObj(decomposition,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_CreateFinishObj",err,error,*999)

    CALL DECOMPOSITION_CREATE_FINISH(decomposition%decomposition,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('decomposition Create')
#endif

    EXITS("cmfe_Decomposition_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_CreateFinishObj

  !
  !================================================================================================================================
  !

  !> Calculates the decomposition topology for data points
  SUBROUTINE cmfe_Decomposition_TopologyDataProjectionCalculateObj(decomposition,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_TopologyDataProjectionCalculateObj",err,error,*999)

    CALL DecompositionTopology_DataProjectionCalculate(decomposition%decomposition%TOPOLOGY,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('cmfe_Decomposition_TopologyDataProjectionCalculateObj',err,error,*999)
#endif

    EXITS("cmfe_Decomposition_TopologyDataProjectionCalculateObj")
    RETURN
999 ERRORS("cmfe_Decomposition_TopologyDataProjectionCalculateObj",err,error)
    EXITS("cmfe_Decomposition_TopologyDataProjectionCalculateObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_TopologyDataProjectionCalculateObj

  !
  !================================================================================================================================
  !

  !>Gets the local data point number for data points projected on an element
  SUBROUTINE cmfe_Decomposition_TopologyElementDataPointLocalNumberGetObj(decomposition,elementNumber,dataPointIndex, &
       & dataPointLocalNumber,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The element number to get the data point for
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The data point index to get the number for
    INTEGER(INTG), INTENT(OUT) :: dataPointLocalNumber !<The data point local number to retu
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_TopologyElementDataPointLocalNumberGetObj",err,error,*999)

    CALL DecompositionTopology_ElementDataPointLocalNumberGet(decomposition%decomposition%TOPOLOGY,elementNumber,dataPointIndex, &
     & dataPointLocalNumber,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('cmfe_Decomposition_TopologyElementDataPointLocalNumberGetObj',err,error,*999)
#endif

    EXITS("cmfe_Decomposition_TopologyElementDataPointLocalNumberGetObj")
    RETURN
999 ERRORS("cmfe_Decomposition_TopologyElementDataPointLocalNumberGetObj",err,error)
    EXITS("cmfe_Decomposition_TopologyElementDataPointLocalNumberGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_TopologyElementDataPointLocalNumberGetObj

  !
  !================================================================================================================================
  !

  !>Gets the user data point number for data points projected on an element
  SUBROUTINE cmfe_Decomposition_TopologyElementDataPointUserNumberGetObj(decomposition,elementNumber,dataPointIndex, &
       & dataPointUserNumber,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The element number to get the data point for
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The data point index to get the number for
    INTEGER(INTG), INTENT(OUT) :: dataPointUserNumber !<The data point user number to retu
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_TopologyElementDataPointUserNumberGetObj",err,error,*999)

    CALL DecompositionTopology_ElementDataPointUserNumberGet(decomposition%decomposition%TOPOLOGY,elementNumber,dataPointIndex, &
     & dataPointUserNumber,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('cmfe_Decomposition_TopologyElementDataPointUserNumberGetObj',err,error,*999)
#endif

    EXITS("cmfe_Decomposition_TopologyElementDataPointUserNumberGetObj")
    RETURN
999 ERRORS("cmfe_Decomposition_TopologyElementDataPointUserNumberGetObj",err,error)
    EXITS("cmfe_Decomposition_TopologyElementDataPointUserNumberGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_TopologyElementDataPointUserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Gets the number of data points projected on an element
  SUBROUTINE cmfe_Decomposition_TopologyNumberOfElementDataPointsGetObj(decomposition,elementNumber,numberOfDataPoints,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The element number to get the data point for
    INTEGER(INTG), INTENT(OUT) :: numberOfDataPoints !<The data point local number to return
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_TopologyNumberOfElementDataPointsGetObj",err,error,*999)

    CALL DecompositionTopology_NumberOfElementDataPointsGet(decomposition%decomposition%TOPOLOGY,elementNumber, &
     & numberOfDataPoints,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('cmfe_Decomposition_TopologyNumberOfElementDataPointsGetObj',err,error,*999)
#endif

    EXITS("cmfe_Decomposition_TopologyNumberOfElementDataPointsGetObj")
    RETURN
999 ERRORS("cmfe_Decomposition_TopologyNumberOfElementDataPointsGetObj",err,error)
    EXITS("cmfe_Decomposition_TopologyNumberOfElementDataPointsGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_TopologyNumberOfElementDataPointsGetObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a domain decomposition for a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_CreateStartNumber(decompositionUserNumber,regionUserNumber,meshUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to create.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to create the decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to create the decomposition for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Decomposition_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Decomposition Create')
#endif

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_CREATE_START(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Decomposition_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a domain decomposition for a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_CreateStartObj(decompositionUserNumber,mesh,decomposition,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to create.
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to create the decomposition for.
    TYPE(cmfe_DecompositionType), INTENT(INOUT) :: decomposition !<On return, the created decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('decomposition Create')
#endif

    CALL DECOMPOSITION_CREATE_START(decompositionUserNumber,mesh%mesh,decomposition%decomposition,err,error,*999)

    EXITS("cmfe_Decomposition_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_DestroyNumber(regionUserNumber,meshUserNumber,decompositionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to destroy the decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to destroy the decomposition for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Decomposition_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_DESTROY(DECOMPOSITION,err,error,*999)
        ELSE
          localError="A decomposition with an user number of "//TRIM(NumberToVString(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Decomposition_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_DestroyObj(decomposition,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_DestroyObj",err,error,*999)

    CALL DECOMPOSITION_DESTROY(decomposition%decomposition,err,error,*999)

    EXITS("cmfe_Decomposition_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_DestroyObj

  !
  !================================================================================================================================
  !

  !>Calculates the element domains for a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_ElementDomainCalculateNumber(regionUserNumber,meshUserNumber,decompositionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to calculate the element domains for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to calculate the element domains for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to calculate the element domains for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Decomposition_ElementDomainCalculateNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_ELEMENT_DOMAIN_CALCULATE(DECOMPOSITION,err,error,*999)
        ELSE
          localError="A decomposition with an user number of "//TRIM(NumberToVString(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Decomposition_ElementDomainCalculateNumber")
    RETURN
999 ERRORS("cmfe_Decomposition_ElementDomainCalculateNumber",err,error)
    EXITS("cmfe_Decomposition_ElementDomainCalculateNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_ElementDomainCalculateNumber

  !
  !================================================================================================================================
  !

  !>Calculates the element domains for a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_ElementDomainCalculateObj(decomposition,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to calcualte the element domains for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_ElementDomainCalculateObj",err,error,*999)

    CALL DECOMPOSITION_ELEMENT_DOMAIN_CALCULATE(decomposition%decomposition,err,error,*999)

    EXITS("cmfe_Decomposition_ElementDomainCalculateObj")
    RETURN
999 ERRORS("cmfe_Decomposition_ElementDomainCalculateObj",err,error)
    EXITS("cmfe_Decomposition_ElementDomainCalculateObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_ElementDomainCalculateObj

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given element in a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_ElementDomainGetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & elementUserNumber,domain,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computational domain of the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Decomposition_ElementDomainGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_ELEMENT_DOMAIN_GET(DECOMPOSITION,elementUserNumber,domain,err,error,*999)
        ELSE
          localError="A decomposition with an user number of "//TRIM(NumberToVString(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Decomposition_ElementDomainGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_ElementDomainGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_ElementDomainGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given element in a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_ElementDomainGetObj(decomposition,elementUserNumber,domain,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computational domain of the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_ElementDomainGetObj",err,error,*999)

    CALL DECOMPOSITION_ELEMENT_DOMAIN_GET(decomposition%decomposition,elementUserNumber,domain,err,error,*999)

    EXITS("cmfe_Decomposition_ElementDomainGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_ElementDomainGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_ElementDomainGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the domain for a given element in a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_ElementDomainSetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & elementUserNumber,domain,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the domain for.
    INTEGER(INTG), INTENT(IN) :: domain !<The computational domain of the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Decomposition_ElementDomainSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_ELEMENT_DOMAIN_SET(DECOMPOSITION,elementUserNumber,domain,err,error,*999)
        ELSE
          localError="A decomposition with an user number of "//TRIM(NumberToVString(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Decomposition_ElementDomainSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_ElementDomainSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_ElementDomainSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the domain for a given element in a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_ElementDomainSetObj(decomposition,elementUserNumber,domain,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the domain for.
    INTEGER(INTG), INTENT(IN) :: domain !<The computational domain of the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_ElementDomainSetObj",err,error,*999)

    CALL DECOMPOSITION_ELEMENT_DOMAIN_SET(decomposition%decomposition,elementUserNumber,domain,err,error,*999)

    EXITS("cmfe_Decomposition_ElementDomainSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_ElementDomainSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_ElementDomainSetObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number used for the decomposition of a mesh for a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_MeshComponentGetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the mesh component for.
    INTEGER(INTG), INTENT(OUT) :: meshComponentNumber !<On return, the mesh component number for the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Decomposition_MeshComponentGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_MESH_COMPONENT_NUMBER_GET(DECOMPOSITION,meshComponentNumber,err,error,*999)
        ELSE
          localError="A decomposition with an user number of "//TRIM(NumberToVString(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Decomposition_MeshComponentGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_MeshComponentGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_MeshComponentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number used for the decomposition of a mesh for a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_MeshComponentGetObj(decomposition,meshComponentNumber,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the mesh component for.
    INTEGER(INTG), INTENT(OUT) :: meshComponentNumber !<On return, the mesh component number for the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_MeshComponentGetObj",err,error,*999)

    CALL DECOMPOSITION_MESH_COMPONENT_NUMBER_GET(decomposition%decomposition,meshComponentNumber,err,error,*999)

    EXITS("cmfe_Decomposition_MeshComponentGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_MeshComponentGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_MeshComponentGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number used for the decomposition of a mesh for a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_MeshComponentSetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number for the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Decomposition_MeshComponentSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_MESH_COMPONENT_NUMBER_SET(DECOMPOSITION,meshComponentNumber,err,error,*999)
        ELSE
          localError="A decomposition with an user number of "//TRIM(NumberToVString(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Decomposition_MeshComponentSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_MeshComponentSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_MeshComponentSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number used for the decomposition of a mesh for a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_MeshComponentSetObj(decomposition,meshComponentNumber,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to Set the mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number for the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_MeshComponentSetObj",err,error,*999)

    CALL DECOMPOSITION_MESH_COMPONENT_NUMBER_SET(decomposition%decomposition,meshComponentNumber,err,error,*999)

    EXITS("cmfe_Decomposition_MeshComponentSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_MeshComponentSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_MeshComponentSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of domains for a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_NumberOfDomainsGetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & numberOfDomains,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of domains for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of domains for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the number of domains for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDomains !<On return, the number of domains in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Decomposition_NumberOfDomainsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_NUMBER_OF_DOMAINS_GET(DECOMPOSITION,numberOfDomains,err,error,*999)
        ELSE
          localError="A decomposition with an user number of "//TRIM(NumberToVString(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Decomposition_NumberOfDomainsGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_NumberOfDomainsGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_NumberOfDomainsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of domains for a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_NumberOfDomainsGetObj(decomposition,numberOfDomains,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the number of domains for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDomains !<On return, the number of domains in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_NumberOfDomainsGetObj",err,error,*999)

    CALL DECOMPOSITION_NUMBER_OF_DOMAINS_GET(decomposition%decomposition,numberOfDomains,err,error,*999)

    EXITS("cmfe_Decomposition_NumberOfDomainsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_NumberOfDomainsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_NumberOfDomainsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of domains for a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_NumberOfDomainsSetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & numberOfDomains,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the number of domains for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the number of domains for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the number of domains for.
    INTEGER(INTG), INTENT(IN) :: numberOfDomains !<The number of domains in the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Decomposition_NumberOfDomainsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_NUMBER_OF_DOMAINS_SET(DECOMPOSITION,numberOfDomains,err,error,*999)
        ELSE
          localError="A decomposition with an user number of "//TRIM(NumberToVString(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Decomposition_NumberOfDomainsSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_NumberOfDomainsSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_NumberOfDomainsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of domains for a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_NumberOfDomainsSetObj(decomposition,numberOfDomains,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the number of domains for.
    INTEGER(INTG), INTENT(IN) :: numberOfDomains !<The number of domains in the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_NumberOfDomainsSetObj",err,error,*999)

    CALL DECOMPOSITION_NUMBER_OF_DOMAINS_SET(decomposition%decomposition,numberOfDomains,err,error,*999)

    EXITS("cmfe_Decomposition_NumberOfDomainsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_NumberOfDomainsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_NumberOfDomainsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_TypeGetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber,decompositionType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the decomposition type for.
    INTEGER(INTG), INTENT(OUT) :: decompositionType !<On return, the type of the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Decomposition_TypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_TYPE_GET(DECOMPOSITION,decompositionType,err,error,*999)
        ELSE
          localError="A decomposition with an user number of "//TRIM(NumberToVString(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Decomposition_TypeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_TypeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_TypeGetObj(decomposition,decompositionType,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the type for.
    INTEGER(INTG), INTENT(OUT) :: decompositionType !<On return, the type of the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_TypeGetObj",err,error,*999)

    CALL DECOMPOSITION_TYPE_GET(decomposition%decomposition,decompositionType,err,error,*999)

    EXITS("cmfe_Decomposition_TypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_TypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_TypeSetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber,decompositionType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: decompositionType !<The type of the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Decomposition_TypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_TYPE_SET(DECOMPOSITION,decompositionType,err,error,*999)
        ELSE
          localError="A decomposition with an user number of "//TRIM(NumberToVString(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Decomposition_TypeSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_TypeSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a decomposition identified by an object.
  SUBROUTINE cmfe_Decomposition_TypeSetObj(decomposition,decompositionType,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to Set the type for.
    INTEGER(INTG), INTENT(IN) :: decompositionType !<The type of the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_TypeSetObj",err,error,*999)

    CALL DECOMPOSITION_TYPE_SET(decomposition%decomposition,decompositionType,err,error,*999)

    EXITS("cmfe_Decomposition_TypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_TypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_TypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets whether lines should be calculated
  SUBROUTINE cmfe_Decomposition_CalculateLinesSetNumber(regionUserNumber,meshUserNumber,&
                                                     & decompositionUserNumber,calculateLinesFlag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the calculate lines flag for.
    LOGICAL, INTENT(IN) :: calculateLinesFlag !<Boolean to determine whether to set lines to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Decomposition_CalculateLinesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_CALCULATE_LINES_SET(DECOMPOSITION,calculateLinesFlag,err,error,*999)
        ELSE
          localError="A decomposition with an user number of "//TRIM(NumberToVString(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Decomposition_CalculateLinesSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_CalculateLinesSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_CalculateLinesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets whether lines should be calculated
  SUBROUTINE cmfe_Decomposition_CalculateLinesSetObj(decomposition,calculateLinesFlag,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the calculate lines flag for.
    LOGICAL, INTENT(IN) :: calculateLinesFlag !<Boolean to determine whether to set lines to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_CalculateLinesSetObj",err,error,*999)

    CALL DECOMPOSITION_CALCULATE_LINES_SET(decomposition%decomposition,calculateLinesFlag,err,error,*999)

    EXITS("cmfe_Decomposition_CalculateLinesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_CalculateLinesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_CalculateLinesSetObj

  !
  !================================================================================================================================
  !

  !>Sets whether faces should be calculated
  SUBROUTINE cmfe_Decomposition_CalculateFacesSetNumber(regionUserNumber,meshUserNumber, &
                                                     & decompositionUserNumber,calculateFacesFlag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the decomposition type for.
    LOGICAL, INTENT(IN) :: calculateFacesFlag !<Boolean to determine whether to set faces to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Decomposition_CalculateFacesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_CALCULATE_FACES_SET(DECOMPOSITION,calculateFacesFlag,err,error,*999)
        ELSE
          localError="A decomposition with an user number of "//TRIM(NumberToVString(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Decomposition_CalculateFacesSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_CalculateFacesSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_CalculateFacesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets whether faces should be calculated
  SUBROUTINE cmfe_Decomposition_CalculateFacesSetObj(decomposition,calculateFacesFlag,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the calculate faces flag for.
    LOGICAL, INTENT(IN) :: calculateFacesFlag !<Boolean to determine whether to set faces to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_CalculateFacesSetObj",err,error,*999)

    CALL DECOMPOSITION_CALCULATE_FACES_SET(decomposition%decomposition,calculateFacesFlag,err,error,*999)

    EXITS("cmfe_Decomposition_CalculateFacesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_CalculateFacesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_CalculateFacesSetObj

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given node in a decomposition identified by a user number.
  SUBROUTINE cmfe_Decomposition_NodeDomainGetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & nodeUserNumber,meshComponentNumber,domain,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the domain for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computational domain of the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Decomposition_NodeDomainGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_NODE_DOMAIN_GET(DECOMPOSITION,nodeUserNumber,meshComponentNumber,domain,err,error,*999)
        ELSE
          localError="A decomposition with an user number of "//TRIM(NumberToVString(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Decomposition_NodeDomainGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_NodeDomainGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_NodeDomainGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given node in a decomposition identified by an object. \todo Maybe swap Node and MeshComponent?
  SUBROUTINE cmfe_Decomposition_NodeDomainGetObj(decomposition,nodeUserNumber,meshComponentNumber,domain,err)

    !Argument variables
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the domain for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computational domain of the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Decomposition_NodeDomainGetObj",err,error,*999)

    CALL DECOMPOSITION_NODE_DOMAIN_GET(decomposition%decomposition,nodeUserNumber,meshComponentNumber,domain,err,error,*999)

    EXITS("cmfe_Decomposition_NodeDomainGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Decomposition_NodeDomainGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Decomposition_NodeDomainGetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a mesh for a mesh identified by a user number.
  SUBROUTINE cmfe_Mesh_CreateFinishNumber(regionUserNumber,meshUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Mesh_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_CREATE_FINISH(MESH,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Mesh Create')
#endif

    EXITS("cmfe_Mesh_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a mesh for a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_CreateFinishObj(mesh,err)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_CreateFinishObj",err,error,*999)

    CALL MESH_CREATE_FINISH(mesh%mesh,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('mesh Create')
#endif

    EXITS("cmfe_Mesh_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a mesh for a mesh identified by a user number.
  SUBROUTINE cmfe_Mesh_CreateStartNumber(meshUserNumber,regionUserNumber,numberOfDimensions,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions for the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Mesh_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Mesh Create')
#endif

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_CREATE_START(meshUserNumber,REGION,numberOfDimensions,MESH,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Mesh_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a mesh for a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_CreateStartObj(meshUserNumber,region,numberOfDimensions,mesh,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start the creation of.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region containing the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions for the mesh.
    TYPE(cmfe_MeshType), INTENT(INOUT) :: mesh !<On return, the created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('mesh Create')
#endif

    CALL MESH_CREATE_START(meshUserNumber,region%region,numberOfDimensions,mesh%mesh,err,error,*999)

    EXITS("cmfe_Mesh_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a mesh for a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_CreateStartInterfaceObj(meshUserNumber,interface,numberOfDimensions,mesh,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start the creation of.
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface containing the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions for the mesh.
    TYPE(cmfe_MeshType), INTENT(INOUT) :: mesh !<On return, the created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_CreateStartInterfaceObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('mesh Create')
#endif

    CALL MESH_CREATE_START(meshUserNumber,interface%interface,numberOfDimensions,mesh%mesh,err,error,*999)

    EXITS("cmfe_Mesh_CreateStartInterfaceObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_CreateStartInterfaceObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_CreateStartInterfaceObj

  !
  !================================================================================================================================
  !

  !>Destroys a mesh identified by a user number.
  SUBROUTINE cmfe_Mesh_DestroyNumber(regionUserNumber,meshUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to destroy.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Mesh_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_DESTROY(MESH,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Mesh_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_DestroyObj(mesh,err)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_DestroyObj",err,error,*999)

    CALL MESH_DESTROY(mesh%mesh,err,error,*999)

    EXITS("cmfe_Mesh_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the number of components in a mesh identified by a user number.
  SUBROUTINE cmfe_Mesh_NumberOfComponentsGetNumber(regionUserNumber,meshUserNumber,numberOfComponents,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of components for.
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Mesh_NumberOfComponentsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_NUMBER_OF_COMPONENTS_GET(MESH,numberOfComponents,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Mesh_NumberOfComponentsGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NumberOfComponentsGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NumberOfComponentsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of components in a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_NumberOfComponentsGetObj(mesh,numberOfComponents,err)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to get the number of components for.
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_NumberOfComponentsGetObj",err,error,*999)

    CALL MESH_NUMBER_OF_COMPONENTS_GET(mesh%mesh,numberOfComponents,err,error,*999)

    EXITS("cmfe_Mesh_NumberOfComponentsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NumberOfComponentsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NumberOfComponentsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of components in a mesh identified by a user number.
  SUBROUTINE cmfe_Mesh_NumberOfComponentsSetNumber(regionUserNumber,meshUserNumber,numberOfComponents,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Mesh_NumberOfComponentsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_NUMBER_OF_COMPONENTS_SET(MESH,numberOfComponents,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Mesh_NumberOfComponentsSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NumberOfComponentsSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NumberOfComponentsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of components in a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_NumberOfComponentsSetObj(mesh,numberOfComponents,err)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_NumberOfComponentsSetObj",err,error,*999)

    CALL MESH_NUMBER_OF_COMPONENTS_SET(mesh%mesh,numberOfComponents,err,error,*999)

    EXITS("cmfe_Mesh_NumberOfComponentsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NumberOfComponentsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NumberOfComponentsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the surrounding elements calculate flag.
  SUBROUTINE cmfe_Mesh_SurroundingElementsCalculateSetNumber(regionUserNumber,meshUserNumber,surroundingElementsCalculateFlag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the surrounding elements calculate flag for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the surrounding elements calculate flag for.
    LOGICAL, INTENT(IN) :: surroundingElementsCalculateFlag !<Boolean flag to determine whether to calculate surrounding elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Mesh_SurroundingElementsCalculateSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_SURROUNDING_ELEMENTS_CALCULATE_SET(MESH,surroundingElementsCalculateFlag,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Mesh_SurroundingElementsCalculateSetNumber")
    RETURN
999 ERRORS("cmfe_Mesh_SurroundingElementsCalculateSetNumber",err,error)
    EXITS("cmfe_Mesh_SurroundingElementsCalculateSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_SurroundingElementsCalculateSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the surrounding elements calculate flag.
  SUBROUTINE cmfe_Mesh_SurroundingElementsCalculateSetObj(mesh,surroundingElementsCalculateFlag,err)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to set the surrounding elements calculate flag for.
    LOGICAL, INTENT(IN) :: surroundingElementsCalculateFlag !<Boolean flag to determine whether to calculate surrounding elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_SurroundingElementsCalculateSetObj",err,error,*999)

    CALL MESH_SURROUNDING_ELEMENTS_CALCULATE_SET(mesh%mesh,surroundingElementsCalculateFlag,err,error,*999)

    EXITS("cmfe_Mesh_SurroundingElementsCalculateSetObj")
    RETURN
999 ERRORS("cmfe_Mesh_SurroundingElementsCalculateSetObj",err,error)
    EXITS("cmfe_Mesh_SurroundingElementsCalculateSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_SurroundingElementsCalculateSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of elements in a mesh identified by a user number.
  SUBROUTINE cmfe_Mesh_NumberOfElementsGetNumber(regionUserNumber,meshUserNumber,numberOfElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements !<On return, the number of elements in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Mesh_NumberOfElementsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_NUMBER_OF_ELEMENTS_GET(MESH,numberOfElements,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Mesh_NumberOfElementsGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NumberOfElementsGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NumberOfElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of elements in a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_NumberOfElementsGetObj(mesh,numberOfElements,err)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements !<On return, the number of elements in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_NumberOfElementsGetObj",err,error,*999)

    CALL MESH_NUMBER_OF_ELEMENTS_GET(mesh%mesh,numberOfElements,err,error,*999)

    EXITS("cmfe_Mesh_NumberOfElementsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NumberOfElementsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NumberOfElementsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements in a mesh identified by a user number.
  SUBROUTINE cmfe_Mesh_NumberOfElementsSetNumber(regionUserNumber,meshUserNumber,numberOfElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements !<The number of elements in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Mesh_NumberOfElementsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_NUMBER_OF_ELEMENTS_SET(MESH,numberOfElements,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Mesh_NumberOfElementsSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NumberOfElementsSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NumberOfElementsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements in a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_NumberOfElementsSetObj(mesh,numberOfElements,err)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements !<The number of elements in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_NumberOfElementsSetObj",err,error,*999)

    CALL MESH_NUMBER_OF_ELEMENTS_SET(mesh%mesh,numberOfElements,err,error,*999)

    EXITS("cmfe_Mesh_NumberOfElementsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NumberOfElementsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NumberOfElementsSetObj
  
  !
  !================================================================================================================================
  !
  
  !>Calculate mesh data points topology in a region identified by a user number based on projection
  SUBROUTINE cmfe_Mesh_TopologyDataPointsCalculateProjectionRegionNumber(regionUserNumber,MeshUserNumber, &
      & DataProjection,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: DataProjection !<The data projection
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("cmfe_Mesh_TopologyDataPointsCalculateProjectionRegionNumber",err,error,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MeshTopologyDataPointsCalculateProjection(MESH,DataProjection%dataProjection,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(MeshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Mesh_TopologyDataPointsCalculateProjectionRegionNumber")
    RETURN
999 ERRORS("cmfe_Mesh_TopologyDataPointsCalculateProjectionRegionNumber",err,error)
    EXITS("cmfe_Mesh_TopologyDataPointsCalculateProjectionRegionNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_Mesh_TopologyDataPointsCalculateProjectionRegionNumber
  
  !  
  !================================================================================================================================
  !  

  !>Calculate mesh data points topology in an interface identified by a user number based on projection
  SUBROUTINE cmfe_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber(parentRegionUserNumber,interfaceUserNumber, &
      & MeshUserNumber,DataProjection,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentregionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: DataProjection !<The data projection
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(VARYING_STRING) :: localError
    
    ENTERS("cmfe_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber",err,error,*999)
 
    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(parentregionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL MESH_USER_NUMBER_FIND(MeshUserNumber,INTERFACE,MESH,err,error,*999)
        IF(ASSOCIATED(MESH)) THEN
          CALL MeshTopologyDataPointsCalculateProjection(MESH,DataProjection%dataProjection,err,error,*999)        
        ELSE
          localError="A mesh with an user number of "//TRIM(NumberToVString(MeshUserNumber,"*",err,error))// &
            & " does not exist on the region with an user number of "//TRIM(NumberToVString(parentregionUserNumber, &
            & "*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentregionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber")
    RETURN
999 ERRORS("cmfe_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber",err,error)
    EXITS("cmfe_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_Mesh_TopologyDataPointsCalculateProjectionInterfaceNumber
  
  !  
  !================================================================================================================================
  !  
  
  !>Calculate mesh data points topology identified by object based on projection
  SUBROUTINE cmfe_Mesh_TopologyDataPointsCalculateProjectionObj(Mesh,DataProjection,err)
  
  !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: Mesh !<The mesh to calculate data points topology for
    TYPE(cmfe_DataProjectionType), INTENT(IN) :: DataProjection !<The data projection
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    ENTERS("cmfe_Mesh_TopologyDataPointsCalculateProjectionObj",err,error,*999)
    
    CALL MeshTopologyDataPointsCalculateProjection(Mesh%mesh,DataProjection%dataProjection,err,error,*999)
 
    EXITS("cmfe_Mesh_TopologyDataPointsCalculateProjectionObj")
    RETURN
999 ERRORS("cmfe_Mesh_TopologyDataPointsCalculateProjectionObj",err,error)
    EXITS("cmfe_Mesh_TopologyDataPointsCalculateProjectionObj")
    CALL cmfe_HandleError(Err,error)
    RETURN
    
  END SUBROUTINE cmfe_Mesh_TopologyDataPointsCalculateProjectionObj

  !
  !================================================================================================================================
  !

  !>Finishes creating elements for a mesh component of a mesh identified by a user number.
  SUBROUTINE cmfe_MeshElements_CreateFinishNumber(regionUserNumber,meshUserNumber,meshComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_MeshElements_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_CREATE_FINISH(MESH_ELEMENTS,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshElements_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes creating elements for a mesh component of a mesh identified by an object.
  SUBROUTINE cmfe_MeshElements_CreateFinishObj(meshElements,err)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_CreateFinishObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_CREATE_FINISH(meshElements%meshElements,err,error,*999)

    EXITS("cmfe_MeshElements_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts creating elements for a mesh component of a mesh identified by a user number.
  SUBROUTINE cmfe_MeshElements_CreateStartNumber(regionUserNumber,meshUserNumber,meshComponentNumber,basisUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the default basis to use for the elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_MeshElements_CreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(BASIS)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL BASIS_USER_NUMBER_FIND(basisUserNumber,BASIS,err,error,*999)
        IF(ASSOCIATED(BASIS)) THEN
          CALL MESH_TOPOLOGY_ELEMENTS_CREATE_START(MESH,meshComponentNumber,BASIS,MESH_ELEMENTS,err,error,*999)
        ELSE
          localError="A basis with an user number of "//TRIM(NumberToVString(basisUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshElements_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts creating elements for a mesh component of a mesh identified by an object.
  SUBROUTINE cmfe_MeshElements_CreateStartObj(mesh,meshComponentNumber,basis,meshElements,err)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(INOUT) :: mesh !<The mesh to start the creation of elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the mesh to start creating the elements for.
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The default basis to use for the elements.
    TYPE(cmfe_MeshElementsType), INTENT(INOUT) :: meshElements !<On return, the created mesh elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_CreateStartObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_CREATE_START(mesh%mesh,meshComponentNumber,basis%basis,meshElements%meshElements,err,error,*999)

    EXITS("cmfe_MeshElements_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh elements for a mesh component on a mesh identified by an user number.
  SUBROUTINE cmfe_Mesh_ElementsGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,meshElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the elements for.
    TYPE(cmfe_MeshElementsType), INTENT(INOUT) :: meshElements !<The mesh elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Mesh_ElementsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,meshElements%meshElements,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Mesh_ElementsGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_ElementsGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_ElementsGetNumber


  !
  !================================================================================================================================
  !

  !>Returns the mesh elements for a mesh component on a mesh identified by an
  !user number.
  SUBROUTINE cmfe_Mesh_ElementsGetObj(mesh,meshComponentNumber,meshElements,err)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to get the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the elements for.
    TYPE(cmfe_MeshElementsType), INTENT(INOUT) :: meshElements !<The mesh elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables

    ENTERS("cmfe_Mesh_ElementsGetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_GET(mesh%mesh,meshComponentNumber,meshElements%meshElements,err,error,*999)

    EXITS("cmfe_Mesh_ElementsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_ElementsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_ElementsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the basis for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE cmfe_MeshElements_BasisGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,globalElementNumber, &
    & basisUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the basis for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the basis for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the basis for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to get the basis for.
    INTEGER(INTG), INTENT(OUT) :: basisUserNumber !<On return, the user number of the basis for the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_MeshElements_BasisGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    NULLIFY(BASIS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_BASIS_GET(globalElementNumber,MESH_ELEMENTS,BASIS,err,error,*999)
        IF(ASSOCIATED(BASIS)) THEN
          basisUserNumber = BASIS%USER_NUMBER
        ELSE
          localError="The basis is not associated for global element number "// &
            & TRIM(NumberToVString(globalElementNumber,"*",err,error))//" of mesh component number "// &
            & TRIM(NumberToVString(meshComponentNumber,"*",err,error))//" from the mesh with a user number of "//&
            & TRIM(NumberToVString(meshUserNumber,"*",err,error))//" in the region with a user number of "// &
            & TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshElements_BasisGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_BasisGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_BasisGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the basis for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE cmfe_MeshElements_BasisGetObj(meshElements,globalElementNumber,basis,err)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to get the basis for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to get the basis for.
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<On return, the basis for the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_BasisGetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_BASIS_GET(globalElementNumber,meshElements%meshElements,basis%basis,err,error,*999)

    EXITS("cmfe_MeshElements_BasisGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_BasisGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_BasisGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE cmfe_MeshElements_BasisSetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,globalElementNumber, &
    & basisUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the basis for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the basis for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis for the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_MeshElements_BasisSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    NULLIFY(BASIS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL BASIS_USER_NUMBER_FIND(basisUserNumber,BASIS,err,error,*999)
        IF(ASSOCIATED(BASIS)) THEN
          CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_BASIS_SET(globalElementNumber,MESH_ELEMENTS,BASIS,err,error,*999)
        ELSE
          localError="A basis with an user number of "//TRIM(NumberToVString(basisUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshElements_BasisSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_BasisSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_BasisSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE cmfe_MeshElements_BasisSetObj(meshElements,globalElementNumber,basis,err)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the basis for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the basis for.
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis for the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_BasisSetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_BASIS_SET(globalElementNumber,meshElements%meshElements,basis%basis,err,error,*999)

    EXITS("cmfe_MeshElements_BasisSetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_BasisSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_BasisSetObj

  !
  !================================================================================================================================
  !

  !>Returns the adjacent element number of a mesh identified by a user number
  SUBROUTINE cmfe_MeshElements_AdjacentElementGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,globalElementNumber, &
    & adjacentElementXi,adjacentElement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh from which to get the adjacent element from.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh from which to get the adjacent element from.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number from which to get adjacent element number from.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to get the adjacent element number for. !\todo this should be a user number
    INTEGER(INTG), INTENT(IN) :: adjacentElementXi !<The xi coordinate direction to get the adjacent element for. Note that -xiCoordinateDirection gives the adjacent element before the element in the xiCoordinateDirection'th direction and +xiCoordinateDirection gives the adjacent element after the element in the xiCoordinateDirection'th direction. The xiCoordinateDirection=0 index will give the information on the current element.
    INTEGER(INTG), INTENT(OUT) :: adjacentElement !<On return, the adjacent element number in the specified xi coordinate direction. Return 0 if the specified element has no adjacent elements in the specified xi coordinate direction.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_MeshElements_AdjacentElementGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ADJACENT_ELEMENT_GET(globalElementNumber,MESH_ELEMENTS,adjacentElementXi,adjacentElement, &
          & err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshElements_AdjacentElementGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_AdjacentElementGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_AdjacentElementGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the adjacent element number of a mesh identified by an object.
  SUBROUTINE cmfe_MeshElements_AdjacentElementGetObj(meshElements,globalElementNumber,adjacentElementXi,adjacentElement,err)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements from which to get the adjacent element for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to get the adjacent element for !\todo this should be a user number
    INTEGER(INTG), INTENT(IN) :: adjacentElementXi !<The xi coordinate direction to get the adjacent element for  Note that -xiCoordinateDirection gives the adjacent element before the element in the xiCoordinateDirection'th direction and +xiCoordinateDirection gives the adjacent element after the element in the xiCoordinateDirection'th direction. The xiCoordinateDirection=0 index will give the information on the current element.
    INTEGER(INTG), INTENT(OUT) :: adjacentElement !<On return, the adjacent element number in the specified xi coordinate direction. Return 0 if the specified element has no adjacent elements in the specified xi coordinate direction.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_AdjacentElementGetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ADJACENT_ELEMENT_GET(globalElementNumber,meshElements%meshElements,adjacentElementXi, &
      & adjacentElement,err,error,*999)

    EXITS("cmfe_MeshElements_AdjacentElementGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_AdjacentElementGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_AdjacentElementGetObj

  !
  !================================================================================================================================
  !

  !>Returns the element nodes for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE cmfe_MeshElements_NodesGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,globalElementNumber, &
    & elementUserNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to get the element nodes for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNodes(:) !<elementUserNodes(i). On return, the user node number number of the i'th element node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_MeshElements_NodesGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODES_GET(globalElementNumber,MESH_ELEMENTS,elementUserNodes,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshElements_NodesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_NodesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_NodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the element nodes for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE cmfe_MeshElements_NodesGetObj(meshElements,globalElementNumber,elementUserNodes,err)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to get the element nodes for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNodes(:) !<elementUserNodes(i). On return, the user node number number of the i'th element node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_NodesGetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODES_GET(globalElementNumber,meshElements%meshElements,elementUserNodes,err,error,*999)

    EXITS("cmfe_MeshElements_NodesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_NodesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_NodesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE cmfe_MeshElements_NodesSetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,globalElementNumber, &
    & elementUserNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementUserNodes(:) !<elementUserNodes(i). The user node number number of the i'th element node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_MeshElements_NodesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODES_SET(globalElementNumber,MESH_ELEMENTS,elementUserNodes,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshElements_NodesSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_NodesSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_NodesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE cmfe_MeshElements_NodesSetObj(meshElements,globalElementNumber,elementUserNodes,err)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementUserNodes(:) !<elementUserNodes(i). The user node number number of the i'th element node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_NodesSetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODES_SET(globalElementNumber,meshElements%meshElements,elementUserNodes,err,error,*999)

    EXITS("cmfe_MeshElements_NodesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_NodesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_NodesSetObj


  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE cmfe_MeshElements_UserNodeVersionSetNumber(regionUserNumber,meshUserNumber,globalElementNumber,versionNumber, &
    & derivativeNumber,userNodeNumber,meshComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to set a version for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element nodes for.

    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: localelementnode
    LOGICAL :: FOUND

    ENTERS("cmfe_MeshElements_UserNodeVersionSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        FOUND=.FALSE.
        DO localelementnode=1,MESH_ELEMENTS%ELEMENTS(globalElementNumber)%basis%NUMBER_OF_NODES
          IF(MESH_ELEMENTS%ELEMENTS(globalElementNumber)%USER_ELEMENT_NODES(localelementnode)==userNodeNumber) THEN
            FOUND=.TRUE.
            EXIT
          END IF
        END DO !localelementnode
        IF(FOUND) THEN
          CALL MeshElements_ElementNodeVersionSet(globalElementNumber,MESH_ELEMENTS,versionNumber,derivativeNumber, &
            & localelementnode,err,error,*999)
        ELSE
          localError="User node number "//TRIM(NumberToVString(userNodeNumber,"*",err,error))// &
            & " does not exist in element number "//TRIM(NumberToVString(globalElementNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshElements_UserNodeVersionSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_UserNodeVersionSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_UserNodeVersionSetNumber

  !
  !================================================================================================================================
   !

  !>Sets/changes the element nodes for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE cmfe_MeshElements_UserNodeVersionSetObj(meshElements,globalElementNumber,versionNumber,derivativeNumber, &
    & userNodeNumber,err)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to set a version for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: localelementnode
    LOGICAL :: FOUND

    ENTERS("cmfe_MeshElements_UserNodeVersionSetObj",err,error,*999)

    FOUND=.FALSE.
    DO localelementnode=1,meshElements%meshElements%ELEMENTS(globalElementNumber)%basis%NUMBER_OF_NODES
      IF(meshElements%meshElements%ELEMENTS(globalElementNumber)%USER_ELEMENT_NODES(localelementnode)==userNodeNumber) THEN
        FOUND=.TRUE.
        EXIT
      END IF
    END DO !localelementnode
    IF(FOUND) THEN
      CALL MeshElements_ElementNodeVersionSet(globalElementNumber,meshElements%meshElements,versionNumber, &
         & derivativeNumber,localelementnode,err,error,*999)
    ELSE
      localError="User node number "//TRIM(NumberToVString(userNodeNumber,"*",err,error))// &
        & " does not exist in element number "//TRIM(NumberToVString(globalElementNumber,"*",err,error))//"."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshElements_UserNodeVersionSetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_UserNodeVersionSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_UserNodeVersionSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE cmfe_MeshElements_LocalElementNodeVersionSetNumber(regionUserNumber,meshUserNumber,globalElementNumber,versionNumber, &
    & derivativeNumber,localElementNodeNumber,meshComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: localElementNodeNumber !<The local element node to set a version for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element nodes for.

    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_MeshElements_LocalElementNodeVersionSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MeshElements_ElementNodeVersionSet(globalElementNumber,MESH_ELEMENTS,versionNumber,derivativeNumber, &
          & localElementNodeNumber,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshElements_LocalElementNodeVersionSetNumber")
    RETURN
999 ERRORS("cmfe_MeshElements_LocalElementNodeVersionSetNumber",err,error)
    EXITS("cmfe_MeshElements_LocalElementNodeVersionSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_LocalElementNodeVersionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE cmfe_MeshElements_LocalElementNodeVersionSetObj(meshElements,globalElementNumber,versionNumber,derivativeNumber, &
    & localElementNodeNumber,err)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: localElementNodeNumber !<The local element node to set a version for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_LocalElementNodeVersionSetObj",err,error,*999)

    CALL MeshElements_ElementNodeVersionSet(globalElementNumber,meshElements%meshElements,versionNumber, &
       & derivativeNumber,localElementNodeNumber,err,error,*999)

    EXITS("cmfe_MeshElements_LocalElementNodeVersionSetObj")
    RETURN
999 ERRORS("cmfe_MeshElements_LocalElementNodeVersionSetObj",err,error)
    EXITS("cmfe_MeshElements_LocalElementNodeVersionSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_LocalElementNodeVersionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the user number for an element in a mesh identified by an user number.
  SUBROUTINE cmfe_MeshElements_UserNumberGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,elementGlobalNumber, &
    & elementUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to get the element user number for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNumber !<On return, the element user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_MeshElements_UserNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MeshElements_ElementUserNumberGet(elementGlobalNumber,elementUserNumber,MESH_ELEMENTS,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshElements_UserNumberGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_UserNumberGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_UserNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the element user number for an element in a mesh identified by an object.
  SUBROUTINE cmfe_MeshElements_UserNumberGetObj(meshElements,elementGlobalNumber,elementUserNumber,err)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to get the element user number for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNumber !<On return, the element user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_UserNumberGetObj",err,error,*999)

    CALL MeshElements_ElementUserNumberGet(elementGlobalNumber,elementUserNumber,meshElements%meshElements, &
      & err,error,*999)

    EXITS("cmfe_MeshElements_UserNumberGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_UserNumberGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_UserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for an element in a mesh identified by an user number.
  SUBROUTINE cmfe_MeshElements_UserNumberSetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,elementGlobalNumber, &
    & elementUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The element user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_MeshElements_UserNumberSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MeshElements_ElementUserNumberSet(elementGlobalNumber,elementUserNumber,MESH_ELEMENTS,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshElements_UserNumberSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_UserNumberSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_UserNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element user number for an element in a mesh identified by an object.
  SUBROUTINE cmfe_MeshElements_UserNumberSetObj(meshElements,elementGlobalNumber,elementUserNumber,err)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The element user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_UserNumberSetObj",err,error,*999)

    CALL MeshElements_ElementUserNumberSet(elementGlobalNumber,elementUserNumber,meshElements%meshElements, &
      & err,error,*999)

    EXITS("cmfe_MeshElements_UserNumberSetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_UserNumberSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_UserNumberSetObj
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the user numbers for all elements in a mesh identified by an user number.
  SUBROUTINE cmfe_MeshElements_UserNumbersAllSetNumber(regionUserNumber,meshUserNumber,meshComponentNumber, &
    & elementUserNumbers,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element user numbers for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element user numbers for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element user numbers for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumbers(:) !<The element user numbers to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_MeshElements_UserNumbersAllSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MeshTopologyElementsUserNumbersAllSet(MESH_ELEMENTS,elementUserNumbers,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshElements_UserNumbersAllSetNumber")
    RETURN
999 ERRORS("cmfe_MeshElements_AllUserNumbersAllSetNumber",err,error)
    EXITS("cmfe_MeshElements_AllUserNumbersAllSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_UserNumbersAllSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element user numbers for all elements in a mesh identified by an object.
  SUBROUTINE cmfe_MeshElements_UserNumbersAllSetObj(meshElements,elementUserNumbers,err)

    !Argument variables
    TYPE(cmfe_MeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element user numbers for
    INTEGER(INTG), INTENT(IN) :: elementUserNumbers(:) !<The element user numbers to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshElements_UserNumbersAllSetObj",err,error,*999)

    CALL MeshTopologyElementsUserNumbersAllSet(meshElements%meshElements,elementUserNumbers, &
      & err,error,*999)

    EXITS("cmfe_MeshElements_UserNumbersAllSetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshElements_UserNumbersAllSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshElements_UserNumbersAllSetObj

  !
  !================================================================================================================================
  !


  !>Checks if the given node exists on the given mesh component.
  SUBROUTINE cmfe_Mesh_NodeExistsNumber( regionUserNumber, meshUserNumber, meshComponentNumber, nodeUserNumber, nodeExists, err )

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to check the node for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh tocheck the node for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the node for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to check.
    LOGICAL, INTENT(OUT) :: nodeExists !<True if the node exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(REGION_TYPE), POINTER :: region
    INTEGER(INTG) :: meshNodeNumber
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Mesh_NodeExistsNumber",err,error,*999)

    nodeExists = .FALSE.

    NULLIFY( region )
    NULLIFY( mesh )
    CALL REGION_USER_NUMBER_FIND( regionUserNumber, Region, err, error, *999 )
    IF(ASSOCIATED(region)) THEN
      CALL MESH_USER_NUMBER_FIND( meshUserNumber, Region, Mesh, err, error, *999 )
      IF( ASSOCIATED( mesh ) ) THEN
        CALL MeshTopologyNodeCheckExists(Mesh,meshComponentNumber,nodeUserNumber,nodeExists,meshNodeNumber,err,error,*999)
      ELSE
        LocalError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(LocalError,err,error,*999)
      END IF
    ELSE
      LocalError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LocalError,err,error,*999)
    END IF

    EXITS("cmfe_Mesh_NodeExistsNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NodeExistsNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NodeExistsNumber

  !
  !================================================================================================================================
  !

  !>Checks if the given node exists on the given mesh component.
  SUBROUTINE cmfe_Mesh_NodeExistsObj( mesh, meshComponentNumber, nodeUserNumber, nodeExists, err )

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to check the node for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the node for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to check.
    LOGICAL, INTENT(OUT) :: nodeExists !<True if the node exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: meshNodeNumber

    nodeExists = .FALSE.

    ENTERS("cmfe_Mesh_NodeExistsObj",err,error,*999)

    CALL MeshTopologyNodeCheckExists(mesh%mesh,meshComponentNumber,nodeUserNumber,nodeExists,meshNodeNumber,err,error,*999)

    EXITS("cmfe_Mesh_NodeExistsObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NodeExistsObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NodeExistsObj

  !
  !================================================================================================================================
  !

  !>Checks if the given element exists on the given mesh component.
  SUBROUTINE cmfe_Mesh_ElementExistsNumber( regionUserNumber, meshUserNumber, meshComponentNumber, &
    & elementUserNumber, elementExists, err )

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to check the element for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to check the element for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the element for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to check.
    LOGICAL, INTENT(OUT) :: elementExists !<True if the element exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables
    TYPE(MESH_TYPE), POINTER :: Mesh
    TYPE(REGION_TYPE), POINTER :: Region
    INTEGER(INTG) :: meshElementNumber
    TYPE(VARYING_STRING) :: LocalError

    ENTERS("cmfe_Mesh_ElementExistsNumber",err,error,*999)

    elementExists = .FALSE.

    NULLIFY( Region )
    NULLIFY( Mesh )
    CALL REGION_USER_NUMBER_FIND( regionUserNumber, Region, err, error, *999 )
    IF( ASSOCIATED( REGION ) ) THEN
      CALL MESH_USER_NUMBER_FIND( meshUserNumber, Region, Mesh, err, error, *999 )
      IF( ASSOCIATED( MESH ) ) THEN
        CALL MeshTopologyElementCheckExists(Mesh,meshComponentNumber,elementUserNumber,elementExists, &
          & meshElementNumber,err,error,*999)
      ELSE
        LocalError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(LocalError,err,error,*999)
      END IF
    ELSE
      LocalError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LocalError,err,error,*999)
    END IF

    EXITS("cmfe_Mesh_ElementExistsNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_ElementExistsNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_ElementExistsNumber

  !
  !================================================================================================================================
  !

  !>Checks if the given element exists on the given mesh component.
  SUBROUTINE cmfe_Mesh_ElementExistsObj( mesh, meshComponentNumber, elementUserNumber, elementExists, err )

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to check the node for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the element for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to check.
    LOGICAL, INTENT(OUT) :: elementExists !<True if the element exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables
    INTEGER(INTG) :: meshElementNumber

    ENTERS("cmfe_Mesh_ElementExistsObj",err,error,*999)

    elementExists = .FALSE.

    CALL MeshTopologyElementCheckExists(mesh%mesh,meshComponentNumber,elementUserNumber,elementExists,meshElementNumber, &
      & err,error,*999)

    EXITS("cmfe_Mesh_ElementExistsObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_ElementExistsObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_ElementExistsObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh nodes for a mesh component on a mesh identified by an user number.
  SUBROUTINE cmfe_Mesh_NodesGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,meshNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the nodes for.
    TYPE(cmfe_MeshNodesType), INTENT(INOUT) :: meshNodes !<On return, the mesh nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Mesh_NodesGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(mesh)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,region,mesh,err,error,*999)
      IF(ASSOCIATED(mesh)) THEN
        CALL MeshTopologyNodesGet(mesh,meshComponentNumber,meshNodes%meshNodes,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Mesh_NodesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NodesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NodesGetNumber


  !
  !================================================================================================================================
  !

  !>Returns the mesh nodes for a mesh component on a mesh identified by an object.
  SUBROUTINE cmfe_Mesh_NodesGetObj(mesh,meshComponentNumber,meshNodes,err)

    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to get the nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the nodes for.
    TYPE(cmfe_MeshNodesType), INTENT(INOUT) :: meshNodes!<On return, the mesh nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Mesh_NodesGetObj",err,error,*999)

    CALL MeshTopologyNodesGet(mesh%mesh,meshComponentNumber,meshNodes%meshNodes,err,error,*999)

    EXITS("cmfe_Mesh_NodesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Mesh_NodesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Mesh_NodesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of nodes at a node in a mesh identified by an user number. 
  SUBROUTINE cmfe_MeshNodes_NumberOfNodesGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,numberOfNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of dervatives for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the number of nodes for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<On return, the number of nodes in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_MeshNodes_NumberOfNodesGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshNodes)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,region,mesh,err,error,*999)
      IF(ASSOCIATED(mesh)) THEN
        CALL MeshTopologyNodesGet(mesh,meshComponentNumber,meshNodes,err,error,*999)
        CALL MeshTopologyNodesNumberOfNodesGet(meshNodes,numberOfNodes,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshNodes_NumberOfNodesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_NumberOfNodesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_NumberOfNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of derivatives for a node in a mesh identified by an object.
  SUBROUTINE cmfe_MeshNodes_NumberOfNodesGetObj(meshNodes,numberOfNodes,err)

    !Argument variables
    TYPE(cmfe_MeshNodesType), INTENT(IN) :: meshNodes!<The mesh nodes to get the number of derivatives at a node for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes!<On return, the number of nodes in a mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshNodes_NumberOfNodesGetObj",err,error,*999)

    CALL MeshTopologyNodesNumberOfNodesGet(meshNodes%meshNodes,numberOfNodes,err,error,*999)

    EXITS("cmfe_MeshNodes_NumberOfNodesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_NumberOfNodesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN
    
  END SUBROUTINE cmfe_MeshNodes_NumberOfNodesGetObj

  !
  !================================================================================================================================
  !
  !>Returns the number of derivatives at a node in a mesh identified by an user number. 
  SUBROUTINE cmfe_MeshNodes_NumberOfDerivativesGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,userNodeNumber, &
    & numberOfDerivatives,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of dervatives for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of derivatives for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the number of derivatives for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the number of derivatives for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDerivatives !<On return, the number of derivatives in the mesh for the user node number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_MeshNodes_NumberOfDerivativesGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshNodes)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,region,mesh,err,error,*999)
      IF(ASSOCIATED(mesh)) THEN
        CALL MeshTopologyNodesGet(mesh,meshComponentNumber,meshNodes,err,error,*999)
        CALL MeshTopologyNodeNumberOfDerivativesGet(meshNodes,userNodeNumber,numberOfDerivatives,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshNodes_NumberOfDerivativesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_NumberOfDerivativesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_NumberOfDerivativesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of derivatives for a node in a mesh identified by an object.
  SUBROUTINE cmfe_MeshNodes_NumberOfDerivativesGetObj(meshNodes,userNodeNumber,numberOfDerivatives,err)

    !Argument variables
    TYPE(cmfe_MeshNodesType), INTENT(IN) :: meshNodes!<The mesh nodes to get the number of derivatives at a node for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the number of derivatives at a node for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDerivatives!<On return, the number of derivatives at a node in a mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshNodes_NumberOfDerivativesGetObj",err,error,*999)

    CALL MeshTopologyNodeNumberOfDerivativesGet(meshNodes%meshNodes,userNodeNumber,numberOfDerivatives,err,error,*999)

    EXITS("cmfe_MeshNodes_NumberOfDerivativesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_NumberOfDerivativesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_NumberOfDerivativesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the derivatives at a node in a mesh identified by an user number. 
  SUBROUTINE cmfe_MeshNodes_DerivativesGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,userNodeNumber, &
    & derivatives,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the derivatives for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the derivatives for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the derivatives for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the derivatives for.
    INTEGER(INTG), INTENT(OUT) :: derivatives(:) !<On return, the derivatives in the mesh for the user node number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_MeshNodes_DerivativesGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshNodes)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,region,mesh,err,error,*999)
      IF(ASSOCIATED(mesh)) THEN
        CALL MeshTopologyNodesGet(mesh,meshComponentNumber,meshNodes,err,error,*999)
        CALL MeshTopologyNodeDerivativesGet(meshNodes,userNodeNumber,derivatives,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshNodes_DerivativesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_DerivativesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_DerivativesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the derivatives for a node in a mesh identified by an object.
  SUBROUTINE cmfe_MeshNodes_DerivativesGetObj(meshNodes,userNodeNumber,derivatives,err)

    !Argument variables
    TYPE(cmfe_MeshNodesType), INTENT(IN) :: meshNodes!<The mesh nodes to get the derivatives at a node for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the derivatives at a node for.
    INTEGER(INTG), INTENT(OUT) :: derivatives(:) !<On return, the derivatives at a node in a mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshNodes_DerivativesGetObj",err,error,*999)

    CALL MeshTopologyNodeDerivativesGet(meshNodes%meshNodes,userNodeNumber,derivatives,err,error,*999)

    EXITS("cmfe_MeshNodes_DerivativesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_DerivativesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_DerivativesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of version at a derivative for a node in a mesh identified by an user number. 
  SUBROUTINE cmfe_MeshNodes_NumberOfVersionsGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,derivativeNumber, &
    & userNodeNumber,numberOfVersions,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of versions.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of versions for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the number of versions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the node to get the number of versions for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the number of versions for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVersions !<On return, the number of versions in the mesh for the derivative index of the user node number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_MeshNodes_NumberOfVersionsGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshNodes)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,region,mesh,err,error,*999)
      IF(ASSOCIATED(mesh)) THEN
        CALL MeshTopologyNodesGet(mesh,meshComponentNumber,meshNodes,err,error,*999)
        CALL MeshTopologyNodeNumberOfVersionsGet(meshnodes,derivativeNumber,userNodeNumber,numberOfVersions,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_MeshNodes_NumberOfVersionsGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_NumberOfVersionsGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_NumberOfVersionsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of versions for an node in a mesh identified by an object.
  SUBROUTINE cmfe_MeshNodes_NumberOfVersionsGetObj(meshNodes,derivativeNumber,userNodeNumber,numberOfVersions,err)

    !Argument variables
    TYPE(cmfe_MeshNodesType), INTENT(IN) :: meshNodes !<The mesh nodes to get the number of versions at a node for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of a node to get the number of versions for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the number of versions at a node for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVersions !<On return, the number of derivatives at the specified node and derivative in a mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_MeshNodes_NumberOfVersionsGetObj",err,error,*999)

    CALL MeshTopologyNodeNumberOfVersionsGet(meshNodes%meshNodes,derivativeNumber,userNodeNumber, &
      & numberOfVersions,err,error,*999)

    EXITS("cmfe_MeshNodes_NumberOfVersionsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_MeshNodes_NumberOfVersionsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_MeshNodes_NumberOfVersionsGetObj

!!==================================================================================================================================
!!
!! DISTRIBUTED_MATRIX_VECTOR
!!
!!==================================================================================================================================

  !>Get the storage type for a distributed matrix
  SUBROUTINE cmfe_DistributedMatrix_StorageTypeGetObj(matrix,storageType,err)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the storage type for
    INTEGER(INTG), INTENT(OUT) :: storageType !<On return, the matrix storage type. \see OPENCMISS_MatrixStorageTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_StorageTypeGetObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_STORAGE_TYPE_GET(matrix%distributedMatrix,storageType,err,error,*999)

    EXITS("cmfe_DistributedMatrix_StorageTypeGetObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_StorageTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_StorageTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get the data type of a distributed matrix
  SUBROUTINE cmfe_DistributedMatrix_DataTypeGetObj(matrix,dataType,err)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data type for
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the matrix data type. \see OPENCMISS_MatrixVectorDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataTypeGetObj",err,error,*999)

    CALL DistributedMatrix_DataTypeGet(matrix%distributedMatrix,dataType,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataTypeGetObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get the dimensions of a distributed matrix on this computational node
  SUBROUTINE cmfe_DistributedMatrix_DimensionsGetObj(matrix,m,n,err)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data type for
    INTEGER(INTG), INTENT(OUT) :: m !<On return, the number of rows for this computational node
    INTEGER(INTG), INTENT(OUT) :: n !<On return, the number of columns
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DimensionsGetObj",err,error,*999)

    CALL DistributedMatrix_DimensionsGet(matrix%distributedMatrix,m,n,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DimensionsGetObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DimensionsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DimensionsGetObj

  !
  !================================================================================================================================
  !

  !>Get the row indices and column indices for a sparse matrix
  SUBROUTINE cmfe_DistributedMatrix_StorageLocationsGetObj(matrix,rowIndices,columnIndices,err)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the storage locations for
    INTEGER(INTG), POINTER, INTENT(OUT) :: rowIndices(:) !<On return, the matrix storage row indices
    INTEGER(INTG), POINTER, INTENT(OUT) :: columnIndices(:) !<On return, the matrix storage column indices
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_StorageLocationsGetObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_STORAGE_LOCATIONS_GET(matrix%distributedMatrix,rowIndices,columnIndices,err,error,*999)

    EXITS("cmfe_DistributedMatrix_StorageLocationsGetObj")

    RETURN
999 ERRORS("cmfe_DistributedMatrix_StorageLocationsGetObj",err,error)
    EXITS("cmfe_DistributedMatrix_StorageLocationsGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_StorageLocationsGetObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this matrix on this computational node
  SUBROUTINE cmfe_DistributedMatrix_DataGetIntgObj(matrix,data,err)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data for
    INTEGER(INTG), POINTER, INTENT(OUT) :: data(:) !<On return, the matrix data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataGetIntgObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_DATA_GET(matrix%distributedMatrix,data,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataGetIntgObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataGetIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataGetIntgObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this matrix once it has finished being used
  SUBROUTINE cmfe_DistributedMatrix_DataRestoreIntgObj(matrix,data,err)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to restore the data for
    INTEGER(INTG), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the matrix data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataRestoreIntgObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_DATA_RESTORE(matrix%distributedMatrix,data,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataRestoreIntgObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataRestoreIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataRestoreIntgObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this matrix on this computational node
  SUBROUTINE cmfe_DistributedMatrix_DataGetDPObj(matrix,data,err)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data for
    REAL(DP), POINTER, INTENT(OUT) :: data(:) !<On return, the matrix data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataGetDPObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_DATA_GET(matrix%distributedMatrix,data,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataGetDPObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataGetDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataGetDPObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this matrix once it has finished being used
  SUBROUTINE cmfe_DistributedMatrix_DataRestoreDPObj(matrix,data,err)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to restore the data for
    REAL(DP), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the matrix data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataRestoreDPObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_DATA_RESTORE(matrix%distributedMatrix,data,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataRestoreDPObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataRestoreDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataRestoreDPObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this matrix on this computational node
  SUBROUTINE cmfe_DistributedMatrix_DataGetSPObj(matrix,data,err)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data for
    REAL(SP), POINTER, INTENT(OUT) :: data(:) !<On return, the matrix data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataGetSPObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_DATA_GET(matrix%distributedMatrix,data,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataGetSPObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataGetSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataGetSPObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this matrix once it has finished being used
  SUBROUTINE cmfe_DistributedMatrix_DataRestoreSPObj(matrix,data,err)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to restore the data for
    REAL(SP), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the matrix data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataRestoreSPObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_DATA_RESTORE(matrix%distributedMatrix,data,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataRestoreSPObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataRestoreSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataRestoreSPObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this matrix on this computational node
  SUBROUTINE cmfe_DistributedMatrix_DataGetLObj(matrix,data,err)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data for
    LOGICAL, POINTER, INTENT(OUT) :: data(:) !<On return, the matrix data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataGetLObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_DATA_GET(matrix%distributedMatrix,data,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataGetLObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataGetLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataGetLObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this matrix once it has finished being used
  SUBROUTINE cmfe_DistributedMatrix_DataRestoreLObj(matrix,data,err)

    !Argument variables
    TYPE(cmfe_DistributedMatrixType), INTENT(IN) :: matrix !<The matrix to restore the data for
    LOGICAL, POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the matrix data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedMatrix_DataRestoreLObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_DATA_RESTORE(matrix%distributedMatrix,data,err,error,*999)

    EXITS("cmfe_DistributedMatrix_DataRestoreLObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedMatrix_DataRestoreLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedMatrix_DataRestoreLObj

  !
  !================================================================================================================================
  !

  !>Get the data type of a distributed vector
  SUBROUTINE cmfe_DistributedVector_DataTypeGetObj(vector,dataType,err)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to get the data type for
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the vector data type. \see OPENCMISS_MatrixVectorDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataTypeGetObj",err,error,*999)

    CALL DistributedVector_DataTypeGet(vector%distributedVector,dataType,err,error,*999)

    EXITS("cmfe_DistributedVector_DataTypeGetObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this vector on this computational node
  SUBROUTINE cmfe_DistributedVector_DataGetIntgObj(vector,data,err)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to get the data for
    INTEGER(INTG), POINTER, INTENT(OUT) :: data(:) !<On return, the vector data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataGetIntgObj",err,error,*999)

    CALL DISTRIBUTED_VECTOR_DATA_GET(vector%distributedVector,data,err,error,*999)

    EXITS("cmfe_DistributedVector_DataGetIntgObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataGetIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataGetIntgObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this vector once it has finished being used
  SUBROUTINE cmfe_DistributedVector_DataRestoreIntgObj(vector,data,err)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to restore the data for
    INTEGER(INTG), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the vector data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataRestoreIntgObj",err,error,*999)

    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(vector%distributedVector,data,err,error,*999)

    EXITS("cmfe_DistributedVector_DataRestoreIntgObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataRestoreIntgObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataRestoreIntgObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this vector on this computational node
  SUBROUTINE cmfe_DistributedVector_DataGetDPObj(vector,data,err)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to get the data for
    REAL(DP), POINTER, INTENT(OUT) :: data(:) !<On return, the vector data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataGetDPObj",err,error,*999)

    CALL DISTRIBUTED_VECTOR_DATA_GET(vector%distributedVector,data,err,error,*999)

    EXITS("cmfe_DistributedVector_DataGetDPObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataGetDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataGetDPObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this vector once it has finished being used
  SUBROUTINE cmfe_DistributedVector_DataRestoreDPObj(vector,data,err)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to restore the data for
    REAL(DP), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the vector data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataRestoreDPObj",err,error,*999)

    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(vector%distributedVector,data,err,error,*999)

    EXITS("cmfe_DistributedVector_DataRestoreDPObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataRestoreDPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataRestoreDPObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this vector on this computational node
  SUBROUTINE cmfe_DistributedVector_DataGetSPObj(vector,data,err)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to get the data for
    REAL(SP), POINTER, INTENT(OUT) :: data(:) !<On return, the vector data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataGetSPObj",err,error,*999)

    CALL DISTRIBUTED_VECTOR_DATA_GET(vector%distributedVector,data,err,error,*999)

    EXITS("cmfe_DistributedVector_DataGetSPObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataGetSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataGetSPObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this vector once it has finished being used
  SUBROUTINE cmfe_DistributedVector_DataRestoreSPObj(vector,data,err)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to restore the data for
    REAL(SP), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the vector data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataRestoreSPObj",err,error,*999)

    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(vector%distributedVector,data,err,error,*999)

    EXITS("cmfe_DistributedVector_DataRestoreSPObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataRestoreSPObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataRestoreSPObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this vector on this computational node
  SUBROUTINE cmfe_DistributedVector_DataGetLObj(vector,data,err)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to get the data for
    LOGICAL, POINTER, INTENT(OUT) :: data(:) !<On return, the vector data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataGetLObj",err,error,*999)

    CALL DISTRIBUTED_VECTOR_DATA_GET(vector%distributedVector,data,err,error,*999)

    EXITS("cmfe_DistributedVector_DataGetLObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataGetLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataGetLObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this vector once it has finished being used
  SUBROUTINE cmfe_DistributedVector_DataRestoreLObj(vector,data,err)

    !Argument variables
    TYPE(cmfe_DistributedVectorType), INTENT(IN) :: vector !<The vector to restore the data for
    LOGICAL, POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the vector data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_DistributedVector_DataRestoreLObj",err,error,*999)

    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(vector%distributedVector,data,err,error,*999)

    EXITS("cmfe_DistributedVector_DataRestoreLObj")

    RETURN
999 ERRORSEXITS("cmfe_DistributedVector_DataRestoreLObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_DistributedVector_DataRestoreLObj

!!==================================================================================================================================
!!
!! NODE_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the process of creating nodes in a region for nodes identified by user number.
  SUBROUTINE cmfe_Nodes_CreateFinishNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Nodes_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_CREATE_FINISH(NODES,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Nodes Create')
#endif

    EXITS("cmfe_Nodes_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a nodes in a region for nodes identified by an object.
  SUBROUTINE cmfe_Nodes_CreateFinishObj(nodes,err)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_CreateFinishObj",err,error,*999)

    CALL NODES_CREATE_FINISH(nodes%nodes,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('nodes Create')
#endif

    EXITS("cmfe_Nodes_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating nodes in a region for nodes identified by user number.
  SUBROUTINE cmfe_Nodes_CreateStartNumber(regionUserNumber,numberOfNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfNodes !<The number of nodes to create.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Nodes_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Nodes Create')
#endif

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL NODES_CREATE_START(REGION,numberOfNodes,NODES,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Nodes_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a nodes in a region for nodes identified by an object.
  SUBROUTINE cmfe_Nodes_CreateStartObj(region,numberOfNodes,nodes,err)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to start the creation of nodes on.
    INTEGER(INTG), INTENT(IN) :: numberOfNodes !<The number of nodes to create.
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<On return, the created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('nodes Create')
#endif

    CALL NODES_CREATE_START(region%region,numberOfNodes,nodes%nodes,err,error,*999)

    EXITS("cmfe_Nodes_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a nodes in a region for nodes identified by an object.
  SUBROUTINE cmfe_Nodes_CreateStartInterfaceObj(interface,numberOfNodes,nodes,err)

    !Argument variables
    TYPE(cmfe_InterfaceType), INTENT(IN) :: interface !<The interface to start the creation of nodes on.
    INTEGER(INTG), INTENT(IN) :: numberOfNodes !<The number of nodes to create.
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<On return, the created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_CreateStartInterfaceObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('nodes Create')
#endif

    CALL NODES_CREATE_START(interface%interface,numberOfNodes,nodes%nodes,err,error,*999)

    EXITS("cmfe_Nodes_CreateStartInterfaceObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_CreateStartInterfaceObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_CreateStartInterfaceObj

  !
  !================================================================================================================================
  !

  !>Destroys the nodes in a region for nodes identified by user number.
  SUBROUTINE cmfe_Nodes_DestroyNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Nodes_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_DESTROY(NODES,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Nodes_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the nodes in a region for nodes identified by an object.
  SUBROUTINE cmfe_Nodes_DestroyObj(nodes,err)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_NodeDestroyObj",err,error,*999)

    CALL NODES_DESTROY(nodes%nodes,err,error,*999)

    EXITS("cmfe_Nodes_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the number of nodes
  SUBROUTINE cmfe_Nodes_NumberOfNodesGetNumber(regionUserNumber,numberOfNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get node count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<On return, the number of nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Nodes_NumberOfNodesGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_NUMBER_OF_NODES_GET(NODES,numberOfNodes,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Nodes_NumberOfNodesGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_NumberOfNodesGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_NumberOfNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of nodes
  SUBROUTINE cmfe_Nodes_NumberOfNodesGetObj(nodes,numberOfNodes,err)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes get node count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<The number of nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_NumberOfNodesGetObj",err,error,*999)

    CALL NODES_NUMBER_OF_NODES_GET(nodes%nodes,numberOfNodes,err,error,*999)

    EXITS("cmfe_Nodes_NumberOfNodesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_NumberOfNodesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_NumberOfNodesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the character label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_LabelGetCNumber(regionUserNumber,nodeGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Nodes_LabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_LABEL_GET(NODES,nodeGlobalNumber,label,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Nodes_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_LabelGetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_LabelGetCObj(nodes,nodeGlobalNumber,label,err)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_LabelGetCObj",err,error,*999)

    CALL NODES_LABEL_GET(nodes%nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("cmfe_Nodes_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_LabelGetVSNumber(regionUserNumber,nodeGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Nodes_LabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_LABEL_GET(NODES,nodeGlobalNumber,label,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Nodes_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_LabelGetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_LabelGetVSObj(nodes,nodeGlobalNumber,label,err)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_LabelGetVSObj",err,error,*999)

    CALL NODES_LABEL_GET(nodes%nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("cmfe_Nodes_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_LabelSetCNumber(regionUserNumber,nodeGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Nodes_LabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_LABEL_SET(NODES,nodeGlobalNumber,label,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Nodes_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_LabelSetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_LabelSetCObj(nodes,nodeGlobalNumber,label,err)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_LabelSetCObj",err,error,*999)

    CALL NODES_LABEL_SET(nodes%nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("cmfe_Nodes_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_LabelSetVSNumber(regionUserNumber,nodeGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Nodes_LabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_LABEL_SET(NODES,nodeGlobalNumber,label,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Nodes_LabelSetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_LabelSetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_LabelSetVSObj(nodes,nodeGlobalNumber,label,err)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_LabelSetVSObj",err,error,*999)

    CALL NODES_LABEL_SET(nodes%nodes,nodeGlobalNumber,label,err,error,*999)

    EXITS("cmfe_Nodes_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the user number for a node in a set of nodes identified by user number.
  SUBROUTINE cmfe_Nodes_UserNumberGetNumber(regionUserNumber,nodeGlobalNumber,nodeUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the node user number for.
    INTEGER(INTG), INTENT(OUT) :: nodeUserNumber !<On return, the user number for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Nodes_UserNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_USER_NUMBER_GET(NODES,nodeGlobalNumber,nodeUserNumber,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Nodes_UserNumberGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_UserNumberGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_UserNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the user number for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_UserNumberGetObj(nodes,nodeGlobalNumber,nodeUserNumber,err)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to get the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the node user number for.
    INTEGER(INTG), INTENT(OUT) :: nodeUserNumber !<On return, the user number for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_UserNumberGetObj",err,error,*999)

    CALL NODES_USER_NUMBER_GET(nodes%nodes,nodeGlobalNumber,nodeUserNumber,err,error,*999)

    EXITS("cmfe_Nodes_UserNumberGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_UserNumberGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_UserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a node in a set of nodes identified by user number.
  SUBROUTINE cmfe_Nodes_UserNumberSetNumber(regionUserNumber,nodeGlobalNumber,nodeUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Nodes_UserNumberSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_USER_NUMBER_SET(NODES,nodeGlobalNumber,nodeUserNumber,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Nodes_UserNumberSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_UserNumberSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_UserNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE cmfe_Nodes_UserNumberSetObj(nodes,nodeGlobalNumber,nodeUserNumber,err)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_UserNumberSetObj",err,error,*999)

    CALL NODES_USER_NUMBER_SET(nodes%nodes,nodeGlobalNumber,nodeUserNumber,err,error,*999)

    EXITS("cmfe_Nodes_UserNumberSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_UserNumberSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_UserNumberSetObj
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the user numbers for a set of nodes identified by user number.
  SUBROUTINE cmfe_Nodes_UserNumbersAllSetNumber(regionUserNumber,nodeUserNumbers,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the node user numbers for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumbers(:) !<The user numbers for the nodes to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: nodes
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Nodes_UserNumbersAllSetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(nodes)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL REGION_NODES_GET(region,nodes,err,error,*999)
      CALL NodesUserNumbersAllSet(nodes,nodeUserNumbers,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Nodes_UserNumbersAllSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_UserNumbersAllSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_UserNumbersAllSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the user numbers for a set of nodes identified by an object. 
  SUBROUTINE cmfe_Nodes_UserNumbersAllSetObj(nodes,nodeUserNumbers,err)

    !Argument variables
    TYPE(cmfe_NodesType), INTENT(IN) :: nodes !<The nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumbers(:) !<The user numbers for the nodes to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Nodes_UserNumbersAllSetObj",err,error,*999)

    CALL NodesUserNumbersAllSet(nodes%nodes,nodeUserNumbers,err,error,*999)

    EXITS("cmfe_Nodes_UserNumbersAllSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Nodes_UserNumbersAllSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Nodes_UserNumbersAllSetObj

!!==================================================================================================================================
!!
!! PROBLEM_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the process of creating CellML equations for a problem identified by user number.
  SUBROUTINE cmfe_Problem_CellMLEquationsCreateFinishNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_CellMLEquationsCreateFinishNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CELLML_EQUATIONS_CREATE_FINISH(PROBLEM,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('CellML Equations Create')
#endif

    EXITS("cmfe_Problem_CellMLEquationsCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_Problem_CellMLEquationsCreateFinishNumber",err,error)
    EXITS("cmfe_Problem_CellMLEquationsCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CellMLEquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML equations for problem identified by an object.
  SUBROUTINE cmfe_Problem_CellMLEquationsCreateFinishObj(problem,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to finish creating the CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_CellMLEquationsCreateFinishObj",err,error,*999)

    CALL PROBLEM_CELLML_EQUATIONS_CREATE_FINISH(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('CellML Equations Create')
#endif

    EXITS("cmfe_Problem_CellMLEquationsCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CellMLEquationsCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CellMLEquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating CellML equations for a problem identified by user number.
  SUBROUTINE cmfe_Problem_CellMLEquationsCreateStartNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_CellMLEquationsCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Equations Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CELLML_EQUATIONS_CREATE_START(PROBLEM,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Problem_CellMLEquationsCreateStartNumber")
    RETURN
999 ERRORS("cmfe_Problem_CellMLEquationsCreateStartNumber",err,error)
    EXITS("cmfe_Problem_CellMLEquationsCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CellMLEquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML equations for problem identified by an object.
  SUBROUTINE cmfe_Problem_CellMLEquationsCreateStartObj(problem,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to start creating the CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_CellMLEquationsCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Equations Create')
#endif

    CALL PROBLEM_CELLML_EQUATIONS_CREATE_START(problem%problem,err,error,*999)

    EXITS("cmfe_Problem_CellMLEquationsCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CellMLEquationsCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CellMLEquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an user number.
  SUBROUTINE cmfe_Problem_CellMLEquationsGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,CellMLEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(cmfe_CellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_CellMLEquationsGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CELLML_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,CellMLEquations%cellmlEquations,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Problem_CellMLEquationsGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CellMLEquationsGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CellMLEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an user number.
  SUBROUTINE cmfe_Problem_CellMLEquationsGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,CellMLEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(cmfe_CellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
     TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_CellMLEquationsGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CELLML_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,CellMLEquations%cellmlEquations,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Problem_CellMLEquationsGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CellMLEquationsGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CellMLEquationsGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an object.
  SUBROUTINE cmfe_Problem_CellMLEquationsGetObj0(problem,controlLoopIdentifier,solverIndex,CellMLEquations,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(cmfe_CellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_CellMLEquationsGetObj0",err,error,*999)

    CALL PROBLEM_CELLML_EQUATIONS_GET(problem%problem,controlLoopIdentifier,solverIndex,CellMLEquations%cellmlEquations, &
      & err,error,*999)

    EXITS("cmfe_Problem_CellMLEquationsGetObj0")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CellMLEquationsGetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CellMLEquationsGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an object.
  SUBROUTINE cmfe_Problem_CellMLEquationsGetObj1(problem,controlLoopIdentifiers,solverIndex,CellMLEquations,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(cmfe_CellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_CellMLEquationsGetObj1",err,error,*999)

    CALL PROBLEM_CELLML_EQUATIONS_GET(problem%problem,controlLoopIdentifiers,solverIndex,CellMLEquations%cellmlEquations, &
      & err,error,*999)

    EXITS("cmfe_Problem_CellMLEquationsGetObj1")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CellMLEquationsGetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CellMLEquationsGetObj1

   !
  !================================================================================================================================
  !

  !>Finishes the process of a problem identified by user number.
  SUBROUTINE cmfe_Problem_CreateFinishNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_CreateFinishNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CREATE_FINISH(PROBLEM,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Create')
#endif

    EXITS("cmfe_Problem_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a problem identified by an object.
  SUBROUTINE cmfe_Problem_CreateFinishObj(problem,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_CreateFinishObj",err,error,*999)

    CALL PROBLEM_CREATE_FINISH(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Create')
#endif

    EXITS("cmfe_Problem_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of a problem identified by user number.
  SUBROUTINE cmfe_Problem_CreateStartNumber(problemUserNumber,problemSpecification,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of.
    INTEGER(INTG), INTENT(IN) :: problemSpecification(:) !<The problem specification array, containt the problem class, type etc
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM

    ENTERS("cmfe_Problem_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_CREATE_START(problemUserNumber,problemSpecification,PROBLEM,err,error,*999)

    EXITS("cmfe_Problem_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a problem identified by an object.
  SUBROUTINE cmfe_Problem_CreateStartObj(problemUserNumber,problemSpecification,problem,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of.
    INTEGER(INTG), INTENT(IN) :: problemSpecification(:) !<The problem specification array, containt the problem class, type etc
    TYPE(cmfe_ProblemType), INTENT(INOUT) :: problem !<On return, the created problem.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Create')
#endif

    CALL PROBLEM_CREATE_START(problemUserNumber,problemSpecification,problem%problem,err,error,*999)

    EXITS("cmfe_Problem_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a control loop for a problem identified by user number.
  SUBROUTINE cmfe_Problem_ControlLoopCreateFinishNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_ControlLoopCreateFinishNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_CREATE_FINISH(PROBLEM,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Control Loop Create')
#endif

    EXITS("cmfe_Problem_ControlLoopCreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopCreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a control loop on a problem identified by an object.
  SUBROUTINE cmfe_Problem_ControlLoopCreateFinishObj(problem,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to finish creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_ControlLoopCreateFinishObj",err,error,*999)

    CALL PROBLEM_CONTROL_LOOP_CREATE_FINISH(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Control Loop Create')
#endif

    EXITS("cmfe_Problem_ControlLoopCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating a control loop for a problem identified by user number.
  SUBROUTINE cmfe_Problem_ControlLoopCreateStartNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_ControlLoopCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Control Loop Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_CREATE_START(PROBLEM,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Problem_ControlLoopCreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopCreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a control loop on a problem identified by an object.
  SUBROUTINE cmfe_Problem_ControlLoopCreateStartObj(problem,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to start creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_ControlLoopCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Control Loop Create')
#endif

    CALL PROBLEM_CONTROL_LOOP_CREATE_START(problem%problem,err,error,*999)

    EXITS("cmfe_Problem_ControlLoopCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys the control loops for a problem identified by user number.
  SUBROUTINE cmfe_Problem_ControlLoopDestroyNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the control loops for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_ControlLoopDestroyNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_DESTROY(PROBLEM,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Problem_ControlLoopDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the control loops on a problem identified by an object.
  SUBROUTINE cmfe_Problem_ControlLoopDestroyObj(problem,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to destroy the control loops for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_ControlLoopDestroyObj",err,error,*999)

    CALL PROBLEM_CONTROL_LOOP_DESTROY(problem%problem,err,error,*999)

    EXITS("cmfe_Problem_ControlLoopDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an user number.
  SUBROUTINE cmfe_Problem_ControlLoopGetNumber0(problemUserNumber,controlLoopIdentifier,controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_ControlLoopGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,controlLoop%controlLoop,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Problem_ControlLoopGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an user number.
  SUBROUTINE cmfe_Problem_ControlLoopGetNumber1(problemUserNumber,controlLoopIdentifiers,controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
     TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_ControlLoopGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,controlLoop%controlLoop,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Problem_ControlLoopGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an object.
  SUBROUTINE cmfe_Problem_ControlLoopGetObj0(problem,controlLoopIdentifier,controlLoop,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_ControlLoopGetObj0",err,error,*999)

    CALL PROBLEM_CONTROL_LOOP_GET(problem%problem,controlLoopIdentifier,controlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_Problem_ControlLoopGetObj0")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopGetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopGetObj0

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an object.
  SUBROUTINE cmfe_Problem_ControlLoopGetObj1(problem,controlLoopIdentifiers,controlLoop,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_ControlLoopGetObj1",err,error,*999)

    CALL PROBLEM_CONTROL_LOOP_GET(problem%problem,controlLoopIdentifiers,controlLoop%controlLoop,err,error,*999)

    EXITS("cmfe_Problem_ControlLoopGetObj1")
    RETURN
999 ERRORSEXITS("cmfe_Problem_ControlLoopGetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_ControlLoopGetObj1

  !
  !================================================================================================================================
  !

  !>Destroys a problem identified by an user number.
  SUBROUTINE cmfe_Problem_DestroyNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_DestroyNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_DESTROY(PROBLEM,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Problem_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a problem identified by an object.
  SUBROUTINE cmfe_Problem_DestroyObj(problem,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_DestroyObj",err,error,*999)

    CALL PROBLEM_DESTROY(problem%problem,err,error,*999)

    EXITS("cmfe_Problem_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_DestroyObj

  !
  !================================================================================================================================
  !

  !>Solves a problem identified by an user number.
  SUBROUTINE cmfe_Problem_SolveNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to solve.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_SolveNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Solve')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVE(PROBLEM,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Solve')
#endif

    EXITS("cmfe_Problem_SolveNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolveNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolveNumber

  !
  !================================================================================================================================
  !

  !>Solves a problem identified by an object.
  SUBROUTINE cmfe_Problem_SolveObj(problem,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to solve.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolveObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Solve')
#endif

    CALL PROBLEM_SOLVE(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Solve')
#endif

    EXITS("cmfe_Problem_SolveObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolveObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolveObj

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an user number.
  SUBROUTINE cmfe_Problem_SolverGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,solver,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_SolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,solver%solver,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Problem_SolverGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an user number.
  SUBROUTINE cmfe_Problem_SolverGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,solver,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
     TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_SolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,solver%solver,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Problem_SolverGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an object.
  SUBROUTINE cmfe_Problem_SolverGetObj0(problem,controlLoopIdentifier,solverIndex,solver,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolverGetObj0",err,error,*999)

    CALL PROBLEM_SOLVER_GET(problem%problem,controlLoopIdentifier,solverIndex,solver%solver,err,error,*999)

    EXITS("cmfe_Problem_SolverGetObj0")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverGetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverGetObj0

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an object.
  SUBROUTINE cmfe_Problem_SolverGetObj1(problem,controlLoopIdentifiers,solverIndex,solver,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolverGetObj1",err,error,*999)

    CALL PROBLEM_SOLVER_GET(problem%problem,controlLoopIdentifiers,solverIndex,solver%solver,err,error,*999)

    EXITS("cmfe_Problem_SolverGetObj1")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverGetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverGetObj1

  !
  !================================================================================================================================
  !

  !>Set boundary conditions for solver equations according to the analytic equations for solver equations identified by user numbers.
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsAnalyticNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to calculate the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_SolverEquations_BoundaryConditionsAnalyticNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL Problem_SolverEquationsBoundaryConditionsAnalytic(SOLVER_EQUATIONS,err,error,*999)
      ELSE
        localError="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A problem with a user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_SolverEquations_BoundaryConditionsAnalyticNumber0")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsAnalyticNumber0",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsAnalyticNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsAnalyticNumber0

  !
  !================================================================================================================================
  !

  !>Set boundary conditions for solver equations according to the analytic equations for solver equations identified by user numbers.
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsAnalyticNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to calculate the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_SolverEquations_BoundaryConditionsAnalyticNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL Problem_SolverEquationsBoundaryConditionsAnalytic(SOLVER_EQUATIONS,err,error,*999)
      ELSE
        localError="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A problem with a user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_SolverEquations_BoundaryConditionsAnalyticNumber1")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsAnalyticNumber1",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsAnalyticNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsAnalyticNumber1

  !
  !================================================================================================================================
  !

  !>Set boundary conditions for solver equations according to the analytic equations.
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsAnalyticObj(solverEquations,err)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_SolverEquations_BoundaryConditionsAnalyticObj",err,error,*999)

    CALL Problem_SolverEquationsBoundaryConditionsAnalytic(solverEquations%solverEquations,err,error,*999)

    EXITS("cmfe_SolverEquations_BoundaryConditionsAnalyticObj")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsAnalyticObj",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsAnalyticObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsAnalyticObj

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating solver equations for a problem identified by user number.
  SUBROUTINE cmfe_Problem_SolverEquationsCreateFinishNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_SolverEquationsCreateFinishNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_CREATE_FINISH(PROBLEM,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Solver Equations Create')
#endif

    EXITS("cmfe_Problem_SolverEquationsCreateFinishNumber")
    RETURN
999 ERRORS("cmfe_Problem_SolverEquationsCreateFinishNumber",err,error)
    EXITS("cmfe_Problem_SolverEquationsCreateFinishNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of solver equations for problem identified by an object.
  SUBROUTINE cmfe_Problem_SolverEquationsCreateFinishObj(problem,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to finish creating the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolverEquationsCreateFinishObj",err,error,*999)

    CALL PROBLEM_SOLVER_EQUATIONS_CREATE_FINISH(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Solver Equations Create')
#endif

    EXITS("cmfe_Problem_SolverEquationsCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverEquationsCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating solver equations for a problem identified by user number.
  SUBROUTINE cmfe_Problem_SolverEquationsCreateStartNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_SolverEquationsCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Solver Equations Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_CREATE_START(PROBLEM,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Problem_SolverEquationsCreateStartNumber")
    RETURN
999 ERRORS("cmfe_Problem_SolverEquationsCreateStartNumber",err,error)
    EXITS("cmfe_Problem_SolverEquationsCreateStartNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of solver equations for problem identified by an object.
  SUBROUTINE cmfe_Problem_SolverEquationsCreateStartObj(problem,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to start creating the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolverEquationsCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Solver Equations Create')
#endif

    CALL PROBLEM_SOLVER_EQUATIONS_CREATE_START(problem%problem,err,error,*999)

    EXITS("cmfe_Problem_SolverEquationsCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverEquationsCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys the solver equations for a problem identified by an user number.
  SUBROUTINE cmfe_Problem_SolverEquationsDestroyNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_SolverEquationsDestroyNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_DESTROY(PROBLEM,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Problem_SolverEquationsDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverEquationsDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the solver equations for problem identified by an object.
  SUBROUTINE cmfe_Problem_SolverEquationsDestroyObj(problem,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to destroy the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolverEquationsDestroyObj",err,error,*999)

    CALL PROBLEM_SOLVER_EQUATIONS_DESTROY(problem%problem,err,error,*999)

    EXITS("cmfe_Problem_SolverEquationsDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverEquationsDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an user number.
  SUBROUTINE cmfe_Problem_SolverEquationsGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,solverEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(cmfe_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_SolverEquationsGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,solverEquations%solverEquations,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Problem_SolverEquationsGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverEquationsGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an user number.
  SUBROUTINE cmfe_Problem_SolverEquationsGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,solverEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(cmfe_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
     TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_SolverEquationsGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,solverEquations%solverEquations,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Problem_SolverEquationsGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverEquationsGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an object.
  SUBROUTINE cmfe_Problem_SolverEquationsGetObj0(problem,controlLoopIdentifier,solverIndex,solverEquations,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(cmfe_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolverEquationsGetObj0",err,error,*999)

    CALL PROBLEM_SOLVER_EQUATIONS_GET(problem%problem,controlLoopIdentifier,solverIndex,solverEquations%solverEquations, &
      & err,error,*999)

    EXITS("cmfe_Problem_SolverEquationsGetObj0")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverEquationsGetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an object.
  SUBROUTINE cmfe_Problem_SolverEquationsGetObj1(problem,controlLoopIdentifiers,solverIndex,solverEquations,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(cmfe_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolverEquationsGetObj1",err,error,*999)

    CALL PROBLEM_SOLVER_EQUATIONS_GET(problem%problem,controlLoopIdentifiers,solverIndex,solverEquations%solverEquations, &
      & err,error,*999)

    EXITS("cmfe_Problem_SolverEquationsGetObj1")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolverEquationsGetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolverEquationsGetObj1

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating solvers for a problem identified by user number.
  SUBROUTINE cmfe_Problem_SolversCreateFinishNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_SolversCreateFinishNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVERS_CREATE_FINISH(PROBLEM,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Solvers Create')
#endif

    EXITS("cmfe_Problem_SolversCreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolversCreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolversCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of solvers for problem identified by an object.
  SUBROUTINE cmfe_Problem_SolversCreateFinishObj(problem,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to finish creating the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolversCreateFinishObj",err,error,*999)

    CALL PROBLEM_SOLVERS_CREATE_FINISH(problem%problem,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Solvers Create')
#endif

    EXITS("cmfe_Problem_SolversCreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolversCreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolversCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating solvers for a problem identified by user number.
  SUBROUTINE cmfe_Problem_SolversCreateStartNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_SolversCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Solvers Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVERS_CREATE_START(PROBLEM,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Problem_SolversCreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolversCreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolversCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of solvers for problem identified by an object.
  SUBROUTINE cmfe_Problem_SolversCreateStartObj(problem,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to start creating the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolversCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Solvers Create')
#endif

    CALL PROBLEM_SOLVERS_CREATE_START(problem%problem,err,error,*999)

    EXITS("cmfe_Problem_SolversCreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolversCreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolversCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys the solvers for a problem identified by an user number.
  SUBROUTINE cmfe_Problem_SolversDestroyNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_SolversDestroyNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVERS_DESTROY(PROBLEM,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Problem_SolversDestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolversDestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolversDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the solvers for problem identified by an object.
  SUBROUTINE cmfe_Problem_SolversDestroyObj(problem,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to destroy the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SolversDestroyObj",err,error,*999)

    CALL PROBLEM_SOLVERS_DESTROY(problem%problem,err,error,*999)

    EXITS("cmfe_Problem_SolversDestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SolversDestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SolversDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the specification array for a problem identified by a user number.
  SUBROUTINE cmfe_Problem_SpecificationGetNumber(problemUserNumber,problemSpecification,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the specification for.
    INTEGER(INTG), INTENT(INOUT) :: problemSpecification(:) !<On return, the problem specification array. Must be allocated and large enough to contain the specification on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(VARYING_STRING) :: localError

    CALL Enters("cmfe_Problem_SpecificationGetNumber",err,error,*999)

    NULLIFY(problem)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL Problem_SpecificationGet(problem,problemSpecification,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVstring(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    CALL Exits("cmfe_Problem_SpecificationGetNumber")
    RETURN
999 CALL Errors("cmfe_Problem_SpecificationGetNumber",err,error)
    CALL Exits("cmfe_Problem_SpecificationGetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SpecificationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the specification array for a problem identified by an object.
  SUBROUTINE cmfe_Problem_SpecificationGetObj(problem,problemSpecification,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the specification for.
    INTEGER(INTG), INTENT(INOUT) :: problemSpecification(:) !<On return, the problem specification array. Must be allocated and large enough to contain the specification on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SpecificationGetObj",err,error,*999)

    CALL Problem_SpecificationGet(problem%problem,problemSpecification,err,error,*999)

    EXITS("cmfe_Problem_SpecificationGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SpecificationGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SpecificationGetObj

  !
  !================================================================================================================================
  !

  !>Returns the size of the specification array for a problem identified by a user number.
  SUBROUTINE cmfe_Problem_SpecificationSizeGetNumber(problemUserNumber,specificationSize,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the size of the specification for.
    INTEGER(INTG), INTENT(OUT) :: specificationSize !<On return, the size of the problem specification array. 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Problem_SpecificationSizeGetNumber",err,error,*999)

    NULLIFY(problem)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL Problem_SpecificationSizeGet(problem,specificationSize,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVstring(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Problem_SpecificationSizeGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SpecificationSizeGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SpecificationSizeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the size of the specification array for a problem identified by an object.
  SUBROUTINE cmfe_Problem_SpecificationSizeGetObj(problem,specificationSize,err)

    !Argument variables
    TYPE(cmfe_ProblemType), INTENT(IN) :: problem !<The problem to get the size of the specification for.
    INTEGER(INTG), INTENT(OUT) :: specificationSize !<On return, the size of the problem specification array. 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Problem_SpecificationSizeGetObj",err,error,*999)

    CALL Problem_SpecificationSizeGet(problem%problem,specificationSize,err,error,*999)

    EXITS("cmfe_Problem_SpecificationSizeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Problem_SpecificationSizeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Problem_SpecificationSizeGetObj

!!==================================================================================================================================
!!
!! REGION_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the coordinate system for a region identified by an user number.
  SUBROUTINE cmfe_Region_CoordinateSystemGetNumber(regionUserNumber,coordinateSystemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to get the coordinate system for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemUserNumber !<On return, the coordinate system user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Region_CoordinateSystemGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(COORDINATE_SYSTEM)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_COORDINATE_SYSTEM_GET(REGION,COORDINATE_SYSTEM,err,error,*999)
      IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
        coordinateSystemUserNumber = COORDINATE_SYSTEM%USER_NUMBER
      ELSE
        localError="The coordinate system is not associated for region number "// &
          & TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Region_CoordinateSystemGetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_CoordinateSystemGetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_CoordinateSystemGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the coordinate system for a region identified by an object.
  SUBROUTINE cmfe_Region_CoordinateSystemGetObj(region,coordinateSystem,err)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to get the coordinate system for.
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<On return, the regions coordinate system.
   INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_CoordinateSystemGetObj",err,error,*999)

    CALL REGION_COORDINATE_SYSTEM_GET(region%region,coordinateSystem%coordinateSystem,err,error,*999)

    EXITS("cmfe_Region_CoordinateSystemGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_CoordinateSystemGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_CoordinateSystemGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the coordinate system for a region identified by an user number.
  SUBROUTINE cmfe_Region_CoordinateSystemSetNumber(regionUserNumber,coordinateSystemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to set the coordinate system for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Region_CoordinateSystemSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(COORDINATE_SYSTEM)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
      IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
        CALL REGION_COORDINATE_SYSTEM_SET(REGION,COORDINATE_SYSTEM,err,error,*999)
      ELSE
        localError="A coordinate system with an user number of "// &
          & TRIM(NumberToVString(coordinateSystemUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Region_CoordinateSystemSetNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_CoordinateSystemSetNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_CoordinateSystemSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the coordinate system for a region identified by an object.
  SUBROUTINE cmfe_Region_CoordinateSystemSetObj(region,coordinateSystem,err)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to set the coordinate system for.
    TYPE(cmfe_CoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_CoordinateSystemSetObj",err,error,*999)

    CALL REGION_COORDINATE_SYSTEM_SET(region%region,coordinateSystem%coordinateSystem,err,error,*999)

    EXITS("cmfe_Region_CoordinateSystemSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_CoordinateSystemSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_CoordinateSystemSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a region identified by user number.
  SUBROUTINE cmfe_Region_CreateFinishNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Region_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_CREATE_FINISH(REGION,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Region Create')
#endif

    EXITS("cmfe_Region_CreateFinishNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_CreateFinishNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a region identified by an object.
  SUBROUTINE cmfe_Region_CreateFinishObj(region,err)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_CreateFinishObj",err,error,*999)

    CALL REGION_CREATE_FINISH(region%region,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('region Create')
#endif

    EXITS("cmfe_Region_CreateFinishObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_CreateFinishObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process creating a region identified by user number.
  SUBROUTINE cmfe_Region_CreateStartNumber(regionUserNumber,parentRegionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to start the creation of.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region to start the creation of the region in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION,REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Region_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Region Create')
#endif

    NULLIFY(PARENT_REGION)
    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL REGION_CREATE_START(regionUserNumber,PARENT_REGION,REGION,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Region_CreateStartNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_CreateStartNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a region identified by an object.
  SUBROUTINE cmfe_Region_CreateStartObj(regionUserNumber,parentRegion,region,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to start the creation of.
    TYPE(cmfe_RegionType), INTENT(IN) :: parentRegion !<The parent region to  to start the creation of the region in.
    TYPE(cmfe_RegionType), INTENT(INOUT) :: region !<On return, the created region.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('region Create')
#endif

    CALL REGION_CREATE_START(regionUserNumber,parentRegion%region,region%region,err,error,*999)

    EXITS("cmfe_Region_CreateStartObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_CreateStartObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a region identified by an user number.
  SUBROUTINE cmfe_Region_DestroyNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Region_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DESTROY(REGION,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Region_DestroyNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_DestroyNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Returns the data points for a region identified by an object.
  SUBROUTINE cmfe_Region_DataPointsGetObj(region,dataPoints,err)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to get the data points for.
    TYPE(cmfe_DataPointsType), INTENT(INOUT) :: dataPoints !<On return, the regions data points.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_DataPointsGetObj",err,error,*999)

    CALL REGION_DATA_POINTS_GET(region%region,dataPoints%dataPoints,err,error,*999)

    EXITS("cmfe_Region_DataPointsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_DataPointsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_DataPointsGetObj

  !
  !================================================================================================================================
  !

  !>Destroys a region identified by an object.
  SUBROUTINE cmfe_Region_DestroyObj(region,err)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(INOUT) :: region !<The region to destroy
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_DestroyObj",err,error,*999)

    CALL REGION_DESTROY(region%region,err,error,*999)

    EXITS("cmfe_Region_DestroyObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_DestroyObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a region identified by an user number.
  SUBROUTINE cmfe_Region_LabelGetCNumber(regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Region_LabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_LABEL_GET(REGION,label,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Region_LabelGetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_LabelGetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a region identified by an object.
  SUBROUTINE cmfe_Region_LabelGetCObj(region,label,err)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_LabelGetCObj",err,error,*999)

    CALL REGION_LABEL_GET(region%region,label,err,error,*999)

    EXITS("cmfe_Region_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a region identified by an user number.
  SUBROUTINE cmfe_Region_LabelGetVSNumber(regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Region_LabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_LABEL_GET(REGION,label,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Region_LabelGetVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_LabelGetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a region identified by an object.
  SUBROUTINE cmfe_Region_LabelGetVSObj(region,label,err)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_LabelGetVSObj",err,error,*999)

    CALL REGION_LABEL_GET(region%region,label,err,error,*999)

    EXITS("cmfe_Region_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a region identified by an user number.
  SUBROUTINE cmfe_Region_LabelSetCNumber(regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Region_LabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_LABEL_SET(REGION,label,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Region_LabelSetCNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_LabelSetCNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a region identified by an object.
  SUBROUTINE cmfe_Region_LabelSetCObj(region,label,err)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_LabelSetCObj",err,error,*999)

    CALL REGION_LABEL_SET(region%region,label,err,error,*999)

    EXITS("cmfe_Region_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a region identified by an user number.
  SUBROUTINE cmfe_Region_LabelSetVSNumber(regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Region_LabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_LABEL_SET(REGION,CHAR(label),err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_RegionLabelStVSNumber")
    RETURN
999 ERRORSEXITS("cmfe_Region_LabelSetVSNumber",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for a region identified by an object.
  SUBROUTINE cmfe_Region_LabelSetVSObj(region,label,err)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_LabelSetVSObj",err,error,*999)

    CALL REGION_LABEL_SET(region%region,CHAR(label),err,error,*999)

    EXITS("cmfe_Region_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the nodes for a region identified by an object.
  SUBROUTINE cmfe_Region_NodesGetObj(region,nodes,err)

    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to get the nodes for.
    TYPE(cmfe_NodesType), INTENT(INOUT) :: nodes !<On return, the regions nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Region_NodesGetObj",err,error,*999)

    CALL REGION_NODES_GET(region%region,nodes%nodes,err,error,*999)

    EXITS("cmfe_Region_NodesGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Region_NodesGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Region_NodesGetObj

!!==================================================================================================================================
!!
!! SOLVER_ROUTINES
!!
!!==================================================================================================================================

  !
  !================================================================================================================================
  !

  !>Adds a CellML environment to CellML equations identified by an user number.
  SUBROUTINE cmfe_CellMLEquations_CellMLAddNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & regionUserNumber,CellMLUserNumber,CellMLIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to add.
    INTEGER(INTG), INTENT(OUT) :: CellMLIndex !<On return, the index of the added CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellMLEquations_CellMLAddNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(CELLML_EQUATIONS)
    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_CELLML_EQUATIONS_GET(SOLVER,CELLML_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
      IF(ASSOCIATED(REGION)) THEN
        CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
        IF(ASSOCIATED(CELLML)) THEN
          CALL CELLML_EQUATIONS_CELLML_ADD(CELLML_EQUATIONS,CELLML,CellMLIndex,err,error,*999)
        ELSE
          localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellMLEquations_CellMLAddNumber0")
    RETURN
999 ERRORSEXITS("cmfe_CellMLEquations_CellMLAddNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_CellMLAddNumber0

  !
  !================================================================================================================================
  !

  !>Adds a CellML environment to CellML equations identified by an user number.
  SUBROUTINE cmfe_CellMLEquations_CellMLAddNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,CellMLUserNumber,CellMLIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to add.
    INTEGER(INTG), INTENT(OUT) :: CellMLIndex !<On return, the index of the added CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_CellMLEquations_CellMLAddNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(CELLML_EQUATIONS)
    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_CELLML_EQUATIONS_GET(SOLVER,CELLML_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
      IF(ASSOCIATED(REGION)) THEN
        CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
        IF(ASSOCIATED(CELLML)) THEN
          CALL CELLML_EQUATIONS_CELLML_ADD(CELLML_EQUATIONS,CELLML,CellMLIndex,err,error,*999)
        ELSE
          localError="A CellML environment with an user number of "//TRIM(NumberToVString(CellMLUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        END IF
      ELSE
        localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_CellMLEquations_CellMLAddNumber1")
    RETURN
999 ERRORSEXITS("cmfe_CellMLEquations_CellMLAddNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_CellMLAddNumber1

  !
  !================================================================================================================================
  !

  !>Adds a CellML environment to CellML equations identified by an object.
  SUBROUTINE cmfe_CellMLEquations_CellMLAddObj(CellMLEquations,CellML,CellMLIndex,err)

    !Argument variables
    TYPE(cmfe_CellMLEquationsType), INTENT(IN) :: CellMLEquations !<The CellML equations to add the CellML environment for.
    TYPE(cmfe_CellMLType), INTENT(IN) :: CellML !<The CellML environment to add.
    INTEGER(INTG), INTENT(OUT) :: CellMLIndex !<On return, the index of the added CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_CellMLEquations_CellMLAddObj",err,error,*999)

    CALL CELLML_EQUATIONS_CELLML_ADD(CellMLEquations%cellmlEquations,CellML%CELLML,CellMLIndex,err,error,*999)

    EXITS("cmfe_CellMLEquations_CellMLAddObj")
    RETURN
999 ERRORSEXITS("cmfe_CellMLEquations_CellMLAddObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_CellMLEquations_CellMLAddObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_CellMLEquationsGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,CellMLEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(cmfe_CellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the CellML equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_CellMLEquationsGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_CELLML_EQUATIONS_GET(SOLVER,CellMLEquations%cellmlEquations,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_CellMLEquationsGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_CellMLEquationsGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_CellMLEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_CellMLEquationsGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,CellMLEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(cmfe_CellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the CelllML equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_CellMLEquationsGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_CELLML_EQUATIONS_GET(SOLVER,CellMLEquations%cellmlEquations,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_CellMLEquationsGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_CellMLEquationsGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_CellMLEquationsGetNumber1

  !================================================================================================================================
  !

  !>Returns the CellML equations for a solver identified by an object.
  SUBROUTINE cmfe_Solver_CellMLEquationsGetObj(solver,CellMLEquations,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the CellML equations for.
    TYPE(cmfe_CellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the CellML equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_CellMLEquationsGetObj",err,error,*999)

    CALL SOLVER_CELLML_EQUATIONS_GET(solver%solver,CellMLEquations%cellmlEquations,err,error,*999)

    EXITS("cmfe_Solver_CellMLEquationsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_CellMLEquationsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_CellMLEquationsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAEEulerSolverTypeGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,DAEEulerSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(OUT) :: DAEEulerSolverType !<On return, the DAE Euler solver type. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DAEEulerSolverTypeGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_EULER_SOLVER_TYPE_GET(SOLVER,DAEEulerSolverType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DAEEulerSolverTypeGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAEEulerSolverTypeGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAEEulerSolverTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAEEulerSolverTypeGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,DAEEulerSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(OUT) :: DAEEulerSolverType !<On return, the DAE Euler solver type. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DAEEulerSolverTypeGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_EULER_SOLVER_TYPE_GET(SOLVER,DAEEulerSolverType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DAEEulerSolverTypeGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAEEulerSolverTypeGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAEEulerSolverTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an object.
  SUBROUTINE cmfe_Solver_DAEEulerSolverTypeGetObj(solver,DAEEulerSolverType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(OUT) :: DAEEulerSolverType !<On return, the DAE Euler solver type. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DAEEulerSolverTypeGetObj",err,error,*999)

    CALL SOLVER_DAE_EULER_SOLVER_TYPE_GET(solver%solver,DAEEulerSolverType,err,error,*999)

    EXITS("cmfe_Solver_DAEEulerSolverTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAEEulerSolverTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAEEulerSolverTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAEEulerSolverTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,DAEEulerSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: DAEEulerSolverType !<The DAE Euler solver type to set. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DAEEulerSolverTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_EULER_SOLVER_TYPE_SET(SOLVER,DAEEulerSolverType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DAEEulerSolverTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAEEulerSolverTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAEEulerSolverTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAEEulerSolverTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,DAEEulerSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: DAEEulerSolverType !<The DAE Euler solver type to set. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DAEEulerSolverTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_EULER_SOLVER_TYPE_SET(SOLVER,DAEEulerSolverType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DAEEulerSolverTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAEEulerSolverTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAEEulerSolverTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an object.
  SUBROUTINE cmfe_Solver_DAEEulerSolverTypeSetObj(solver,DAEEulerSolverType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: DAEEulerSolverType !<The DAE Euler solver type to set. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DAEEulerSolverTypeSetObj",err,error,*999)

    CALL SOLVER_DAE_EULER_SOLVER_TYPE_SET(solver%solver,DAEEulerSolverType,err,error,*999)

    EXITS("cmfe_Solver_DAEEulerSolverTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAEEulerSolverTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAEEulerSolverTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAESolverTypeGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,DAESolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE solver type for
    INTEGER(INTG), INTENT(OUT) :: DAESolverType !<On return, the DAE solver type. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DAESolverTypeGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_SOLVER_TYPE_GET(SOLVER,DAESolverType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DAESolverTypeGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAESolverTypeGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAESolverTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAESolverTypeGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,DAESolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE solver type for
    INTEGER(INTG), INTENT(OUT) :: DAESolverType !<On return, the DAE solver type. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DAESolverTypeGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_SOLVER_TYPE_GET(SOLVER,DAESolverType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DAESolverTypeGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAESolverTypeGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAESolverTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an differential-algebraic equation solver identified by an object.
  SUBROUTINE cmfe_Solver_DAESolverTypeGetObj(solver,DAESolverType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(OUT) :: DAESolverType !<On return, the DAE solver type. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DAESolverTypeGetObj",err,error,*999)

    CALL SOLVER_DAE_SOLVER_TYPE_GET(solver%solver,DAESolverType,err,error,*999)

    EXITS("cmfe_Solver_DAESolverTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAESolverTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAESolverTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAESolverTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,DAESolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: DAESolverType !<The DAE solver type to set. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DAESolverTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_SOLVER_TYPE_SET(SOLVER,DAESolverType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DAESolverTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAESolverTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAESolverTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAESolverTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,DAESolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: DAESolverType !<The DAE solver type to set. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DAESolverTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_SOLVER_TYPE_SET(SOLVER,DAESolverType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DAESolverTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAESolverTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAESolverTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an object.
  SUBROUTINE cmfe_Solver_DAESolverTypeSetObj(solver,DAESolverType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: DAESolverType !<The DAE solver type to set. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DAESolverTypeSetObj",err,error,*999)

    CALL SOLVER_DAE_SOLVER_TYPE_SET(solver%solver,DAESolverType,err,error,*999)

    EXITS("cmfe_Solver_DAESolverTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAESolverTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAESolverTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAETimesSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,startTime,endTime,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: endTime !<The end time for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DAETimesSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_TIMES_SET(SOLVER,startTime,endTime,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DAETimesSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAETimesSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAETimesSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAETimesSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,startTime,endTime,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: endTime !<The end time for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DAETimesSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_TIMES_SET(SOLVER,startTime,endTime,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DAETimesSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAETimesSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAETimesSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for an differential-algebraic equation solver identified by an object.
  SUBROUTINE cmfe_Solver_DAETimesSetObj(solver,startTime,endTime,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the DAE times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: endTime !<The end time for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DAETimesSetObj",err,error,*999)

    CALL SOLVER_DAE_TIMES_SET(solver%solver,startTime,endTime,err,error,*999)

    EXITS("cmfe_Solver_DAETimesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAETimesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAETimesSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the (initial) time step for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAETimeStepSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,timeStep,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: timeStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DAETimeStepSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_TIME_STEP_SET(SOLVER,timeStep,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DAETimeStepSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAETimeStepSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAETimeStepSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the (initial) time step for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE cmfe_Solver_DAETimeStepSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,timeStep,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: timeStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DAETimeStepSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_TIME_STEP_SET(SOLVER,timeStep,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DAETimeStepSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAETimeStepSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAETimeStepSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the (initial) time step for an differential-algebraic equation solver identified by an object.
  SUBROUTINE cmfe_Solver_DAETimeStepSetObj(solver,timeStep,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the DAE times for.
    REAL(DP), INTENT(IN) :: timeStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DAETimeStepSetObj",err,error,*999)

    CALL SOLVER_DAE_TIME_STEP_SET(solver%solver,timeStep,err,error,*999)

    EXITS("cmfe_Solver_DAETimeStepSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DAETimeStepSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DAETimeStepSetObj

  !
  !================================================================================================================================
  !

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicDegreeGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,degree,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic degree for.
    INTEGER(INTG), INTENT(OUT) :: degree !<On return, the dynamic degree. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DynamicDegreeGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_DEGREE_GET(SOLVER,degree,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicDegreeGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicDegreeGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicDegreeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicDegreeGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,degree,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic degree for
    INTEGER(INTG), INTENT(OUT) :: degree !<On return, the dynamic degree. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DynamicDegreeGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_DEGREE_GET(SOLVER,degree,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicDegreeGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicDegreeGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicDegreeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicDegreeGetObj(solver,degree,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(OUT) :: degree !<On return, the dynamic degree. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicDegreeGetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_DEGREE_GET(solver%solver,degree,err,error,*999)

    EXITS("cmfe_Solver_DynamicDegreeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicDegreeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicDegreeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicDegreeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,degree,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: degree !<The dynamic degree to set. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DynamicDegreeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,degree,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicDegreeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicDegreeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicDegreeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicDegreeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,degree,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the dynamic degree for
    INTEGER(INTG), INTENT(IN) :: degree !<The dynamic degree to set. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DynamicDegreeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,degree,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicDegreeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicDegreeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicDegreeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicDegreeSetObj(solver,degree,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: degree !<The dynamic degree to set. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicDegreeSetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_DEGREE_SET(solver%solver,degree,err,error,*999)

    EXITS("cmfe_Solver_DynamicDegreeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicDegreeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicDegreeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicLinearityTypeGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,linearityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the dynamic linearity type. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DynamicLinearityTypeGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_LINEARITY_TYPE_GET(SOLVER,linearityType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicLinearityTypeGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicLinearityTypeGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicLinearityTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicLinearityTypeGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,linearityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the dynamic linearity type. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DynamicLinearityTypeGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_LINEARITY_TYPE_GET(SOLVER,linearityType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicLinearityTypeGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicLinearityTypeGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicLinearityTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for a dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicLinearityTypeGetObj(solver,linearityType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the dynamic linearity type. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicLinearityTypeGetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_LINEARITY_TYPE_GET(solver%solver,linearityType,err,error,*999)

    EXITS("cmfe_Solver_DynamicLinearityTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicLinearityTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicLinearityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicNonlinearSolverGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & nonlinearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(OUT) :: nonlinearSolverIndex !<On return, the solver index of the nonlinear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DynamicNonlinearSolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(NONLINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET(SOLVER,NONLINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from nonlinear solver
      nonlinearSolverIndex=NONLINEAR_SOLVER%GLOBAL_NUMBER
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicNonlinearSolverGetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_DynamicNonlinearSolverGetNumber0",err,error)
    EXITS("cmfe_Solver_DynamicNonlinearSolverGetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicNonlinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicNonlinearSolverGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & nonlinearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(OUT) :: nonlinearSolverIndex !<On return, the dynamic nonlinear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DynamicNonlinearSolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(NONLINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET(SOLVER,NONLINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from nonlinear solver
      nonlinearSolverIndex=NONLINEAR_SOLVER%GLOBAL_NUMBER
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicNonlinearSolverGetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_DynamicNonlinearSolverGetNumber1",err,error)
    EXITS("cmfe_Solver_DynamicNonlinearSolverGetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicNonlinearSolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicNonlinearSolverGetObj(solver,nonlinearSolver,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the dynamic nonlinear solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: nonlinearSolver  !<On return, the dynamic nonlinear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicNonlinearSolverGetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET(solver%solver,nonlinearSolver%solver,err,error,*999)

    EXITS("cmfe_Solver_DynamicNonlinearSolverGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicNonlinearSolverGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicNonlinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a linear dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicLinearSolverGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,linearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the solver index of the linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DynamicLinearSolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from linear solver
      linearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicLinearSolverGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicLinearSolverGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicLinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a linear dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicLinearSolverGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,linearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the dynamic linear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DynamicLinearSolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from linear solver
      linearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicLinearSolverGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicLinearSolverGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicLinearSolverGetNumber1

  !================================================================================================================================
  !

  !>Returns the linear solver associated with a linear dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicLinearSolverGetObj(solver,linearSolver,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the dynamic linear solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: linearSolver !<On return, the dynamic linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicLinearSolverGetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_LINEAR_SOLVER_GET(solver%solver,linearSolver%solver,err,error,*999)

    EXITS("cmfe_Solver_DynamicLinearSolverGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicLinearSolverGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicLinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the scheme for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicSchemeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,scheme,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: scheme !<The dynamic scheme to set. \see OPENCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DynamicSchemeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_SCHEME_SET(SOLVER,scheme,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicSchemeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicSchemeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicSchemeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the scheme for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicSchemeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,scheme,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: scheme !<The dynamic scheme to set. \see OPENCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DynamicSchemeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_SCHEME_SET(SOLVER,scheme,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicSchemeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicSchemeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicSchemeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the scheme for a dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicSchemeSetObj(solver,scheme,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: scheme !<The dynamic scheme to set. \see OPENCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicSchemeSetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_SCHEME_SET(solver%solver,scheme,err,error,*999)

    EXITS("cmfe_Solver_DynamicSchemeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicSchemeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicSchemeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta value for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicThetaSetNumber00(problemUserNumber,controlLoopIdentifier,solverIndex,theta,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: theta !<The dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DynamicThetaSetNumber00",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,theta,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicThetaSetNumber00")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicThetaSetNumber00",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicThetaSetNumber00

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta value for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicThetaSetNumber01(problemUserNumber,controlLoopIdentifier,solverIndex,thetas,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: thetas(:) !<thetas(i). The i'th dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DynamicThetaSetNumber01",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,thetas,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicThetaSetNumber01")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicThetaSetNumber01",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicThetaSetNumber01

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicThetaSetNumber10(problemUserNumber,controlLoopIdentifiers,solverIndex,theta,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: theta !<The dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DynamicThetaSetNumber10",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,theta,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicThetaSetNumber10")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicThetaSetNumber10",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicThetaSetNumber10

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicThetaSetNumber11(problemUserNumber,controlLoopIdentifiers,solverIndex,thetas,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: thetas(:) !<thetas(i). The i'th dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DynamicThetaSetNumber11",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,thetas,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicThetaSetNumber11")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicThetaSetNumber11",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicThetaSetNumber11

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicThetaSetObj0(solver,theta,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the theta for.
    REAL(DP), INTENT(IN) :: theta !<The dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicThetaSetObj0",err,error,*999)

    CALL SOLVER_DYNAMIC_THETA_SET(solver%solver,theta,err,error,*999)

    EXITS("cmfe_Solver_DynamicThetaSetObj0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicThetaSetObj0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicThetaSetObj0

   !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicThetaSetObj1(solver,thetas,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the theta for.
    REAL(DP), INTENT(IN) :: thetas(:) !<thetas(i). The i'th dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicThetaSetObj1",err,error,*999)

    CALL SOLVER_DYNAMIC_THETA_SET(solver%solver,thetas,err,error,*999)

    EXITS("cmfe_Solver_DynamicThetaSetObj1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicThetaSetObj1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicThetaSetObj1

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicTimesSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,currentTime,timeIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_DynamicTimesSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_TIMES_SET(SOLVER,currentTime,timeIncrement,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicTimesSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicTimesSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicTimesSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for a dynamic solver identified by an user number.
  SUBROUTINE cmfe_Solver_DynamicTimesSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,currentTime,timeIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_SolverDynamicTimeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_TIMES_SET(SOLVER,currentTime,timeIncrement,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_DynamicTimesSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicTimesSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicTimesSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the times for a dynamic solver identified by an object.
  SUBROUTINE cmfe_Solver_DynamicTimesSetObj(solver,currentTime,timeIncrement,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_DynamicTimesSetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_TIMES_SET(solver%solver,currentTime,timeIncrement,err,error,*999)

    EXITS("cmfe_Solver_DynamicTimesSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_DynamicTimesSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_DynamicTimesSetObj
  
  !
  !================================================================================================================================
  !

  !>Sets the arbitrary path logical for a geometric transformation identified by an user number.
  SUBROUTINE cmfe_Solver_GeometricTransformationArbitraryPathSetNumber(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & arbitraryPath,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the arbitrary path for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the arbitrary path for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index for the geometric transformation solver.
    LOGICAL, INTENT(IN) :: arbitraryPath !<.TRUE. if the the transformation has an arbitrary path, .FALSE. if the path is uni-directional
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_GeometricTransformationArbitraryPathSetNumber",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationArbitraryPathSet(solver,arbitraryPath,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NumberToVString(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Solver_GeometricTransformationArbitraryPathSetNumber")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationArbitraryPathSetNumber",err,error)
    EXITS("cmfe_Solver_GeometricTransformationArbitraryPathSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationArbitraryPathSetNumber
  
  !
  !================================================================================================================================
  !

  !>Sets the arbitrary path logical for a geometric transformation solver identified by an object.
  SUBROUTINE cmfe_Solver_GeometricTransformationArbitraryPathSetObj(solver,arbitraryPath,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the arbitrary path for.
    LOGICAL, INTENT(IN) :: arbitraryPath !<.TRUE. if the the transformation has an arbitrary path, .FALSE. if the path is uni-directional
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationArbitraryPathSetObj",err,error,*999)
    
    CALL Solver_GeometricTransformationArbitraryPathSet(solver%solver,arbitraryPath,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationArbitraryPathSetObj")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationArbitraryPathSetObj",err,error)
    EXITS("cmfe_Solver_GeometricTransformationArbitraryPathSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationArbitraryPathSetObj
  
  !
  !================================================================================================================================
  !

  !>Clear transformation a geometric transformation identified by an user number.
  SUBROUTINE cmfe_Solver_GeometricTransformationClearNumber(problemUserNumber,controlLoopIdentifier,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to clear.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to clear.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index for the geometric transformation solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_GeometricTransformationClearNumber",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationClear(solver,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NumberToVString(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Solver_GeometricTransformationClearNumber")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationClearNumber",err,error)
    EXITS("cmfe_Solver_GeometricTransformationClearNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationClearNumber
  
  !
  !================================================================================================================================
  !

  !>Clear transformation for a geometric transformation solver identified by an object.
  SUBROUTINE cmfe_Solver_GeometricTransformationClearObj(solver,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to clear
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationClearObj",err,error,*999)
    
    CALL Solver_GeometricTransformationClear(solver%solver,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationClearObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_GeometricTransformationClearObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationClearObj
  
  !
  !================================================================================================================================
  !

  !>Sets the field for a geometric transformation identified by an user number.
  SUBROUTINE cmfe_Solver_GeometricTransformationFieldSetNumber(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & regionUserNumber,fieldUserNumber,variableType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index for the geometric transformation solver.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number for the field
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field user number
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the transformation for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_GeometricTransformationFieldSetNumber",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(field)
    NULLIFY(region)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
        IF(ASSOCIATED(region)) THEN
          CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
          IF(ASSOCIATED(field)) THEN
            CALL Solver_GeometricTransformationFieldSet(solver,field,variableType,err,error,*999)
          ELSE
            localError="A field with user number of "//TRIM(NumberToVString(fieldUserNumber,"*",err,error))// &
              & " does not exist."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="A region with user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="A solver with index of "//TRIM(NumberToVString(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Solver_GeometricTransformationFieldSetNumber")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationFieldSetNumber",err,error)
    EXITS("cmfe_Solver_GeometricTransformationFieldSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationFieldSetNumber
  
  !
  !================================================================================================================================
  !

  !>Sets the field for a geometric transformation solver identified by an object.
  SUBROUTINE cmfe_Solver_GeometricTransformationFieldSetObj(solver,field,variableType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the field for.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !<The field for the solver to set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the transformation for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationFieldSetObj",err,error,*999)
    
    CALL Solver_GeometricTransformationFieldSet(solver%solver,field%field,variableType,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationFieldSetObj")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationFieldSetObj",err,error)
    EXITS("cmfe_Solver_GeometricTransformationFieldSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationFieldSetObj
  
  !
  !================================================================================================================================
  !

  !>Sets the full transformation matrix for a geometric transformation identified by an user number, default to be the 1st load increment
  SUBROUTINE cmfe_Solver_GeometricTransformationMatrixSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & matrix,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the matrix for.
    REAL(DP), INTENT(IN) :: matrix(:,:) !<The full transformation matrix to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_GeometricTransformationMatrixSetNumber0",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationMatrixSet(solver,matrix,1,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NumberToVString(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Solver_GeometricTransformationMatrixSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationMatrixSetNumber0",err,error)
    EXITS("cmfe_Solver_GeometricTransformationMatrixSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationMatrixSetNumber0
  
  !
  !================================================================================================================================
  !

  !>Sets the full transformation matrix for a geometric transformation solver identified by an object, default to be the 1st load increment
  SUBROUTINE cmfe_Solver_GeometricTransformationMatrixSetObj0(solver,matrix,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the matrix for.
    REAL(DP), INTENT(IN) :: matrix(:,:) !<The full transformation matrix to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationMatrixSetObj0",err,error,*999)
    
    CALL Solver_GeometricTransformationMatrixSet(solver%solver,matrix,1,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationMatrixSetObj0")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationMatrixSetObj0",err,error)
    EXITS("cmfe_Solver_GeometricTransformationMatrixSetObj0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationMatrixSetObj0
  
  !
  !================================================================================================================================
  !

  !>Sets the full transformation matrix at a specific increment for a geometric transformation identified by an user number.
  SUBROUTINE cmfe_Solver_GeometricTransformationMatrixSetNumber1(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & matrix,loadIncrementIdx,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the matrix for.
    REAL(DP), INTENT(IN) :: matrix(:,:) !<The full transformation matrix to set
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the matrix for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_GeometricTransformationMatrixSetNumber1",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationMatrixSet(solver,matrix,loadIncrementIdx,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NumberToVString(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Solver_GeometricTransformationMatrixSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationMatrixSetNumber1",err,error)
    EXITS("cmfe_Solver_GeometricTransformationMatrixSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationMatrixSetNumber1
  
  !
  !================================================================================================================================
  !

  !>Sets the full transformation matrix vector at a specific load increment for a geometric transformation solver identified by an object.
  SUBROUTINE cmfe_Solver_GeometricTransformationMatrixSetObj1(solver,matrix,loadIncrementIdx,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the matrix for.
    REAL(DP), INTENT(IN) :: matrix(:,:) !<The full transformation matrix to set
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the matrix for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationMatrixSetObj1",err,error,*999)
    
    CALL Solver_GeometricTransformationMatrixSet(solver%solver,matrix,loadIncrementIdx,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationMatrixSetObj1")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationMatrixSetObj1",err,error)
    EXITS("cmfe_Solver_GeometricTransformationMatrixSetObj1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationMatrixSetObj1
  
  !
  !================================================================================================================================
  !

  !>Sets the arbitrary path logical for a geometric transformation identified by an user number.
  SUBROUTINE cmfe_Solver_GeometricTransformationNoLoadIncrementsSetNumber(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,numberOfIncrements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index for the geometric transformation solver.
    INTEGER(INTG), INTENT(IN) :: numberOfIncrements !<The number of load increments to apply the transformation
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_GeometricTransformationNumberOfLoadIncrementsSetNumber",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationNumberOfLoadIncrementsSet(solver,numberOfIncrements,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NumberToVString(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Solver_GeometricTransformationNumberOfLoadIncrementsSetNumber")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationNumberOfLoadIncrementsSetNumber",err,error)
    EXITS("cmfe_Solver_GeometricTransformationNumberOfLoadIncrementsSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationNoLoadIncrementsSetNumber
  
  !
  !================================================================================================================================
  !

  !>Sets the arbitrary path logical for a geometric transformation solver identified by an object.
  SUBROUTINE cmfe_Solver_GeometricTransformationNoLoadIncrementsSetObj(solver,numberOfIncrements,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: numberOfIncrements !<The number of load increments to apply the transformation
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationNumberOfLoadIncrementsSetObj",err,error,*999)
    
    CALL Solver_GeometricTransformationNumberOfLoadIncrementsSet(solver%solver,numberOfIncrements,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationNumberOfLoadIncrementsSetObj")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationNumberOfLoadIncrementsSetObj",err,error)
    EXITS("cmfe_Solver_GeometricTransformationNumberOfLoadIncrementsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationNoLoadIncrementsSetObj
  
  !
  !================================================================================================================================
  !

  !>Sets the rotation for a geometric transformation identified by an user number, default to be the 1st load increment
  SUBROUTINE cmfe_Solver_GeometricTransformationRotationSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & pivotPoint,axis,angle,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the rotation for.
    REAL(DP), INTENT(IN) :: pivotPoint(:) !<The pivot point to rotate about
    REAL(DP), INTENT(IN) :: axis(:) !<The axis to  to rotate around
    REAL(DP), INTENT(IN) :: angle !<The angle to rotate
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_GeometricTransformationRotationSetNumber0",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationRotationSet(solver,pivotPoint,axis,angle,1,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NumberToVString(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Solver_GeometricTransformationRotationSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationRotationSetNumber0",err,error)
    EXITS("cmfe_Solver_GeometricTransformationRotationSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationRotationSetNumber0
  
  !
  !================================================================================================================================
  !

  !>Sets the rotation for a geometric transformation solver identified by an object, default to be the 1st load increment
  SUBROUTINE cmfe_Solver_GeometricTransformationRotationSetObj0(solver,pivotPoint,axis,angle,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the rotation for.
    REAL(DP), INTENT(IN) :: pivotPoint(:) !<The pivot point to rotate about
    REAL(DP), INTENT(IN) :: axis(:) !<The axis to  to rotate around
    REAL(DP), INTENT(IN) :: angle !<The angle to rotate
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationRotationSetObj0",err,error,*999)
    
    CALL Solver_GeometricTransformationRotationSet(solver%solver,pivotPoint,axis,angle,1,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationRotationSetObj0")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationRotationSetObj0",err,error)
    EXITS("cmfe_Solver_GeometricTransformationRotationSetObj0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationRotationSetObj0
  
  !
  !================================================================================================================================
  !

  !>Sets the rotation at a specific increment for a geometric transformation identified by an user number.
  SUBROUTINE cmfe_Solver_GeometricTransformationRotationSetNumber1(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & pivotPoint,axis,angle,loadIncrementIdx,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the rotation for.
    REAL(DP), INTENT(IN) :: pivotPoint(:) !<The pivot point to rotate about
    REAL(DP), INTENT(IN) :: axis(:) !<The axis to  to rotate around
    REAL(DP), INTENT(IN) :: angle !<The angle to rotate
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the rotation for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_GeometricTransformationRotationSetNumber1",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationRotationSet(solver,pivotPoint,axis,angle,loadIncrementIdx,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NumberToVString(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Solver_GeometricTransformationRotationSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationRotationSetNumber1",err,error)
    EXITS("cmfe_Solver_GeometricTransformationRotationSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationRotationSetNumber1
  
  !
  !================================================================================================================================
  !

  !>Sets the rotation at a specific load increment for a geometric transformation solver identified by an object.
  SUBROUTINE cmfe_Solver_GeometricTransformationRotationSetObj1(solver,pivotPoint,axis,angle,loadIncrementIdx,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the rotation for.
    REAL(DP), INTENT(IN) :: pivotPoint(:) !<The pivot point to rotate about
    REAL(DP), INTENT(IN) :: axis(:) !<The axis to  to rotate around
    REAL(DP), INTENT(IN) :: angle !<The angle to rotate
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the rotation for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationRotationSetObj1",err,error,*999)
    
    CALL Solver_GeometricTransformationRotationSet(solver%solver,pivotPoint,axis,angle,loadIncrementIdx,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationRotationSetObj1")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationRotationSetObj1",err,error)
    EXITS("cmfe_Solver_GeometricTransformationRotationSetObj1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationRotationSetObj1
  
  !
  !================================================================================================================================
  !

  !>Sets the scalings for a geometric transformation identified by an user number.
  SUBROUTINE cmfe_Solver_GeometricTransformationScalingsSetNumber(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & scalings,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the scalings for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the scalings for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the scalings for.
    REAL(DP), INTENT(IN) :: scalings(:) !<The scalings to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_GeometricTransformationScalingsSetNumber",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationScalingsSet(solver,scalings,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NumberToVString(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Solver_GeometricTransformationScalingsSetNumber")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationScalingsSetNumber",err,error)
    EXITS("cmfe_Solver_GeometricTransformationScalingsSetNumber")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationScalingsSetNumber
  
  !
  !================================================================================================================================
  !

  !>Sets the scalings for a geometric transformation solver identified by an object.
  SUBROUTINE cmfe_Solver_GeometricTransformationScalingsSetObj(solver,scalings,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the scalings for.
    REAL(DP), INTENT(IN) :: scalings(:) !<The scalings to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationScalingsSetObj",err,error,*999)
    
    CALL Solver_GeometricTransformationScalingsSet(solver%solver,scalings,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationScalingsSetObj")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationScalingsSetObj",err,error)
    EXITS("cmfe_Solver_GeometricTransformationScalingsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationScalingsSetObj
  
  !
  !================================================================================================================================
  !

  !>Sets the translation for a geometric transformation identified by an user number, default to be the 1st load increment
  SUBROUTINE cmfe_Solver_GeometricTransformationTranslationSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & translation,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the translation for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the translation for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the translation for.
    REAL(DP), INTENT(IN) :: translation(:) !<The translation components to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_GeometricTransformationTranslationSetNumber0",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationTranslationSet(solver,translation,1,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NumberToVString(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Solver_GeometricTransformationTranslationSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationTranslationSetNumber0",err,error)
    EXITS("cmfe_Solver_GeometricTransformationTranslationSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationTranslationSetNumber0
  
  !
  !================================================================================================================================
  !

  !>Sets the translation vector for a geometric transformation solver identified by an object, default to be the 1st load increment
  SUBROUTINE cmfe_Solver_GeometricTransformationTranslationSetObj0(solver,translation,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the translation for.
    REAL(DP), INTENT(IN) :: translation(:) !<The translation components to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationTranslationSetObj0",err,error,*999)
    
    CALL Solver_GeometricTransformationTranslationSet(solver%solver,translation,1,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationTranslationSetObj0")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationTranslationSetObj0",err,error)
    EXITS("cmfe_Solver_GeometricTransformationTranslationSetObj0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationTranslationSetObj0
  
  !
  !================================================================================================================================
  !

  !>Sets the translation at a specific increment for a geometric transformation identified by an user number.
  SUBROUTINE cmfe_Solver_GeometricTransformationTranslationSetNumber1(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & translation,loadIncrementIdx,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the translation for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the translation for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the translation for.
    REAL(DP), INTENT(IN) :: translation(:) !<The translation components to set
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the translation for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_GeometricTransformationTranslationSetNumber1",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationTranslationSet(solver,translation,loadIncrementIdx,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NumberToVString(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Solver_GeometricTransformationTranslationSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationTranslationSetNumber1",err,error)
    EXITS("cmfe_Solver_GeometricTransformationTranslationSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationTranslationSetNumber1
  
  !
  !================================================================================================================================
  !

  !>Sets the translation vector at a specific load increment for a geometric transformation solver identified by an object.
  SUBROUTINE cmfe_Solver_GeometricTransformationTranslationSetObj1(solver,translation,loadIncrementIdx,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the translation for.
    REAL(DP), INTENT(IN) :: translation(:) !<The translation components to set
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the translation for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_GeometricTransformationTranslationSetObj1",err,error,*999)
    
    CALL Solver_GeometricTransformationTranslationSet(solver%solver,translation,loadIncrementIdx,err,error,*999)

    EXITS("cmfe_Solver_GeometricTransformationTranslationSetObj1")
    RETURN
999 ERRORS("cmfe_Solver_GeometricTransformationTranslationSetObj1",err,error)
    EXITS("cmfe_Solver_GeometricTransformationTranslationSetObj1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_GeometricTransformationTranslationSetObj1

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LabelGetCNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LabelGetCNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_GET(SOLVER,label,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Solver_LabelGetCNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelGetCNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelGetCNumber0

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LabelGetCNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LabelGetCNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_GET(SOLVER,label,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    ENDIF

    EXITS("cmfe_Solver_LabelGetCNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelGetCNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelGetCNumber1

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a solver identified by an object.
  SUBROUTINE cmfe_Solver_LabelGetCObj(solver,label,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LabelGetCObj",err,error,*999)

    CALL SOLVER_LABEL_GET(solver%solver,label,err,error,*999)

    EXITS("cmfe_Solver_LabelGetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelGetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LabelGetVSNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LabelGetVSNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_GET(SOLVER,label,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LabelGetVSNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelGetVSNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelGetVSNumber0

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LabelGetVSNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The solver identifiers.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LabelGetVSNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_GET(SOLVER,label,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LabelGetVSNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelGetVSNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelGetVSNumber1

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a solver identified by an object.
  SUBROUTINE cmfe_Solver_LabelGetVSObj(solver,label,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LabelGetVSObj",err,error,*999)

    CALL SOLVER_LABEL_GET(solver%solver,label,err,error,*999)

    EXITS("cmfe_Solver_LabelGetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelGetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LabelSetCNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LabelSetCNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_SET(SOLVER,label,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LabelSetCNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelSetCNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelSetCNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LabelSetCNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The solver identifiers.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LabelSetCNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_SET(SOLVER,label,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LabelSetCNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelSetCNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelSetCNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a solver identified by an object.
  SUBROUTINE cmfe_Solver_LabelSetCObj(solver,label,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LabelSetCObj",err,error,*999)

    CALL SOLVER_LABEL_SET(solver%solver,label,err,error,*999)

    EXITS("cmfe_Solver_LabelSetCObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelSetCObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LabelSetVSNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The solver identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LabelSetVSNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_SET(SOLVER,CHAR(label),err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_SolverLabelStVSNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelSetVSNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelSetVSNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LabelSetVSNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LabelSetVSNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_SET(SOLVER,CHAR(label),err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_SolverLabelStVSNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelSetVSNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelSetVSNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for a solver identified by an object.
  SUBROUTINE cmfe_Solver_LabelSetVSObj(solver,label,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LabelSetVSObj",err,error,*999)

    CALL SOLVER_LABEL_SET(solver%solver,CHAR(label),err,error,*999)

    EXITS("cmfe_Solver_LabelSetVSObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LabelSetVSObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the type of library for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LibraryTypeGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,libraryType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: libraryType !<On return, the library type for the solver. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LibraryTypeGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LIBRARY_TYPE_GET(SOLVER,libraryType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LibraryTypeGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LibraryTypeGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LibraryTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the library type for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LibraryTypeGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,libraryType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: libraryType !<On return, the library type for the solver. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LibraryTypeGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LIBRARY_TYPE_GET(SOLVER,libraryType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LibraryTypeGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LibraryTypeGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LibraryTypeGetNumber1

  !================================================================================================================================
  !

  !>Returns the library type for a solver identified by an object.
  SUBROUTINE cmfe_Solver_LibraryTypeGetObj(solver,libraryType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: libraryType !<On return, the library type for the solver. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LibraryTypeGetObj",err,error,*999)

    CALL SOLVER_LIBRARY_TYPE_GET(solver%solver,libraryType,err,error,*999)

    EXITS("cmfe_Solver_LibraryTypeGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LibraryTypeGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LibraryTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LibraryTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,libraryType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the library type for.
    INTEGER(INTG), INTENT(IN) :: libraryType !<The library type for the solver to set. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LibraryTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LIBRARY_TYPE_SET(SOLVER,libraryType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LibraryTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LibraryTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LibraryTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the library type for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LibraryTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,libraryType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the library type for.
    INTEGER(INTG), INTENT(IN) :: libraryType !<The library type for the solver to set. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LibraryTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LIBRARY_TYPE_SET(SOLVER,libraryType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LibraryTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LibraryTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LibraryTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the library type for a solver identified by an object.
  SUBROUTINE cmfe_Solver_LibraryTypeSetObj(solver,libraryType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: libraryType !<The library type for the solver to set. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LibraryTypeSetObj",err,error,*999)

    CALL SOLVER_LIBRARY_TYPE_SET(solver%solver,libraryType,err,error,*999)

    EXITS("cmfe_Solver_LibraryTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LibraryTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LibraryTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of direct linear solver for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearDirectTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,directSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: directSolverType !<The type of the direct linear solver to set. \see OPENCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearDirectTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_DIRECT_TYPE_SET(SOLVER,directSolverType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearDirectTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearDirectTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearDirectTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of direct linear solver for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearDirectTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,directSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: directSolverType !<The type of the direct linear solver to set. \see OPENCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearDirectTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_DIRECT_TYPE_SET(SOLVER,directSolverType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearDirectTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearDirectTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearDirectTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of direct linear solver for a solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearDirectTypeSetObj(solver,directSolverType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: directSolverType !<The type of the direct linear solver to set. \see OPENCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearDirectTypeSetObj",err,error,*999)

    CALL SOLVER_LINEAR_DIRECT_TYPE_SET(solver%solver,directSolverType,err,error,*999)

    EXITS("cmfe_Solver_LinearDirectTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearDirectTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearDirectTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the MUMPS ICNTL(icntl)=ivalue integer control parameters through the PETSc-MUMPS interface. Must be called after the boundary conditions have been set up.
  SUBROUTINE cmfe_Solver_MumpsSetIcntl(solver,icntl,ivalue,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: icntl !<The MUMPS ICNTL integer control parameter 
    INTEGER(INTG), INTENT(IN) :: ivalue !<The MUMPS ICNTL integer value to set: ICNTL(icntl)=ivalue
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_MumpsSetIcntl",err,error,*999)

    CALL Solver_MumpsSetIcntl(solver%solver,icntl,ivalue,err,error,*999)

    EXITS("cmfe_Solver_MumpsSetIcntl")
    RETURN
999 ERRORSEXITS("cmfe_Solver_MumpsSetIcntl",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_MumpsSetIcntl

  !
  !================================================================================================================================
  !

  !>Sets/changes the MUMPS CNTL(icntl)=val real/complex control parameters through the PETSc-MUMPS interface. Must be called after the boundary conditions have been set up.
  SUBROUTINE cmfe_Solver_MumpsSetCntl(solver,icntl,val,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: icntl !<The MUMPS CNTL integer control parameter 
    REAL(DP), INTENT(IN) :: val !<The MUMPS CNTL real value to set: CNTL(icntl)=val
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_MumpsSetCntl",err,error,*999)

    CALL Solver_MumpsSetCntl(solver%solver,icntl,val,err,error,*999)

    EXITS("cmfe_Solver_MumpsSetCntl")
    RETURN
999 ERRORSEXITS("cmfe_Solver_MumpsSetCntl",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_MumpsSetCntl

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL Solver_LinearIterativeAbsoluteToleranceSet(SOLVER,absoluteTolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL Solver_LinearIterativeAbsoluteToleranceSet(SOLVER,absoluteTolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeAbsoluteToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearIterativeAbsoluteToleranceSetObj(solver,absoluteTolerance,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetObj",err,error,*999)

    CALL Solver_LinearIterativeAbsoluteToleranceSet(solver%solver,absoluteTolerance,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetObj")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetObj",err,error)
    EXITS("cmfe_Solver_LinearIterativeAbsoluteToleranceSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeAbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & divergenceTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: divergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL Solver_LinearIterativeDivergenceToleranceSet(SOLVER,divergenceTolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & divergenceTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: divergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL Solver_LinearIterativeDivergenceToleranceSet(SOLVER,divergenceTolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeDivergenceToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearIterativeDivergenceToleranceSetObj(solver,divergenceTolerance,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: divergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearIterativeDivergenceToleranceSetObj",err,error,*999)

    CALL Solver_LinearIterativeDivergenceToleranceSet(solver%solver,divergenceTolerance,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeDivergenceToleranceSetObj")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeDivergenceToleranceSetObj",err,error)
    EXITS("cmfe_Solver_LinearIterativeDivergenceToleranceSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeDivergenceToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeGMRESRestartSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & GMRESRestart,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the GMRES restart value for.
    INTEGER(INTG), INTENT(IN) :: GMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearIterativeGMRESRestartSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET(SOLVER,GMRESRestart,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearIterativeGMRESRestartSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeGMRESRestartSetNumber0",err,error)
    EXITS("cmfe_Solver_LinearIterativeGMRESRestartSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeGMRESRestartSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeGMRESRestartSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & GMRESRestart,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: GMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearIterativeGMRESRestartSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET(SOLVER,GMRESRestart,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearIterativeGMRESRestartSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeGMRESRestartSetNumber1",err,error)
    EXITS("cmfe_Solver_LinearIterativeGMRESRestartSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeGMRESRestartSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearIterativeGMRESRestartSetObj(solver,GMRESRestart,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: GMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearIterativeGMRESRestartSetObj",err,error,*999)

    CALL SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET(solver%solver,GMRESRestart,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeGMRESRestartSetObj")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeGMRESRestartSetObj",err,error)
    EXITS("cmfe_Solver_LinearIterativeGMRESRestartSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeGMRESRestartSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeMaximumIterationsSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearIterativeMaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL Solver_LinearIterativeMaximumIterationsSet(SOLVER,maximumIterations,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearIterativeMaximumIterationsSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeMaximumIterationsSetNumber0",err,error)
    EXITS("cmfe_Solver_LinearIterativeMaximumIterationsSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeMaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeMaximumIterationsSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearIterativeMaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL Solver_LinearIterativeMaximumIterationsSet(SOLVER,maximumIterations,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearIterativeMaximumIterationsSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeMaximumIterationsSetNumber1",err,error)
    EXITS("cmfe_Solver_LinearIterativeMaximumIterationsSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeMaximumIterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearIterativeMaximumIterationsSetObj(solver,maximumIterations,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearIterativeMaximumIterationsSetObj",err,error,*999)

    CALL Solver_LinearIterativeMaximumIterationsSet(solver%solver,maximumIterations,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeMaximumIterationsSetObj")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeMaximumIterationsSetObj",err,error)
    EXITS("cmfe_Solver_LinearIterativeMaximumIterationsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeMaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the preconditioner type for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativePreconditionerTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & preconditionerType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: preconditionerType !<The preconditioner type to set. \see OPENCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearIterativePreconditionerTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL Solver_LinearIterativePreconditionerTypeSet(SOLVER,preconditionerType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearIterativePreconditionerTypeSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativePreconditionerTypeSetNumber0",err,error)
    EXITS("cmfe_Solver_LinearIterativePreconditionerTypeSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativePreconditionerTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the preconditioner type for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativePreconditionerTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & preconditionerType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: preconditionerType !<The preconditioner type to set. \see OPENCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearIterativePreconditionerTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL Solver_LinearIterativePreconditionerTypeSet(SOLVER,preconditionerType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearIterativePreconditionerTypeSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativePreconditionerTypeSetNumber1",err,error)
    EXITS("cmfe_Solver_LinearIterativePreconditionerTypeSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativePreconditionerTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the preconditioner type for an iterative linear solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearIterativePreconditionerTypeSetObj(solver,preconditionerType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: preconditionerType !<The preconditioner type to set. \see OPENCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearIterativePreconditionerTypeSetObj",err,error,*999)

    CALL Solver_LinearIterativePreconditionerTypeSet(solver%solver,preconditionerType,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativePreconditionerTypeSetObj")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativePreconditionerTypeSetObj",err,error)
    EXITS("cmfe_Solver_LinearIterativePreconditionerTypeSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativePreconditionerTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeRelativeToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearIterativeRelativeToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL Solver_LinearIterativeRelativeToleranceSet(SOLVER,relativeTolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearIterativeRelativeToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeRelativeToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_LinearIterativeRelativeToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeRelativeToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeRelativeToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearIterativeRelativeToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL Solver_LinearIterativeRelativeToleranceSet(SOLVER,relativeTolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearIterativeRelativeToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeRelativeToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_LinearIterativeRelativeToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeRelativeToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearIterativeRelativeToleranceSetObj(solver,relativeTolerance,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearIterativeRelativeToleranceSetObj",err,error,*999)

    CALL Solver_LinearIterativeRelativeToleranceSet(solver%solver,relativeTolerance,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeRelativeToleranceSetObj")
    RETURN
999 ERRORS("cmfe_Solver_LinearIterativeRelativeToleranceSetObj",err,error)
    EXITS("cmfe_Solver_LinearIterativeRelativeToleranceSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeRelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,iterativeSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: iterativeSolverType !<The iterative solver type to set. \see OPENCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearIterativeTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_TYPE_SET(SOLVER,iterativeSolverType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearIterativeTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearIterativeTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for an iterative linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearIterativeTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,iterativeSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: iterativeSolverType !<The iterative solver type to set. \see OPENCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearIterativeTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_TYPE_SET(SOLVER,iterativeSolverType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearIterativeTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearIterativeTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type for an iterative linear solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearIterativeTypeSetObj(solver,iterativeSolverType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: iterativeSolverType !<The iterative solver type to set. \see OPENCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearIterativeTypeSetObj",err,error,*999)

    CALL SOLVER_LINEAR_ITERATIVE_TYPE_SET(solver%solver,iterativeSolverType,err,error,*999)

    EXITS("cmfe_Solver_LinearIterativeTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearIterativeTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearIterativeTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for a linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,linearSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: linearSolverType !<The linear solver type to set. \see OPENCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_TYPE_SET(SOLVER,linearSolverType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for a linear solver identified by an user number.
  SUBROUTINE cmfe_Solver_LinearTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,linearSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: linearSolverType !<The linear solver type to set. \see OPENCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_LinearTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_TYPE_SET(SOLVER,linearSolverType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_LinearTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type for a linear solver identified by an object.
  SUBROUTINE cmfe_Solver_LinearTypeSetObj(solver,linearSolverType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: linearSolverType !<The linear solver type to set. \see OPENCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_LinearTypeSetObj",err,error,*999)

    CALL SOLVER_LINEAR_TYPE_SET(solver%solver,linearSolverType,err,error,*999)

    EXITS("cmfe_Solver_LinearTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_LinearTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_LinearTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for an Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonAbsoluteToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonAbsoluteToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET(SOLVER,absoluteTolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonAbsoluteToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonAbsoluteToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonAbsoluteToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonAbsoluteToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonAbsoluteToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,absoluteTolerance, &
    & err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonAbsoluteToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET(SOLVER,absoluteTolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonAbsoluteToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonAbsoluteToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonAbsoluteToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonAbsoluteToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonAbsoluteToleranceSetObj(solver,absoluteTolerance,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonAbsoluteToleranceSetObj",err,error,*999)

    CALL SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET(solver%solver,absoluteTolerance,err,error,*999)

    EXITS("cmfe_Solver_NewtonAbsoluteToleranceSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonAbsoluteToleranceSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonAbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & monitorLinesearchFlag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the linesearch monitoring for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL Solver_NewtonLineSearchMonitorOutputSet(SOLVER,monitorLinesearchFlag,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber0

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & monitorLinesearchFlag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL Solver_NewtonLineSearchMonitorOutputSet(SOLVER,monitorLinesearchFlag,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchMonitorOutputSetNumber1

  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonLineSearchMonitorOutputSetObj(solver,monitorLinesearchFlag,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the linesearch monitoring for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonLineSearchMonitorOutputSetObj",err,error,*999)

    CALL Solver_NewtonLineSearchMonitorOutputSet(solver%solver,monitorLinesearchFlag,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchMonitorOutputSetObj")
    RETURN
999 ERRORS("cmfe_Solver_NewtonLineSearchMonitorOutputSetObj",err,error)
    EXITS("cmfe_Solver_NewtonLineSearchMonitorOutputSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchMonitorOutputSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for an Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonJacobianCalculationTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & jacobianCalculationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonJacobianCalculationTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET(SOLVER,jacobianCalculationType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonJacobianCalculationTypeSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonJacobianCalculationTypeSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonJacobianCalculationTypeSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonJacobianCalculationTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonJacobianCalculationTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & jacobianCalculationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonJacobianCalculationTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET(SOLVER,jacobianCalculationType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonJacobianCalculationTypeSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonJacobianCalculationTypeSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonJacobianCalculationTypeSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonJacobianCalculationTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonJacobianCalculationTypeSetObj(solver,jacobianCalculationType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonJacobianCalculationTypeSetObj",err,error,*999)

    CALL SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET(solver%solver,jacobianCalculationType,err,error,*999)

    EXITS("cmfe_Solver_NewtonJacobianCalculationTypeSetObj")
    RETURN
999 ERRORS("cmfe_Solver_NewtonJacobianCalculationTypeSetObj",err,error)
    EXITS("cmfe_Solver_NewtonJacobianCalculationTypeSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonJacobianCalculationTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLinearSolverGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,linearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the solver index of the linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonLinearSolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from linear solver
      linearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonLinearSolverGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLinearSolverGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLinearSolverGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,linearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the Newton linear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonLinearSolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from linear solver
      linearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonLinearSolverGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLinearSolverGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLinearSolverGetNumber1

  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonLinearSolverGetObj(solver,linearSolver,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the Newton linear solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: linearSolver !<On return, the Newton linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonLinearSolverGetObj",err,error,*999)

    CALL SOLVER_NEWTON_LINEAR_SOLVER_GET(solver%solver,linearSolver%solver,err,error,*999)

    EXITS("cmfe_Solver_NewtonLinearSolverGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLinearSolverGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonCellMLSolverGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,CellMLSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: CellMLSolverIndex !<On return, the solver index of the CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,CELLML_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonCellMLSolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(CELLML_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_CELLML_SOLVER_GET(SOLVER,CELLML_SOLVER,err,error,*999)
      !todo: get the solver index from CellML solver
      CellMLSolverIndex=CELLML_SOLVER%GLOBAL_NUMBER
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonCellMLSolverGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonCellMLSolverGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonCellMLSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonCellMLSolverGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,CellMLSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: CellMLSolverIndex !<On return, the Newton CellML solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,CELLML_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonCellMLSolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(CELLML_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_CELLML_SOLVER_GET(SOLVER,CELLML_SOLVER,err,error,*999)
      !todo: get the solver index from CellML solver
      CellMLSolverIndex=CELLML_SOLVER%GLOBAL_NUMBER
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonCellMLSolverGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonCellMLSolverGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonCellMLSolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonCellMLSolverGetObj(solver,CellMLSolver,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the Newton CellML solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: CellMLSolver !<On return, the Newton CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonCellMLSolverGetObj",err,error,*999)

    CALL SOLVER_NEWTON_CELLML_SOLVER_GET(solver%solver,CellMLSolver%solver,err,error,*999)

    EXITS("cmfe_Solver_NewtonCellMLSolverGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonCellMLSolverGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonCellMLSolverGetObj
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for an Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonConvergenceTestTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & convergenceTestType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the convergence test for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonConvergenceTestTypeSetNumber0",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      CALL Solver_NewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonConvergenceTestTypeSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonConvergenceTestTypeSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonConvergenceTestTypeSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonConvergenceTestTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonConvergenceTestTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
      & convergenceTestType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonConvergenceTestTypeSetNumber1",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
      CALL Solver_NewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonConvergenceTestTypeSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonConvergenceTestTypeSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonConvergenceTestTypeSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonConvergenceTestTypeSetNumber1
  
  ! 
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonConvergenceTestTypeSetObj(solver,convergenceTestType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonConvergenceTestTypeSetObj",err,error,*999)

    CALL Solver_NewtonConvergenceTestTypeSet(solver%solver,convergenceTestType,err,error,*999)

    EXITS("cmfe_Solver_NewtonConvergenceTestTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonConvergenceTestTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonConvergenceTestTypeSetObj

  !
  !================================================================================================================================
  !
  
  !>Sets/changes the line search alpha for an Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchAlphaSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,alpha,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search alpha for.
    REAL(DP), INTENT(IN) :: alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonLineSearchAlphaSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_ALPHA_SET(SOLVER,alpha,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonLineSearchAlphaSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLineSearchAlphaSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchAlphaSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search alpha for a Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchAlphaSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,alpha,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the alpha for.
    REAL(DP), INTENT(IN) :: alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonLineSearchAlphaSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_ALPHA_SET(SOLVER,alpha,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonLineSearchAlphaSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLineSearchAlphaSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchAlphaSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search alpha for a Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonLineSearchAlphaSetObj(solver,alpha,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton line search solver to set the alpha for.
    REAL(DP), INTENT(IN) :: alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonLineSearchAlphaSetObj",err,error,*999)

    CALL SOLVER_NEWTON_LINESEARCH_ALPHA_SET(solver%solver,alpha,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchAlphaSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLineSearchAlphaSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchAlphaSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for an Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchMaxStepSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,maxStep,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonLineSearchMaxStepSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET(SOLVER,maxStep,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonLineSearchMaxStepSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonLineSearchMaxStepSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonLineSearchMaxStepSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchMaxStepSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchMaxStepSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,maxStep,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonLineSearchMaxStepSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET(SOLVER,maxStep,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonLineSearchMaxStepSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonLineSearchMaxStepSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonLineSearchMaxStepSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchMaxStepSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonLineSearchMaxStepSetObj(solver,maxStep,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton line search solver to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonLineSearchMaxStepSetObj",err,error,*999)

    CALL SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET(solver%solver,maxStep,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchMaxStepSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLineSearchMaxStepSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchMaxStepSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for an Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchStepTolSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,stepTol,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonLineSearchStepTolSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_STEPTOL_SET(SOLVER,stepTol,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonLineSearchStepTolSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonLineSearchStepTolSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonLineSearchStepTolSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchStepTolSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchStepTolSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,stepTol,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonLineSearchStepTolSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_STEPTOL_SET(SOLVER,stepTol,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonLineSearchStepTolSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonLineSearchStepTolSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonLineSearchStepTolSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchStepTolSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonLineSearchStepTolSetObj(solver,stepTol,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton line search solver to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonLineSearchStepTolSetObj",err,error,*999)

    CALL SOLVER_NEWTON_LINESEARCH_STEPTOL_SET(solver%solver,stepTol,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchStepTolSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLineSearchStepTolSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchStepTolSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search type for an Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,lineSearchType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Newton line search solver to set. \see OPENCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonLineSearchTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_TYPE_SET(SOLVER,lineSearchType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonLineSearchTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLineSearchTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonLineSearchTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,lineSearchType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Newton line search solver to set. \see OPENCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonLineSearchTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_TYPE_SET(SOLVER,lineSearchType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonLineSearchTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLineSearchTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonLineSearchTypeSetObj(solver,lineSearchType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Newton line search solver to set. \see OPENCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonLineSearchTypeSetObj",err,error,*999)

    CALL SOLVER_NEWTON_LINESEARCH_TYPE_SET(solver%solver,lineSearchType,err,error,*999)

    EXITS("cmfe_Solver_NewtonLineSearchTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonLineSearchTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonLineSearchTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for an Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & maximumFunctionEvaluations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL Solver_NewtonMaximumFunctionEvaluationsSet(SOLVER,maximumFunctionEvaluations,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & maximumFunctionEvaluations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL Solver_NewtonMaximumFunctionEvaluationsSet(SOLVER,maximumFunctionEvaluations,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetObj(solver,maximumFunctionEvaluations,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the maximum number of function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetObj",err,error,*999)

    CALL Solver_NewtonMaximumFunctionEvaluationsSet(solver%solver,maximumFunctionEvaluations,err,error,*999)

    EXITS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetObj")
    RETURN
999 ERRORS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetObj",err,error)
    EXITS("cmfe_Solver_NewtonMaximumFunctionEvaluationsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonMaximumFunctionEvaluationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonMaximumIterationsSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonMaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET(SOLVER,maximumIterations,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonMaximumIterationsSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonMaximumIterationsSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonMaximumIterationsSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonMaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonMaximumIterationsSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,maximumIterations, &
    & err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonMaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET(SOLVER,maximumIterations,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonMaximumIterationsSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonMaximumIterationsSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonMaximumIterationsSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonMaximumIterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonMaximumIterationsSetObj(solver,maximumIterations,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonMaximumIterationsSetObj",err,error,*999)

    CALL SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET(solver%solver,maximumIterations,err,error,*999)

    EXITS("cmfe_Solver_NewtonMaximumIterationsSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonMaximumIterationsSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonMaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for an Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonRelativeToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonRelativeToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_RELATIVE_TOLERANCE_SET(SOLVER,relativeTolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonRelativeToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonRelativeToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonRelativeToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonRelativeToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonRelativeToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,relativeTolerance, &
    & err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonRelativeToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_RELATIVE_TOLERANCE_SET(SOLVER,relativeTolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonRelativeToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonRelativeToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonRelativeToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonRelativeToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonRelativeToleranceSetObj(solver,relativeTolerance,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonRelativeToleranceSetObj",err,error,*999)

    CALL SOLVER_NEWTON_RELATIVE_TOLERANCE_SET(solver%solver,relativeTolerance,err,error,*999)

    EXITS("cmfe_Solver_NewtonRelativeToleranceSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonRelativeToleranceSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonRelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for an Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonSolutionToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & solutionTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonSolutionToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_SOLUTION_TOLERANCE_SET(SOLVER,solutionTolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonSolutionToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonSolutionToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonSolutionToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonSolutionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonSolutionToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,solutionTolerance, &
    & err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The absolulte tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonSolutionToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_SOLUTION_TOLERANCE_SET(SOLVER,solutionTolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonSolutionToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonSolutionToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonSolutionToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonSolutionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonSolutionToleranceSetObj(solver,solutionTolerance,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonSolutionToleranceSetObj",err,error,*999)

    CALL SOLVER_NEWTON_SOLUTION_TOLERANCE_SET(solver%solver,solutionTolerance,err,error,*999)

    EXITS("cmfe_Solver_NewtonSolutionToleranceSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonSolutionToleranceSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonSolutionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Newton trust region solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonTrustRegionDelta0SetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,delta0,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonTrustRegionDelta0SetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TRUSTREGION_DELTA0_SET(SOLVER,delta0,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonTrustRegionDelta0SetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonTrustRegionDelta0SetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonTrustRegionDelta0SetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTrustRegionDelta0SetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Newton trust region solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonTrustRegionDelta0SetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,delta0,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonTrustRegionDelta0SetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TRUSTREGION_DELTA0_SET(SOLVER,delta0,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonTrustRegionDelta0SetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonTrustRegionDelta0SetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonTrustRegionDelta0SetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTrustRegionDelta0SetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Newton trust region solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonTrustRegionDelta0SetObj(solver,delta0,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton trust region solver to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonTrustRegionDelta0SetObj",err,error,*999)

    CALL SOLVER_NEWTON_TRUSTREGION_DELTA0_SET(solver%solver,delta0,err,error,*999)

    EXITS("cmfe_Solver_NewtonTrustRegionDelta0SetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonTrustRegionDelta0SetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTrustRegionDelta0SetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Newton trust region solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonTrustRegionToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,tolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonTrustRegionToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET(SOLVER,tolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonTrustRegionToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_NewtonTrustRegionToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_NewtonTrustRegionToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTrustRegionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Newton trust region solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonTrustRegionToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,tolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonTrustRegionToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET(SOLVER,tolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonTrustRegionToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_NewtonTrustRegionToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_NewtonTrustRegionToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTrustRegionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Newton trust region solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonTrustRegionToleranceSetObj(solver,tolerance,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton trust region solver to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonTrustRegionToleranceSetObj",err,error,*999)

    CALL SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET(solver%solver,tolerance,err,error,*999)

    EXITS("cmfe_Solver_NewtonTrustRegionToleranceSetObj")
    RETURN
999 ERRORS("cmfe_Solver_NewtonTrustRegionToleranceSetObj",err,error)
    EXITS("cmfe_Solver_NewtonTrustRegionToleranceSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTrustRegionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,newtonSolveType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: newtonSolveType !<The type of the Newton solver to set. \see OPENCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TYPE_SET(SOLVER,newtonSolveType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_NewtonTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,newtonSolveType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: newtonSolveType !<The type of the Newton solver to set. \see OPENCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_NewtonTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TYPE_SET(SOLVER,newtonSolveType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NewtonTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_NewtonTypeSetObj(solver,newtonSolveType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: newtonSolveType !<The type of the Newton solver to set. \see OPENCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NewtonTypeSetObj",err,error,*999)

    CALL SOLVER_NEWTON_TYPE_SET(solver%solver,newtonSolveType,err,error,*999)

    EXITS("cmfe_Solver_NewtonTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NewtonTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NewtonTypeSetObj

  !
  !================================================================================================================================
  !
  !>Sets/changes the absolute tolerance for an Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_ABSOLUTE_TOLERANCE_SET(SOLVER,absoluteTolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber1(problemUserNumber, &
      & controlLoopIdentifiers,solverIndex,absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_ABSOLUTE_TOLERANCE_SET(SOLVER,absoluteTolerance,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetObj(solver,absoluteTolerance,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_ABSOLUTE_TOLERANCE_SET(solver%solver,absoluteTolerance,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonAbsoluteToleranceSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonAbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Quasi-Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0(problemUserNumber, &
      & controlLoopIdentifier,solverIndex,monitorLinesearchFlag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the linesearch monitoring for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL Solver_QuasiNewtonLineSearchMonitorOutputSet(SOLVER,monitorLinesearchFlag,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber0

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Quasi-Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
      & monitorLinesearchFlag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL Solver_QuasiNewtonLineSearchMonitorOutputSet(SOLVER,monitorLinesearchFlag,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetNumber1

  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Quasi-Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetObj(solver,monitorLinesearchFlag,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the linesearch monitoring for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetObj",err,error,*999)

    CALL Solver_QuasiNewtonLineSearchMonitorOutputSet(solver%solver,monitorLinesearchFlag,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMonitorOutputSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for an Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & jacobianCalculationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Quasi-Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL Solver_QuasiNewtonJacobianCalculationTypeSet(SOLVER,jacobianCalculationType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
      & jacobianCalculationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Quasi-Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL Solver_QuasiNewtonJacobianCalculationTypeSet(SOLVER,jacobianCalculationType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetObj(solver,jacobianCalculationType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Quasi-Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetObj",err,error,*999)

    CALL Solver_QuasiNewtonJacobianCalculationTypeSet(solver%solver,jacobianCalculationType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonJacobianCalculationTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLinearSolverGetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,linearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the solver index of the linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonLinearSolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from linear solver
      linearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonLinearSolverGetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLinearSolverGetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLinearSolverGetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLinearSolverGetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,linearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the Quasi-Newton linear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonLinearSolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from linear solver
      linearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonLinearSolverGetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLinearSolverGetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLinearSolverGetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLinearSolverGetNumber1

  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonLinearSolverGetObj(solver,linearSolver,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the Quasi-Newton linear solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: linearSolver !<On return, the Quasi-Newton linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonLinearSolverGetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_LINEAR_SOLVER_GET(solver%solver,linearSolver%solver,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLinearSolverGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonLinearSolverGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonCellMLSolverGetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,CellMLSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: CellMLSolverIndex !<On return, the solver index of the CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,CELLML_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonCellMLSolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(CELLML_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_CELLML_SOLVER_GET(SOLVER,CELLML_SOLVER,err,error,*999)
      !todo: get the solver index from CellML solver
      CellMLSolverIndex=CELLML_SOLVER%GLOBAL_NUMBER
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonCellMLSolverGetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonCellMLSolverGetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonCellMLSolverGetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonCellMLSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonCellMLSolverGetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,CellMLSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: CellMLSolverIndex !<On return, the Quasi-Newton CellML solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,CELLML_SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonCellMLSolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(CELLML_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_CELLML_SOLVER_GET(SOLVER,CELLML_SOLVER,err,error,*999)
      !todo: get the solver index from CellML solver
      CellMLSolverIndex=CELLML_SOLVER%GLOBAL_NUMBER
      CALL FlagError("Not implemented.",err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonCellMLSolverGetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonCellMLSolverGetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonCellMLSolverGetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonCellMLSolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonCellMLSolverGetObj(solver,CellMLSolver,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the Quasi-Newton CellML solver for.
    TYPE(cmfe_SolverType), INTENT(INOUT) :: CellMLSolver !<On return, the Quasi-Newton CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonCellMLSolverGetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_CELLML_SOLVER_GET(solver%solver,CellMLSolver%solver,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonCellMLSolverGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonCellMLSolverGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonCellMLSolverGetObj
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for an Quasi-Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & convergenceTestType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the convergence test for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber0",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      CALL Solver_QuasiNewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
      & convergenceTestType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber1",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
      CALL Solver_QuasiNewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetNumber1
  
  ! 
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetObj(solver,convergenceTestType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetObj",err,error,*999)

    CALL Solver_QuasiNewtonConvergenceTestTypeSet(solver%solver,convergenceTestType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonConvergenceTestTypeSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonConvergenceTestTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for an Quasi-Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,maxStep,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_LINESEARCH_MAXSTEP_SET(SOLVER,maxStep,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Quasi-Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,maxStep,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_LINESEARCH_MAXSTEP_SET(SOLVER,maxStep,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Quasi-Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetObj(solver,maxStep,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton line search solver to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_LINESEARCH_MAXSTEP_SET(solver%solver,maxStep,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchMaxStepSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchMaxStepSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for an Quasi-Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,stepTol,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_LINESEARCH_STEPTOL_SET(SOLVER,stepTol,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Quasi-Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,stepTol,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_LINESEARCH_STEPTOL_SET(SOLVER,stepTol,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchStepTolSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Quasi-Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchStepTolSetObj(solver,stepTol,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton line search solver to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_LINESEARCH_STEPTOL_SET(solver%solver,stepTol,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchStepTolSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchStepTolSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search type for an Quasi-Newton linesearch solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,lineSearchType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Quasi-Newton line search solver to set. \see OPENCMISS_QuasiNewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_LINESEARCH_TYPE_SET(SOLVER,lineSearchType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Quasi-Newton line search solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,lineSearchType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Quasi-Newton line search solver to set. \see OPENCMISS_QuasiNewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_LINESEARCH_TYPE_SET(SOLVER,lineSearchType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Quasi-Newton line search solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchTypeSetObj(solver,lineSearchType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Quasi-Newton line search solver to set. \see OPENCMISS_QuasiNewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonLineSearchTypeSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_LINESEARCH_TYPE_SET(solver%solver,lineSearchType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonLineSearchTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonLineSearchTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonLineSearchTypeSetObj


  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for an Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & maximumFunctionEvaluations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL Solver_QuasiNewtonMaximumFunctionEvaluationsSet(SOLVER,maximumFunctionEvaluations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
      & maximumFunctionEvaluations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL Solver_QuasiNewtonMaximumFunctionEvaluationsSet(SOLVER,maximumFunctionEvaluations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj(solver,maximumFunctionEvaluations,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the maximum number of function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj",err,error,*999)

    CALL Solver_QuasiNewtonMaximumFunctionEvaluationsSet(solver%solver,maximumFunctionEvaluations,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonMaximumFunctionEvaluationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_MAXIMUM_ITERATIONS_SET(SOLVER,maximumIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_MAXIMUM_ITERATIONS_SET(SOLVER,maximumIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonMaximumIterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonMaximumIterationsSetObj(solver,maximumIterations,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonMaximumIterationsSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_MAXIMUM_ITERATIONS_SET(solver%SOLVER,maximumIterations,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonMaximumIterationsSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonMaximumIterationsSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonMaximumIterationsSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonMaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for an Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_RELATIVE_TOLERANCE_SET(SOLVER,relativeTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_RELATIVE_TOLERANCE_SET(SOLVER,relativeTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRelativeToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonRelativeToleranceSetObj(solver,relativeTolerance,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonRelativeToleranceSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_RELATIVE_TOLERANCE_SET(solver%SOLVER,relativeTolerance,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonRelativeToleranceSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonRelativeToleranceSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonRelativeToleranceSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for an Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,solutionTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_SOLUTION_TOLERANCE_SET(SOLVER,solutionTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,solutionTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The absolulte tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_SOLUTION_TOLERANCE_SET(SOLVER,solutionTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonSolutionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonSolutionToleranceSetObj(solver,solutionTolerance,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonSolutionToleranceSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_SOLUTION_TOLERANCE_SET(solver%SOLVER,solutionTolerance,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonSolutionToleranceSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonSolutionToleranceSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonSolutionToleranceSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonSolutionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Quasi-Newton trust region solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,delta0,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_TRUSTREGION_DELTA0_SET(SOLVER,delta0,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Quasi-Newton trust region solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,delta0,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_TRUSTREGION_DELTA0_SET(SOLVER,delta0,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Quasi-Newton trust region solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetObj(solver,delta0,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton trust region solver to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_TRUSTREGION_DELTA0_SET(solver%SOLVER,delta0,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonTrustRegionDelta0SetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionDelta0SetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Quasi-Newton trust region solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,tolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL Solver_QuasiNewtonTrustRegionToleranceSet(SOLVER,tolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Quasi-Newton trust region solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,tolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL Solver_QuasiNewtonTrustRegionToleranceSet(SOLVER,tolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Quasi-Newton trust region solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetObj(solver,tolerance,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton trust region solver to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetObj",err,error,*999)

    CALL Solver_QuasiNewtonTrustRegionToleranceSet(solver%solver,tolerance,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetObj")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetObj",err,error)
    EXITS("cmfe_Solver_QuasiNewtonTrustRegionToleranceSetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTrustRegionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the restart of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonRestartSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,quasiNewtonRestart,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestart !<The restart of the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonRestartSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_RESTART_SET(SOLVER,quasiNewtonRestart,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonRestartSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonRestartSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRestartSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the restart of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonRestartSetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,quasiNewtonRestart,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestart !<The restart of the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonRestartSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_RESTART_SET(SOLVER,quasiNewtonRestart,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonRestartSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonRestartSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRestartSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the restart of a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonRestartSetObj(solver,quasiNewtonRestart,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestart !<The restart of the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonRestartSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_RESTART_SET(solver%SOLVER,quasiNewtonRestart,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonRestartSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonRestartSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRestartSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the restart type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonRestartTypeSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,quasiNewtonRestartType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestartType !<The restart type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonRestartTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonRestartTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_RESTART_TYPE_SET(SOLVER,quasiNewtonRestartType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonRestartTypeSetNumber0")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonRestartTypeSetNumber0",err,error)
    EXITS("cmfe_Solver_QuasiNewtonRestartTypeSetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRestartTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the restart type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonRestartTypeSetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,quasiNewtonRestartType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestartType !<The restart type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonRestartTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonRestartTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_RESTART_TYPE_SET(SOLVER,quasiNewtonRestartType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonRestartTypeSetNumber1")
    RETURN
999 ERRORS("cmfe_Solver_QuasiNewtonRestartTypeSetNumber1",err,error)
    EXITS("cmfe_Solver_QuasiNewtonRestartTypeSetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRestartTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the restart type of a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonRestartTypeSetObj(solver,quasiNewtonRestartType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestartType !<The restart type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonRestartTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonRestartTypeSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_RESTART_TYPE_SET(solver%SOLVER,quasiNewtonRestartType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonRestartTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonRestartTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonRestartTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the scale type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonScaleTypeSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,quasiNewtonScaleType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonScaleType !<The scale type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonScaleTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonScaleTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_SCALE_TYPE_SET(SOLVER,quasiNewtonScaleType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonScaleTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonScaleTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonScaleTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the scale type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonScaleTypeSetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,quasiNewtonScaleType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonScaleType !<The scale type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonScaleTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonScaleTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_SCALE_TYPE_SET(SOLVER,quasiNewtonScaleType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonScaleTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonScaleTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonScaleTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the scale type of a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonScaleTypeSetObj(solver,quasiNewtonScaleType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonScaleType !<The scale type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonScaleTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonScaleTypeSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_SCALE_TYPE_SET(solver%SOLVER,quasiNewtonScaleType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonScaleTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonScaleTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonScaleTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonSolveTypeSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,quasiNewtonSolveType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonSolveType !<The type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonSolveTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_SOLVE_TYPE_SET(SOLVER,quasiNewtonSolveType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonSolveTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonSolveTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonSolveTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonSolveTypeSetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,quasiNewtonSolveType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonSolveType !<The type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonSolveTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_SOLVE_TYPE_SET(SOLVER,quasiNewtonSolveType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonSolveTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonSolveTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonSolveTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonSolveTypeSetObj(solver,quasiNewtonSolveType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonSolveType !<The type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonSolveTypeSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_SOLVE_TYPE_SET(solver%SOLVER,quasiNewtonSolveType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonSolveTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonSolveTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonSolveTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonTypeSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,quasiNewtonType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonType !<The Quasi-Newton type to set. \see OPENCMISS_QuasiNewtonTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_TYPE_SET(SOLVER,quasiNewtonType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE cmfe_Solver_QuasiNewtonTypeSetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,quasiNewtonType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonType !<The Quasi-Newton type to set. \see OPENCMISS_QuasiNewtonTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_QuasiNewtonTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_TYPE_SET(SOLVER,quasiNewtonType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_QuasiNewtonTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an object.
  SUBROUTINE cmfe_Solver_QuasiNewtonTypeSetObj(solver,quasiNewtonType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonType !<The Quasi-Newton type to set. \see OPENCMISS_QuasiNewtonTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_QuasiNewtonTypeSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_TYPE_SET(solver%SOLVER,quasiNewtonType,err,error,*999)

    EXITS("cmfe_Solver_QuasiNewtonTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_QuasiNewtonTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_QuasiNewtonTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a nonlinear solver identified by an user number.
  SUBROUTINE cmfe_Solver_NonlinearTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,nonlinearSolveType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: nonlinearSolveType !<The type of the nonlinear solver to set. \see OPENCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_NonlinearTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NONLINEAR_TYPE_SET(SOLVER,nonlinearSolveType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NonlinearTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NonlinearTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NonlinearTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a nonlinear solver identified by an user number.
  SUBROUTINE cmfe_Solver_NonlinearTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,nonlinearSolveType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: nonlinearSolveType !<The type of the nonlinear solver to set. \see OPENCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_NonlinearTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NONLINEAR_TYPE_SET(SOLVER,nonlinearSolveType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_NonlinearTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NonlinearTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NonlinearTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a nonlinear solver identified by an object.
  SUBROUTINE cmfe_Solver_NonlinearTypeSetObj(solver,nonlinearSolveType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: nonlinearSolveType !<The type of the nonlinear solver to set. \see OPENCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_NonlinearTypeSetObj",err,error,*999)

    CALL SOLVER_NONLINEAR_TYPE_SET(solver%SOLVER,nonlinearSolveType,err,error,*999)

    EXITS("cmfe_Solver_NonlinearTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_NonlinearTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_NonlinearTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_OutputTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The type of solver output to set. \see OPENCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_OutputTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_OUTPUT_TYPE_SET(SOLVER,outputType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_OutputTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_OutputTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_OutputTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of output for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_OutputTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the output type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The type of solver output to set. \see OPENCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_OutputTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_OUTPUT_TYPE_SET(SOLVER,outputType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_OutputTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_OutputTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_OutputTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the output type for a solver identified by an object.
  SUBROUTINE cmfe_Solver_OutputTypeSetObj(solver,outputType,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The type of solver output to set. \see OPENCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_OutputTypeSetObj",err,error,*999)

    CALL SOLVER_OUTPUT_TYPE_SET(solver%SOLVER,outputType,err,error,*999)

    EXITS("cmfe_Solver_OutputTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_OutputTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the solver equations for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_SolverEquationsGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,solverEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(cmfe_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_SolverEquationsGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,solverEquations%solverEquations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_SolverEquationsGetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_Solver_SolverEquationsGetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_SolverEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solver equations for a solver identified by an user number.
  SUBROUTINE cmfe_Solver_SolverEquationsGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,solverEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(cmfe_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_Solver_SolverEquationsGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,solverEquations%solverEquations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_Solver_SolverEquationsGetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_Solver_SolverEquationsGetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_SolverEquationsGetNumber1

  !================================================================================================================================
  !

  !>Returns the solver equations for a solver identified by an object.
  SUBROUTINE cmfe_Solver_SolverEquationsGetObj(solver,solverEquations,err)

    !Argument variables
    TYPE(cmfe_SolverType), INTENT(IN) :: solver !<The solver to get the solver equations for.
    TYPE(cmfe_SolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_Solver_SolverEquationsGetObj",err,error,*999)

    CALL SOLVER_SOLVER_EQUATIONS_GET(solver%SOLVER,solverEquations%solverEquations,err,error,*999)

    EXITS("cmfe_Solver_SolverEquationsGetObj")
    RETURN
999 ERRORSEXITS("cmfe_Solver_SolverEquationsGetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_Solver_SolverEquationsGetObj

  !
  !================================================================================================================================
  !

  !>Adds equations sets to solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_EquationsSetAddNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & regionUserNumber,equationsSetUserNumber,equationsSetIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region with the equations set to add.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to add.
    INTEGER(INTG), INTENT(OUT) :: equationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_SolverEquations_EquationsSetAddNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
      IF(ASSOCIATED(REGION)) THEN
        CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
        IF(ASSOCIATED(EQUATIONS_SET)) THEN
          CALL SOLVER_EQUATIONS_EQUATIONS_SET_ADD(SOLVER_EQUATIONS,EQUATIONS_SET,equationsSetIndex,err,error,*999)
        ELSE
          LOCAL_ERROR="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FlagError(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_SolverEquations_EquationsSetAddNumber0")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_EquationsSetAddNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_EquationsSetAddNumber0

  !
  !================================================================================================================================
  !

  !>Adds equations sets to solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_EquationsSetAddNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,equationsSetUserNumber,equationsSetIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region with the equations set to add.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to add.
    INTEGER(INTG), INTENT(OUT) :: equationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_SolverEquations_EquationsSetAddNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
      IF(ASSOCIATED(REGION)) THEN
        CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
        IF(ASSOCIATED(EQUATIONS_SET)) THEN
          CALL SOLVER_EQUATIONS_EQUATIONS_SET_ADD(SOLVER_EQUATIONS,EQUATIONS_SET,equationsSetIndex,err,error,*999)
        ELSE
          LOCAL_ERROR="An equations set with an user number of "//TRIM(NumberToVString(equationsSetUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
          CALL FlagError(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FlagError(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_SolverEquations_EquationsSetAddNumber1")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_EquationsSetAddNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_EquationsSetAddNumber1

  !================================================================================================================================
  !

  !>Adds equations sets to solver equations identified by an object.
  SUBROUTINE cmfe_SolverEquations_EquationsSetAddObj(solverEquations,equationsSet,equationsSetIndex,err)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to add the equations set for.
    TYPE(cmfe_EquationsSetType), INTENT(IN) :: equationsSet !<The equations set to add.
    INTEGER(INTG), INTENT(OUT) :: equationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_SolverEquations_EquationsSetAddObj",err,error,*999)

    CALL SOLVER_EQUATIONS_EQUATIONS_SET_ADD(solverEquations%solverEquations,equationsSet%equationsSet,equationsSetIndex, &
      & err,error,*999)

    EXITS("cmfe_SolverEquations_EquationsSetAddObj")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_EquationsSetAddObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_EquationsSetAddObj

  !
  !================================================================================================================================
  !

  !>Adds an interface condition to solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_InterfaceConditionAddNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & interfaceRegionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,interfaceConditionIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the region containing the interface and interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to add.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIndex !<On return, the index of the added interface condition in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: INTERFACE_REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_SolverEquations_InterfaceConditionAddNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(INTERFACE_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(interfaceRegionUserNumber,INTERFACE_REGION,err,error,*999)
      IF(ASSOCIATED(INTERFACE_REGION)) THEN
        CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,INTERFACE_REGION,INTERFACE,err,error,*999)
        IF(ASSOCIATED(INTERFACE)) THEN
          CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
          IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
            CALL SOLVER_EQUATIONS_INTERFACE_CONDITION_ADD(SOLVER_EQUATIONS,INTERFACE_CONDITION,interfaceConditionIndex, &
              & err,error,*999)
          ELSE
            LOCAL_ERROR="An interface condition with an user number of "// &
              & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
              & " does not exist on interface number "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
              & " of parent region number "//TRIM(NumberToVString(interfaceRegionUserNumber,"*",err,error))//"."
            CALL FlagError(LOCAL_ERROR,err,error,*999)
          END IF
        ELSE
          LOCAL_ERROR="An interface with an user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " does not exist on parent region number "// &
            & TRIM(NumberToVString(interfaceRegionUserNumber,"*",err,error))//"."
          CALL FlagError(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NumberToVString(interfaceRegionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FlagError(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_SolverEquationsInterfaceConditionNumber0")
    RETURN
999 ERRORS("cmfe_SolverEquations_InterfaceConditionAddNumber0",err,error)
    EXITS("cmfe_SolverEquations_InterfaceConditionAddNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_InterfaceConditionAddNumber0

  !
  !================================================================================================================================
  !

  !>Adds an interface condition to solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_InterfaceConditionAddNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & interfaceRegionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,interfaceConditionIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the region containing the interface and interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containting the interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface conditions to add.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIndex !<On return, the index of the added interface condition in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: INTERFACE_REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_SolverEquations_InterfaceConditionAddNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(INTERFACE_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(interfaceRegionUserNumber,INTERFACE_REGION,err,error,*999)
      IF(ASSOCIATED(INTERFACE_REGION)) THEN
        CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,INTERFACE_REGION,INTERFACE,err,error,*999)
        IF(ASSOCIATED(INTERFACE)) THEN
          CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
          IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
            CALL SOLVER_EQUATIONS_INTERFACE_CONDITION_ADD(SOLVER_EQUATIONS,INTERFACE_CONDITION,interfaceConditionIndex, &
              & err,error,*999)
          ELSE
            LOCAL_ERROR="An interface condition with an user number of "// &
              & TRIM(NumberToVString(interfaceConditionUserNumber,"*",err,error))// &
              & " does not exist on interface number "//TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
              & " of parent region number "//TRIM(NumberToVString(interfaceRegionUserNumber,"*",err,error))//"."
            CALL FlagError(LOCAL_ERROR,err,error,*999)
          END IF
        ELSE
          LOCAL_ERROR="An interface with an user number of "// &
            & TRIM(NumberToVString(interfaceUserNumber,"*",err,error))// &
            & " does not exist on parent region number "// &
            & TRIM(NumberToVString(interfaceRegionUserNumber,"*",err,error))//"."
          CALL FlagError(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NumberToVString(interfaceRegionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FlagError(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_SolverEquations_InterfaceConditionAddNumber1")
    RETURN
999 ERRORS("cmfe_SolverEquations_InterfaceConditionAddNumber1",err,error)
    EXITS("cmfe_SolverEquations_InterfaceConditionAddNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_InterfaceConditionAddNumber1

  !================================================================================================================================
  !

  !>Adds an interface condition to solver equations identified by an object.
  SUBROUTINE cmfe_SolverEquations_InterfaceConditionAddObj(solverEquations,interfaceCondition,interfaceConditionIndex,err)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to add the equations set for.
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to add.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIndex !<On return, the index of the added interface condition in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_SolverEquations_InterfaceConditionAddObj",err,error,*999)

    CALL SOLVER_EQUATIONS_INTERFACE_CONDITION_ADD(solverEquations%solverEquations,interfaceCondition%interfaceCondition, &
      & interfaceConditionIndex,err,error,*999)

    EXITS("cmfe_SolverEquations_InterfaceConditionAddObj")
    RETURN
999 ERRORS("cmfe_SolverEquations_InterfaceConditionAddObj",err,error)
    EXITS("cmfe_SolverEquations_InterfaceConditionAddObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_InterfaceConditionAddObj

  !
  !================================================================================================================================
  !
  
  !>Set the time dependence type of interface matrices
  SUBROUTINE cmfe_InterfaceMatrices_TimeDependenceTypeSet(interfaceCondition, &
    & interfaceMatrixIndex,hasTranspose,timeDependenceTypes,Err)
    
    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to add.
    INTEGER(INTG), INTENT(IN) :: timeDependenceTypes(:) !<Time dependence types for the given interface matrix and it's transpose (if any). \see INTERFACE_MATRICES_ROUTINES_InterfaceMatricesTimeDependenceTypes,INTERFACE_MATRICES_ROUTINES
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIndex
    LOGICAL, INTENT(IN) :: hasTranspose
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    ENTERS("cmfe_InterfaceMatrices_TimeDependenceTypeSet",err,error,*999)
    
    IF(SIZE(timeDependenceTypes)/=2) CALL FlagError("Invalid size of time dependence types array. Must be 2.",err,error,*999)
    IF(timeDependenceTypes(1)>0.AND.timeDependenceTypes(1)<=CMFE_NUMBER_OF_INTERFACE_MATRIX_TYPES) THEN
      CALL InterfaceMatrix_TimeDependenceTypeSet(interfaceCondition%interfaceCondition, &
        & interfaceMatrixIndex,.FALSE.,timeDependenceTypes(1),err,error,*999)
      IF(hasTranspose.AND.(timeDependenceTypes(2)>0.AND.timeDependenceTypes(2)<=CMFE_NUMBER_OF_INTERFACE_MATRIX_TYPES)) THEN
        CALL InterfaceMatrix_TimeDependenceTypeSet(interfaceCondition%interfaceCondition, &
          & interfaceMatrixIndex,.TRUE.,timeDependenceTypes(2),err,error,*999)
      ELSE
        IF(.NOT.hasTranspose) THEN
          !ok)
        ELSEIF(hasTranspose.AND. &
          & .NOT.(timeDependenceTypes(2)>0.AND.timeDependenceTypes(2)<=CMFE_NUMBER_OF_INTERFACE_MATRIX_TYPES)) THEN
          LOCAL_ERROR="Interface matrix number "//TRIM(NumberToVString(interfaceMatrixIndex,"*",err,error))// &
            & " has transpose but invalid time dependence type of "//TRIM(NumberToVString(timeDependenceTypes(1), &
            & "*",err,error))//" ."
          CALL FlagError(LOCAL_ERROR,err,error,*999)
        ENDIF
      ENDIF
    ELSE
      LOCAL_ERROR="Interface matrix time dependence type of "//TRIM(NumberToVString(timeDependenceTypes(1),"*",err,error))// &
        & " is invalid for interface matrix number "//TRIM(NumberToVString(interfaceMatrixIndex,"*",err,error))// &
        & " ."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    ENDIF
    
    EXITS("cmfe_InterfaceMatrices_TimeDependenceTypeSet")
    RETURN
999 ERRORS("cmfe_InterfaceMatrices_TimeDependenceTypeSet",err,error)
    EXITS("cmfe_InterfaceMatrices_TimeDependenceTypeSet")
    CALL cmfe_HandleError(err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfaceMatrices_TimeDependenceTypeSet

  !
  !================================================================================================================================
  !
  
  !>Get the time dependence type of interface matrices
  SUBROUTINE cmfe_InterfaceMatrices_TimeDependenceTypeGet(interfaceCondition, &
    & interfaceMatrixIndex,hasTranspose,timeDependenceTypes,Err)
    
    !Argument variables
    TYPE(cmfe_InterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to add.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceTypes(:) !<Time dependence types for the given interface matrix and it's transpose (if any). \see INTERFACE_MATRICES_ROUTINES_InterfaceMatricesTimeDependenceTypes,INTERFACE_MATRICES_ROUTINES
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIndex
    LOGICAL, INTENT(IN) :: hasTranspose
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code
    !Local Variables
   
    ENTERS("cmfe_InterfaceMatrices_TimeDependenceTypeGet",err,error,*999)
    
    IF(SIZE(timeDependenceTypes)/=2) CALL FlagError("Invalid size of time dependence types array. Must be 2.",err,error,*999)
    CALL InterfaceMatrix_TimeDependenceTypeGet(interfaceCondition%interfaceCondition, &
      & interfaceMatrixIndex,.FALSE.,timeDependenceTypes(1),err,error,*999)
    IF(hasTranspose) THEN
      CALL InterfaceMatrix_TimeDependenceTypeGet(interfaceCondition%interfaceCondition, &
        & interfaceMatrixIndex,.TRUE.,timeDependenceTypes(2),err,error,*999)
    ENDIF
    
    EXITS("cmfe_InterfaceMatrices_TimeDependenceTypeGet")
    RETURN
999 ERRORS("cmfe_InterfaceMatrices_TimeDependenceTypeGet",err,error)
    EXITS("cmfe_InterfaceMatrices_TimeDependenceTypeGet")
    CALL cmfe_HandleError(err,error)
    RETURN
    
  END SUBROUTINE cmfe_InterfaceMatrices_TimeDependenceTypeGet
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_SparsityTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type to set. \see OPENCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_SolverEquations_SparsityTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL SOLVER_EQUATIONS_SPARSITY_TYPE_SET(SOLVER_EQUATIONS,sparsityType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_SolverEquations_SparsityTypeSetNumber0")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_SparsityTypeSetNumber0",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_SparsityTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for solver equations identified by an user number.
  SUBROUTINE cmfe_SolverEquations_SparsityTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type to set. \see OPENCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_SolverEquations_SparsityTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL SOLVER_EQUATIONS_SPARSITY_TYPE_SET(SOLVER_EQUATIONS,sparsityType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_SolverEquations_SparsityTypeSetNumber1")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_SparsityTypeSetNumber1",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_SparsityTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for solver equations identified by an object.
  SUBROUTINE cmfe_SolverEquations_SparsityTypeSetObj(solverEquations,sparsityType,err)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type to set. \see OPENCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_SolverEquations_SparsityTypeSetObj",err,error,*999)

    CALL SOLVER_EQUATIONS_SPARSITY_TYPE_SET(solverEquations%solverEquations,sparsityType,err,error,*999)

    EXITS("cmfe_SolverEquations_SparsityTypeSetObj")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_SparsityTypeSetObj",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_SparsityTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of the boundary conditions for the solver equations identified by the user numbers
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to finish the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SolverEquations_BoundaryConditionsCreateFinish(SOLVER_EQUATIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FlagError(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber0")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber0",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber0

  !
  !================================================================================================================================
  !

  !>Finish the creation of the boundary conditions for the solver equations identified by the user numbers
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to finish the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SolverEquations_BoundaryConditionsCreateFinish(SOLVER_EQUATIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FlagError(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber1")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber1",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateFinishNumber1

  !
  !================================================================================================================================
  !

  !>Finish the creation of the boundary conditions for the solver equations
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateFinishObj(solverEquations,err)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations containing the boundary conditions to finish.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_SolverEquations_BoundaryConditionsCreateFinishObj",err,error,*999)

    CALL SolverEquations_BoundaryConditionsCreateFinish(solverEquations%solverEquations,err,error,*999)

    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateFinishObj")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsCreateFinishObj",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateFinishObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateFinishObj

   !
  !================================================================================================================================
  !

  !>Start the creation of boundary conditions for solver equations identified by user numbers
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateStartNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to start the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_SolverEquations_BoundaryConditionsCreateStartNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SolverEquations_BoundaryConditionsCreateStart(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FlagError(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateStartNumber0")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsCreateStartNumber0",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateStartNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateStartNumber0

  !
  !================================================================================================================================
  !

  !>Start the creation of boundary conditions for solver equations identified by user numbers
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateStartNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to start the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    ENTERS("cmfe_SolverEquations_BoundaryConditionsCreateStartNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SolverEquations_BoundaryConditionsCreateStart(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FlagError(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(LOCAL_ERROR,err,error,*999)
    END IF

    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateStartNumber1")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsCreateStartNumber1",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateStartNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateStartNumber1

  !
  !================================================================================================================================
  !

   !>Start the creation of the boundary conditions for the solver equations
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateStartObj(solverEquations,boundaryConditions,err)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(INOUT) :: solverEquations !<The solver equations containing the boundary conditions to start.
    TYPE(cmfe_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, the created boundary conditions.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    ENTERS("cmfe_SolverEquations_BoundaryConditionsCreateStartObj",err,error,*999)

    CALL SolverEquations_BoundaryConditionsCreateStart(solverEquations%solverEquations, &
        & boundaryConditions%boundaryConditions,err,error,*999)

    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateStartObj")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsCreateStartObj",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsCreateStartObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Get the boundary conditions for solver equations identified by user numbers
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & boundaryConditions,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to get the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    TYPE(cmfe_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, The boundary conditions for the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_SolverEquations_BoundaryConditionsGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,boundaryConditions%boundaryConditions,err,error,*999)
      ELSE
        localError="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_SolverEquations_BoundaryConditionsGetNumber0")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsGetNumber0",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsGetNumber0")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsGetNumber0

  !
  !================================================================================================================================
  !

  !>Get the boundary conditions for solver equations identified by user numbers
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & boundaryConditions,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to start the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    TYPE(cmfe_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, The boundary conditions for the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: localError

    ENTERS("cmfe_SolverEquations_BoundaryConditionsGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,boundaryConditions%boundaryConditions,err,error,*999)
      ELSE
        localError="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A problem with an user number of "//TRIM(NumberToVString(problemUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    EXITS("cmfe_SolverEquations_BoundaryConditionsGetNumber1")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsGetNumber1",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsGetNumber1")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsGetNumber1

  !
  !================================================================================================================================
  !

  !>Get the boundary conditions for solver equations
  SUBROUTINE cmfe_SolverEquations_BoundaryConditionsGetObj(solverEquations,boundaryConditions,err)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the boundary conditions for.
    TYPE(cmfe_BoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, The boundary conditions for the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_SolverEquations_BoundaryConditionsGetObj",err,error,*999)

    CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(solverEquations%solverEquations,boundaryConditions%boundaryConditions, &
      & err,error,*999)

    EXITS("cmfe_SolverEquations_BoundaryConditionsGetObj")
    RETURN
999 ERRORS("cmfe_SolverEquations_BoundaryConditionsGetObj",err,error)
    EXITS("cmfe_SolverEquations_BoundaryConditionsGetObj")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_BoundaryConditionsGetObj

  !
  !================================================================================================================================
  !

  !>Get the number of solver matrices for the solver equations
  SUBROUTINE cmfe_SolverEquations_NumberOfMatricesGet(solverEquations,numberOfMatrices,err)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the number of matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of matrices for the solver equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_SolverEquations_NumberOfMatricesGet",err,error,*999)

    CALL SolverEquations_NumberOfMatricesGet(solverEquations%solverEquations,numberOfMatrices,err,error,*999)

    EXITS("cmfe_SolverEquations_NumberOfMatricesGet")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_NumberOfMatricesGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_NumberOfMatricesGet

  !
  !================================================================================================================================
  !

  !>Get a solver matrix from the solver equations matrices
  SUBROUTINE cmfe_SolverEquations_MatrixGet(solverEquations,matrixIndex,matrix,err)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the matrix for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The solver matrix index to get
    TYPE(cmfe_DistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested solver matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_SolverEquations_MatrixGet",err,error,*999)

    CALL SolverEquations_MatrixGet(solverEquations%solverEquations,matrixIndex,matrix%distributedMatrix,err,error,*999)

    EXITS("cmfe_SolverEquations_MatrixGet")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_MatrixGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_MatrixGet

  !
  !================================================================================================================================
  !

  !>Get the Jacobian matrix from the solver equations matrices for nonlinear solver equations
  SUBROUTINE cmfe_SolverEquations_JacobianMatrixGet(solverEquations,matrix,err)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the Jacobian matrix for
    TYPE(cmfe_DistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the solver equations Jacobian matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_SolverEquations_JacobianMatrixGet",err,error,*999)

    CALL SolverEquations_JacobianMatrixGet(solverEquations%solverEquations,matrix%distributedMatrix,err,error,*999)

    EXITS("cmfe_SolverEquations_JacobianMatrixGet")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_JacobianMatrixGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_JacobianMatrixGet

  !
  !================================================================================================================================
  !

  !>Get the vector assiciated with a solver matrix from the solver equations matrices
  SUBROUTINE cmfe_SolverEquations_VectorGet(solverEquations,matrixIndex,vector,err)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the vector for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The solver matrix index to get the vector for
    TYPE(cmfe_DistributedVectorType), INTENT(INOUT) :: vector !<On return, the requested solver matrix vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_SolverEquations_VectorGet",err,error,*999)

    CALL SolverEquations_VectorGet(solverEquations%solverEquations,matrixIndex,vector%distributedVector,err,error,*999)

    EXITS("cmfe_SolverEquations_VectorGet")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_VectorGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_VectorGet

  !
  !================================================================================================================================
  !

  !>Get the residual vector from the solver equations for nonlinear problems
  SUBROUTINE cmfe_SolverEquations_ResidualVectorGet(solverEquations,residualVector,err)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the residual vector for
    TYPE(cmfe_DistributedVectorType), INTENT(INOUT) :: residualVector !<On return, the solver residual vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_SolverEquations_ResidualVectorGet",err,error,*999)

    CALL SolverEquations_ResidualVectorGet(solverEquations%solverEquations,residualVector%distributedVector,err,error,*999)

    EXITS("cmfe_SolverEquations_ResidualVectorGet")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_ResidualVectorGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_ResidualVectorGet

  !
  !================================================================================================================================
  !

  !>Get the right hand side vector from the solver equations
  SUBROUTINE cmfe_SolverEquations_RhsVectorGet(solverEquations,rhsVector,err)

    !Argument variables
    TYPE(cmfe_SolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the right hand side vector for
    TYPE(cmfe_DistributedVectorType), INTENT(INOUT) :: rhsVector !<On return, the solver right hand side vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    ENTERS("cmfe_SolverEquations_RhsVectorGet",err,error,*999)

    CALL SolverEquations_RhsVectorGet(solverEquations%solverEquations,rhsVector%distributedVector,err,error,*999)

    EXITS("cmfe_SolverEquations_RhsVectorGet")
    RETURN
999 ERRORSEXITS("cmfe_SolverEquations_RhsVectorGet",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_SolverEquations_RhsVectorGet

  !
  !================================================================================================================================
  !

  !>Get the user number of the given region.
  SUBROUTINE cmfe_UserNumberGetRegion( region, userNumber, err )
    !Argument variables
    TYPE(cmfe_RegionType), INTENT(IN) :: region !<The region to get the user number for
    INTEGER(INTG), INTENT(OUT) :: userNumber !<The region's user number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    err = 0

    userNumber = region%region%USER_NUMBER

  END SUBROUTINE cmfe_UserNumberGetRegion

  !
  !================================================================================================================================
  !

  !>Get the user number of the given mesh.
  SUBROUTINE cmfe_UserNumberGetMesh( mesh, userNumber, err )
    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !<The mesh to get the user number for
    INTEGER(INTG), INTENT(OUT) :: userNumber !<The mesh's user number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    err = 0

    userNumber = mesh%mesh%USER_NUMBER

  END SUBROUTINE cmfe_UserNumberGetMesh

  !
  !================================================================================================================================
  !

  !>Get the user number of the given basis.
  SUBROUTINE cmfe_UserNumberGetBasis( basis, userNumber, err )
    !Argument variables
    TYPE(cmfe_BasisType), INTENT(IN) :: basis !<The basis to get the user number for
    INTEGER(INTG), INTENT(OUT) :: userNumber !<The basis's user number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    err = 0

    userNumber = basis%basis%USER_NUMBER

  END SUBROUTINE cmfe_UserNumberGetBasis

  !
  !================================================================================================================================
  !

  !>Update the bioelectrics geometric field by interpolating the finite elasticity geometric field
  SUBROUTINE cmfe_BioelectricsFiniteElasticity_UpdateGeometricField(controlLoop,calcClosestGaussPoint,err)
  
    !Argument variables
    TYPE(cmfe_ControlLoopType), INTENT(INOUT) :: controlLoop !<The bioelectrics control loop
    LOGICAL, INTENT(IN) :: calcClosestGaussPoint
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_BioelectricsFiniteElasticity_UpdateGeometricField",err,error,*999)

    CALL BioelectricFiniteElasticity_UpdateGeometricField(controlLoop%controlLoop,calcClosestGaussPoint,err,error,*999)

    EXITS("cmfe_BioelectricsFiniteElasticity_UpdateGeometricField")
    RETURN
999 ERRORS("cmfe_BioelectricsFiniteElasticity_UpdateGeometricField",err,error)
    EXITS("cmfe_BioelectricsFiniteElasticity_UpdateGeometricField")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_BioelectricsFiniteElasticity_UpdateGeometricField

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given FieldML XML file.
  SUBROUTINE cmfe_FieldML_InputCreateFromFileVS( filename, fieldml, err )
    !Arguments
    TYPE(VARYING_STRING), INTENT(IN) :: filename !< The FieldML XML file to parse.
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputCreateFromFileVS",err,error,*999)

#ifdef USEFIELDML

    ALLOCATE( fieldml%fieldmlInfo, stat=err )
    CALL FIELDML_INPUT_INITIALISE_FROM_FILE( fieldml%fieldmlInfo, filename, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCreateFromFileVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputCreateFromFileVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputCreateFromFileVS

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given FieldML XML file.
  SUBROUTINE cmfe_FieldML_InputCreateFromFileC( filename, fieldml, err )
    !Arguments
    CHARACTER(LEN=*), INTENT(IN) :: filename !< The FieldML XML file to parse.
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputCreateFromFileC",err,error,*999)

#ifdef USEFIELDML

    ALLOCATE( fieldml%fieldmlInfo, stat=err )
    CALL FIELDML_INPUT_INITIALISE_FROM_FILE( fieldml%fieldmlInfo, var_str(filename), err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCreateFromFileC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputCreateFromFileC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputCreateFromFileC

  !
  !================================================================================================================================
  !

  !> Creates a mesh using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputMeshCreateStartObjVS( fieldml, meshArgumentName, mesh, meshNumber, region, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: meshArgumentName !< The name of the argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !< The region in which to create the mesh.
    TYPE(cmfe_MeshType), INTENT(INOUT) :: mesh !< On return, the newly created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputMeshCreateStartObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, meshArgumentName, mesh%mesh, meshNumber, region%region, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputMeshCreateStartObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputMeshCreateStartObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputMeshCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Creates a mesh with the given user number using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputMeshCreateStartNumberVS( fieldml, meshArgumentName, meshNumber, regionNumber, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: meshArgumentName !< The name of the mesh argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    ENTERS("cmfe_FieldML_InputMeshCreateStartNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    NULLIFY( mesh )
    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, meshArgumentName, mesh, meshNumber, region, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputMeshCreateStartNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputMeshCreateStartNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputMeshCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Creates a mesh using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputMeshCreateStartObjC( fieldml, meshArgumentName, mesh, meshNumber, region, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: meshArgumentName !< The name of the argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !< The region in which to create the mesh.
    TYPE(cmfe_MeshType), INTENT(INOUT) :: mesh !< On return, the newly created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputMeshCreateStartObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, var_str(meshArgumentName), mesh%mesh, meshNumber, region%region, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputMeshCreateStartObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputMeshCreateStartObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputMeshCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Creates a mesh with the given user number using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputMeshCreateStartNumberC( fieldml, meshArgumentName, meshNumber, regionNumber, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: meshArgumentName !< The name of the mesh argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    ENTERS("cmfe_FieldML_InputMeshCreateStartNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    NULLIFY( mesh )
    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, var_str(meshArgumentName), mesh, meshNumber, region, &
      & err, error, *999)

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputMeshCreateStartNumberC")
    RETURN
999 ERRORS("cmfe_FieldML_InputMeshCreateStartNumberC",err,error)
    EXITS("cmfe_FieldML_InputMeshCreateStartNumberC")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputMeshCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputCoordinateSystemCreateStartObjVS( fieldml, evaluatorName, coordinateSystem, userNumber, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !< On return, the newly created coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    
    ENTERS("cmfe_FieldML_InputCoordinateSystemCreateStartObjVS",err,error,*999)
    
#ifdef USEFIELDML
    
    CALL FieldmlInput_CoordinateSystemCreateStart( fieldml%fieldmlInfo, evaluatorName, coordinateSystem%coordinateSystem, &
      & userNumber, err, error, *999 )
    
#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCoordinateSystemCreateStartObjVS")
    RETURN
999 ERRORS("cmfe_FieldML_InputCoordinateSystemCreateStartObjVS",err,error)
    EXITS("cmfe_FieldML_InputCoordinateSystemCreateStartObjVS")
    CALL cmfe_HandleError(err,error)    
    RETURN
   
  END SUBROUTINE cmfe_FieldML_InputCoordinateSystemCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputCoordinateSystemCreateStartNumberVS( fieldml, evaluatorName, userNumber, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.
    !Locals
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM

    ENTERS("cmfe_FieldML_InputCoordinateSystemCreateStartNumberVS",err,error,*999)

#ifdef USEFIELDML

    NULLIFY( COORDINATE_SYSTEM )
    CALL FieldmlInput_CoordinateSystemCreateStart( fieldml%fieldmlInfo, evaluatorName, COORDINATE_SYSTEM, &
      & userNumber, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCoordinateSystemCreateStartNumberVS")
    RETURN
999 ERRORS("cmfe_FieldML_InputCoordinateSystemCreateStartNumberVS",err,error)
    EXITS("cmfe_FieldML_InputCoordinateSystemCreateStartNumberVS")
    CALL cmfe_HandleError(err,error)
    RETURN
    
  END SUBROUTINE cmfe_FieldML_InputCoordinateSystemCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputCoordinateSystemCreateStartObjC( fieldml, evaluatorName, coordinateSystem, userNumber, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    TYPE(cmfe_CoordinateSystemType), INTENT(INOUT) :: coordinateSystem !< On return, the newly created coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputCoordinateSystemCreateStartObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FieldmlInput_CoordinateSystemCreateStart( fieldml%fieldmlInfo, var_str(evaluatorName), &
      & coordinateSystem%coordinateSystem, userNumber, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCoordinateSystemCreateStartObjC")
    RETURN
999 ERRORS("cmfe_FieldML_InputCoordinateSystemCreateStartObjC",err,error)
    EXITS("cmfe_FieldML_InputCoordinateSystemCreateStartObjC")
    CALL cmfe_HandleError(err,error)
    RETURN
    
  END SUBROUTINE cmfe_FieldML_InputCoordinateSystemCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputCoordinateSystemCreateStartNumberC( fieldml, evaluatorName, userNumber, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM

    ENTERS("cmfe_FieldML_InputCoordinateSystemCreateStartNumberC",err,error,*999)

#ifdef USEFIELDML

    NULLIFY( COORDINATE_SYSTEM )
    CALL FieldmlInput_CoordinateSystemCreateStart( fieldml%fieldmlInfo, var_str(evaluatorName), COORDINATE_SYSTEM, &
      & userNumber, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCoordinateSystemCreateStartNumberC")
    RETURN
999 ERRORS("cmfe_FieldML_InputCoordinateSystemCreateStartNumberC",err,error)
    EXITS("cmfe_FieldML_InputCoordinateSystemCreateStartNumberC")
    CALL cmfe_HandleError(err,error)
    RETURN
    
  END SUBROUTINE cmfe_FieldML_InputCoordinateSystemCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputBasisCreateStartNumberVS( fieldml, evaluatorName, userNumber, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(BASIS_TYPE), POINTER :: basis

    ENTERS("cmfe_FieldML_InputBasisCreateStartNumberVS",err,error,*999)

#ifdef USEFIELDML

    NULLIFY( basis )
    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, evaluatorName, userNumber, basis, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputBasisCreateStartNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputBasisCreateStartNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_FieldML_InputBasisCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputBasisCreateStartObjVS( fieldml, evaluatorName, userNumber, basis, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<On return, the newly created basis.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputBasisCreateStartObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, evaluatorName, userNumber, basis%basis, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputBasisCreateStartObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputBasisCreateStartObjVS",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_FieldML_InputBasisCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputBasisCreateStartNumberC( fieldml, evaluatorName, userNumber, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(BASIS_TYPE), POINTER :: basis

    ENTERS("cmfe_FieldML_InputBasisCreateStartNumberC",err,error,*999)

#ifdef USEFIELDML

    NULLIFY( basis )
    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, var_str(evaluatorName), userNumber, basis, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputBasisCreateStartNumberC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputBasisCreateStartNumberC",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_FieldML_InputBasisCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputBasisCreateStartObjC( fieldml, evaluatorName, userNumber, basis, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    TYPE(cmfe_BasisType), INTENT(INOUT) :: basis !<On return, the newly created basis.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputBasisCreateStartObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, var_str(evaluatorName), userNumber, basis%basis, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputBasisCreateStartObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputBasisCreateStartObjC",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_FieldML_InputBasisCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputNodesCreateStartNumberVS( fieldml, nodesArgumentName, regionNumber, nodes, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the nodes from.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region to create to the nodes in.
    TYPE(cmfe_NodesType), INTENT(INOUT) :: nodes !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region

    ENTERS("cmfe_FieldML_InputNodesCreateStartNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, nodesArgumentName, region, nodes%nodes, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputNodesCreateStartNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputNodesCreateStartNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_FieldML_InputNodesCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputNodesCreateStartObjVS( fieldml, nodesArgumentName, region, nodes, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the basis from.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !< The user number of the region to create to the nodes in.
    TYPE(cmfe_NodesType), INTENT(INOUT) :: nodes  !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputNodesCreateStartObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, nodesArgumentName, region%region, nodes%nodes, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputNodesCreateStartObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputNodesCreateStartObjVS",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_FieldML_InputNodesCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputNodesCreateStartNumberC( fieldml, nodesArgumentName, regionNumber, nodes, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the nodes from.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region to create to the nodes in.
    TYPE(cmfe_NodesType), INTENT(INOUT) :: nodes !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region

    ENTERS("cmfe_FieldML_InputNodesCreateStartNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, var_str(nodesArgumentName), region, nodes%nodes, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputNodesCreateStartNumberC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputNodesCreateStartNumberC",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_FieldML_InputNodesCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputNodesCreateStartObjC( fieldml, nodesArgumentName, region, nodes, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the basis from.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !< The user number of the region to create to the nodes in.
    TYPE(cmfe_NodesType), INTENT(INOUT) :: nodes  !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputNodesCreateStartObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, var_str(nodesArgumentName), region%region, nodes%nodes, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputNodesCreateStartObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputNodesCreateStartObjC",err,error)
    CALL cmfe_HandleError(err,error)
   RETURN

  END SUBROUTINE cmfe_FieldML_InputNodesCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the given mesh.
  SUBROUTINE cmfe_FieldML_InputCreateMeshComponentObjVS( fieldml, mesh, componentNumber, evaluatorName, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !< The mesh for which to create the mesh component.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the mesh from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputCreateMeshComponentObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh%mesh, componentNumber, evaluatorName, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCreateMeshComponentObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputCreateMeshComponentObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputCreateMeshComponentObjVS

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the mesh identified by the given user number.
  SUBROUTINE cmfe_FieldML_InputCreateMeshComponentNumberVS( fieldml, regionNumber, meshNumber, componentNumber, evaluatorName, &
    & err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh for which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    ENTERS( "CMISSFieldML_InputCreateMeshComponentNumberVS", err, error, *999 )

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh, componentNumber, evaluatorName, err, error, *999 )
    
#else
    
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
    
#endif

    EXITS("cmfe_FieldML_InputCreateMeshComponentNumberVS")
    RETURN
999 ERRORS("cmfe_FieldML_InputCreateMeshComponentNumberVS",err,error)
    EXITS("cmfe_FieldML_InputCreateMeshComponentNumberVS")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputCreateMeshComponentNumberVS

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the given mesh.
  SUBROUTINE cmfe_FieldML_InputCreateMeshComponentObjC( fieldml, mesh, componentNumber, evaluatorName, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !< The mesh for which to create the mesh component.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the mesh from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputCreateMeshComponentObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh%mesh, componentNumber, var_str(evaluatorName), &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCreateMeshComponentObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputCreateMeshComponentObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputCreateMeshComponentObjC

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the mesh identified by the given user number.
  SUBROUTINE cmfe_FieldML_InputCreateMeshComponentNumberC( fieldml, regionNumber, meshNumber, componentNumber, evaluatorName, &
    & err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh for which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    ENTERS( "CMISSFieldML_InputCreateMeshComponentNumberC", err, error, *999 )

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh, componentNumber, var_str(evaluatorName), err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputCreateMeshComponentNumberC")
    RETURN
999 ERRORS("cmfe_FieldML_InputCreateMeshComponentNumberC",err,error)
    EXITS("cmfe_FieldML_InputCreateMeshComponentNumberC")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputCreateMeshComponentNumberC

  !
  !================================================================================================================================
  !

  !> Create a field using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputFieldCreateStartObjVS( fieldml, region, decomposition, fieldNumber, field, variableType, &
    & evaluatorName, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !< The region in which the field is to be created.
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !< The decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !< On return, the newly created field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputFieldCreateStartObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region%region, decomposition%decomposition, fieldNumber, &
      & field%field, variableType, evaluatorName, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputFieldCreateStartObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputFieldCreateStartObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputFieldCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Create a field with the given user number using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputFieldCreateStartNumberVS( fieldml, regionNumber, meshNumber, decompositionNumber, fieldNumber, &
    & variableType, evaluatorName, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the field.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: decompositionNumber !< The user number of the decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(FIELD_TYPE), POINTER :: field

    ENTERS("cmfe_FieldML_InputFieldCreateStartNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )
    CALL DECOMPOSITION_USER_NUMBER_TO_DECOMPOSITION( decompositionNumber, mesh, decomposition, err, error, *999 )

    NULLIFY( field )
    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region, decomposition, fieldNumber, field, variableType, &
      & evaluatorName, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputFieldCreateStartNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputFieldCreateStartNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputFieldCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Create a field using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputFieldCreateStartObjC( fieldml, region, decomposition, fieldNumber, field, variableType, &
    & evaluatorName, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(cmfe_RegionType), INTENT(IN) :: region !< The region in which the field is to be created.
    TYPE(cmfe_DecompositionType), INTENT(IN) :: decomposition !< The decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !< On return, the newly created field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputFieldCreateStartObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region%region, decomposition%decomposition, fieldNumber, &
      & field%field, variableType, var_str(evaluatorName), err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputFieldCreateStartObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputFieldCreateStartObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputFieldCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Create a field with the given user number using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputFieldCreateStartNumberC( fieldml, regionNumber, meshNumber, decompositionNumber, fieldNumber, &
    & variableType, evaluatorName, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the field.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: decompositionNumber !< The user number of the decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(FIELD_TYPE), POINTER :: field

    ENTERS("cmfe_FieldML_InputFieldCreateStartNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )
    CALL DECOMPOSITION_USER_NUMBER_TO_DECOMPOSITION( decompositionNumber, mesh, decomposition, err, error, *999 )

    NULLIFY( field )
    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region, decomposition, fieldNumber, field, variableType, &
      & var_str(evaluatorName), err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputFieldCreateStartNumberC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputFieldCreateStartNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputFieldCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of the given field, using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputFieldParametersUpdateObjVS( fieldml, field, evaluatorName, variableType, &
    & setType, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !< On return, the field object.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputFieldParametersUpdateObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, evaluatorName, field%field, variableType, &
      &  setType, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputFieldParametersUpdateObjVS")
    RETURN
999 ERRORS("cmfe_FieldML_InputFieldParametersUpdateObjVS",err,error)
    EXITS("cmfe_FieldML_InputFieldParametersUpdateObjVS")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputFieldParametersUpdateObjVS

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of field with the given user number, using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputFieldParametersUpdateNumberVS( fieldml, regionNumber, fieldNumber, &
    & evaluatorName, variableType, setType, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region of the field for which parameters are to be updated.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field for which parameters are to be updated.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    ENTERS("cmfe_FieldML_InputFieldParametersUpdateNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, evaluatorName, field, variableType, setType, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputFieldParametersUpdateNumberVS")
    RETURN
999 ERRORS("cmfe_FieldML_InputFieldParametersUpdateNumberVS",err,error)
    EXITS("cmfe_FieldML_InputFieldParametersUpdateNumberVS")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputFieldParametersUpdateNumberVS

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of the given field, using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputFieldParametersUpdateObjC( fieldml, field, evaluatorName, &
    & variableType, setType, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(cmfe_FieldType), INTENT(INOUT) :: field !< On return, the field object.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_InputFieldParametersUpdateObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, var_str(evaluatorName), field%field, variableType, &
      & setType, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputFieldParametersUpdateObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_InputFieldParametersUpdateObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputFieldParametersUpdateObjC

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of field with the given user number, using the given FieldML evaluator.
  SUBROUTINE cmfe_FieldML_InputFieldParametersUpdateNumberC( fieldml, regionNumber, fieldNumber, &
    & evaluatorName, variableType, setType, err )
    !Arguments
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region of the field for which parameters are to be updated.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field for which parameters are to be updated.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    ENTERS("cmfe_FieldML_InputFieldParametersUpdateNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, var_str(evaluatorName), field, variableType, &
      & setType, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_InputFieldParametersUpdateNumberC")
    RETURN
999 ERRORS("cmfe_FieldML_InputFieldParametersUpdateNumberC",err,error)
    EXITS("cmfe_FieldML_InputFieldParametersUpdateNumberC")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_InputFieldParametersUpdateNumberC

  !
  !================================================================================================================================
  !

  !> Write the FieldML document managed by the given context to a file with the given name.
  SUBROUTINE cmfe_FieldML_OutputWriteVS( fieldml, filename, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: filename !< The name of the file to write the FieldML document to.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputWriteVS",err,error,*999)

#ifdef USEFIELDML

    IF( .NOT. fieldml%fieldmlInfo%IS_OUT ) THEN
      CALL FlagError( "Inbound FieldML handle used four an output-only operation.", ERR, error, *999 )
    END IF

    CALL FIELDML_OUTPUT_WRITE( fieldml%fieldmlInfo, filename, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputWriteVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputWriteVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputWriteVS

  !
  !================================================================================================================================
  !

  !> Write the FieldML document managed by the given context to a file with the given name.
  SUBROUTINE cmfe_FieldML_OutputWriteC( fieldml, filename, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: filename !< The name of the file to write the FieldML document to.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputWriteC",err,error,*999)

#ifdef USEFIELDML

    IF( .NOT. fieldml%fieldmlInfo%IS_OUT ) THEN
      CALL FlagError( "Inbound FieldML handle used four an output-only operation.", ERR, error, *999 )
    END IF

    CALL FIELDML_OUTPUT_WRITE( fieldml%fieldmlInfo, var_str(filename), err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputWriteC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputWriteC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputWriteC

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE cmfe_FieldML_OutputAddFieldNoTypeObjVS( fieldml, baseName, dofFormat, field, variableType, setType, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !< The field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputAddFieldNoTypeObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field%field, variableType, setType, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldNoTypeObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldNoTypeObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldNoTypeObjVS

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE cmfe_FieldML_OutputAddFieldNoTypeNumberVS( fieldml, baseName, dofFormat, regionNumber, fieldNumber, &
    & variableType, setType, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region containing the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    ENTERS("cmfe_FieldML_OutputAddFieldNoTypeNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field, variableType, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldNoTypeNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldNoTypeNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldNoTypeNumberVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE cmfe_FieldML_OutputAddFieldWithTypeObjVS( fieldml, baseName, dofFormat, field, variableType, setType, typeHandle, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !< The field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputAddFieldWithTypeObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field%field, variableType, setType, typeHandle, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldWithTypeObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldWithTypeObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldWithTypeObjVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE cmfe_FieldML_OutputAddFieldWithTypeNumberVS( fieldml, baseName, dofFormat, regionNumber, fieldNumber, &
    & variableType, setType, typeHandle, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    ENTERS("cmfe_FieldML_OutputAddFieldWithTypeNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field, variableType, setType, typeHandle, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldWithTypeNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldWithTypeNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldWithTypeNumberVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE cmfe_FieldML_OutputAddFieldNoTypeObjC( fieldml, baseName, dofFormat, field, variableType, setType, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !< The field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputAddFieldNoTypeObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field%field, variableType, &
      & setType, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldNoTypeObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldNoTypeObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldNoTypeObjC

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE cmfe_FieldML_OutputAddFieldNoTypeNumberC( fieldml, baseName, dofFormat, regionNumber, fieldNumber, &
    & variableType, setType, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region containing the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    ENTERS("cmfe_FieldML_OutputAddFieldNoTypeNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field, variableType, &
      & setType, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldNoTypeNumberC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldNoTypeNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldNoTypeNumberC

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE cmfe_FieldML_OutputAddFieldWithTypeObjC( fieldml, baseName, dofFormat, field, variableType, setType, typeHandle, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !< The field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputAddFieldWithTypeObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field%field, variableType, &
      & typeHandle, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldWithTypeObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldWithTypeObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldWithTypeObjC

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE cmfe_FieldML_OutputAddFieldWithTypeNumberC( fieldml, baseName, dofFormat, regionNumber, fieldNumber, &
    & variableType, setType, typeHandle, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    ENTERS("cmfe_FieldML_OutputAddFieldWithTypeNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field, variableType, &
      & setType, typeHandle, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldWithTypeNumberC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldWithTypeNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldWithTypeNumberC

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given mesh.
  SUBROUTINE cmfe_FieldML_OutputCreateObjVS( mesh, location, baseName, connectivityFormat, fieldml, err )
    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !< The mesh to use when initialising the FieldML context.
    TYPE(VARYING_STRING), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputCreateObjVS",err,error,*999)

#ifdef USEFIELDML

    ALLOCATE( fieldml%fieldmlInfo, stat=err )
    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh%mesh, location, baseName, connectivityFormat, fieldml%fieldmlInfo, &
      & err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputCreateObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputCreateObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputCreateObjVS

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the mesh with the given user number.
  SUBROUTINE cmfe_FieldML_OutputCreateNumberVS( regionNumber, meshNumber, location, baseName, connectivityFormat, fieldml, err )
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the mesh to use when initialising the FieldML context.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when initialising the FieldML context.
    TYPE(VARYING_STRING), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    ENTERS("cmfe_FieldML_OutputCreateNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )

    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh, location, baseName, connectivityFormat, fieldml%fieldmlInfo, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputCreateNumberVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputCreateNumberVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputCreateNumberVS

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given mesh.
  SUBROUTINE cmfe_FieldML_OutputCreateObjC( mesh, location, baseName, connectivityFormat, fieldml, err )
    !Argument variables
    TYPE(cmfe_MeshType), INTENT(IN) :: mesh !< The mesh to use when initialising the FieldML context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputCreateObjC",err,error,*999)

#ifdef USEFIELDML

    ALLOCATE( fieldml%fieldmlInfo, stat=err )
    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh%mesh, var_str(location), var_str(baseName), var_str(connectivityFormat), &
      & fieldml%fieldmlInfo, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputCreateObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputCreateObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputCreateObjC

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the mesh with the given user number.
  SUBROUTINE cmfe_FieldML_OutputCreateNumberC( regionNumber, meshNumber, location, baseName, connectivityFormat, fieldml, err )
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the mesh to use when initialising the FieldML context.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when initialising the FieldML context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    ENTERS("cmfe_FieldML_OutputCreateNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )

    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh, var_str(location), var_str(baseName), var_str(connectivityFormat), &
      & fieldml%fieldmlInfo, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputCreateNumberC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputCreateNumberC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputCreateNumberC

  !
  !================================================================================================================================
  !

  !> Add the given field to the current FieldML context, only including the given components.
  SUBROUTINE cmfe_FieldML_OutputAddFieldComponentsObjVS( fieldml, typeHandle, baseName, dofFormat, field, fieldComponentNumbers, &
    & variableType, setType, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !< The field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:)
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputAddFieldComponentsObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, baseName, dofFormat, field%field, &
      & fieldComponentNumbers, variableType, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldComponentsObjVS")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldComponentsObjVS",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldComponentsObjVS

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the current FieldML context, only including the given components.
  SUBROUTINE cmfe_FieldML_OutputAddFieldComponentsNumberVS( fieldml, typeHandle, baseName, dofFormat, regionNumber, &
    & fieldNumber, fieldComponentNumbers, variableType, setType, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:) !< The component numbers to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    ENTERS("cmfe_FieldML_OutputAddFieldComponentsNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, baseName, dofFormat, field, fieldComponentNumbers,&
      & variableType, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldComponentsNumberVS")
    RETURN
999 ERRORS("cmfe_FieldML_OutputAddFieldComponentsNumberVS",err,error)
    EXITS("cmfe_FieldML_OutputAddFieldComponentsNumberVS")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldComponentsNumberVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the current FieldML context, only including the given components.
  SUBROUTINE cmfe_FieldML_OutputAddFieldComponentsObjC( fieldml, typeHandle, baseName, dofFormat, field, fieldComponentNumbers, &
    & variableType, setType, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(cmfe_FieldType), INTENT(IN) :: field !< The field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:)
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    ENTERS("cmfe_FieldML_OutputAddFieldComponentsObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, var_str(baseName), var_str(dofFormat), &
      & field%field, fieldComponentNumbers, variableType, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldComponentsObjC")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddFieldComponentsObjC",err,error)
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldComponentsObjC

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the current FieldML context, only including the given components.
  SUBROUTINE cmfe_FieldML_OutputAddFieldComponentsNumberC( fieldml, typeHandle, baseName, dofFormat, regionNumber, &
    & fieldNumber, fieldComponentNumbers, variableType, setType, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:) !< The component numbers to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    ENTERS("cmfe_FieldML_OutputAddFieldComponentsNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, var_str(baseName), var_str(dofFormat), &
      & field, fieldComponentNumbers, variableType, setType, err, error, *999 )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddFieldComponentsNumberC")
    RETURN
999 ERRORS("cmfe_FieldML_OutputAddFieldComponentsNumberC",err,error)
    EXITS("cmfe_FieldML_OutputAddFieldComponentsNumberC")
    CALL cmfe_HandleError(err,error)
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddFieldComponentsNumberC

  !
  !================================================================================================================================
  !

  !>Import a FieldML object from the library into the current session.
  SUBROUTINE cmfe_FieldML_OutputAddImport( fieldml, name, handle, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: name !< The name of the object to import.
    INTEGER(INTG), INTENT(OUT) :: handle !< A handle to the newly imported FieldML object.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Locals
    TYPE(VARYING_STRING) :: stringName

    ENTERS("cmfe_FieldML_OutputAddImport",err,error,*999)

#ifdef USEFIELDML

    stringName = name

    handle = FIELDML_OUTPUT_IMPORT( fieldml%fieldmlInfo, stringName, err, error )
    IF(err/=0) GOTO 999

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldML_OutputAddImport")
    RETURN
999 ERRORSEXITS("cmfe_FieldML_OutputAddImport",err,error)
    CALL cmfe_HandleError( err, error )
    RETURN

  END SUBROUTINE cmfe_FieldML_OutputAddImport

  !
  !================================================================================================================================
  !

  !>Finalises a Fieldml context.
  SUBROUTINE cmfe_FieldMLIO_Finalise( fieldml, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(OUT) :: fieldml !< The FieldML context to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_FieldMLIO_Finalise", err, error, *999 )

#ifdef USEFIELDML

    CALL FIELDML_IO_FINALISE( fieldml%fieldmlInfo, err, error, *999  )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldMLIO_Finalise")
    RETURN
999 ERRORSEXITS("cmfe_FieldMLIO_Finalise",err,error)
    CALL cmfe_HandleError( err, error )
    RETURN

  END SUBROUTINE cmfe_FieldMLIO_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a Fieldml context.
  SUBROUTINE cmfe_FieldMLIO_Initialise( fieldml, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(OUT) :: fieldml !< The FieldML context to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_FieldMLIO_Initialise", err, error, *999 )

#ifdef USEFIELDML

    NULLIFY( fieldml%fieldmlInfo )

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    EXITS("cmfe_FieldMLIO_Initialise")
    RETURN
999 ERRORSEXITS("cmfe_FieldMLIO_Initialise",err,error)
    CALL cmfe_HandleError( err, error )
    RETURN

  END SUBROUTINE cmfe_FieldMLIO_Initialise

  !
  !================================================================================================================================
  !

  !>Get the session handle from a Fieldml context.
  SUBROUTINE cmfe_FieldMLIO_GetSession( fieldml, sessionHandle, err )
    !Argument variables
    TYPE(cmfe_FieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context whose session handle is to be returned.
    INTEGER(INTG), INTENT(OUT) :: sessionHandle !<The session handle.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    ENTERS("cmfe_FieldMLIO_GetSession", err, error, *999 )

#ifdef USEFIELDML

    sessionHandle = fieldml%fieldmlInfo%FML_HANDLE

#else
    CALL FlagError("Must compile with USEFIELDML=true to use FieldML functionality.",err,error,*999)
#endif

    EXITS("cmfe_FieldMLIO_GetSession")
    RETURN
999 ERRORSEXITS("cmfe_FieldMLIO_GetSession",err,error)
    CALL cmfe_HandleError( err, error )
    RETURN

  END SUBROUTINE cmfe_FieldMLIO_GetSession

  !
  !================================================================================================================================
  !


END MODULE OpenCMISS_Iron
