!> \file
!> \author Chris Bradley
!> \brief This module handles all field related routines.
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand, the University of Oxford, Oxford, United
!> Kingdom and King's College, London, United Kingdom. Portions created
!> by the University of Auckland, the University of Oxford and King's
!> College, London are Copyright (C) 2007-2010 by the University of
!> Auckland, the University of Oxford and King's College, London.
!> All Rights Reserved.
!>
!> Contributor(s):
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>

!> This module handles all field related routines.
MODULE FIELD_ROUTINES

  USE BASE_ROUTINES
  USE BASIS_ROUTINES
  USE COMP_ENVIRONMENT
  USE COORDINATE_ROUTINES
  USE CMISS_MPI
  USE DISTRIBUTED_MATRIX_VECTOR
  USE DOMAIN_MAPPINGS
  USE KINDS
  USE INPUT_OUTPUT
  USE ISO_VARYING_STRING
  USE LISTS
  USE MATHS
  USE MPI
  USE MESH_ROUTINES
  USE NODE_ROUTINES
  USE STRINGS
  USE TYPES

  IMPLICIT NONE

  PRIVATE

  !Module parameters

  !> \addtogroup FIELD_ROUTINES_DependentTypes FIELD_ROUTINES::DependentTypes
  !> \brief Depedent field parameter types
  !> \see FIELD_ROUTINES,OPENCMISS_FieldDependentTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_INDEPENDENT_TYPE=1 !<Independent field type \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DEPENDENT_TYPE=2 !<Dependent field type \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_DimensionTypes FIELD_ROUTINES::DimensionTypes
  !> \brief Field dimension parameter types
  !> \see FIELD_ROUTINES,OPENCMISS_FieldDimensionTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_SCALAR_DIMENSION_TYPE=1 !<Scalar field \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_VECTOR_DIMENSION_TYPE=2 !<Vector field \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_TENSOR_DIMENSION_TYPE=3 !<Tensor field \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_FieldTypes FIELD_ROUTINES::FieldTypes
  !> \brief Field type parameters
  !> \see FIELD_ROUTINES,OPENCMISS_FieldTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_GEOMETRIC_TYPE=1 !<Geometric field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_FIBRE_TYPE=2 !<Fibre field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GENERAL_TYPE=3 !<General field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_MATERIAL_TYPE=4 !<Material field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GEOMETRIC_GENERAL_TYPE=5 !<Geometric general field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_InterpolationTypes FIELD_ROUTINES::InterpolationTypes
  !> \brief Field interpolation parameters
  !> \see FIELD_ROUTINES,OPENCMISS_FieldInterpolationTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_CONSTANT_INTERPOLATION=1 !<Constant interpolation. One parameter for the field \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_ELEMENT_BASED_INTERPOLATION=2 !<Element based interpolation. Parameters are different in each element \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_NODE_BASED_INTERPOLATION=3 !<Node based interpolation. Parameters are nodal based and a basis function is used \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GRID_POINT_BASED_INTERPOLATION=4 !<Grid point based interpolation. Parameters are different at each grid point \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GAUSS_POINT_BASED_INTERPOLATION=5 !<Gauss point based interpolation. Parameters are different at each Gauss point \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DATA_POINT_BASED_INTERPOLATION=6 !<data point based interpolation. Parameters are different at each data point \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_VariableTypes FIELD_ROUTINES::VariableTypes
  !> \brief Field variable type parameters
  !> \see FIELD_ROUTINES,OPENCMISS_FieldVariableTypes
  !> \todo sort out variable access routines so that you are always accessing by variable type rather than variable number.
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_NUMBER_OF_VARIABLE_TYPES=48 !<Number of different field variable types possible \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
  INTEGER(INTG), PARAMETER :: FIELD_NUMBER_OF_VARIABLE_SUBTYPES=4 !<The number of variants of a particular variable - currently 4. U, delUdelN, delUdelT,del2UdelT2 \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_U_VARIABLE_TYPE=1 !<Standard variable type i.e., u \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELUDELN_VARIABLE_TYPE=2 !<Normal derivative variable type i.e., du/dn \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELUDELT_VARIABLE_TYPE=3 !<First time derivative variable type i.e., du/dt \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DEL2UDELT2_VARIABLE_TYPE=4 !<Second time derivative variable type i.e., d^2u/dt^2 \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_V_VARIABLE_TYPE=5 !<Second standard variable type i.e., v \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELVDELN_VARIABLE_TYPE=6 !<Second normal derivative variable type i.e., dv/dn \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELVDELT_VARIABLE_TYPE=7 !<First time derivative variable type i.e., du/dt \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DEL2VDELT2_VARIABLE_TYPE=8 !<Second time derivative variable type i.e., d^2u/dt^2 \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_U1_VARIABLE_TYPE=9 !<Third standard variable type i.e., v \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU1DELN_VARIABLE_TYPE=10 !<Third normal derivative variable type i.e., dv/dn \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU1DELT_VARIABLE_TYPE=11 !<Third time derivative variable type i.e., du/dt \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DEL2U1DELT2_VARIABLE_TYPE=12 !<Third time derivative variable type i.e., d^2u/dt^2 \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_U2_VARIABLE_TYPE=13 !<Fourth standard variable type i.e., v \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU2DELN_VARIABLE_TYPE=14 !<Fourth normal derivative variable type i.e., dv/dn \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU2DELT_VARIABLE_TYPE=15 !<Fourth time derivative variable type i.e., du/dt \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DEL2U2DELT2_VARIABLE_TYPE=16 !<Fourth time derivative variable type i.e., d^2u/dt^2 \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_U3_VARIABLE_TYPE=17 !<Fifth standard variable type i.e., v \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU3DELN_VARIABLE_TYPE=18 !<Fifth normal derivative variable type i.e., dv/dn \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU3DELT_VARIABLE_TYPE=19 !<Fifth time derivative variable type i.e., du/dt \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DEL2U3DELT2_VARIABLE_TYPE=20 !<Fifth time derivative variable type i.e., d^2u/dt^2 \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_U4_VARIABLE_TYPE=21 !<Sixth standard variable type i.e., v \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU4DELN_VARIABLE_TYPE=22 !<Sixth normal derivative variable type i.e., dv/dn \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU4DELT_VARIABLE_TYPE=23 !<Sixth time derivative variable type i.e., du/dt \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DEL2U4DELT2_VARIABLE_TYPE=24 !<Sixth time derivative variable type i.e., d^2u/dt^2 \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_U5_VARIABLE_TYPE=25 !<Seventh standard variable type i.e., v \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU5DELN_VARIABLE_TYPE=26 !<Seventh normal derivative variable type i.e., dv/dn \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU5DELT_VARIABLE_TYPE=27 !<Seventh time derivative variable type i.e., du/dt \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DEL2U5DELT2_VARIABLE_TYPE=28 !<Seventh time derivative variable type i.e., d^2u/dt^2 \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_U6_VARIABLE_TYPE=29 !<Eighth standard variable type i.e., v \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU6DELN_VARIABLE_TYPE=30 !<Eighth normal derivative variable type i.e., dv/dn \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU6DELT_VARIABLE_TYPE=31 !<Eighth time derivative variable type i.e., du/dt \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DEL2U6DELT2_VARIABLE_TYPE=32 !<Eighth time derivative variable type i.e., d^2u/dt^2 \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_U7_VARIABLE_TYPE=33 !<Ninth standard variable type i.e., v \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU7DELN_VARIABLE_TYPE=34 !<Ninth normal derivative variable type i.e., dv/dn \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU7DELT_VARIABLE_TYPE=35 !<Ninth time derivative variable type i.e., du/dt \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DEL2U7DELT2_VARIABLE_TYPE=36 !<Ninth time derivative variable type i.e., d^2u/dt^2 \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_U8_VARIABLE_TYPE=37 !<Tenth standard variable type i.e., v \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU8DELN_VARIABLE_TYPE=38 !<Tenth normal derivative variable type i.e., dv/dn \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU8DELT_VARIABLE_TYPE=39 !<Tenth time derivative variable type i.e., du/dt \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DEL2U8DELT2_VARIABLE_TYPE=40 !<Tenth time derivative variable type i.e., d^2u/dt^2 \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_U9_VARIABLE_TYPE=41 !<Eleventh standard variable type i.e., v \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU9DELN_VARIABLE_TYPE=42 !<Eleventh normal derivative variable type i.e., dv/dn \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU9DELT_VARIABLE_TYPE=43 !<Eleventh time derivative variable type i.e., du/dt \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DEL2U9DELT2_VARIABLE_TYPE=44 !<Eleventh time derivative variable type i.e., d^2u/dt^2 \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_U10_VARIABLE_TYPE=45 !<Twelfth standard variable type i.e., v \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU10DELN_VARIABLE_TYPE=46 !<Twelfth normal derivative variable type i.e., dv/dn \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DELU10DELT_VARIABLE_TYPE=47 !<Twelfth time derivative variable type i.e., du/dt \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DEL2U10DELT2_VARIABLE_TYPE=48 !<Twelfth time derivative variable type i.e., d^2u/dt^2 \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
  !>@}
  
  !> \addtogroup FIELD_ROUTINES_DofTypes FIELD_ROUTINES::DofTypes
  !> \brief Field dof type parameters
  !> \see FIELD_ROUTINES
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_CONSTANT_DOF_TYPE=1 !<The dof is from a field variable component with constant interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_ELEMENT_DOF_TYPE=2 !<The dof is from a field variable component with element based interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_NODE_DOF_TYPE=3 !<The dof is from a field variable component with node based interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GRID_POINT_DOF_TYPE=4 !<The dof is from a field variable component with grid point based interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GAUSS_POINT_DOF_TYPE=5 !<The dof is from a field variable component with Gauss point based interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DATA_POINT_DOF_TYPE=6 !<The dof is from a field variable component with Gauss point based interpolation \see FIELD_ROUTINES_DofTypes,FIELD_ROUTINES
  !>@}
   
  !> \addtogroup FIELD_ROUTINES_DataTypes FIELD_ROUTINES::DataTypes
  !> \brief Field data types
  !> \see FIELD_ROUTINES,OPENCMISS_FieldDataTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_INTG_TYPE=1 !<Integer field data type \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_SP_TYPE=2 !<Single precision real field data type \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_DP_TYPE=3 !<Double precision real field data type \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_L_TYPE=4 !<Logical field data type \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
  !>@}
   
  !> \addtogroup FIELD_ROUTINES_DOFOrderTypes FIELD_ROUTINES::DOFOrderTypes
  !> \brief Field DOF order types
  !> \see FIELD_ROUTINES,OPENCMISS_FieldDOFOrderTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_SEPARATED_COMPONENT_DOF_ORDER=1 !<Field variable component dofs are not contiguous \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER=2 !<Field variable component dofs are contiguous \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_ParameterSetTypes FIELD_ROUTINES::ParameterSetTypes
  !> \brief Field parameter set type parameters \todo make program defined constants negative?
  !> \see FIELD_ROUTINES,OPENCMISS_FieldParameterSetTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_NUMBER_OF_SET_TYPES=99 !<The maximum number of different parameter sets for a field \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_VALUES_SET_TYPE=1 !<The parameter set corresponding to the field values (at time T+DT for dynamic problems) \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_BOUNDARY_CONDITIONS_SET_TYPE=2 !<The parameter set corresponding to the field boundary conditions \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_INITIAL_VALUES_SET_TYPE=3 !<The parameter set corresponding to the field initial values \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_INCREMENTAL_VALUES_SET_TYPE=4 !<The parameter set corresponding to the field incremental values \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_ANALYTIC_VALUES_SET_TYPE=5 !<The parameter set corresponding to the analytic field values \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_PREVIOUS_VALUES_SET_TYPE=6 !<The parameter set corresponding to the previous field values (at time T) \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE=7 !<The parameter set corresponding to the mean predicited values (at time T+DT) \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_VELOCITY_VALUES_SET_TYPE=8 !<The parameter set corresponding to the velocity values (at time T+DT) \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_INITIAL_VELOCITY_SET_TYPE=9 !<The parameter set corresponding to the initial velocity values for dynamic problems. This is also the previous velocity values \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_PREVIOUS_VELOCITY_SET_TYPE=9 !<The parameter set corresponding to the previous velocity values (at time T). This is also the initial velocity values for dynamic problems. \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE=10 !<The parameter set corresponding to the mean predicited velocity values (at time T+DT) \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_ACCELERATION_VALUES_SET_TYPE=11 !<The parameter set corresponding to the acceleration values (at time T+DT) \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_INITIAL_ACCELERATION_SET_TYPE=12 !<The parameter set corresponding to the initial acceleration values for dynamic problems. This is also the previous accelearation values \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_PREVIOUS_ACCELERATION_SET_TYPE=12 !<The parameter set corresponding to the previous acceleration values (at time T).This is also the initial acceleration values for dynamic problems. \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE=13 !<The parameter set corresponding to the mean predicted acceleration values (at time T+DT) \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_PREDICTED_DISPLACEMENT_SET_TYPE=14 !<The parameter set corresponding to the predicted values (at time T+DT) \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_PREDICTED_VELOCITY_SET_TYPE=15 !<The parameter set corresponding to the predicted velocity values (at time T+DT) \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_PREDICTED_ACCELERATION_SET_TYPE=16 !<The parameter set corresponding to the predicted acceleration values (at time T+DT) \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_RESIDUAL_SET_TYPE=17 !<The parameter set corresponding to the evaluated residual values (at time T) \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_PREVIOUS_RESIDUAL_SET_TYPE=18 !<The parameter set corresponding to the residual values evaluated previously (at time T-DT) \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_MESH_DISPLACEMENT_SET_TYPE=19 !<The parameter set corresponding to the mesh displacement values for ALE \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_MESH_VELOCITY_SET_TYPE=20 !<The parameter set corresponding to the mesh velocity values for ALE \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_BOUNDARY_SET_TYPE=21 !<The parameter set corresponding to the mesh velocity values for ALE \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_INPUT_DATA1_SET_TYPE=22 !<The parameter set corresponding to a input field \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_INPUT_DATA2_SET_TYPE=23 !<The parameter set corresponding to a input field \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_INPUT_DATA3_SET_TYPE=24 !<The parameter set corresponding to a input field \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_INPUT_VEL1_SET_TYPE=25 !<The parameter set corresponding to a input field (PPE)\see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_INPUT_VEL2_SET_TYPE=26 !<The parameter set corresponding to a input field (PPE)\see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_INPUT_VEL3_SET_TYPE=27 !<The parameter set corresponding to a input field (PPE)\see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_INPUT_LABEL_SET_TYPE=28 !<The parameter set corresponding to a input field (PPE)\see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_PRESSURE_VALUES_SET_TYPE=29 !<The parameter set corresponding to the surface pressure values (at time T+DT). \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_PREVIOUS_PRESSURE_SET_TYPE=30 !<The parameter set corresponding to the previous surface pressure values (at previous increment step). \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES 
  INTEGER(INTG), PARAMETER :: FIELD_RELATIVE_VELOCITY_SET_TYPE=31 !<The parameter set corresponding to the relative velocity values for ALE \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_NEGATIVE_MESH_VELOCITY_SET_TYPE=32 !<The parameter set corresponding to the NEGATIVE mesh velocity values for ALE \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_PREVIOUS_ITERATION_VALUES_SET_TYPE=33 !<The parameter set corresponding to the previous iteration field values (at iteration n) \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE=34 !<The parameter set corresponding to the impermeable flag field values \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_INTEGRATED_NEUMANN_SET_TYPE=35 !<Stores integrated Neumann values calculated from Neumann point values \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
  !>@}

  !> \addtogroup FIELD_ROUTINES_ScalingTypes FIELD_ROUTINES::ScalingTypes
  !> \brief Field scaling type parameters
  !> \see FIELD_ROUTINES,OPENCMISS_FieldScalingTypes
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_NO_SCALING=0 !<The field is not scaled \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_UNIT_SCALING=1 !<The field has unit scaling \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_ARC_LENGTH_SCALING=2 !<The field has arc length scaling \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_ARITHMETIC_MEAN_SCALING=3 !<The field has arithmetic mean of the arc length scaling \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GEOMETRIC_MEAN_SCALING=4 !<The field has geometric mean of the arc length scaling \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_HARMONIC_MEAN_SCALING=5 !<The field has harmonic mean of the arc length scaling \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
  !>@}
  
  !> \addtogroup FIELD_ROUTINES_InterpolationComponentsTypes FIELD_ROUTINES::InterpolationComponentsTypes
  !> \brief Field interpolation components types
  !> \see FIELD_ROUTINES
  !>@{
  INTEGER(INTG), PARAMETER :: FIELD_ALL_COMPONENTS_TYPE=1 !<The field is interpolated for all components \see FIELD_ROUTINES_InterpolationComponentsTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_GEOMETRIC_COMPONENTS_TYPE=2 !<The field is interpolated for geometric components \see FIELD_ROUTINES_InterpolationComponentsTypes,FIELD_ROUTINES
  INTEGER(INTG), PARAMETER :: FIELD_NONGEOMETRIC_COMPONENTS_TYPE=3 !<The field is interpolated for non-geometric components \see FIELD_ROUTINES_InterpolationComponentsTypes,FIELD_ROUTINES
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Gets the label for a field variable component.
  INTERFACE FIELD_COMPONENT_LABEL_GET
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_GET_C
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_GET_VS
  END INTERFACE !FIELD_COMPONENT_LABEL_GET
  
  !>Sets/changes the label for a field variable component.
  INTERFACE FIELD_COMPONENT_LABEL_SET
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_C
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_VS
  END INTERFACE !FIELD_COMPONENT_LABEL_SET
  
  !>Sets/changes the label for a field variable component and locks so that no further changes can be made.
  INTERFACE FIELD_COMPONENT_LABEL_SET_AND_LOCK
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_AND_LOCK_C
    MODULE PROCEDURE FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS
  END INTERFACE !FIELD_COMPONENT_LABEL_SET_AND_LOCK
  
  !>Initialises the values of parameter set of a field variable component to a constant value.
  INTERFACE FIELD_COMPONENT_VALUES_INITIALISE
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_INTG
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_SP
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_DP
    MODULE PROCEDURE FIELD_COMPONENT_VALUES_INITIALISE_L
  END INTERFACE !FIELD_COMPONENT_VALUES_INITIALISE

  !>Starts the process of creating a field
  INTERFACE FIELD_CREATE_START
    MODULE PROCEDURE FIELD_CREATE_START_INTERFACE
    MODULE PROCEDURE FIELD_CREATE_START_REGION
  END INTERFACE !FIELD_CREATE_START
  
  !>Gets the label for a field.
  INTERFACE FIELD_LABEL_GET
    MODULE PROCEDURE FIELD_LABEL_GET_C
    MODULE PROCEDURE FIELD_LABEL_GET_VS
  END INTERFACE !FIELD_LABEL_GET
  
  !>Sets/changes the label for a field.
  INTERFACE FIELD_LABEL_SET
    MODULE PROCEDURE FIELD_LABEL_SET_C
    MODULE PROCEDURE FIELD_LABEL_SET_VS
  END INTERFACE !FIELD_LABEL_SET
  
  !>Sets/changes the label for a field and locks so that no further changes can be made.
  INTERFACE FIELD_LABEL_SET_AND_LOCK
    MODULE PROCEDURE FIELD_LABEL_SET_AND_LOCK_C
    MODULE PROCEDURE FIELD_LABEL_SET_AND_LOCK_VS
  END INTERFACE !FIELD_LABEL_SET_AND_LOCK
  
  !>Adds the alpha times the parameter set values from one parameter set type to another parameter set type.
  INTERFACE FIELD_PARAMETER_SETS_ADD
    MODULE PROCEDURE FIELD_PARAMETER_SETS_ADD_DP
    MODULE PROCEDURE FIELD_PARAMETER_SETS_ADD_DP1
  END INTERFACE !FIELD_PARAMETER_SETS_ADD

  !>Adds the given value to the given parameter set for the constant of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_ADD_CONSTANT
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_CONSTANT_L
  END INTERFACE !FIELD_PARAMETER_SET_ADD_CONSTANT

  !>Adds the given value to the given parameter set for a particular local dof of the field variable.
  INTERFACE FIELD_PARAMETER_SET_ADD_LOCAL_DOF
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L
  END INTERFACE !FIELD_PARAMETER_SET_ADD_LOCAL_DOF

  !>Adds the given value to the given parameter set for a particular user element of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_ADD_ELEMENT
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_ELEMENT_L
  END INTERFACE !FIELD_PARAMETER_SET_ADD_ELEMENT
  
  !>Adds the given value to the given parameter set for a particular local element of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L
  END INTERFACE !FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT

  !>Adds the given value to the given parameter set for a particular user node, derivative and version of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_ADD_NODE
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_NODE_L
  END INTERFACE !FIELD_PARAMETER_SET_ADD_NODE
  
  !>Adds the given value to the given parameter set for a particular local node, derivative and version of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_ADD_LOCAL_NODE
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L
  END INTERFACE !FIELD_PARAMETER_SET_ADD_LOCAL_NODE

  !>Returns a pointer to the specified field parameter set array. The pointer must be restored with a call to FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_RESTORE call. Note: the values can be used for read operations but a FIELD_PARAMETER_SET_UPDATE call must be used to change any values.
  INTERFACE FIELD_PARAMETER_SET_DATA_GET
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_GET_L
  END INTERFACE !FIELD_PARAMETER_SET_DATA_GET
 
  !>Restores the specified field variable parameter set array that was obtained with FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_GET.
  INTERFACE FIELD_PARAMETER_SET_DATA_RESTORE
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_DATA_RESTORE_L
  END INTERFACE !FIELD_PARAMETER_SET_DATA_GET
 
  !>Returns from the given parameter set a value for the specified constant of a field variable component.
  INTERFACE FIELD_PARAMETER_SET_GET_CONSTANT
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_CONSTANT_L
  END INTERFACE !FIELD_PARAMETER_SET_GET_CONSTANT
  
  !>Returns from the given parameter set a value for the specified data point of a field variable component.
  INTERFACE Field_ParameterSetGetDataPoint
    MODULE PROCEDURE Field_ParameterSetGetDataPointIntg
    MODULE PROCEDURE Field_ParameterSetGetDataPointSp
    MODULE PROCEDURE Field_ParameterSetGetDataPointDp
    MODULE PROCEDURE Field_ParameterSetGetDataPointL
  END INTERFACE !Field_ParameterSetGetDataPoint

  !>Returns from the given parameter set a value for the specified element of a field variable component.
  INTERFACE FIELD_PARAMETER_SET_GET_ELEMENT
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_ELEMENT_L
  END INTERFACE !FIELD_PARAMETER_SET_GET_ELEMENT
  
  !>Returns the given parameter set value for a particular local dof of the field variable.
  INTERFACE FIELD_PARAMETER_SET_GET_LOCAL_DOF
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_LOCAL_DOF_L
  END INTERFACE !FIELD_PARAMETER_SET_GET_LOCAL_DOF

  !>Returns from the given parameter set a value for the specified node, derivative and version of a field variable component.
  INTERFACE FIELD_PARAMETER_SET_GET_NODE
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_NODE_L
  END INTERFACE !FIELD_PARAMETER_SET_GET_NODE

  !>Returns from the given parameter set a value for the specified node, derivative and version of a field variable component.
  INTERFACE Field_ParameterSetGetLocalNode
    MODULE PROCEDURE Field_ParameterSetGetLocalNode_Intg
    MODULE PROCEDURE Field_ParameterSetGetLocalNode_Sp
    MODULE PROCEDURE Field_ParameterSetGetLocalNode_Dp
    MODULE PROCEDURE Field_ParameterSetGetLocalNode_L
  END INTERFACE !Field_ParameterSetGetLocalNode

  !>Returns from the given parameter set a value for the specified node, derivative and version of a field variable component.
  INTERFACE Field_ParameterSetGetLocalElement
    MODULE PROCEDURE Field_ParameterSetGetLocalElement_Intg
    MODULE PROCEDURE Field_ParameterSetGetLocalElement_Sp
    MODULE PROCEDURE Field_ParameterSetGetLocalElement_Dp
    MODULE PROCEDURE Field_ParameterSetGetLocalElement_L
  END INTERFACE !Field_ParameterSetGetLocalElement

  !>Returns from the given parameter set a value for the specified element and Gauss point of a field variable component.  TODO: sp/int/l versions
  INTERFACE FIELD_PARAMETER_SET_GET_GAUSS_POINT
    MODULE PROCEDURE FIELD_PARAMETER_SET_GET_GAUSS_POINT_DP
  END INTERFACE !FIELD_PARAMETER_SET_GET_GAUSS_POINT
  
  !>Updates the given parameter set with the given value for the constant of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_CONSTANT
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_CONSTANT_L
  END INTERFACE !FIELD_PARAMETER_SET_UPDATE_CONSTANT
  
  !>Updates the given parameter set a value for the specified data point of a field variable component.
  INTERFACE Field_ParameterSetUpdateDataPoint
    MODULE PROCEDURE Field_ParameterSetUpdateDataPointIntg
    MODULE PROCEDURE Field_ParameterSetUpdateDataPointSp
    MODULE PROCEDURE Field_ParameterSetUpdateDataPointDp
    MODULE PROCEDURE Field_ParameterSetUpdateDataPointL
  END INTERFACE !Field_ParameterSetUpdateDataPoint

  !>Updates the given parameter set with the given value for a particular local dof of the field variable.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L
  END INTERFACE !FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF

  !>Updates the given parameter set with the given values for all local dofs of the field variable.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP
  END INTERFACE !FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS

  !>Updates the given parameter set with the given value for a particular user element of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_ELEMENT
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_ELEMENT_L
  END INTERFACE !FIELD_PARAMETER_SET_UPDATE_ELEMENT
  
  !>Updates the given parameter set with the given value for a particular local element of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L
  END INTERFACE !FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT

  !>Updates the given parameter set with the given value for a particular user node, derivative and version of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_NODE
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_NODE_L
  END INTERFACE !FIELD_PARAMETER_SET_UPDATE_NODE
  
  !>Updates the given parameter set with the given value for a particular local node, derivative and version of the field variable component.
  INTERFACE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP
    MODULE PROCEDURE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L
  END INTERFACE !FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE

  !>Updates the given parameter set with the given value for a particular element and gauss point of the field variable component. 
  INTERFACE FieldParameterSetUpdateGaussPoint
    MODULE PROCEDURE FieldParameterSetUpdateGaussPointIntg
    MODULE PROCEDURE FieldParameterSetUpdateGaussPointSP
    MODULE PROCEDURE FieldParameterSetUpdateGaussPointDP
    MODULE PROCEDURE FieldParameterSetUpdateGaussPointL
  END INTERFACE FieldParameterSetUpdateGaussPoint

  !>Updates the given parameter set with the given value for a particular element and gauss point of the field variable component. 
  INTERFACE FIELD_PARAMETER_SET_UPDATE_GAUSS_POINT
    MODULE PROCEDURE FieldParameterSetUpdateGaussPointIntg
    MODULE PROCEDURE FieldParameterSetUpdateGaussPointSP
    MODULE PROCEDURE FieldParameterSetUpdateGaussPointDP
    MODULE PROCEDURE FieldParameterSetUpdateGaussPointL
  END INTERFACE FIELD_PARAMETER_SET_UPDATE_GAUSS_POINT

  !>Updates the given parameter set with the given value for a particular element and data point of the field variable component. TODO: sp/int/l versions
  INTERFACE Field_ParameterSetUpdateElementDataPoint
    MODULE PROCEDURE Field_ParameterSetUpdateElementDataPointDP
  END INTERFACE !Field_ParameterSetUpdateElementDataPoint

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative. \todo Update FIELD_INTERPOLATED_POINT_TYPE to include VALUES array for other data types eg sp/int and then add ability to FIELD_PARAMETER_SET_INTERPOLATE_XI with these data types
  INTERFACE FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_XI
    MODULE PROCEDURE FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_XI_DP
  END INTERFACE !FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_XI

  !>Interpolates the given parameter set at a specified set of xi locations for the specified element and derviative. \todo Update FIELD_INTERPOLATED_POINT_TYPE to include VALUES array for other data types eg sp/int and then add ability to FIELD_PARAMETER_SET_INTERPOLATE_XI with these data types
  INTERFACE FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_XI
    MODULE PROCEDURE FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_XI_DP
  END INTERFACE !FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_XI

  !>Interpolates the given parameter set at the specified gauss point number for the specified element and derviative. \todo Update FIELD_INTERPOLATED_POINT_TYPE to include VALUES array for other data types eg sp/int and then add ability to FIELD_PARAMETER_SET_INTERPOLATE_XI with these data types
  INTERFACE FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_GAUSS
    MODULE PROCEDURE FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_GAUSS_DP
  END INTERFACE !FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_GAUSS

  !>Interpolates the given parameter set at the specified gauss point numbers for the specified element and derviative. If no Gauss points are specified then all Gauss points are interpolated. \todo Update FIELD_INTERPOLATED_POINT_TYPE to include VALUES array for other data types eg sp/int and then add ability to FIELD_PARAMETER_SET_INTERPOLATE_XI with these data types
  INTERFACE FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_GAUSS
    MODULE PROCEDURE FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_GAUSS_DP
  END INTERFACE !FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_GAUSS

  !>Finds and returns a field identified by a user number. If no field  with that number exits field is left nullified.
  INTERFACE FIELD_USER_NUMBER_FIND
    MODULE PROCEDURE FIELD_USER_NUMBER_FIND_INTERFACE
    MODULE PROCEDURE FIELD_USER_NUMBER_FIND_REGION
  END INTERFACE !FIELD_USER_NUMBER_FIND
  
  !> Find the field with the given user number, or throw an error if it does not exist.
  INTERFACE FIELD_USER_NUMBER_TO_FIELD
    MODULE PROCEDURE FIELD_USER_NUMBER_TO_FIELD_INTERFACE
    MODULE PROCEDURE FIELD_USER_NUMBER_TO_FIELD_REGION
  END INTERFACE !FIELD_USER_NUMBER_TO_FIELD
  
  !>Gets the label for a field variable type.
  INTERFACE FIELD_VARIABLE_LABEL_GET
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_GET_C
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_GET_VS
  END INTERFACE !FIELD_VARIABLE_LABEL_GET
  
  !>Sets/changes the label for a field variable type.
  INTERFACE FIELD_VARIABLE_LABEL_SET
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_C
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_VS
  END INTERFACE !FIELD_VARIABLE_LABEL_SET
  
  !>Sets/changes the label for a field variable type and locks so that no further changes can be made.
  INTERFACE FIELD_VARIABLE_LABEL_SET_AND_LOCK
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_AND_LOCK_C
    MODULE PROCEDURE FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS
  END INTERFACE !FIELD_VARIABLE_LABEL_SET_AND_LOCK

  !>Initialises the fields.
  INTERFACE FIELDS_INITIALISE
    MODULE PROCEDURE FIELDS_INITIALISE_INTERFACE
    MODULE PROCEDURE FIELDS_INITIALISE_REGION
  END INTERFACE !FIELDS_INITIALISE
  
  PUBLIC FIELD_INDEPENDENT_TYPE,FIELD_DEPENDENT_TYPE

  PUBLIC FIELD_SCALAR_DIMENSION_TYPE,FIELD_VECTOR_DIMENSION_TYPE,FIELD_TENSOR_DIMENSION_TYPE

  PUBLIC FIELD_GEOMETRIC_TYPE,FIELD_FIBRE_TYPE,FIELD_GENERAL_TYPE,FIELD_MATERIAL_TYPE,FIELD_GEOMETRIC_GENERAL_TYPE

  PUBLIC FIELD_CONSTANT_INTERPOLATION,FIELD_ELEMENT_BASED_INTERPOLATION,FIELD_NODE_BASED_INTERPOLATION, &
    & FIELD_GRID_POINT_BASED_INTERPOLATION,FIELD_GAUSS_POINT_BASED_INTERPOLATION,FIELD_DATA_POINT_BASED_INTERPOLATION

  PUBLIC FIELD_CONSTANT_DOF_TYPE,FIELD_ELEMENT_DOF_TYPE,FIELD_NODE_DOF_TYPE,FIELD_GRID_POINT_DOF_TYPE,FIELD_GAUSS_POINT_DOF_TYPE, &
    & FIELD_DATA_POINT_DOF_TYPE

  PUBLIC FIELD_NUMBER_OF_VARIABLE_TYPES,FIELD_NUMBER_OF_VARIABLE_SUBTYPES,FIELD_NUMBER_OF_SET_TYPES, &
    & FIELD_U_VARIABLE_TYPE,FIELD_DELUDELN_VARIABLE_TYPE,FIELD_DELUDELT_VARIABLE_TYPE, &
    & FIELD_DEL2UDELT2_VARIABLE_TYPE,FIELD_V_VARIABLE_TYPE,FIELD_DELVDELN_VARIABLE_TYPE,FIELD_DELVDELT_VARIABLE_TYPE, &
    & FIELD_DEL2VDELT2_VARIABLE_TYPE,&
    & FIELD_U1_VARIABLE_TYPE,FIELD_DELU1DELN_VARIABLE_TYPE,FIELD_DELU1DELT_VARIABLE_TYPE,FIELD_DEL2U1DELT2_VARIABLE_TYPE,&
    & FIELD_U2_VARIABLE_TYPE,FIELD_DELU2DELN_VARIABLE_TYPE,FIELD_DELU2DELT_VARIABLE_TYPE,FIELD_DEL2U2DELT2_VARIABLE_TYPE,&
    & FIELD_U3_VARIABLE_TYPE,FIELD_DELU3DELN_VARIABLE_TYPE,FIELD_DELU3DELT_VARIABLE_TYPE,FIELD_DEL2U3DELT2_VARIABLE_TYPE,&
    & FIELD_U4_VARIABLE_TYPE,FIELD_DELU4DELN_VARIABLE_TYPE,FIELD_DELU4DELT_VARIABLE_TYPE,FIELD_DEL2U4DELT2_VARIABLE_TYPE,&
    & FIELD_U5_VARIABLE_TYPE,FIELD_DELU5DELN_VARIABLE_TYPE,FIELD_DELU5DELT_VARIABLE_TYPE,FIELD_DEL2U5DELT2_VARIABLE_TYPE,&
    & FIELD_U6_VARIABLE_TYPE,FIELD_DELU6DELN_VARIABLE_TYPE,FIELD_DELU6DELT_VARIABLE_TYPE,FIELD_DEL2U6DELT2_VARIABLE_TYPE,&
    & FIELD_U7_VARIABLE_TYPE,FIELD_DELU7DELN_VARIABLE_TYPE,FIELD_DELU7DELT_VARIABLE_TYPE,FIELD_DEL2U7DELT2_VARIABLE_TYPE,&
    & FIELD_U8_VARIABLE_TYPE,FIELD_DELU8DELN_VARIABLE_TYPE,FIELD_DELU8DELT_VARIABLE_TYPE,FIELD_DEL2U8DELT2_VARIABLE_TYPE,&
    & FIELD_U9_VARIABLE_TYPE,FIELD_DELU9DELN_VARIABLE_TYPE,FIELD_DELU9DELT_VARIABLE_TYPE,FIELD_DEL2U9DELT2_VARIABLE_TYPE,&
    & FIELD_U10_VARIABLE_TYPE,FIELD_DELU10DELN_VARIABLE_TYPE,FIELD_DELU10DELT_VARIABLE_TYPE,FIELD_DEL2U10DELT2_VARIABLE_TYPE

  PUBLIC FIELD_INTG_TYPE,FIELD_SP_TYPE,FIELD_DP_TYPE,FIELD_L_TYPE

  PUBLIC FIELD_SEPARATED_COMPONENT_DOF_ORDER,FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER

  PUBLIC FIELD_VALUES_SET_TYPE,FIELD_BOUNDARY_CONDITIONS_SET_TYPE,FIELD_INITIAL_VALUES_SET_TYPE,FIELD_INCREMENTAL_VALUES_SET_TYPE, &
    & FIELD_ANALYTIC_VALUES_SET_TYPE,FIELD_PREVIOUS_VALUES_SET_TYPE,FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE, &
    & FIELD_VELOCITY_VALUES_SET_TYPE,FIELD_INITIAL_VELOCITY_SET_TYPE,FIELD_PREVIOUS_VELOCITY_SET_TYPE, &
    & FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE,FIELD_ACCELERATION_VALUES_SET_TYPE,FIELD_INITIAL_ACCELERATION_SET_TYPE, &
    & FIELD_PREVIOUS_ACCELERATION_SET_TYPE,FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE,FIELD_PREDICTED_DISPLACEMENT_SET_TYPE, &
    & FIELD_PREDICTED_VELOCITY_SET_TYPE,FIELD_PREDICTED_ACCELERATION_SET_TYPE,FIELD_RESIDUAL_SET_TYPE, & 
    & FIELD_PREVIOUS_RESIDUAL_SET_TYPE,FIELD_MESH_DISPLACEMENT_SET_TYPE,FIELD_MESH_VELOCITY_SET_TYPE,FIELD_BOUNDARY_SET_TYPE, &
    & FIELD_INPUT_DATA1_SET_TYPE, FIELD_INPUT_DATA2_SET_TYPE, FIELD_INPUT_DATA3_SET_TYPE, FIELD_PRESSURE_VALUES_SET_TYPE, &
    & FIELD_PREVIOUS_PRESSURE_SET_TYPE, FIELD_RELATIVE_VELOCITY_SET_TYPE, FIELD_NEGATIVE_MESH_VELOCITY_SET_TYPE, &
    & FIELD_PREVIOUS_ITERATION_VALUES_SET_TYPE, &
    & FIELD_INPUT_VEL1_SET_TYPE,FIELD_INPUT_VEL2_SET_TYPE,FIELD_INPUT_VEL3_SET_TYPE,FIELD_INPUT_LABEL_SET_TYPE, &
    & FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE,FIELD_INTEGRATED_NEUMANN_SET_TYPE

  PUBLIC FIELD_NO_SCALING,FIELD_UNIT_SCALING,FIELD_ARC_LENGTH_SCALING,FIELD_HARMONIC_MEAN_SCALING,FIELD_ARITHMETIC_MEAN_SCALING, &
    & FIELD_GEOMETRIC_MEAN_SCALING
    
  PUBLIC FIELD_ALL_COMPONENTS_TYPE,FIELD_GEOMETRIC_COMPONENTS_TYPE,FIELD_NONGEOMETRIC_COMPONENTS_TYPE

  PUBLIC FIELD_COORDINATE_SYSTEM_GET

  PUBLIC FIELD_COMPONENT_DOF_GET_CONSTANT,FIELD_COMPONENT_DOF_GET_USER_ELEMENT,FIELD_COMPONENT_DOF_GET_USER_NODE, &
    & Field_componentDofGetUserDataPoint

  PUBLIC FIELD_COMPONENT_INTERPOLATION_CHECK,FIELD_COMPONENT_INTERPOLATION_GET,FIELD_COMPONENT_INTERPOLATION_SET, &
    & FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK

  PUBLIC FIELD_COMPONENT_LABEL_GET,FIELD_COMPONENT_LABEL_SET,FIELD_COMPONENT_LABEL_SET_AND_LOCK

  PUBLIC FIELD_COMPONENT_MESH_COMPONENT_CHECK,FIELD_COMPONENT_MESH_COMPONENT_GET,FIELD_COMPONENT_MESH_COMPONENT_SET, &
    & FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK
  
  PUBLIC FIELD_COMPONENT_VALUES_INITIALISE

  PUBLIC FIELD_CREATE_FINISH,FIELD_CREATE_START,FIELD_DESTROY,FIELDS_FINALISE,FIELDS_INITIALISE

  PUBLIC FIELD_DATA_TYPE_CHECK,FIELD_DATA_TYPE_GET,FIELD_DATA_TYPE_SET,FIELD_DATA_TYPE_SET_AND_LOCK

  PUBLIC Field_GeometricGeneralFieldGet

  PUBLIC FIELD_DEPENDENT_TYPE_CHECK,FIELD_DEPENDENT_TYPE_GET,FIELD_DEPENDENT_TYPE_SET,FIELD_DEPENDENT_TYPE_SET_AND_LOCK

  PUBLIC FIELD_DIMENSION_CHECK,FIELD_DIMENSION_GET,FIELD_DIMENSION_SET,FIELD_DIMENSION_SET_AND_LOCK

  PUBLIC FIELD_DOF_ORDER_TYPE_CHECK,FIELD_DOF_ORDER_TYPE_GET,FIELD_DOF_ORDER_TYPE_SET,FIELD_DOF_ORDER_TYPE_SET_AND_LOCK

  PUBLIC FIELD_GEOMETRIC_FIELD_GET,FIELD_GEOMETRIC_FIELD_SET,FIELD_GEOMETRIC_FIELD_SET_AND_LOCK

  PUBLIC Field_GeometricParametersElementLineLengthGet

  PUBLIC FIELD_INTERPOLATE_GAUSS,FIELD_INTERPOLATE_XI,FIELD_INTERPOLATE_NODE,FIELD_INTERPOLATE_FIELD_NODE, &
    & FIELD_INTERPOLATE_LOCAL_FACE_GAUSS

  PUBLIC FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_INT_PT_METRIC,FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_NODE

  PUBLIC FIELD_INTERPOLATED_POINT_METRICS_CALCULATE,FIELD_INTERPOLATED_POINTS_METRICS_FINALISE, &
    & FIELD_INTERPOLATED_POINTS_METRICS_INITIALISE,FIELD_INTERPOLATED_POINTS_FINALISE, &
    & FIELD_INTERPOLATED_POINTS_INITIALISE,FIELD_PHYSICAL_POINTS_INITIALISE,FIELD_PHYSICAL_POINTS_FINALISE

  PUBLIC FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET,FIELD_INTERPOLATION_PARAMETERS_FINALISE, &
    & FIELD_INTERPOLATION_PARAMETERS_INITIALISE,FIELD_INTERPOLATION_PARAMETERS_LINE_GET, &
    & FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_ELEM_GET,FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_LINE_GET, &
    & FIELD_INTERPOLATION_PARAMETERS_FACE_GET,FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_FACE_GET

  PUBLIC FIELD_LABEL_GET,FIELD_LABEL_SET,FIELD_LABEL_SET_AND_LOCK
  
  PUBLIC FIELD_MESH_DECOMPOSITION_GET,FIELD_MESH_DECOMPOSITION_SET,FIELD_MESH_DECOMPOSITION_SET_AND_LOCK

  PUBLIC Field_DataProjectionSet

  PUBLIC FIELD_NUMBER_OF_COMPONENTS_CHECK,FIELD_NUMBER_OF_COMPONENTS_GET,FIELD_NUMBER_OF_COMPONENTS_SET, &
    & FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK

  PUBLIC FIELD_NUMBER_OF_VARIABLES_CHECK,FIELD_NUMBER_OF_VARIABLES_GET,FIELD_NUMBER_OF_VARIABLES_SET, &
    & FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK
  
  PUBLIC FIELD_PARAMETER_SETS_ADD,FIELD_PARAMETER_SETS_COPY,FIELD_PARAMETER_SET_DESTROY

  PUBLIC FIELD_PARAMETERS_TO_FIELD_PARAMETERS_COMPONENT_COPY

  PUBLIC FIELD_PARAMETER_SET_GET
  
  PUBLIC FIELD_PARAMETER_SET_ADD_CONSTANT,FIELD_PARAMETER_SET_ADD_LOCAL_DOF,FIELD_PARAMETER_SET_ADD_ELEMENT, &
    & FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT,FIELD_PARAMETER_SET_ADD_NODE,FIELD_PARAMETER_SET_ADD_LOCAL_NODE
  
  PUBLIC FIELD_PARAMETER_SET_CREATE

  PUBLIC Field_ParameterSetEnsureCreated,FIELD_PARAMETER_SET_CREATED

  PUBLIC FIELD_PARAMETER_SET_DATA_GET,FIELD_PARAMETER_SET_DATA_RESTORE

  PUBLIC FIELD_PARAMETER_SET_GET_CONSTANT,Field_ParameterSetGetDataPoint,FIELD_PARAMETER_SET_GET_ELEMENT, &
    & FIELD_PARAMETER_SET_GET_LOCAL_DOF,FIELD_PARAMETER_SET_GET_NODE,Field_ParameterSetGetLocalNode, &
    & FIELD_PARAMETER_SET_GET_GAUSS_POINT,Field_ParameterSetGetLocalElement

  PUBLIC FIELD_PARAMETER_SET_OUTPUT

  PUBLIC FIELD_PARAMETER_SET_UPDATE_FINISH,FIELD_PARAMETER_SET_UPDATE_START

  PUBLIC FIELD_PARAMETER_SET_UPDATE_CONSTANT,FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF,FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS, &
    & FIELD_PARAMETER_SET_UPDATE_ELEMENT,FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT,FIELD_PARAMETER_SET_UPDATE_NODE, &
    & FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE,Field_ParameterSetUpdateDataPoint

  PUBLIC Field_ParameterSetNodeScaleFactorGet,Field_ParameterSetNodeScaleFactorSet, &
    & Field_ParameterSetNodeScaleFactorsGet,Field_ParameterSetNodeScaleFactorsSet, &
    & Field_ParameterSetNodeNumberOfScaleFactorDofsGet

  PUBLIC FieldParameterSetUpdateGaussPoint,FIELD_PARAMETER_SET_UPDATE_GAUSS_POINT

  PUBLIC FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_XI, FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_XI

  PUBLIC FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_GAUSS, FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_GAUSS

  PUBLIC Field_ParameterSetUpdateElementDataPoint

  PUBLIC FIELD_PARAMETER_SET_VECTOR_GET

  PUBLIC FIELD_REGION_GET

  PUBLIC FIELD_SCALING_TYPE_CHECK,FIELD_SCALING_TYPE_GET,FIELD_SCALING_TYPE_SET,FIELD_SCALING_TYPE_SET_AND_LOCK

  PUBLIC FIELD_TYPE_CHECK,FIELD_TYPE_GET,FIELD_TYPE_SET,FIELD_TYPE_SET_AND_LOCK
  
  PUBLIC FIELD_USER_NUMBER_FIND, FIELD_USER_NUMBER_TO_FIELD

  PUBLIC FIELD_VARIABLE_GET

  PUBLIC FIELD_VARIABLE_LABEL_GET,FIELD_VARIABLE_LABEL_SET,FIELD_VARIABLE_LABEL_SET_AND_LOCK

  PUBLIC FIELD_VARIABLE_TYPES_CHECK,FIELD_VARIABLE_TYPE_CHECK,FIELD_VARIABLE_TYPES_GET

  PUBLIC FIELD_VARIABLE_TYPES_SET,FIELD_VARIABLE_TYPES_SET_AND_LOCK

  PUBLIC MESH_EMBEDDING_PUSH_DATA, MESH_EMBEDDING_PULL_GAUSS_POINT_DATA, FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD

  PUBLIC Field_CalculateEnclosedVolume
   
CONTAINS

  !
  !================================================================================================================================
  !

  !>Checks the interpolation type for a field variable component.
  SUBROUTINE FIELD_COMPONENT_INTERPOLATION_CHECK(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,INTERPOLATION_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the interpolation for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type of the field variable component to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number of the field variable component to check
    INTEGER(INTG), INTENT(IN) :: INTERPOLATION_TYPE !<The interpolation type of the field variable component to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_COMPONENT_INTERPOLATION_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              SELECT CASE(INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE/=FIELD_CONSTANT_INTERPOLATION) THEN
                  LOCAL_ERROR="Invalid interpolation type. The interpolation type for component number "// &
                    & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                    & " which is not constant interpolation."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE/=FIELD_ELEMENT_BASED_INTERPOLATION) THEN
                  LOCAL_ERROR="Invalid interpolation type. The interpolation type for component number "// &
                    & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                    & " which is not element based interpolation."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE/=FIELD_NODE_BASED_INTERPOLATION) THEN
                  LOCAL_ERROR="Invalid interpolation type. The interpolation type for component number "// &
                    & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                    & " which is not node based interpolation."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE/=FIELD_GRID_POINT_BASED_INTERPOLATION) THEN
                  LOCAL_ERROR="Invalid interpolation type. The interpolation type for component number "// &
                    & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                    & " which is not grid point based interpolation."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE/=FIELD_GAUSS_POINT_BASED_INTERPOLATION) THEN
                  LOCAL_ERROR="Invalid interpolation type. The interpolation type for component number "// &
                    & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                    & " which is not Gauss point based interpolation."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE/=FIELD_DATA_POINT_BASED_INTERPOLATION) THEN
                  LOCAL_ERROR="Invalid interpolation type. The interpolation type for component number "// &
                    & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                    & " which is not data point based interpolation."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE DEFAULT
                LOCAL_ERROR="The specified interpolation type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_COMPONENT_INTERPOLATION_CHECK")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_INTERPOLATION_CHECK",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_INTERPOLATION_CHECK")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_INTERPOLATION_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the interpolation type for a field variable component identified by a pointer. \see OPENCMISS::CMISSFieldComponentInterpolationGet
  SUBROUTINE FIELD_COMPONENT_INTERPOLATION_GET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,INTERPOLATION_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the interpolation for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type of the field variable component to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number of the field variable component to set
    INTEGER(INTG), INTENT(OUT) :: INTERPOLATION_TYPE !<On return, the interpolation type of the field variable component \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_COMPONENT_INTERPOLATION_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              INTERPOLATION_TYPE=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_COMPONENT_INTERPOLATION_GET")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_INTERPOLATION_GET",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_INTERPOLATION_GET")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_INTERPOLATION_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component. \see OPENCMISS::CMISSFieldComponentInterpolationSet
  SUBROUTINE FIELD_COMPONENT_INTERPOLATION_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,INTERPOLATION_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the interpolation for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type of the field variable component to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number of the field variable component to set
    INTEGER(INTG), INTENT(IN) :: INTERPOLATION_TYPE !<The interpolation type to set \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_COMPONENT_INTERPOLATION_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN          
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
              IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)) THEN
                IF(FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(COMPONENT_NUMBER,VARIABLE_TYPE)) THEN
                  LOCAL_ERROR="The interpolation type has been locked for component number "// &
                    & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                    & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ELSE
                  SELECT CASE(INTERPOLATION_TYPE)                
                  CASE(FIELD_CONSTANT_INTERPOLATION)
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
                  CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
                  CASE(FIELD_NODE_BASED_INTERPOLATION)
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
                  CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
                  CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
                  CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)=INTERPOLATION_TYPE
                  CASE DEFAULT
                    LOCAL_ERROR="The specified interpolation type of "// &
                      & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  END SELECT
                ENDIF
              ELSE
                LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE),"*",ERR,ERROR))// &
                  & " components."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_COMPONENT_INTERPOLATION_SET")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_INTERPOLATION_SET",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_INTERPOLATION_SET")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_INTERPOLATION_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component and locks so that no further changes can be made.
  SUBROUTINE FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,INTERPOLATION_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the interpolation for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type of the field variable component to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number of the field variable component to set
    INTEGER(INTG), INTENT(IN) :: INTERPOLATION_TYPE !<The interpolation type to set \see FIELD_ROUTINES_InterpolationTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_COMPONENT_INTERPOLATION_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,INTERPOLATION_TYPE,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(COMPONENT_NUMBER,VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_INTERPOLATION_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Returns the dof numbers for a field variable component that corresponds to the specified constant
  SUBROUTINE FIELD_COMPONENT_DOF_GET_CONSTANT(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LOCAL_DOF,GLOBAL_DOF,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the dof for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the dof for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get the dof for
    INTEGER(INTG), INTENT(OUT) :: LOCAL_DOF !<On exit, the local dof corresponding to the constant
    INTEGER(INTG), INTENT(OUT) :: GLOBAL_DOF !<On exit, the global dof corresponding to the constant
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("FIELD_COMPONENT_DOF_GET_CONSTANT",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                IF(ASSOCIATED(FIELD_VARIABLE%DOMAIN_MAPPING)) THEN
                  LOCAL_DOF=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                  GLOBAL_DOF=FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(LOCAL_DOF)
                ELSE
                  LOCAL_ERROR="The field variable domain mapping is not associated for variable type "// &
                    & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by constant for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by constant for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by constant for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by constant for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)  
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by constant for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)                
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                  & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)            
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_COMPONENT_DOF_GET_CONSTANT")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_DOF_GET_CONSTANT",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_DOF_GET_CONSTANT")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_DOF_GET_CONSTANT
  
  !
  !================================================================================================================================
  !

  !>Returns the dof numbers for a field component that corresponds to the specified user data point.
  SUBROUTINE Field_componentDofGetUserDataPoint(field,variableType,userDataPointNumber,componentNumber,localDof, &
    & globalDof,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the dof for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the dof for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The user data point number to get the dof for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field component number to get the dof for
    INTEGER(INTG), INTENT(OUT) :: localDof !<On exit, the local dof corresponding to the user data point
    INTEGER(INTG), INTENT(OUT) :: globalDof !<On exit, the global dof corresponding to the user data point
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    LOGICAL :: ghostDataPoint,userDataPointExists
    INTEGER(INTG) :: decompositionLocalDataPointNumber
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError
    
    CALL ENTERS("Field_componentDofGetUserDataPoint",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>FIELD%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
              SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                localError="Can not get the dof by user data point for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                CALL FLAG_error(localError,err,error,*999)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                localError="Can not get the dof by user data point for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                CALL FLAG_ERROR(localError,err,error,*999)
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                localError="Can not get the dof by user data point for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                CALL FLAG_ERROR(localError,err,error,*999)
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                localError="Can not get the dof by user data point for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                CALL FLAG_ERROR(localError,err,error,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                localError="Can not get the dof by user data point for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                CALL FLAG_ERROR(localError,err,error,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                decomposition=>fieldVariable%COMPONENTS(componentNumber)%DOMAIN%DECOMPOSITION
                IF(ASSOCIATED(decomposition)) THEN
                  decompositionTopology=>decomposition%TOPOLOGY
                  userDataPointExists=.TRUE.
                  IF(ASSOCIATED(decompositionTopology)) THEN
                    CALL DecompositionTopologyDataPointCheckExists(decompositionTopology,userDataPointNumber,userDataPointExists, &
                      & decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                    IF(userDataPointExists) THEN
                      localDof=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                        & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)
                      globalDof=fieldVariable%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(localDof)
                    ELSE
                      localError="The specified user data point number of "// &
                        & TRIM(NUMBER_TO_VSTRING(userDataPointNumber,"*",err,error))// &
                        & " does not exist in the domain for field component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of field variable "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",err,error))//"."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    ENDIF
                  ELSE
                    CALL FLAG_ERROR("Decomposition topology is not associated.",err,error,*999)
                  ENDIF
                ELSE
                  CALL FLAG_ERROR("Decomposition is not associated.",err,error,*999)
                ENDIF
              CASE DEFAULT
                localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                  & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                  & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                  & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                  & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",err,error))//"."
                CALL FLAG_ERROR(localError,err,error,*999)
              END SELECT
            ELSE
              localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",err,error))//" which has "// &
                & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))// &
                & " components."
              CALL FLAG_ERROR(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",err,error))//"."
            CALL FLAG_ERROR(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    ENDIF
    
    CALL EXITS("Field_componentDofGetUserDataPoint")
    RETURN
999 CALL ERRORS("Field_componentDofGetUserDataPoint",err,error)
    CALL EXITS("Field_componentDofGetUserDataPoint")
    RETURN 1
  END SUBROUTINE Field_componentDofGetUserDataPoint

  !
  !================================================================================================================================
  !

  !>Returns the dof numbers for a field component that corresponds to the specified user element.
  SUBROUTINE FIELD_COMPONENT_DOF_GET_USER_ELEMENT(FIELD,VARIABLE_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER,LOCAL_DOF, &
    & GLOBAL_DOF,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the dof for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the dof for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to get the dof for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get the dof for
    INTEGER(INTG), INTENT(OUT) :: LOCAL_DOF !<On exit, the local dof corresponding to the user element
    INTEGER(INTG), INTENT(OUT) :: GLOBAL_DOF !<On exit, the global dof corresponding to the user element
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("FIELD_COMPONENT_DOF_GET_USER_ELEMENT",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                DECOMPOSITION=>FIELD%DECOMPOSITION
                IF(ASSOCIATED(DECOMPOSITION)) THEN
                  DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                  CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                    & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                  IF(USER_ELEMENT_EXISTS) THEN
                    IF(ASSOCIATED(FIELD_VARIABLE%DOMAIN_MAPPING)) THEN
                      LOCAL_DOF=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                        & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                      GLOBAL_DOF=FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(LOCAL_DOF)
                    ELSE
                      CALL FLAG_ERROR("The field variable domain mapping is not associated.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The specified user element number of "// &
                      & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                      & " does not exist in the decomposition for field component number "// &
                      & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable "// &
                      & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user element for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                  & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_COMPONENT_DOF_GET_USER_ELEMENT")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_DOF_GET_USER_ELEMENT",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_DOF_GET_USER_ELEMENT")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_DOF_GET_USER_ELEMENT

  !
  !================================================================================================================================
  !
  !>Returns the dof numbers for a field component that corresponds to the specified user node and derivative.
  SUBROUTINE FIELD_COMPONENT_DOF_GET_USER_NODE(FIELD,VARIABLE_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER,USER_NODE_NUMBER, & 
    & COMPONENT_NUMBER,LOCAL_DOF,GLOBAL_DOF,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the dof for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the dof for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The version number to get the dof for
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The derivative number to get the dof for
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to get the dof for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get the dof for
    INTEGER(INTG), INTENT(OUT) :: LOCAL_DOF !<On exit, the local dof corresponding to the user node
    INTEGER(INTG), INTENT(OUT) :: GLOBAL_DOF !<On exit, the global dof corresponding to the user node
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_COMPONENT_DOF_GET_USER_NODE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user node for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user node for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(DOMAIN)) THEN
                  DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                  CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                    & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                  IF(USER_NODE_EXISTS) THEN
                    IF(ASSOCIATED(FIELD_VARIABLE%DOMAIN_MAPPING)) THEN
                      IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%NUMBER_OF_DERIVATIVES) &
                        & THEN
                        LOCAL_DOF=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                          & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% & 
                          & VERSIONS(VERSION_NUMBER)
                        GLOBAL_DOF=FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(LOCAL_DOF)
                      ELSE
                        LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for user node number "// &
                          & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                          & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                          & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                          & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                          & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%NUMBER_OF_DERIVATIVES, &
                          & "*",ERR,ERROR))//" derivatives."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      CALL FLAG_ERROR("The field variable domain mapping is not associated.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The specified user node number of "// &
                      & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                      & " does not exist in the domain for field component number "// &
                      & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable "// &
                      & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  CALL FLAG_ERROR("Field variable component domain is not associated.",ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user node for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user node for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                LOCAL_ERROR="Can not get the dof by user node for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                  & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_COMPONENT_DOF_GET_USER_NODE")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_DOF_GET_USER_NODE",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_DOF_GET_USER_NODE")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_DOF_GET_USER_NODE

  !
  !================================================================================================================================
  !

  !>Gets the label for a field variable component for character labels. \see OPENCMISS::CMISSFieldComponentLabelGet
  SUBROUTINE FIELD_COMPONENT_LABEL_GET_C(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    CHARACTER(LEN=*), INTENT(OUT) :: LABEL !<On return, the field variable label
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: C_LENGTH,VS_LENGTH
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("FIELD_COMPONENT_LABEL_GET_C",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              C_LENGTH=LEN(LABEL)
              VS_LENGTH=LEN_TRIM(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%COMPONENT_LABEL)
              IF(C_LENGTH>VS_LENGTH) THEN
                LABEL=CHAR(LEN_TRIM(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%COMPONENT_LABEL))
              ELSE
                LABEL=CHAR(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%COMPONENT_LABEL,C_LENGTH)
              ENDIF
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_COMPONENT_LABEL_GET_C")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_LABEL_GET_C",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_LABEL_GET_C")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_LABEL_GET_C

  !
  !================================================================================================================================
  !

  !>Gets the label for a field variable component for varying string labels. \see OPENCMISS::CMISSFieldComponentLabelGet
  SUBROUTINE FIELD_COMPONENT_LABEL_GET_VS(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    TYPE(VARYING_STRING), INTENT(OUT) :: LABEL !<On return, the field variable label
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("FIELD_COMPONENT_LABEL_GET_VS",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              LABEL=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%COMPONENT_LABEL
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_COMPONENT_LABEL_GET_VS")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_LABEL_GET_VS",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_LABEL_GET_VS")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_LABEL_GET_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable component for character labels. \see OPENCMISS::CMISSFieldComponentLabelSet
  SUBROUTINE FIELD_COMPONENT_LABEL_SET_C(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_COMPONENT_LABEL_SET_C",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN              
              IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)) THEN
                IF(FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED(COMPONENT_NUMBER,VARIABLE_TYPE)) THEN
                  LOCAL_ERROR="The component label has been locked for component number "// &
                    & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                    & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ELSE
                  FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS(COMPONENT_NUMBER,VARIABLE_TYPE)=LABEL
                ENDIF
              ELSE
                LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE),"*",ERR,ERROR))// &
                  & " components."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF                
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_COMPONENT_LABEL_SET_C")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_LABEL_SET_C",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_LABEL_SET_C")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_LABEL_SET_C

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable component for varying string labels. \see OPENCMISS::CMISSFieldComponentLabelSet
  SUBROUTINE FIELD_COMPONENT_LABEL_SET_VS(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_VARIABLE_LABEL_SET_VS",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN              
              IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)) THEN
                IF(FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED(COMPONENT_NUMBER,VARIABLE_TYPE)) THEN
                  LOCAL_ERROR="The component label has been locked for component number "// &
                    & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                    & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ELSE
                  FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS(COMPONENT_NUMBER,VARIABLE_TYPE)=LABEL
                ENDIF
              ELSE
                LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE),"*",ERR,ERROR))// &
                  & " components."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_COMPONENT_LABEL_SET_VS")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_LABEL_SET_VS",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_LABEL_SET_VS")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_LABEL_SET_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for character labels and locks so that no further changes can be made.
  SUBROUTINE FIELD_COMPONENT_LABEL_SET_AND_LOCK_C(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The label to set/change 
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_C",ERR,ERROR,*999)

    CALL FIELD_COMPONENT_LABEL_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED(COMPONENT_NUMBER,VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_C")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_C",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_C")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_LABEL_SET_AND_LOCK_C

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for varying string labels and locks so that no further changes can be made.
  SUBROUTINE FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The label to set/change 
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS",ERR,ERROR,*999)

    CALL FIELD_COMPONENT_LABEL_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LABEL,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED(COMPONENT_NUMBER,VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_LABEL_SET_AND_LOCK_VS

  !
  !================================================================================================================================
  !

  !>Check the mesh component number for a field variable component.
  SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_CHECK(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,MESH_COMPONENT,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the mesh component for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check the field variable component for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to check the field variable component for
    INTEGER(INTG), INTENT(IN) :: MESH_COMPONENT !<The mesh component to check for the specified field variable component
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_COMPONENT_MESH_COMPONENT_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%MESH_COMPONENT_NUMBER/=MESH_COMPONENT) THEN
                LOCAL_ERROR="Invalid mesh component number. The mesh component number for component number "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " which is does correspond to the specified mesh component number of "// &
                  & TRIM(NUMBER_TO_VSTRING(MESH_COMPONENT,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The field variable type must be > 1 and <= "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_COMPONENT_MESH_COMPONENT_CHECK")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_MESH_COMPONENT_CHECK",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_MESH_COMPONENT_CHECK")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_CHECK
  
  !
  !================================================================================================================================
  !

  !>Gets the mesh component number for a field variable component. \see CMISSFieldComponentMeshComponentGet
  SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_GET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,MESH_COMPONENT,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the mesh component for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the field variable component for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to get the field variable component for
    INTEGER(INTG), INTENT(OUT) :: MESH_COMPONENT !<On return, the mesh component to get for the specified field variable component
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_COMPONENT_MESH_COMPONENT_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              MESH_COMPONENT=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%MESH_COMPONENT_NUMBER
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The field variable type must be > 1 and <= "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_COMPONENT_MESH_COMPONENT_GET")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_MESH_COMPONENT_GET",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_MESH_COMPONENT_GET")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_GET
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component. \see OPENCMISS::CMISSFieldComponentMeshComponentSet
  SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,MESH_COMPONENT_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the mesh component for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to set the mesh component for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to set the mesh component for
    INTEGER(INTG), INTENT(IN) :: MESH_COMPONENT_NUMBER !<The mesh component to set for the specified field variable component
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH   
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_COMPONENT_MESH_COMPONENT_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        DECOMPOSITION=>FIELD%DECOMPOSITION
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          MESH=>DECOMPOSITION%MESH
          IF(ASSOCIATED(MESH)) THEN
            IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
              IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
                IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)) THEN
                    IF(FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(COMPONENT_NUMBER,VARIABLE_TYPE)) THEN
                      LOCAL_ERROR="The mesh component has been locked for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ELSE
                      SELECT CASE(FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE))
! Should set anyway in case user changes interpolation(?) Needed by finite elasticity / material field - Sander  
!                      CASE(FIELD_CONSTANT_INTERPOLATION)
!                        LOCAL_ERROR="Can not set a mesh component for field component number "// &
!                          & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
!                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
!                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
!                          & " which has constant interpolation."
!                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      CASE(FIELD_ELEMENT_BASED_INTERPOLATION,FIELD_NODE_BASED_INTERPOLATION,FIELD_GRID_POINT_BASED_INTERPOLATION, &
                        & FIELD_GAUSS_POINT_BASED_INTERPOLATION, FIELD_CONSTANT_INTERPOLATION,FIELD_DATA_POINT_BASED_INTERPOLATION)
                        IF(MESH_COMPONENT_NUMBER>0.AND.MESH_COMPONENT_NUMBER<=MESH%NUMBER_OF_COMPONENTS) THEN
                          FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(COMPONENT_NUMBER,VARIABLE_TYPE)=MESH_COMPONENT_NUMBER
                        ELSE
                          LOCAL_ERROR="Mesh component number "//TRIM(NUMBER_TO_VSTRING(MESH_COMPONENT_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid. The component number must be between 1 and "// &
                            & TRIM(NUMBER_TO_VSTRING(MESH%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                            & " for mesh number "//TRIM(NUMBER_TO_VSTRING(MESH%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      CASE DEFAULT
                        LOCAL_ERROR="The interpolation type "//TRIM(NUMBER_TO_VSTRING(FIELD%CREATE_VALUES_CACHE% &
                          & INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE),"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      END SELECT
                    ENDIF
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE),"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field variable type must be > 1 and <= "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF              
            ELSE
              CALL FLAG_ERROR("Field create values cache is not associated.",ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The decomposition mesh is not associated for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The decomposition is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_COMPONENT_MESH_COMPONENT_SET")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_MESH_COMPONENT_SET",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_MESH_COMPONENT_SET")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component and locks it so that no further changes can be made.
  SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,MESH_COMPONENT_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the mesh component for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to set the mesh component for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to set the mesh component for
    INTEGER(INTG), INTENT(IN) :: MESH_COMPONENT_NUMBER !<The mesh component to set for the specified field variable component
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_COMPONENT_MESH_COMPONENT_SET(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,MESH_COMPONENT_NUMBER,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(COMPONENT_NUMBER,VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_MESH_COMPONENT_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a constant integer value. \see OPENCMISS::CMISSFieldComponentValuesInitialise
  SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the values for 
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to intialise \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to initialise \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to initialise
    INTEGER(INTG), INTENT(IN) :: VALUE !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: element_idx,derivative_idx,version_idx,field_dof,node_idx,partial_deriv_idx,gauss_point_idx,MAX_NGP
    INTEGER(INTG), POINTER :: FIELD_PARAMETERS(:)
    TYPE(DOMAIN_TYPE), POINTER :: COMPONENT_DOMAIN
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: FIELD_PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR
   
    CALL ENTERS("FIELD_COMPONENT_VALUES_INITIALISE_INTG",ERR,ERROR,*999)

    NULLIFY(FIELD_PARAMETERS)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        !Check the variable type
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            !Check the data type
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              !Check the component number
              IF(COMPONENT_NUMBER>0.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                !Check the from set type input
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  FIELD_PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(FIELD_PARAMETER_SET)) THEN
                    !Get the parameters values
                    CALL DISTRIBUTED_VECTOR_DATA_GET(FIELD_PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,ERR,ERROR,*999)
                    !Set the field components to give a constant value. Note that as the value is constant we can set the ghost dofs
                    !and not worry about updating the field parameter set.
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                      FIELD_PARAMETERS(field_dof)=VALUE
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                            DO element_idx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                              field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(element_idx)
                              FIELD_PARAMETERS(field_dof)=VALUE
                            ENDDO !element_idx
                          ELSE
                            CALL FLAG_ERROR("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                            DO node_idx=1,DOMAIN_NODES%TOTAL_NUMBER_OF_NODES
                              DO derivative_idx=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                                DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                                  field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                                  partial_deriv_idx= &
                                    & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%PARTIAL_DERIVATIVE_INDEX
                                  SELECT CASE(partial_deriv_idx)
                                  CASE(NO_PART_DERIV)
                                    FIELD_PARAMETERS(field_dof)=VALUE
                                  CASE(PART_DERIV_S1)
                                    FIELD_PARAMETERS(field_dof)=1_INTG
                                  CASE(PART_DERIV_S1_S1)
                                    FIELD_PARAMETERS(field_dof)=0_INTG
                                  CASE(PART_DERIV_S2)
                                    FIELD_PARAMETERS(field_dof)=1_INTG
                                  CASE(PART_DERIV_S2_S2)
                                    FIELD_PARAMETERS(field_dof)=0_INTG
                                  CASE(PART_DERIV_S1_S2)
                                    FIELD_PARAMETERS(field_dof)=0_INTG
                                  CASE(PART_DERIV_S3)
                                    FIELD_PARAMETERS(field_dof)=1_INTG
                                  CASE(PART_DERIV_S3_S3)
                                    FIELD_PARAMETERS(field_dof)=0_INTG
                                  CASE(PART_DERIV_S1_S3)
                                    FIELD_PARAMETERS(field_dof)=0_INTG
                                  CASE(PART_DERIV_S2_S3)
                                    FIELD_PARAMETERS(field_dof)=0_INTG
                                  CASE(PART_DERIV_S1_S2_S3)
                                    FIELD_PARAMETERS(field_dof)=0_INTG
                                  CASE DEFAULT
                                    LOCAL_ERROR="The partial derivative index of "// &
                                      & TRIM(NUMBER_TO_VSTRING(partial_deriv_idx,"*",ERR,ERROR))//" for node number "// &
                                      & TRIM(NUMBER_TO_VSTRING(node_idx,"*",ERR,ERROR))//" and derivative number "// &
                                      & TRIM(NUMBER_TO_VSTRING(derivative_idx,"*",ERR,ERROR))//" is invalid."
                                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                  END SELECT
                                ENDDO !version_idx
                              ENDDO !derivative_idx
                            ENDDO !node_idx
                          ELSE
                            CALL FLAG_ERROR("Domain topology nodes is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN 
                            !GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gauss_point_idx,element_idx)=variable_local_ny
                            MAX_NGP=SIZE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)
                            DO element_idx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                              DO gauss_point_idx=1,MAX_NGP ! could be just element's gauss_point_idx
                                field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gauss_point_idx,element_idx)
                                FIELD_PARAMETERS(field_dof)=VALUE
                              ENDDO !gauss_point_idx
                            ENDDO !element_idx
                          ELSE
                            CALL FLAG_ERROR("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                    !Restore the  parameter set 
                    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(FIELD_PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not be created on variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// & 
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable component number of "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" is invalid for a variable type of "//&
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" on field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                  & ". The number of components must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not match the integer data type of the specified value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is not defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The field variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE

        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_COMPONENT_VALUES_INITIALISE_INTG")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_VALUES_INITIALISE_INTG",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_VALUES_INITIALISE_INTG")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_INTG

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a single precision constant value. \see OPENCMISS::CMISSFieldComponentValuesInitialise
  SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the values for 
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to intiialise \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to initialise \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to initialise
    REAL(SP), INTENT(IN) :: VALUE !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: element_idx,derivative_idx,version_idx,field_dof,node_idx,partial_deriv_idx,gauss_point_idx,MAX_NGP
    REAL(SP), POINTER :: FIELD_PARAMETERS(:)
    TYPE(DOMAIN_TYPE), POINTER :: COMPONENT_DOMAIN
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: FIELD_PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR
   
    CALL ENTERS("FIELD_COMPONENT_VALUES_INITIALISE_SP",ERR,ERROR,*999)

    NULLIFY(FIELD_PARAMETERS)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        !Check the variable type
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            !Check the data type
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              !Check the component number
              IF(COMPONENT_NUMBER>0.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                !Check the from set type input
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  FIELD_PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(FIELD_PARAMETER_SET)) THEN
                    !Get the parameters values
                    CALL DISTRIBUTED_VECTOR_DATA_GET(FIELD_PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,ERR,ERROR,*999)
                    !Set the field components to give a constant value. Note that as the value is constant we can set the ghost dofs
                    !and not worry about updating the field parameter set.
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                      FIELD_PARAMETERS(field_dof)=VALUE
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                            DO element_idx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                              field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(element_idx)
                              FIELD_PARAMETERS(field_dof)=VALUE
                            ENDDO !element_idx
                          ELSE
                            CALL FLAG_ERROR("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                            DO node_idx=1,DOMAIN_NODES%TOTAL_NUMBER_OF_NODES
                              DO derivative_idx=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                                DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                                  field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                                  partial_deriv_idx= &
                                    & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%PARTIAL_DERIVATIVE_INDEX
                                  SELECT CASE(partial_deriv_idx)
                                  CASE(NO_PART_DERIV)
                                    FIELD_PARAMETERS(field_dof)=VALUE
                                  CASE(PART_DERIV_S1)
                                    FIELD_PARAMETERS(field_dof)=1.0_SP
                                  CASE(PART_DERIV_S1_S1)
                                    FIELD_PARAMETERS(field_dof)=0.0_SP
                                  CASE(PART_DERIV_S2)
                                    FIELD_PARAMETERS(field_dof)=1.0_SP
                                  CASE(PART_DERIV_S2_S2)
                                    FIELD_PARAMETERS(field_dof)=0.0_SP
                                  CASE(PART_DERIV_S1_S2)
                                    FIELD_PARAMETERS(field_dof)=0.0_SP
                                  CASE(PART_DERIV_S3)
                                    FIELD_PARAMETERS(field_dof)=1.0_SP
                                  CASE(PART_DERIV_S3_S3)
                                    FIELD_PARAMETERS(field_dof)=0.0_SP
                                  CASE(PART_DERIV_S1_S3)
                                    FIELD_PARAMETERS(field_dof)=0.0_SP
                                  CASE(PART_DERIV_S2_S3)
                                    FIELD_PARAMETERS(field_dof)=0.0_SP
                                  CASE(PART_DERIV_S1_S2_S3)
                                    FIELD_PARAMETERS(field_dof)=0.0_SP
                                  CASE DEFAULT
                                    LOCAL_ERROR="The partial derivative index of "// &
                                      & TRIM(NUMBER_TO_VSTRING(partial_deriv_idx,"*",ERR,ERROR))//" for node number "// &
                                      & TRIM(NUMBER_TO_VSTRING(node_idx,"*",ERR,ERROR))//" and derivative number "// &
                                      & TRIM(NUMBER_TO_VSTRING(derivative_idx,"*",ERR,ERROR))//" is invalid."
                                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                  END SELECT
                                ENDDO !version_idx
                              ENDDO !derivative_idx
                            ENDDO !node_idx
                          ELSE
                            CALL FLAG_ERROR("Domain topology nodes is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN 
                            !GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gauss_point_idx,element_idx)=variable_local_ny
                            MAX_NGP=SIZE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)
                            DO element_idx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                              DO gauss_point_idx=1,MAX_NGP ! could be just element's gauss_point_idx
                                field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gauss_point_idx,element_idx)
                                FIELD_PARAMETERS(field_dof)=VALUE
                              ENDDO !gauss_point_idx
                            ENDDO !element_idx
                          ELSE
                            CALL FLAG_ERROR("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                    !Restore the  parameter set 
                    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(FIELD_PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not be created on variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// & 
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable component number of "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" is invalid for a variable type of "//&
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" on field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                  & ". The number of components must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not match the single precision data type of the specified value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is not defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The field variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_COMPONENT_VALUES_INITIALISE_SP")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_VALUES_INITIALISE_SP",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_VALUES_INITIALISE_SP")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_SP

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a double precision constant value. \see OPENCMISS::CMISSFieldComponentValuesInitialise
  SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the values for 
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to intiialise \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to initialise \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to initialise
    REAL(DP), INTENT(IN) :: VALUE !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: elementIdx,derivative_idx,version_idx,field_dof,node_idx,partial_deriv_idx,gauss_point_idx,MAX_NGP, &
      & dataPointIdx,localDataPointNumber
    REAL(DP), POINTER :: FIELD_PARAMETERS(:)
    TYPE(DOMAIN_TYPE), POINTER :: COMPONENT_DOMAIN
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DecompositionDataPointsType), POINTER :: decompositionData
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: FIELD_PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR
   
    CALL ENTERS("FIELD_COMPONENT_VALUES_INITIALISE_DP",ERR,ERROR,*999)

    NULLIFY(FIELD_PARAMETERS)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        !Check the variable type
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            !Check the data type
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              !Check the component number
              IF(COMPONENT_NUMBER>0.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                !Check the from set type input
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  FIELD_PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(FIELD_PARAMETER_SET)) THEN
                    !Get the parameters values
                    CALL DISTRIBUTED_VECTOR_DATA_GET(FIELD_PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,ERR,ERROR,*999)
                    !Set the field components to give a constant value. Note that as the value is constant we can set the ghost dofs
                    !and not worry about updating the field parameter set.
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                      FIELD_PARAMETERS(field_dof)=VALUE
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                            DO elementIdx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                              field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(elementIdx)
                              FIELD_PARAMETERS(field_dof)=VALUE
                            ENDDO !elementIdx
                          ELSE
                            CALL FLAG_ERROR("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                            DO node_idx=1,DOMAIN_NODES%TOTAL_NUMBER_OF_NODES
                              DO derivative_idx=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                                DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                                  field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                                  partial_deriv_idx= &
                                    & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%PARTIAL_DERIVATIVE_INDEX
                                  SELECT CASE(partial_deriv_idx)
                                  CASE(NO_PART_DERIV)
                                    FIELD_PARAMETERS(field_dof)=VALUE
                                  CASE(PART_DERIV_S1)
                                    FIELD_PARAMETERS(field_dof)=1.0_DP
                                  CASE(PART_DERIV_S1_S1)
                                    FIELD_PARAMETERS(field_dof)=0.0_DP
                                  CASE(PART_DERIV_S2)
                                    FIELD_PARAMETERS(field_dof)=1.0_DP
                                  CASE(PART_DERIV_S2_S2)
                                    FIELD_PARAMETERS(field_dof)=0.0_DP
                                  CASE(PART_DERIV_S1_S2)
                                    FIELD_PARAMETERS(field_dof)=0.0_DP
                                  CASE(PART_DERIV_S3)
                                    FIELD_PARAMETERS(field_dof)=1.0_DP
                                  CASE(PART_DERIV_S3_S3)
                                    FIELD_PARAMETERS(field_dof)=0.0_DP
                                  CASE(PART_DERIV_S1_S3)
                                    FIELD_PARAMETERS(field_dof)=0.0_DP
                                  CASE(PART_DERIV_S2_S3)
                                    FIELD_PARAMETERS(field_dof)=0.0_DP
                                  CASE(PART_DERIV_S1_S2_S3)
                                    FIELD_PARAMETERS(field_dof)=0.0_DP
                                  CASE DEFAULT
                                    LOCAL_ERROR="The partial derivative index of "// &
                                      & TRIM(NUMBER_TO_VSTRING(partial_deriv_idx,"*",ERR,ERROR))//" for node number "// &
                                      & TRIM(NUMBER_TO_VSTRING(node_idx,"*",ERR,ERROR))//" and derivative number "// &
                                      & TRIM(NUMBER_TO_VSTRING(derivative_idx,"*",ERR,ERROR))//" is invalid."
                                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                  END SELECT
                                ENDDO !version_idx
                              ENDDO !derivative_idx
                            ENDDO !node_idx
                          ELSE
                            CALL FLAG_ERROR("Domain topology nodes is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN 
                            !GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gauss_point_idx,elementIdx)=variable_local_ny
                            MAX_NGP=SIZE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)
                            DO elementIdx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                              DO gauss_point_idx=1,MAX_NGP ! could be just element's gauss_point_idx
                                field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gauss_point_idx,elementIdx)
                                FIELD_PARAMETERS(field_dof)=VALUE
                              ENDDO !gauss_point_idx
                            ENDDO !elementIdx
                          ELSE
                            CALL FLAG_ERROR("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                            decompositionData=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN%DECOMPOSITION%TOPOLOGY%dataPoints
                            IF(ASSOCIATED(decompositionData)) THEN
                              DO elementIdx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                DO dataPointIdx=1,decompositionData%elementDataPoint(elementIdx)%numberOfProjectedData
                                  localDataPointNumber=decompositionData%elementDataPoint(elementIdx)%dataIndices(dataPointIdx)% &
                                    & localNumber
                                  field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(localDataPointNumber)
                                  FIELD_PARAMETERS(field_dof)=VALUE
                                ENDDO !dataPointIdx                             
                              ENDDO !elementIdx
                            ELSE
                              CALL FLAG_ERROR("Decomposition data point topology is not associated.",ERR,ERROR,*999)
                            ENDIF
                            
                          ELSE
                            CALL FLAG_ERROR("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                    !Restore the  parameter set 
                    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(FIELD_PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not be created on variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// & 
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable component number of "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" is invalid for a variable type of "//&
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" on field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                  & ". The number of components must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not match the double precision data type of the specified value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is not defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The field variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_COMPONENT_VALUES_INITIALISE_DP")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_VALUES_INITIALISE_DP",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_VALUES_INITIALISE_DP")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_DP

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a logical constant value. \see OPENCMISS::CMISSFieldComponentValuesInitialise
  SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the values for 
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to intiialise \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to initialise \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number to initialise
    LOGICAL, INTENT(IN) :: VALUE !<The constant value to initialise the parameter set for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: element_idx,derivative_idx,version_idx,field_dof,node_idx,partial_deriv_idx
    LOGICAL, POINTER :: FIELD_PARAMETERS(:)
    TYPE(DOMAIN_TYPE), POINTER :: COMPONENT_DOMAIN
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: FIELD_PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR
   
    CALL ENTERS("FIELD_COMPONENT_VALUES_INITIALISE_L",ERR,ERROR,*999)

    NULLIFY(FIELD_PARAMETERS)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        !Check the variable type
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            !Check the data type
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              !Check the component number
              IF(COMPONENT_NUMBER>0.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                !Check the from set type input
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  FIELD_PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(FIELD_PARAMETER_SET)) THEN
                    !Get the parameters values
                    CALL DISTRIBUTED_VECTOR_DATA_GET(FIELD_PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,ERR,ERROR,*999)
                    !Set the field components to give a constant value. Note that as the value is constant we can set the ghost dofs
                    !and not worry about updating the field parameter set.
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                      FIELD_PARAMETERS(field_dof)=VALUE
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_ELEMENTS=>DOMAIN_TOPOLOGY%ELEMENTS
                          IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                            DO element_idx=1,DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                              field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(element_idx)
                              FIELD_PARAMETERS(field_dof)=VALUE
                            ENDDO !element_idx
                          ELSE
                            CALL FLAG_ERROR("Domain topology elements is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      COMPONENT_DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(COMPONENT_DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>COMPONENT_DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                            DO node_idx=1,DOMAIN_NODES%TOTAL_NUMBER_OF_NODES
                              DO derivative_idx=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                                DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                                  field_dof=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                                  partial_deriv_idx= &
                                    & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%PARTIAL_DERIVATIVE_INDEX
                                  SELECT CASE(partial_deriv_idx)
                                  CASE(NO_PART_DERIV)
                                    FIELD_PARAMETERS(field_dof)=VALUE
                                  CASE(PART_DERIV_S1)
                                    FIELD_PARAMETERS(field_dof)=.TRUE.
                                  CASE(PART_DERIV_S1_S1)
                                    FIELD_PARAMETERS(field_dof)=.FALSE.
                                  CASE(PART_DERIV_S2)
                                    FIELD_PARAMETERS(field_dof)=.TRUE.
                                  CASE(PART_DERIV_S2_S2)
                                    FIELD_PARAMETERS(field_dof)=.FALSE.
                                  CASE(PART_DERIV_S1_S2)
                                    FIELD_PARAMETERS(field_dof)=.FALSE.
                                  CASE(PART_DERIV_S3)
                                    FIELD_PARAMETERS(field_dof)=.TRUE.
                                  CASE(PART_DERIV_S3_S3)
                                    FIELD_PARAMETERS(field_dof)=.FALSE.
                                  CASE(PART_DERIV_S1_S3)
                                    FIELD_PARAMETERS(field_dof)=.FALSE.
                                  CASE(PART_DERIV_S2_S3)
                                    FIELD_PARAMETERS(field_dof)=.FALSE.
                                  CASE(PART_DERIV_S1_S2_S3)
                                    FIELD_PARAMETERS(field_dof)=.FALSE.
                                  CASE DEFAULT
                                    LOCAL_ERROR="The partial derivative index of "// &
                                      & TRIM(NUMBER_TO_VSTRING(partial_deriv_idx,"*",ERR,ERROR))//" for node number "// &
                                      & TRIM(NUMBER_TO_VSTRING(node_idx,"*",ERR,ERROR))//" and derivative number "// &
                                      & TRIM(NUMBER_TO_VSTRING(derivative_idx,"*",ERR,ERROR))//" is invalid."
                                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                  END SELECT
                                ENDDO !version_idx
                              ENDDO !derivative_idx
                            ENDDO !node_idx
                          ELSE
                            CALL FLAG_ERROR("Domain topology nodes is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                    !Restore the  parameter set 
                    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(FIELD_PARAMETER_SET%PARAMETERS,FIELD_PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not be created on variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// & 
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable component number of "// &
                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" is invalid for a variable type of "//&
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" on field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                  & ". The number of components must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not match the logical data type of the specified value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is not defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The field variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_COMPONENT_VALUES_INITIALISE_L")
    RETURN
999 CALL ERRORS("FIELD_COMPONENT_VALUES_INITIALISE_L",ERR,ERROR)
    CALL EXITS("FIELD_COMPONENT_VALUES_INITIALISE_L")
    RETURN 1
  END SUBROUTINE FIELD_COMPONENT_VALUES_INITIALISE_L

  !
  !================================================================================================================================
  !

  !>Returns the coordinate system for a field accounting for regions and interfaces
  SUBROUTINE FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the coordinate system for
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM !<On return, the fields coordinate system. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_COORDINATE_SYSTEM_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
        CALL FLAG_ERROR("Coordinate system is already associated.",ERR,ERROR,*999)
      ELSE
        NULLIFY(COORDINATE_SYSTEM)
        NULLIFY(INTERFACE)
        REGION=>FIELD%REGION
        IF(ASSOCIATED(REGION)) THEN
          COORDINATE_SYSTEM=>REGION%COORDINATE_SYSTEM
          IF(.NOT.ASSOCIATED(COORDINATE_SYSTEM)) THEN
            LOCAL_ERROR="The coordinate system is not associated for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" of region number "// &
              & TRIM(NUMBER_TO_VSTRING(REGION%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          INTERFACE=>FIELD%INTERFACE
          IF(ASSOCIATED(INTERFACE)) THEN
            COORDINATE_SYSTEM=>INTERFACE%COORDINATE_SYSTEM
            IF(.NOT.ASSOCIATED(COORDINATE_SYSTEM)) THEN
              LOCAL_ERROR="The coordinate system is not associated for field number "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" of interface number "// &
                & TRIM(NUMBER_TO_VSTRING(INTERFACE%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF         
          ELSE
            LOCAL_ERROR="The region or interface is not associated for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_COORDINATE_SYSTEM_GET")
    RETURN
999 CALL ERRORS("FIELD_COORDINATE_SYSTEM_GET",ERR,ERROR)
    CALL EXITS("FIELD_COORDINATE_SYSTEM_GET")
    RETURN 1
  END SUBROUTINE FIELD_COORDINATE_SYSTEM_GET

  !
  !================================================================================================================================
  !

  !>Checks the data type for a field variable.
  SUBROUTINE FIELD_DATA_TYPE_CHECK(FIELD,VARIABLE_TYPE,DATA_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the data type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DATA_TYPE !<The data type of the field variable to check \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_DATA_TYPE_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            SELECT CASE(DATA_TYPE)              
            CASE(FIELD_INTG_TYPE)
              IF(FIELD_VARIABLE%DATA_TYPE/=FIELD_INTG_TYPE) THEN
                LOCAL_ERROR="Invalid data type. The data type for variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " which is not an integer data type."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_SP_TYPE)
              IF(FIELD_VARIABLE%DATA_TYPE/=FIELD_SP_TYPE) THEN
                LOCAL_ERROR="Invalid data type. The data type for variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " which is not a single precision data type."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)




              ENDIF
            CASE(FIELD_DP_TYPE)
              IF(FIELD_VARIABLE%DATA_TYPE/=FIELD_DP_TYPE) THEN
                LOCAL_ERROR="Invalid data type. The data type for variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " which is not a double precision data type."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
             CASE(FIELD_L_TYPE)
               IF(FIELD_VARIABLE%DATA_TYPE/=FIELD_L_TYPE) THEN
                 LOCAL_ERROR="Invalid data type. The data type for variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " which is not a logical data type."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE DEFAULT
              LOCAL_ERROR="The specified data type of "//TRIM(NUMBER_TO_VSTRING(DATA_TYPE,"*",ERR,ERROR))// &
                & " is invalid."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_DATA_TYPE_CHECK")
    RETURN
999 CALL ERRORS("FIELD_DATA_TYPE_CHECK",ERR,ERROR)
    CALL EXITS("FIELD_DATA_TYPE_CHECK")
    RETURN 1
  END SUBROUTINE FIELD_DATA_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the data type for a field variable. \see OPENCMISS::CMISSFieldDataTypeGet
  SUBROUTINE FIELD_DATA_TYPE_GET(FIELD,VARIABLE_TYPE,DATA_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the data type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: DATA_TYPE !<On return, the data type of the field variable \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_DATA_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            DATA_TYPE=FIELD_VARIABLE%DATA_TYPE
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_DATA_TYPE_GET")
    RETURN
999 CALL ERRORS("FIELD_DATA_TYPE_GET",ERR,ERROR)
    CALL EXITS("FIELD_DATA_TYPE_GET")
    RETURN 1
  END SUBROUTINE FIELD_DATA_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable. \see OPENCMISS::CMISSFieldDataTypeSet
  SUBROUTINE FIELD_DATA_TYPE_SET(FIELD,VARIABLE_TYPE,DATA_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the interpolation for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type of the field variable component to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DATA_TYPE !<The data type to set \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_DATA_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN          
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN            
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
              IF(FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED(VARIABLE_TYPE)) THEN
                LOCAL_ERROR="The data type has been locked for variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ELSE
                SELECT CASE(DATA_TYPE)                
                CASE(FIELD_INTG_TYPE)
                  FIELD%CREATE_VALUES_CACHE%DATA_TYPES(VARIABLE_TYPE)=FIELD_INTG_TYPE
                CASE(FIELD_SP_TYPE)
                  FIELD%CREATE_VALUES_CACHE%DATA_TYPES(VARIABLE_TYPE)=FIELD_SP_TYPE
                CASE(FIELD_DP_TYPE)
                  FIELD%CREATE_VALUES_CACHE%DATA_TYPES(VARIABLE_TYPE)=FIELD_DP_TYPE
                CASE(FIELD_L_TYPE)
                  FIELD%CREATE_VALUES_CACHE%DATA_TYPES(VARIABLE_TYPE)=FIELD_L_TYPE
                CASE DEFAULT
                  LOCAL_ERROR="The specified data type of "//TRIM(NUMBER_TO_VSTRING(DATA_TYPE,"*",ERR,ERROR))// &
                    & " is invalid."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Field create values cache is not associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_DATA_TYPE_SET")
    RETURN
999 CALL ERRORS("FIELD_DATA_TYPE_SET",ERR,ERROR)
    CALL EXITS("FIELD_DATA_TYPE_SET")
    RETURN 1
  END SUBROUTINE FIELD_DATA_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable and locks it so that no further changes can be made.
  SUBROUTINE FIELD_DATA_TYPE_SET_AND_LOCK(FIELD,VARIABLE_TYPE,DATA_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the interpolation for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type of the field variable component to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DATA_TYPE !<The data type to set \see FIELD_ROUTINES_DataTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_DATA_TYPE_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_DATA_TYPE_SET(FIELD,VARIABLE_TYPE,DATA_TYPE,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED(VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
 
    CALL EXITS("FIELD_DATA_TYPE_SET_AND_LOCK")
    RETURN
999 CALL ERRORS("FIELD_DATA_TYPE_SET_AND_LOCK",ERR,ERROR)
    CALL EXITS("FIELD_DATA_TYPE_SET_AND_LOCK")
    RETURN 1
  END SUBROUTINE FIELD_DATA_TYPE_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Checks the DOF order type for a field variable.
  SUBROUTINE FIELD_DOF_ORDER_TYPE_CHECK(FIELD,VARIABLE_TYPE,DOF_ORDER_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the DOF order type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_ORDER_TYPE !<The DOF order type of the field variable to check \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_DOF_ORDER_TYPE_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            SELECT CASE(DOF_ORDER_TYPE)              
            CASE(FIELD_SEPARATED_COMPONENT_DOF_ORDER)
              IF(FIELD_VARIABLE%DOF_ORDER_TYPE/=FIELD_SEPARATED_COMPONENT_DOF_ORDER) THEN
                LOCAL_ERROR="Invalid DOF order type. The DOF order type for variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " which is not a separated component DOF order type."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER)
              IF(FIELD_VARIABLE%DATA_TYPE/=FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER) THEN
                LOCAL_ERROR="Invalid DOF order type. The DOF order type for variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " which is not a contiguous component DOF order type."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE DEFAULT
              LOCAL_ERROR="The specified DOF order type of "//TRIM(NUMBER_TO_VSTRING(DOF_ORDER_TYPE,"*",ERR,ERROR))// &
                & " is invalid."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_DOF_ORDER_TYPE_CHECK")
    RETURN
999 CALL ERRORS("FIELD_DOF_ORDER_TYPE_CHECK",ERR,ERROR)
    CALL EXITS("FIELD_DOF_ORDER_TYPE_CHECK")
    RETURN 1
  END SUBROUTINE FIELD_DOF_ORDER_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the DOF order type for a field variable. \see OPENCMISS::CMISSFieldDOFOrderTypeGet
  SUBROUTINE FIELD_DOF_ORDER_TYPE_GET(FIELD,VARIABLE_TYPE,DOF_ORDER_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the DOF order type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: DOF_ORDER_TYPE !<On return, the DOF order type of the field variable \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_DOF_ORDER_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            DOF_ORDER_TYPE=FIELD_VARIABLE%DOF_ORDER_TYPE
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)



        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_DOF_ORDER_TYPE_GET")
    RETURN
999 CALL ERRORS("FIELD_DOF_ORDER_TYPE_GET",ERR,ERROR)
    CALL EXITS("FIELD_DOF_ORDER_TYPE_GET")
    RETURN 1
  END SUBROUTINE FIELD_DOF_ORDER_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF order type for a field variable. Note: for contiguous component DOF ordering all the components of the field variable must have the same interpolation type.
  SUBROUTINE FIELD_DOF_ORDER_TYPE_SET(FIELD,VARIABLE_TYPE,DOF_ORDER_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the DOF order type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_ORDER_TYPE !<The DOF order type to set \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx
    LOGICAL :: SAME_INTERPOLATION,SAME_MESH_COMPONENT
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_DOF_ORDER_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN          
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN            
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
              IF(FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED(VARIABLE_TYPE)) THEN
                LOCAL_ERROR="The DOF order type has been locked for variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ELSE
                SELECT CASE(DOF_ORDER_TYPE)                
                CASE(FIELD_SEPARATED_COMPONENT_DOF_ORDER)
                  FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES(VARIABLE_TYPE)=FIELD_SEPARATED_COMPONENT_DOF_ORDER
                CASE(FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER)
                  SAME_INTERPOLATION=.TRUE.
                  SAME_MESH_COMPONENT=.TRUE.
                  DO component_idx=2,FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)
                    IF(FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(component_idx,VARIABLE_TYPE)/= &
                      & FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(1,VARIABLE_TYPE)) THEN
                      SAME_INTERPOLATION=.FALSE.
                      EXIT
                    ENDIF
                    IF(FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(component_idx,VARIABLE_TYPE)/= &
                      & FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(1,VARIABLE_TYPE)) THEN
                      SAME_MESH_COMPONENT=.FALSE.
                      EXIT
                    ENDIF
                  ENDDO !component_idx
                  IF(SAME_INTERPOLATION.AND.SAME_MESH_COMPONENT) THEN
                    FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES(VARIABLE_TYPE)=FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER
                  ELSE
                    CALL FLAG_ERROR("Invalid field variable component set. For continguous component DOF "// &
                      & "ordering the field variable components must have the same interpolation type and mesh components.", &
                      & ERR,ERROR,*999)
                  ENDIF
                CASE DEFAULT
                  LOCAL_ERROR="The specified DOF order type of "//TRIM(NUMBER_TO_VSTRING(DOF_ORDER_TYPE,"*",ERR,ERROR))// &
                    & " is invalid."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Field create values cache is not associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_DOF_ORDER_TYPE_SET")
    RETURN
999 CALL ERRORS("FIELD_DOF_ORDER_TYPE_SET",ERR,ERROR)
    CALL EXITS("FIELD_DOF_ORDER_TYPE_SET")
    RETURN 1
  END SUBROUTINE FIELD_DOF_ORDER_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF order type for a field variable and locks it so that no further changes can be made.
  SUBROUTINE FIELD_DOF_ORDER_TYPE_SET_AND_LOCK(FIELD,VARIABLE_TYPE,DOF_ORDER_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the DOF order for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to set \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_ORDER_TYPE !<The DOF order type to set \see FIELD_ROUTINES_DOFOrderTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_DOF_ORDER_TYPE_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_DOF_ORDER_TYPE_SET(FIELD,VARIABLE_TYPE,DOF_ORDER_TYPE,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED(VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
 
    CALL EXITS("FIELD_DOF_ORDER_TYPE_SET_AND_LOCK")
    RETURN
999 CALL ERRORS("FIELD_DOF_ORDER_TYPE_SET_AND_LOCK",ERR,ERROR)
    CALL EXITS("FIELD_DOF_ORDER_TYPE_SET_AND_LOCK")
    RETURN 1
  END SUBROUTINE FIELD_DOF_ORDER_TYPE_SET_AND_LOCK

  !

  !================================================================================================================================
  !

  !>Finalises a field variable component and deallocates all memory.
  SUBROUTINE FIELD_VARIABLE_COMPONENT_FINALISE(FIELD_VARIABLE_COMPONENT,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_VARIABLE_COMPONENT_TYPE) :: FIELD_VARIABLE_COMPONENT !<The field variable component to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELD_VARIABLE_COMPONENT_FINALISE",ERR,ERROR,*999)

    FIELD_VARIABLE_COMPONENT%COMPONENT_LABEL=""
    CALL FIELD_VARIABLE_COMPONENT_PARAM_TO_DOF_MAP_FINALISE(FIELD_VARIABLE_COMPONENT,ERR,ERROR,*999)

    CALL EXITS("FIELD_VARIABLE_COMPONENT_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_VARIABLE_COMPONENT_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_COMPONENT_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_COMPONENT_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises a field variable component.
  SUBROUTINE FIELD_VARIABLE_COMPONENT_INITIALISE(FIELD_VARIABLE,COMPONENT_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE !<A pointer to the field variable to initialise the component for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field component number of the field variable component
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: COMP_NUMBER,derivativeIdx,DUMMY_ERR,ne,VARIABLE_TYPE, NGP, MAXINTERP,globalElementNumber,nodeIdx,numParameters
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION    
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR

    CALL ENTERS("FIELD_VARIABLE_COMPONENT_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELD_VARIABLE)) THEN
      FIELD=>FIELD_VARIABLE%FIELD
      IF(ASSOCIATED(FIELD)) THEN
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          VARIABLE_TYPE=FIELD_VARIABLE%VARIABLE_TYPE
          IF(ALLOCATED(FIELD_VARIABLE%COMPONENTS)) THEN
            IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
              FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%COMPONENT_NUMBER=COMPONENT_NUMBER
              FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%FIELD_VARIABLE=>FIELD_VARIABLE
              DECOMPOSITION=>FIELD%DECOMPOSITION
              IF(ASSOCIATED(DECOMPOSITION)) THEN
                MESH=>DECOMPOSITION%MESH
                IF(ASSOCIATED(MESH)) THEN
                  COMP_NUMBER=FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(COMPONENT_NUMBER,VARIABLE_TYPE)
                  IF(COMP_NUMBER>0.AND.COMP_NUMBER<=MESH%NUMBER_OF_COMPONENTS) THEN
                    FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%MESH_COMPONENT_NUMBER=COMP_NUMBER
                    FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN=>DECOMPOSITION%DOMAIN(COMP_NUMBER)%PTR
                    DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                    IF(.NOT.ASSOCIATED(DOMAIN)) THEN
                      LOCAL_ERROR="Field component "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                        & " does not have a domain associated."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The mesh component number of "//TRIM(NUMBER_TO_VSTRING(COMP_NUMBER,"*",ERR,ERROR))// &
                      & " for field component "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. The component number must be between 1 and "// &
                      & TRIM(NUMBER_TO_VSTRING(MESH%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="Decomposition mesh is not associated for field number "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="Decomposition is not associated for field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)                  
              ENDIF
              FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%COMPONENT_LABEL=""
              FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%COMPONENT_LABEL= &
                & FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS(COMPONENT_NUMBER,VARIABLE_TYPE)
              FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE= &
                FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(COMPONENT_NUMBER,VARIABLE_TYPE)
              SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters=1
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=0
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters=1
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=0
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters=-1
                DO ne=1,DOMAIN%TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                  BASIS=>DOMAIN%TOPOLOGY%ELEMENTS%ELEMENTS(ne)%BASIS
                  IF(BASIS%NUMBER_OF_ELEMENT_PARAMETERS>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                    & maxNumberElementInterpolationParameters) FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                    & maxNumberElementInterpolationParameters=BASIS%NUMBER_OF_ELEMENT_PARAMETERS
                ENDDO !ne
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=-1
                DO nodeIdx=1,DOMAIN%TOPOLOGY%NODES%TOTAL_NUMBER_OF_NODES
                  numParameters=0
                  DO derivativeIdx=1,DOMAIN%TOPOLOGY%NODES%NODES(nodeIdx)%NUMBER_OF_DERIVATIVES
                    numParameters=numParameters+DOMAIN%TOPOLOGY%NODES%NODES(nodeIdx)%DERIVATIVES(derivativeIdx)%numberOfVersions
                  ENDDO !derivativeIdx
                  IF(numParameters>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters) &
                    & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=numParameters
                ENDDO !nodeIdx
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)             
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION) ! ?
                MAXINTERP = -1
                DO ne=1,DOMAIN%TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                  BASIS=>DOMAIN%TOPOLOGY%ELEMENTS%ELEMENTS(ne)%BASIS
                  NGP = BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%PTR%NUMBER_OF_GAUSS
                  IF(NGP > MAXINTERP) MAXINTERP = NGP
                ENDDO
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters = MAXINTERP
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters = 0
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                WRITE(*,*) "In datapointbasedinterpolation"
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters=-1
                WRITE(*,*) "DOMAIN%TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS", DOMAIN%TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                DO ne=1,DOMAIN%TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                  WRITE(*,*) "In forloop", ne
                  globalElementNumber=DECOMPOSITION%TOPOLOGY%ELEMENTS%ELEMENTS(ne)%GLOBAL_NUMBER
                  WRITE(*,*) "DECOMPOSITION%TOPOLOGY%ELEMENTS%ELEMENTS(ne)%GLOBAL_NUMBER", &
                      & DECOMPOSITION%TOPOLOGY%ELEMENTS%ELEMENTS(ne)%GLOBAL_NUMBER
                  WRITE(*,*) "Before if"
                  IF(ASSOCIATED(DECOMPOSITION%TOPOLOGY%dataPoints)) THEN
                    WRITE(*,*) "DECOMPOSITION%TOPOLOGY%dataPoints%numberOfElementDataPoints(globalElementNumber)"
                  ELSE
                    WRITE(*,*) "NOT ALLOCATED"
                  ENDIF
                  IF(DECOMPOSITION%TOPOLOGY%dataPoints%numberOfElementDataPoints(globalElementNumber)> &
                      & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters) THEN
                    FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberElementInterpolationParameters= &
                      &  DECOMPOSITION%TOPOLOGY%dataPoints%numberOfElementDataPoints(globalElementNumber)
                    WRITE(*,*) "In if loop"
                  ENDIF
                ENDDO
                FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%maxNumberNodeInterpolationParameters=0
                WRITE(*,*) "BEFORE PARAM TO DOF MAP"
              CASE DEFAULT
                LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                  & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is invalid."
              END SELECT
              CALL FIELD_VARIABLE_COMPONENT_PARAM_TO_DOF_MAP_INITIALISE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER), &
                & ERR,ERROR,*999)
            ELSE
              LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*998)
            ENDIF
          ELSE
            CALL FLAG_ERROR("Field variable components have not been allocated.",ERR,ERROR,*998)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Field create values cache is not associated.",ERR,ERROR,*998)
        ENDIF
      ELSE
        CALL FLAG_ERROR("Field variable field is not associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field variable is is not associated.",ERR,ERROR,*998)
    ENDIF

    CALL EXITS("FIELD_VARIABLE_COMPONENT_INITIALISE")
    RETURN
999 CALL FIELD_VARIABLE_COMPONENT_FINALISE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER),DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("FIELD_VARIABLE_COMPONENT_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_COMPONENT_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_COMPONENT_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises a field variable component parameter to dof map and deallocates all memory.
  SUBROUTINE FIELD_VARIABLE_COMPONENT_PARAM_TO_DOF_MAP_FINALISE(FIELD_VARIABLE_COMPONENT,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_VARIABLE_COMPONENT_TYPE) :: FIELD_VARIABLE_COMPONENT !<The field variable component to finialise the parameter to dof map for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELD_VARIABLE_COMPONENT_PARAM_TO_DOF_MAP_FINALISE",ERR,ERROR,*999)

    IF(ALLOCATED(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES))  &
      & DEALLOCATE(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES)
    IF(ALLOCATED(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS))  &
      & DEALLOCATE(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS)
    IF(ALLOCATED(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%GRID_POINT_PARAM2DOF_MAP%GRID_POINTS))  &
      & DEALLOCATE(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%GRID_POINT_PARAM2DOF_MAP%GRID_POINTS)
    IF(ALLOCATED(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS))  &
      & DEALLOCATE(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS)
    IF(ALLOCATED(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%DATA_POINTS))  &
      & DEALLOCATE(FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%DATA_POINTS)
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%GRID_POINT_PARAM2DOF_MAP%NUMBER_OF_GRID_POINT_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%NUMBER_OF_GAUSS_POINT_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS=0

    CALL EXITS("FIELD_VARIABLE_COMPONENT_PARAM_TO_DOF_MAP_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_VARIABLE_COMPONENT_PARAM_TO_DOF_MAP_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_COMPONENT_PARAM_TO_DOF_MAP_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_COMPONENT_PARAM_TO_DOF_MAP_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises a field variable component parameter to dof map.
  SUBROUTINE FIELD_VARIABLE_COMPONENT_PARAM_TO_DOF_MAP_INITIALISE(FIELD_VARIABLE_COMPONENT,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_VARIABLE_COMPONENT_TYPE) :: FIELD_VARIABLE_COMPONENT !<The field variable component to initialise the parameter to dof map for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELD_VARIABLE_COMPONENT_PARAM_TO_DOF_MAP_INITIALISE",ERR,ERROR,*999)

    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%GRID_POINT_PARAM2DOF_MAP%NUMBER_OF_GRID_POINT_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%NUMBER_OF_GAUSS_POINT_PARAMETERS=0
    FIELD_VARIABLE_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS=0

    CALL EXITS("FIELD_VARIABLE_COMPONENT_PARAM_TO_DOF_MAP_INITIALISE")
    RETURN
999 CALL ERRORS("FIELD_VARIABLE_COMPONENT_PARAM_TO_DOF_MAP_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_COMPONENT_PARAM_TO_DOF_MAP_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_COMPONENT_PARAM_TO_DOF_MAP_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises the field variable components for a field variable and deallocates all memory.
  SUBROUTINE FIELD_VARIABLE_COMPONENTS_FINALISE(FIELD_VARIABLE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_VARIABLE_TYPE) :: FIELD_VARIABLE !<The field variable to finalise the field variable components for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx

    CALL ENTERS("FIELD_VARIABLE_COMPONENTS_FINALISE",ERR,ERROR,*999)

    IF(ALLOCATED(FIELD_VARIABLE%COMPONENTS)) THEN
      DO component_idx=1,SIZE(FIELD_VARIABLE%COMPONENTS,1)
        CALL FIELD_VARIABLE_COMPONENT_FINALISE(FIELD_VARIABLE%COMPONENTS(component_idx),ERR,ERROR,*999)
      ENDDO !component_idx
      DEALLOCATE(FIELD_VARIABLE%COMPONENTS)
    ENDIF
    FIELD_VARIABLE%NUMBER_OF_COMPONENTS=0

    CALL EXITS("FIELD_VARIABLE_COMPONENTS_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_VARIABLE_COMPONENTS_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_COMPONENTS_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_COMPONENTS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the field components.
  SUBROUTINE FIELD_VARIABLE_COMPONENTS_INITIALISE(FIELD,VARIABLE_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the field variable components for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to initialise the field variable components for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_VARIABLE_COMPONENTS_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(ALLOCATED(FIELD_VARIABLE%COMPONENTS)) THEN
              CALL FLAG_ERROR("Field variable already has allocated components.",ERR,ERROR,*999)
            ELSE
              ALLOCATE(FIELD_VARIABLE%COMPONENTS(FIELD_VARIABLE%NUMBER_OF_COMPONENTS),STAT=ERR)
              IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable components.",ERR,ERROR,*999)
              DO component_idx=1,FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                CALL FIELD_VARIABLE_COMPONENT_INITIALISE(FIELD_VARIABLE,component_idx,ERR,ERROR,*999)
              ENDDO !component_idx
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FLAG_ERROR("Field create values cache is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_VARIABLE_COMPONENTS_INITIALISE")
    RETURN
999 CALL ERRORS("FIELD_VARIABLE_COMPONENTS_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_COMPONENTS_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_COMPONENTS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a field. \see OPENCMISS::CMISSFieldCreateFinish
  SUBROUTINE FIELD_CREATE_FINISH(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: componentIdx,parameterSetIdx,scalingIdx,variableIdx
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_CREATE_FINISH",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has already been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        !Check field has a decomposition associated
        IF(ASSOCIATED(FIELD%DECOMPOSITION)) THEN
          !Check for field validity
          CALL FieldVariablesCheck(field,err,error,*999)
          !Initialise the components
          CALL FIELD_VARIABLES_INITIALISE(FIELD,ERR,ERROR,*999)
          IF(ASSOCIATED(FIELD%GEOMETRIC_FIELD)) THEN
            CALL FIELD_CREATE_VALUES_CACHE_FINALISE(FIELD%CREATE_VALUES_CACHE,ERR,ERROR,*999)
            FIELD%FIELD_FINISHED=.TRUE.
            !Calculate dof mappings
            CALL FIELD_MAPPINGS_CALCULATE(FIELD,ERR,ERROR,*999)
            !Set up the geometric parameters
            CALL FIELD_GEOMETRIC_PARAMETERS_INITIALISE(FIELD,ERR,ERROR,*999)
            !Initialise the scalings
            CALL FIELD_SCALINGS_INITIALISE(FIELD,ERR,ERROR,*999)
            !Initialise the field parameter sets 
            CALL FIELD_PARAMETER_SETS_INITIALISE(FIELD,ERR,ERROR,*999)
          ELSE
            CALL FLAG_ERROR("Field does not have a geometric field associated.",ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Field does not have a mesh decomposition associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"",FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"Field number : ",FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Global number = ",FIELD%GLOBAL_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  User number = ",FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Label = ",FIELD%LABEL,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Dependent type = ",FIELD%DEPENDENT_TYPE,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Field type = ",FIELD%TYPE,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of variables = ",FIELD%NUMBER_OF_VARIABLES,ERR,ERROR,*999)
      IF(DIAGNOSTICS2) THEN
        DO variableIdx=1,FIELD%NUMBER_OF_VARIABLES
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Variable : ",variableIdx,ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Variable Type = ",variableIdx,ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Variable Label = ",FIELD%VARIABLES(variableIdx)%VARIABLE_LABEL, &
            & ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Dimension = ",FIELD%VARIABLES(variableIdx)%DIMENSION, &
            & ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Data type = ",FIELD%VARIABLES(variableIdx)%DATA_TYPE, &
            & ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      DOF order type = ",FIELD%VARIABLES(variableIdx)%DOF_ORDER_TYPE, &
            & ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Max num element interpolation parameters = ",FIELD% &
            & VARIABLES(variableIdx)%maxNumberElementInterpolationParameters,ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Max num node interpolation parameters = ",FIELD% &
            & VARIABLES(variableIdx)%maxNumberNodeInterpolationParameters,ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Number of DOFs = ",FIELD%VARIABLES(variableIdx)% &
            & NUMBER_OF_DOFS,ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Total number of DOFs = ",FIELD%VARIABLES(variableIdx)% &
            & TOTAL_NUMBER_OF_DOFS,ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Number of global DOFs = ",FIELD%VARIABLES(variableIdx)% &
            & NUMBER_OF_GLOBAL_DOFS,ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Number of components = ",FIELD%VARIABLES(variableIdx)% &
            & NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
          IF(DIAGNOSTICS3) THEN
            DO componentIdx=1,FIELD%VARIABLES(variableIdx)%NUMBER_OF_COMPONENTS
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"        Component : ",componentIdx,ERR,ERROR,*999)
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"          Component label = ",FIELD%VARIABLES(variableIdx)% &
                COMPONENTS(componentIdx)%COMPONENT_LABEL,ERR,ERROR,*999)
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"          Interpolation type = ",FIELD%VARIABLES(variableIdx)% &
                COMPONENTS(componentIdx)%INTERPOLATION_TYPE,ERR,ERROR,*999)
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"          Mesh component number = ",FIELD%VARIABLES(variableIdx)% &
                COMPONENTS(componentIdx)%MESH_COMPONENT_NUMBER,ERR,ERROR,*999)
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"          Scaling index = ",FIELD%VARIABLES(variableIdx)% &
                COMPONENTS(componentIdx)%SCALING_INDEX,ERR,ERROR,*999)
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"          Max num element interpolation parameters = ",FIELD% &
                & VARIABLES(variableIdx)%COMPONENTS(componentIdx)%maxNumberElementInterpolationParameters,ERR,ERROR,*999)
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"          Max num node interpolation parameters = ",FIELD% &
                & VARIABLES(variableIdx)%COMPONENTS(componentIdx)%maxNumberNodeInterpolationParameters,ERR,ERROR,*999)         
            ENDDO !componentIdx
          ENDIF
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameter sets = ",FIELD%VARIABLES(variableIdx)% &
            & PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS,ERR,ERROR,*999)
          IF(DIAGNOSTICS3) THEN
            DO parameterSetIdx=1,FIELD%VARIABLES(variableIdx)%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"        Parameter set index : ",parameterSetIdx,ERR,ERROR,*999)
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"          Set type : ",FIELD%VARIABLES(variableIdx)% &
                & PARAMETER_SETS%PARAMETER_SETS(parameterSetIdx)%PTR%SET_TYPE,ERR,ERROR,*999)
            ENDDO !parameterSetIdx
          ENDIF
        ENDDO !variableIdx
      ENDIF
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Scaling type = ",FIELD%SCALINGS%SCALING_TYPE,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of scaling indices = ",FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES, &
        & ERR,ERROR,*999)
      IF(DIAGNOSTICS2) THEN
        DO scalingIdx=1,FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Scaling index : ",scalingIdx,ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Mesh component number : ",FIELD%SCALINGS%SCALINGS(scalingIdx)% &
            & MESH_COMPONENT_NUMBER,ERR,ERROR,*999)
        ENDDO !scalingIdx
      ENDIF
    ENDIF

    CALL EXITS("FIELD_CREATE_FINISH")
    RETURN
999 CALL ERRORS("FIELD_CREATE_FINISH",ERR,ERROR)
    CALL EXITS("FIELD_CREATE_FINISH")
    RETURN 1
  END SUBROUTINE FIELD_CREATE_FINISH

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field.
  SUBROUTINE FIELD_CREATE_START_GENERIC(FIELDS,USER_NUMBER,FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELDS_TYPE), POINTER :: FIELDS !<A pointer to the fields
    INTEGER(INTG), INTENT(IN) :: USER_NUMBER !<The user number for the field to create
    TYPE(FIELD_TYPE), POINTER :: FIELD !<On return, a pointer to the field. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: field_no
    TYPE(FIELD_TYPE), POINTER :: NEW_FIELD
    TYPE(FIELD_PTR_TYPE), POINTER :: NEW_FIELDS(:)

    NULLIFY(NEW_FIELD)
    NULLIFY(NEW_FIELDS)

    CALL ENTERS("FIELD_CREATE_START_GENERIC",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELDS)) THEN
      IF(ASSOCIATED(FIELD)) THEN
        CALL FLAG_ERROR("Field is already associated.",ERR,ERROR,*998)
      ELSE
        !Set default field properties
        CALL FIELD_INITIALISE(NEW_FIELD,ERR,ERROR,*999)
        NEW_FIELD%GLOBAL_NUMBER=FIELDS%NUMBER_OF_FIELDS+1
        NEW_FIELD%USER_NUMBER=USER_NUMBER
        NEW_FIELD%LABEL="Field "//TRIM(NUMBER_TO_VSTRING(USER_NUMBER,"*",ERR,ERROR))
        IF(ERR/=0) GOTO 999
        NEW_FIELD%FIELDS=>FIELDS
        NULLIFY(NEW_FIELD%REGION)
        NULLIFY(NEW_FIELD%INTERFACE)
        NEW_FIELD%GEOMETRIC_FIELD=>NEW_FIELD
        NEW_FIELD%NUMBER_OF_VARIABLES=1
        NEW_FIELD%SCALINGS%SCALING_TYPE=FIELD_ARITHMETIC_MEAN_SCALING
        NEW_FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES=0
        NULLIFY(NEW_FIELD%CREATE_VALUES_CACHE)
        !Add new field into list of fields 
        ALLOCATE(NEW_FIELDS(FIELDS%NUMBER_OF_FIELDS+1),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new fields.",ERR,ERROR,*999)
        DO field_no=1,FIELDS%NUMBER_OF_FIELDS
          NEW_FIELDS(field_no)%PTR=>FIELDS%FIELDS(field_no)%PTR
        ENDDO !field_no
        NEW_FIELDS(FIELDS%NUMBER_OF_FIELDS+1)%PTR=>NEW_FIELD
        IF(ASSOCIATED(FIELDS%FIELDS)) DEALLOCATE(FIELDS%FIELDS)
        FIELDS%FIELDS=>NEW_FIELDS
        FIELDS%NUMBER_OF_FIELDS=FIELDS%NUMBER_OF_FIELDS+1
        FIELD=>NEW_FIELD
      ENDIF
    ELSE
      CALL FLAG_ERROR("Fields is not associated.",ERR,ERROR,*998)
    ENDIF

    CALL EXITS("FIELD_CREATE_START_GENERIC")
    RETURN
999 IF(ASSOCIATED(NEW_FIELD)) DEALLOCATE(NEW_FIELD)
    IF(ASSOCIATED(NEW_FIELDS)) DEALLOCATE(NEW_FIELDS)
    NULLIFY(FIELD)
998 CALL ERRORS("FIELD_CREATE_START_GENERIC",ERR,ERROR)
    CALL EXITS("FIELD_CREATE_START_GENERIC")
    RETURN 1
  END SUBROUTINE FIELD_CREATE_START_GENERIC

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field defined by a user number in the specified interface. \see OPENCMISS::CMISSFieldCreateStart
  !>Default values set for the FIELD's attributes are:
  !>- DEPENDENT_TYPE: 1 (FIELD_INDEPENDENT_TYPE)
  !>- DIMENSION: 2 (FIELD_VECTOR_DIMENSION_TYPE)
  !>- TYPE: 1 (FIELD_GEOMETRIC_TYPE)
  !>- NUMBER_OF_VARIABLES: 1
  !>- GEOMETRIC_FIELD: itself
  !>- SCALINGS%SCALING_TYPE: 3 (FIELD_ARITHMETIC_MEAN_SCALING)
  !>\todo Add in FIELD_INITIALISE
  SUBROUTINE FIELD_CREATE_START_INTERFACE(USER_NUMBER,INTERFACE,FIELD,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: USER_NUMBER !<The user number for the field
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE !<A pointer to the interface in which to create the field
    TYPE(FIELD_TYPE), POINTER :: FIELD !<On return, a pointer to the field being created. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR    

    CALL ENTERS("FIELD_CREATE_START_INTERFACE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERFACE)) THEN
      IF(ASSOCIATED(FIELD)) THEN
        CALL FLAG_ERROR("Field is already associated.",ERR,ERROR,*999)
      ELSE
        NULLIFY(FIELD)
        IF(ASSOCIATED(INTERFACE%FIELDS)) THEN
          CALL FIELD_USER_NUMBER_FIND_GENERIC(USER_NUMBER,INTERFACE%FIELDS,FIELD,ERR,ERROR,*999)
          IF(ASSOCIATED(FIELD)) THEN
            LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(USER_NUMBER,"*",ERR,ERROR))// &
              & " has already been created on interface number "//TRIM(NUMBER_TO_VSTRING(INTERFACE%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            CALL FIELD_CREATE_START_GENERIC(INTERFACE%FIELDS,USER_NUMBER,FIELD,ERR,ERROR,*999)
            FIELD%INTERFACE=>INTERFACE
            CALL FIELD_CREATE_VALUES_CACHE_INITIALISE(FIELD,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The fields on interface number "//TRIM(NUMBER_TO_VSTRING(INTERFACE%USER_NUMBER,"*",ERR,ERROR))// &
            & " are not associated."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Interface is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_CREATE_START_INTERFACE")
    RETURN
999 CALL ERRORS("FIELD_CREATE_START_INTERFACE",ERR,ERROR)
    CALL EXITS("FIELD_CREATE_START_INTERFACE")
    RETURN 1
    
  END SUBROUTINE FIELD_CREATE_START_INTERFACE

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field defined by a user number in the specified region. \see OPENCMISS::CMISSFieldCreateStart
  !>Default values set for the FIELD's attributes are:
  !>- DEPENDENT_TYPE: 1 (FIELD_INDEPENDENT_TYPE)
  !>- DIMENSION: 2 (FIELD_VECTOR_DIMENSION_TYPE)
  !>- TYPE: 1 (FIELD_GEOMETRIC_TYPE)
  !>- NUMBER_OF_VARIABLES: 1
  !>- GEOMETRIC_FIELD: itself
  !>- SCALINGS%SCALING_TYPE: 3 (FIELD_ARITHMETIC_MEAN_SCALING)
  !>\todo Add in FIELD_INITIALISE
  SUBROUTINE FIELD_CREATE_START_REGION(USER_NUMBER,REGION,FIELD,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: USER_NUMBER !<The user number for the field
    TYPE(REGION_TYPE), POINTER :: REGION !<A pointer to the region in which to create the field
    TYPE(FIELD_TYPE), POINTER :: FIELD !<On return, a pointer to the field being created
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_CREATE_START_REGION",ERR,ERROR,*999)

    IF(ASSOCIATED(REGION)) THEN
      IF(ASSOCIATED(FIELD)) THEN
        CALL FLAG_ERROR("Field is already associated.",ERR,ERROR,*999)
      ELSE
        NULLIFY(FIELD)
        IF(ASSOCIATED(REGION%FIELDS)) THEN
          CALL FIELD_USER_NUMBER_FIND_GENERIC(USER_NUMBER,REGION%FIELDS,FIELD,ERR,ERROR,*999)
          IF(ASSOCIATED(FIELD)) THEN
            LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(USER_NUMBER,"*",ERR,ERROR))// &
              & " has already been created on region number "//TRIM(NUMBER_TO_VSTRING(REGION%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            CALL FIELD_CREATE_START_GENERIC(REGION%FIELDS,USER_NUMBER,FIELD,ERR,ERROR,*999)
            FIELD%REGION=>REGION
            CALL FIELD_CREATE_VALUES_CACHE_INITIALISE(FIELD,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The fields on region number "//TRIM(NUMBER_TO_VSTRING(REGION%USER_NUMBER,"*",ERR,ERROR))// &
            & " are not associated."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Region is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_CREATE_START_REGION")
    RETURN
999 CALL ERRORS("FIELD_CREATE_START_REGION",ERR,ERROR)
    CALL EXITS("FIELD_CREATE_START_REGION")
    RETURN 1
  END SUBROUTINE FIELD_CREATE_START_REGION

  !
  !================================================================================================================================
  !

  !>Finalise the create values cache for a field.
  SUBROUTINE FIELD_CREATE_VALUES_CACHE_FINALISE(CREATE_VALUES_CACHE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_CREATE_VALUES_CACHE_TYPE), POINTER :: CREATE_VALUES_CACHE !<A pointer to the create values cache to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,variable_idx

    CALL ENTERS("FIELD_CREATE_VALUES_CACHE_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(CREATE_VALUES_CACHE)) THEN
      IF(ALLOCATED(CREATE_VALUES_CACHE%VARIABLE_TYPES)) DEALLOCATE(CREATE_VALUES_CACHE%VARIABLE_TYPES)
      IF(ALLOCATED(CREATE_VALUES_CACHE%VARIABLE_LABELS)) THEN
        DO variable_idx=1,SIZE(CREATE_VALUES_CACHE%VARIABLE_LABELS,1)
          CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)=""
        ENDDO !variable_idx
        DEALLOCATE(CREATE_VALUES_CACHE%VARIABLE_LABELS)
      ENDIF
      IF(ALLOCATED(CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED)) DEALLOCATE(CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED)
      IF(ALLOCATED(CREATE_VALUES_CACHE%DIMENSION)) DEALLOCATE(CREATE_VALUES_CACHE%DIMENSION)
      IF(ALLOCATED(CREATE_VALUES_CACHE%DIMENSION_LOCKED)) DEALLOCATE(CREATE_VALUES_CACHE%DIMENSION_LOCKED)
      IF(ALLOCATED(CREATE_VALUES_CACHE%DATA_TYPES)) DEALLOCATE(CREATE_VALUES_CACHE%DATA_TYPES)
      IF(ALLOCATED(CREATE_VALUES_CACHE%DATA_TYPES_LOCKED)) DEALLOCATE(CREATE_VALUES_CACHE%DATA_TYPES_LOCKED)
      IF(ALLOCATED(CREATE_VALUES_CACHE%DOF_ORDER_TYPES)) DEALLOCATE(CREATE_VALUES_CACHE%DOF_ORDER_TYPES)
      IF(ALLOCATED(CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED)) DEALLOCATE(CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED)
      IF(ALLOCATED(CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS)) DEALLOCATE(CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS)
      IF(ALLOCATED(CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED)) DEALLOCATE(CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED)
      IF(ALLOCATED(CREATE_VALUES_CACHE%COMPONENT_LABELS)) THEN
        DO variable_idx=1,SIZE(CREATE_VALUES_CACHE%COMPONENT_LABELS,2)
          DO component_idx=1,SIZE(CREATE_VALUES_CACHE%COMPONENT_LABELS,1)
            CREATE_VALUES_CACHE%COMPONENT_LABELS(component_idx,variable_idx)=""
          ENDDO !component_idx
        ENDDO !variable_idx
        DEALLOCATE(CREATE_VALUES_CACHE%COMPONENT_LABELS)
      ENDIF
      IF(ALLOCATED(CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED)) DEALLOCATE(CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED)
      IF(ALLOCATED(CREATE_VALUES_CACHE%INTERPOLATION_TYPE)) DEALLOCATE(CREATE_VALUES_CACHE%INTERPOLATION_TYPE)
      IF(ALLOCATED(CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED)) DEALLOCATE(CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED)
      IF(ALLOCATED(CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER)) DEALLOCATE(CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER)
      IF(ALLOCATED(CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED)) DEALLOCATE(CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED)
      DEALLOCATE(CREATE_VALUES_CACHE)
    ENDIF
 
    CALL EXITS("FIELD_CREATE_VALUES_CACHE_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_CREATE_VALUES_CACHE_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_CREATE_VALUES_CACHE_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_CREATE_VALUES_CACHE_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the create values cache for a field.
  SUBROUTINE FIELD_CREATE_VALUES_CACHE_INITIALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the create values cache for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    INTEGER(INTG) :: DUMMY_ERR,NUMBER_OF_COMPONENTS,component_idx,variable_idx
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR

    CALL ENTERS("FIELD_CREATE_VALUES_CACHE_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        CALL FLAG_ERROR("Create values cache is already associated.",ERR,ERROR,*998)
      ELSE
        ALLOCATE(FIELD%CREATE_VALUES_CACHE,STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate create values cache.",ERR,ERROR,*999)
        SELECT CASE(FIELD%TYPE)
        CASE(FIELD_GEOMETRIC_TYPE,FIELD_FIBRE_TYPE,FIELD_GEOMETRIC_GENERAL_TYPE)
          NULLIFY(COORDINATE_SYSTEM)
          CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
          NUMBER_OF_COMPONENTS=COORDINATE_SYSTEM%NUMBER_OF_DIMENSIONS
        CASE(FIELD_GENERAL_TYPE,FIELD_MATERIAL_TYPE)
          NUMBER_OF_COMPONENTS=1
        CASE DEFAULT
          LOCAL_ERROR="The field type of "//TRIM(NUMBER_TO_VSTRING(FIELD%TYPE,"*",ERR,ERROR))//" is invalid for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(FIELD%NUMBER_OF_VARIABLES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocated create values cache variable types.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocated create values cache variable labels.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocated create values cache variable labels locked.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%DIMENSION(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocated create values cache dimension.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocated create values cache dimension locked.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%DATA_TYPES(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocated create values cache data types.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocated create values cache data types locked.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocated create values cache DOF order types.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocated create values cache DOF order types locked.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocated create values cache number of components.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocated create values cache number of components locked.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocated create values cache component labels.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocated create values cache component labels locked.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocated create values cache interpolation type.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocated create values cache interpolation type locked.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocated create values cache mesh component type.",ERR,ERROR,*999)
        ALLOCATE(FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES), &
          & STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocated create values cache mesh component type locked.",ERR,ERROR,*999)
        FIELD%CREATE_VALUES_CACHE%LABEL_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%DECOMPOSITION_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%DEPENDENT_TYPE_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%NUMBER_OF_VARIABLES_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%GEOMETRIC_FIELD_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%SCALING_TYPE_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%TYPE_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES=0
        FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS=""
        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%DIMENSION=0
        FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%DATA_TYPES=0
        FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES=0
        FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS=0
        FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS=""
        FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE=0
        FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER=0
        FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED=.FALSE.
        FIELD%CREATE_VALUES_CACHE%DataProjectionLocked=.FALSE.
        DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
          FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(variable_idx)=variable_idx
          SELECT CASE(variable_idx)
          CASE(FIELD_U_VARIABLE_TYPE)
            SELECT CASE(FIELD%TYPE)
            CASE(FIELD_GEOMETRIC_TYPE)
              FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="Coordinate"
            CASE(FIELD_FIBRE_TYPE)
              FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="Fibre"
            CASE(FIELD_MATERIAL_TYPE)
              FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="Material"              
            CASE(FIELD_GENERAL_TYPE)
              FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U"
            CASE(FIELD_GEOMETRIC_GENERAL_TYPE)
              FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U"
            CASE DEFAULT
              LOCAL_ERROR="The field type of "//TRIM(NUMBER_TO_VSTRING(FIELD%TYPE,"*",ERR,ERROR))// &
                & " is invalid for field number "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          CASE(FIELD_DELUDELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U/del n"
          CASE(FIELD_DELUDELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U/del t"
          CASE(FIELD_DEL2UDELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U/del t^2"
          CASE(FIELD_V_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="V"
          CASE(FIELD_DELVDELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del V/del n"
          CASE(FIELD_DELVDELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del V/del t"
          CASE(FIELD_DEL2VDELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 V/del t^2"
          CASE(FIELD_U1_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U1"
          CASE(FIELD_DELU1DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U1/del n"
          CASE(FIELD_DELU1DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U1/del t"
          CASE(FIELD_DEL2U1DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U1/del t^2"
          CASE(FIELD_U2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U2"
          CASE(FIELD_DELU2DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U2/del n"
          CASE(FIELD_DELU2DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U2/del t"
          CASE(FIELD_DEL2U2DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U2/del t^2"
          CASE(FIELD_U3_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U3"
          CASE(FIELD_DELU3DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U3/del n"
          CASE(FIELD_DELU3DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U3/del t"
          CASE(FIELD_DEL2U3DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U3/del t^2"
          CASE(FIELD_U4_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U4"
          CASE(FIELD_DELU4DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U4/del n"
          CASE(FIELD_DELU4DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U4/del t"
          CASE(FIELD_DEL2U4DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U4/del t^2"
          CASE(FIELD_U5_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U5"
          CASE(FIELD_DELU5DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U5/del n"
          CASE(FIELD_DELU5DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U5/del t"
          CASE(FIELD_DEL2U5DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U5/del t^2"
          CASE(FIELD_U6_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U6"
          CASE(FIELD_DELU6DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U6/del n"
          CASE(FIELD_DELU6DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U6/del t"
          CASE(FIELD_DEL2U6DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U6/del t^2"
          CASE(FIELD_U7_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U7"
          CASE(FIELD_DELU7DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U7/del n"
          CASE(FIELD_DELU7DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U7/del t"
          CASE(FIELD_DEL2U7DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U7/del t^2"
          CASE(FIELD_U8_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U8"
          CASE(FIELD_DELU8DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U8/del n"
          CASE(FIELD_DELU8DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U8/del t"
          CASE(FIELD_DEL2U8DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U8/del t^2"
          CASE(FIELD_U9_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U9"
          CASE(FIELD_DELU9DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U9/del n"
          CASE(FIELD_DELU9DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U9/del t"
          CASE(FIELD_DEL2U9DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U/9del t^2"
          CASE(FIELD_U10_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="U10"
          CASE(FIELD_DELU10DELN_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U10/del n"
          CASE(FIELD_DELU10DELT_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del U10/del t"
          CASE(FIELD_DEL2U10DELT2_VARIABLE_TYPE)
            FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_idx)="del^2 U10/del t^2"
          CASE DEFAULT
            LOCAL_ERROR="The variable type of "//TRIM(NUMBER_TO_VSTRING(variable_idx,"*",ERR,ERROR))//" is invalid."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
          FIELD%CREATE_VALUES_CACHE%DIMENSION(variable_idx)=FIELD_VECTOR_DIMENSION_TYPE
          FIELD%CREATE_VALUES_CACHE%DATA_TYPES(variable_idx)=FIELD_DP_TYPE
          FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES(variable_idx)=FIELD_SEPARATED_COMPONENT_DOF_ORDER
          FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_idx)=NUMBER_OF_COMPONENTS
          DO component_idx=1,NUMBER_OF_COMPONENTS
            FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS(component_idx,variable_idx)= &
              & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))






            IF(ERR/=0) GOTO 999
            FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(component_idx,variable_idx)=FIELD_NODE_BASED_INTERPOLATION
            FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(component_idx,variable_idx)=1
          ENDDO !component_idx
        ENDDO !variable_idx
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*998)
    ENDIF

    CALL EXITS("FIELD_CREATE_VALUES_CACHE_INITIALISE")
    RETURN
999 CALL FIELD_CREATE_VALUES_CACHE_FINALISE(FIELD%CREATE_VALUES_CACHE,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("FIELD_CREATE_VALUES_CACHE_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_CREATE_VALUES_CACHE_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_CREATE_VALUES_CACHE_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets a geometric general field for a field if there is any (eg. the dependent field for a finite elasticity equation),
  !>otherwise the normal geometric field is returned if present.
  !>If no geometric field is found then an error is raised.
  SUBROUTINE Field_GeometricGeneralFieldGet(field,geometricField,generalFound,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: field !<A pointer to the field to get the geometric field for
    TYPE(FIELD_TYPE), POINTER, INTENT(OUT) :: geometricField !<On return, a pointer to the geometric field. Must not be associated on entry.
    LOGICAL, INTENT(OUT) :: generalFound !<On return, true if we found a geometric general field, otherwise false.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: fieldIdx
    TYPE(FIELD_TYPE), POINTER :: otherField
    TYPE(VARYING_STRING) :: localError

    CALL Enters("Field_GeometricGeneralFieldGet",err,error,*999)

    NULLIFY(geometricField)

    ! Check input parameters
    IF(ASSOCIATED(field)) THEN
      IF(field%field_finished) THEN
        IF(.NOT.ASSOCIATED(field%fields)) THEN
          CALL FlagError("Field fields are not associated.",err,error,*999)
        END IF
      ELSE
        localError="Field number "//TRIM(number_to_vstring(field%user_number,"*",err,error))// &
          & " has not been finished."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    END IF
    IF(ASSOCIATED(geometricField)) THEN
      CALL FlagError("Geometric field is already associated.",err,error,*999)
    END IF

    generalFound=.FALSE.
    ! Find the geometric general field associated with this field
    DO fieldIdx=1,field%fields%number_of_fields
      otherField=>field%fields%fields(fieldIdx)%ptr
      IF(ASSOCIATED(otherField)) THEN
        IF(otherField%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
          geometricField=>otherField
          generalFound=.TRUE.
        END IF
      ELSE
        CALL FlagError("Field number "//TRIM(number_to_vstring(fieldIdx,"*",err,error))// &
          & " is not associated.",err,error,*999)
      END IF
    END DO

    IF(.NOT.generalFound) THEN
      ! We couldn't find a geometric general field.
      ! Just return the undeformed geometric field.
      IF(ASSOCIATED(field%geometric_field)) THEN
        geometricField=>field%geometric_field
      ELSE
        CALL FlagError("Geometric general field not found and geometric field is not associated.",err,error,*999)
      END IF
    END IF

    CALL Exits("Field_GeometricGeneralFieldGet")
    RETURN
999 CALL Errors("Field_GeometricGeneralFieldGet",err,error)
    CALL Exits("Field_GeometricGeneralFieldGet")
    RETURN 1
  END SUBROUTINE Field_GeometricGeneralFieldGet

  !
  !================================================================================================================================
  !

  !>Checks the dependent type for a field.
  SUBROUTINE FIELD_DEPENDENT_TYPE_CHECK(FIELD,DEPENDENT_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the dependent type for
    INTEGER(INTG), INTENT(IN) :: DEPENDENT_TYPE !<The dependent type to check \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_DEPENDENT_TYPE_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        SELECT CASE(DEPENDENT_TYPE)
        CASE(FIELD_INDEPENDENT_TYPE)
          IF(FIELD%DEPENDENT_TYPE/=FIELD_INDEPENDENT_TYPE) THEN
            LOCAL_ERROR="Invalid dependent type. The dependent type of field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%DEPENDENT_TYPE,"*",ERR,ERROR))// &
              & " which is not an independent field."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_DEPENDENT_TYPE)
          IF(FIELD%DEPENDENT_TYPE/=FIELD_DEPENDENT_TYPE) THEN
            LOCAL_ERROR="Invalid dependent type. The dependent type of field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%DEPENDENT_TYPE,"*",ERR,ERROR))// &
              & " which is not a dependent field."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE DEFAULT
          LOCAL_ERROR="The specified dependent type of "//TRIM(NUMBER_TO_VSTRING(DEPENDENT_TYPE,"*",ERR,ERROR))// &
            & " is invalid."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_DEPENDENT_TYPE_CHECK")
    RETURN
999 CALL ERRORS("FIELD_DEPENDENT_TYPE_CHECK",ERR,ERROR)
    CALL EXITS("FIELD_DEPENDENT_TYPE_CHECK")
    RETURN 1
  END SUBROUTINE FIELD_DEPENDENT_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the dependent type for a field. \see OPENCMISS::CMISSFieldDependentTypeGet
  SUBROUTINE FIELD_DEPENDENT_TYPE_GET(FIELD,DEPENDENT_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the dependent type for
    INTEGER(INTG), INTENT(OUT) :: DEPENDENT_TYPE !<On return, the dependent type to get \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_DEPENDENT_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        DEPENDENT_TYPE=FIELD%DEPENDENT_TYPE
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_DEPENDENT_TYPE_GET")
    RETURN
999 CALL ERRORS("FIELD_DEPENDENT_TYPE_GET",ERR,ERROR)
    CALL EXITS("FIELD_DEPENDENT_TYPE_GET")
    RETURN 1
  END SUBROUTINE FIELD_DEPENDENT_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field. \see OPENCMISS::CMISSFieldDependentTypeSet
  SUBROUTINE FIELD_DEPENDENT_TYPE_SET(FIELD,DEPENDENT_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the dependent type for
    INTEGER(INTG), INTENT(IN) :: DEPENDENT_TYPE !<The dependent type to set/change \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_DEPENDENT_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%DEPENDENT_TYPE_LOCKED) THEN
            LOCAL_ERROR="The dependent type has been locked for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            SELECT CASE(DEPENDENT_TYPE)
            CASE(FIELD_INDEPENDENT_TYPE)
              FIELD%DEPENDENT_TYPE=FIELD_INDEPENDENT_TYPE
            CASE(FIELD_DEPENDENT_TYPE)
              FIELD%DEPENDENT_TYPE=FIELD_DEPENDENT_TYPE
            CASE DEFAULT
              LOCAL_ERROR="The supplied dependent type of "//TRIM(NUMBER_TO_VSTRING(DEPENDENT_TYPE,"*",ERR,ERROR))//" is invalid."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_DEPENDENT_TYPE_SET")
    RETURN
999 CALL ERRORS("FIELD_DEPENDENT_TYPE_SET",ERR,ERROR)
    CALL EXITS("FIELD_DEPENDENT_TYPE_SET")
    RETURN 1
  END SUBROUTINE FIELD_DEPENDENT_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field and locks so that no further changes are possible.
  SUBROUTINE FIELD_DEPENDENT_TYPE_SET_AND_LOCK(FIELD,DEPENDENT_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the dependent type for
    INTEGER(INTG), INTENT(IN) :: DEPENDENT_TYPE !<The dependent type to set/change \see FIELD_ROUTINES_DependentTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_DEPENDENT_TYPE_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_DEPENDENT_TYPE_SET(FIELD,DEPENDENT_TYPE,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%DEPENDENT_TYPE_LOCKED=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_DEPENDENT_TYPE_SET_AND_LOCK")
    RETURN
999 CALL ERRORS("FIELD_DEPENDENT_TYPE_SET_AND_LOCK",ERR,ERROR)
    CALL EXITS("FIELD_DEPENDENT_TYPE_SET_AND_LOCK")
    RETURN 1
  END SUBROUTINE FIELD_DEPENDENT_TYPE_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Destroys a field. \see OPENCMISS::CMISSFieldDestroy
  SUBROUTINE FIELD_DESTROY(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to destroy
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: field_idx,field_position,field_position2
    TYPE(FIELD_TYPE), POINTER :: FIELD2,GEOMETRIC_FIELD
    TYPE(FIELDS_TYPE), POINTER :: FIELDS
    TYPE(FIELD_PTR_TYPE), POINTER :: NEW_FIELDS(:),NEW_FIELDS_USING(:)

    NULLIFY(NEW_FIELDS)
    NULLIFY(NEW_FIELDS_USING)

    CALL ENTERS("FIELD_DESTROY",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      FIELDS=>FIELD%FIELDS
      IF(ASSOCIATED(FIELDS)) THEN
        field_position=FIELD%GLOBAL_NUMBER
        GEOMETRIC_FIELD=>FIELD%GEOMETRIC_FIELD
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          IF(ASSOCIATED(GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS)) THEN
            !Delete this field from the list of fields using the geometric field.
            field_position2=0
            DO field_idx=1,GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING
              FIELD2=>GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING(field_idx)%PTR
              IF(FIELD2%USER_NUMBER==FIELD%USER_NUMBER) THEN
                field_position2=field_idx
                EXIT
              ENDIF
            ENDDO !field_idx
            IF(field_position2/=0) THEN
              ALLOCATE(NEW_FIELDS_USING(GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING+1),STAT=ERR)
              IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new fields using.",ERR,ERROR,*999)
              DO field_idx=1,GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING
                IF(field_idx<field_position2) THEN
                  NEW_FIELDS_USING(field_idx)%PTR=>GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING(field_idx)%PTR
                ELSE IF(field_idx>field_position2) THEN
                  NEW_FIELDS_USING(field_idx-1)%PTR=>GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING(field_idx)%PTR
                ENDIF
              ENDDO !field_idx
              GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING=GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS% &
                & NUMBER_OF_FIELDS_USING-1
              IF(ASSOCIATED(GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING)) &
                & DEALLOCATE(GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING)
              GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING=>NEW_FIELDS_USING
            ELSE
              !??? Error
            ENDIF
          ENDIF
        ENDIF
        CALL FIELD_FINALISE(FIELD,ERR,ERROR,*999)
        IF(FIELDS%NUMBER_OF_FIELDS>1) THEN
          ALLOCATE(NEW_FIELDS(FIELDS%NUMBER_OF_FIELDS-1),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new fields.",ERR,ERROR,*999)
          DO field_idx=1,FIELDS%NUMBER_OF_FIELDS
            IF(field_idx<field_position) THEN
              NEW_FIELDS(field_idx)%PTR=>FIELDS%FIELDS(field_idx)%PTR
            ELSE IF(field_idx>field_position) THEN
              FIELDS%FIELDS(field_idx)%PTR%GLOBAL_NUMBER=FIELDS%FIELDS(field_idx)%PTR%GLOBAL_NUMBER-1
              NEW_FIELDS(field_idx-1)%PTR=>FIELDS%FIELDS(field_idx)%PTR
            ENDIF
          ENDDO !field_no
          DEALLOCATE(FIELDS%FIELDS)
          FIELDS%FIELDS=>NEW_FIELDS
          FIELDS%NUMBER_OF_FIELDS=FIELDS%NUMBER_OF_FIELDS-1
        ELSE
          DEALLOCATE(FIELDS%FIELDS)
          FIELDS%NUMBER_OF_FIELDS=0
        ENDIF
      ELSE
        CALL FLAG_ERROR("Field fields is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_DESTROY")
    RETURN
999 IF(ASSOCIATED(NEW_FIELDS)) DEALLOCATE(NEW_FIELDS)
    IF(ASSOCIATED(NEW_FIELDS_USING)) DEALLOCATE(NEW_FIELDS_USING)
    CALL ERRORS("FIELD_DESTROY",ERR,ERROR)
    CALL EXITS("FIELD_DESTROY")
    RETURN 1
  END SUBROUTINE FIELD_DESTROY

  !
  !================================================================================================================================
  !

  !>Checks the field dimension for a field variable.
  SUBROUTINE FIELD_DIMENSION_CHECK(FIELD,VARIABLE_TYPE,DIMENSION_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: DIMENSION_TYPE !<The field dimension to check \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("FIELD_DIMENSION_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            SELECT CASE(DIMENSION_TYPE)
            CASE(FIELD_SCALAR_DIMENSION_TYPE)
              IF(FIELD_VARIABLE%DIMENSION/=FIELD_SCALAR_DIMENSION_TYPE) THEN
                LOCAL_ERROR="Invalid dimension type. The dimension type for variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DIMENSION,"*",ERR,ERROR))// &
                  & " which is not a scalar field."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_VECTOR_DIMENSION_TYPE)
              IF(FIELD_VARIABLE%DIMENSION/=FIELD_VECTOR_DIMENSION_TYPE) THEN
                LOCAL_ERROR="Invalid dimension type. The dimension type for variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DIMENSION,"*",ERR,ERROR))// &
                  & " which is not a vector field."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_TENSOR_DIMENSION_TYPE) 
              IF(FIELD_VARIABLE%DIMENSION/=FIELD_TENSOR_DIMENSION_TYPE) THEN
                LOCAL_ERROR="Invalid dimension type. The dimension type for variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DIMENSION,"*",ERR,ERROR))// &
                  & " which is not a tensor field."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF

           CASE DEFAULT
              LOCAL_ERROR="The specified dimension type of "//TRIM(NUMBER_TO_VSTRING(DIMENSION_TYPE,"*",ERR,ERROR))// &
                & " is invalid."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_DIMENSION_CHECK")
    RETURN
999 CALL ERRORS("FIELD_DIMENSION_CHECK",ERR,ERROR)
    CALL EXITS("FIELD_DIMENSION_CHECK")
    RETURN 1
  END SUBROUTINE FIELD_DIMENSION_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the field dimension for a field variable. \see OPENCMISS::CMISSFieldDimensionGet
  SUBROUTINE FIELD_DIMENSION_GET(FIELD,VARIABLE_TYPE,DIMENSION,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(OUT) :: DIMENSION !<On return, the field dimension to get \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("FIELD_DIMENSION_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            DIMENSION=FIELD_VARIABLE%DIMENSION
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_DIMENSION_GET")
    RETURN
999 CALL ERRORS("FIELD_DIMENSION_GET",ERR,ERROR)
    CALL EXITS("FIELD_DIMENSION_GET")
    RETURN 1
  END SUBROUTINE FIELD_DIMENSION_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field dimension for a field variable.
  SUBROUTINE FIELD_DIMENSION_SET(FIELD,VARIABLE_TYPE,FIELD_DIMENSION,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_DIMENSION !<The field dimension to set/change \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: NUMBER_OF_COMPONENTS,NEW_NUMBER_OF_COMPONENTS,variable_idx
    INTEGER(INTG), ALLOCATABLE :: NEW_INTERPOLATION_TYPE(:,:),NEW_MESH_COMPONENT_NUMBER(:,:)
    LOGICAL, ALLOCATABLE :: NEW_COMPONENT_LABELS_LOCKED(:,:),NEW_INTERPOLATION_TYPE_LOCKED(:,:), &
      & NEW_MESH_COMPONENT_NUMBER_LOCKED(:,:)
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    TYPE(VARYING_STRING), ALLOCATABLE :: NEW_COMPONENT_LABELS(:,:)

    CALL ENTERS("FIELD_DIMENSION_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
              IF(FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED(VARIABLE_TYPE)) THEN
                LOCAL_ERROR="The field dimension has been locked for for variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ELSE
                SELECT CASE(FIELD_DIMENSION)
                CASE(FIELD_SCALAR_DIMENSION_TYPE)
                  IF(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)/=1) THEN
                    NUMBER_OF_COMPONENTS=SIZE(FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE,1)
                    NEW_NUMBER_OF_COMPONENTS=1
                    !Here, new number of components always >= old_number_of_components
                    DO variable_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
                      IF (FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_idx) > NEW_NUMBER_OF_COMPONENTS) THEN 
                        IF (variable_idx /= VARIABLE_TYPE) THEN
                          NEW_NUMBER_OF_COMPONENTS=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_idx)
                        ENDIF
                      ENDIF
                    ENDDO
                    ALLOCATE(NEW_COMPONENT_LABELS(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new component labels.",ERR,ERROR,*999)
                    ALLOCATE(NEW_COMPONENT_LABELS_LOCKED(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new component labels locked.",ERR,ERROR,*999)
                    ALLOCATE(NEW_INTERPOLATION_TYPE(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new interpolation type.",ERR,ERROR,*999)
                    ALLOCATE(NEW_INTERPOLATION_TYPE_LOCKED(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new interpolation type locked.",ERR,ERROR,*999)
                    ALLOCATE(NEW_MESH_COMPONENT_NUMBER(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new mesh component number.",ERR,ERROR,*999)
                    ALLOCATE(NEW_MESH_COMPONENT_NUMBER_LOCKED(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new mesh component number locked.",ERR,ERROR,*999)
                    NEW_COMPONENT_LABELS(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                      & FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS(1:NEW_NUMBER_OF_COMPONENTS,:)
                    NEW_COMPONENT_LABELS_LOCKED(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                      & FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED(1:NEW_NUMBER_OF_COMPONENTS,:)
                    NEW_INTERPOLATION_TYPE(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                      & FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(1:NEW_NUMBER_OF_COMPONENTS,:)
                    NEW_INTERPOLATION_TYPE_LOCKED(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                      & FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(1:NEW_NUMBER_OF_COMPONENTS,:)
                    NEW_MESH_COMPONENT_NUMBER(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                      & FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(1:NEW_NUMBER_OF_COMPONENTS,:)
                    NEW_MESH_COMPONENT_NUMBER_LOCKED(1:NEW_NUMBER_OF_COMPONENTS,:)= &
                      & FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(1:NEW_NUMBER_OF_COMPONENTS,:)

                    CALL MOVE_ALLOC(NEW_COMPONENT_LABELS,FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS)
                    CALL MOVE_ALLOC(NEW_COMPONENT_LABELS_LOCKED,FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED)
                    CALL MOVE_ALLOC(NEW_INTERPOLATION_TYPE,FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE)
                    CALL MOVE_ALLOC(NEW_INTERPOLATION_TYPE_LOCKED,FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED)
                    CALL MOVE_ALLOC(NEW_MESH_COMPONENT_NUMBER,FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER)
                    CALL MOVE_ALLOC(NEW_MESH_COMPONENT_NUMBER_LOCKED,FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED)

                    FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)=1
                  ENDIF
                  FIELD%CREATE_VALUES_CACHE%DIMENSION(VARIABLE_TYPE)=FIELD_SCALAR_DIMENSION_TYPE
                CASE(FIELD_VECTOR_DIMENSION_TYPE)
                  FIELD%CREATE_VALUES_CACHE%DIMENSION(VARIABLE_TYPE)=FIELD_VECTOR_DIMENSION_TYPE
                CASE(FIELD_TENSOR_DIMENSION_TYPE)
                  FIELD%CREATE_VALUES_CACHE%DIMENSION(VARIABLE_TYPE)=FIELD_TENSOR_DIMENSION_TYPE
                  CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                CASE DEFAULT
                  LOCAL_ERROR="The specified field dimension of "//TRIM(NUMBER_TO_VSTRING(FIELD_DIMENSION,"*",ERR,ERROR))// &
                    & " is invalid."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_DIMENSION_SET")
    RETURN
999 IF(ALLOCATED(NEW_COMPONENT_LABELS)) DEALLOCATE(NEW_COMPONENT_LABELS)
    IF(ALLOCATED(NEW_COMPONENT_LABELS_LOCKED)) DEALLOCATE(NEW_COMPONENT_LABELS_LOCKED)
    IF(ALLOCATED(NEW_INTERPOLATION_TYPE)) DEALLOCATE(NEW_INTERPOLATION_TYPE)
    IF(ALLOCATED(NEW_INTERPOLATION_TYPE_LOCKED)) DEALLOCATE(NEW_INTERPOLATION_TYPE_LOCKED)
    IF(ALLOCATED(NEW_MESH_COMPONENT_NUMBER)) DEALLOCATE(NEW_MESH_COMPONENT_NUMBER)
    IF(ALLOCATED(NEW_MESH_COMPONENT_NUMBER_LOCKED)) DEALLOCATE(NEW_MESH_COMPONENT_NUMBER_LOCKED)
    CALL ERRORS("FIELD_DIMENSION_SET",ERR,ERROR)
    CALL EXITS("FIELD_DIMENSION_SET")
    RETURN 1
  END SUBROUTINE FIELD_DIMENSION_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field dimension for a field variable  and locks so that no further changes can be made.
  SUBROUTINE FIELD_DIMENSION_SET_AND_LOCK(FIELD,VARIABLE_TYPE,FIELD_DIMENSION,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_DIMENSION !<The field dimension to set/change \see FIELD_ROUTINES_DimensionTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_DIMENSION_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_DIMENSION_SET(FIELD,VARIABLE_TYPE,FIELD_DIMENSION,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED(VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_DIMENSION_SET_AND_LOCK")
    RETURN
999 CALL ERRORS("FIELD_DIMENSION_SET_AND_LOCK",ERR,ERROR)
    CALL EXITS("FIELD_DIMENSION_SET_AND_LOCK")
    RETURN 1
  END SUBROUTINE FIELD_DIMENSION_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Finalises a field and deallocates all memory.
  SUBROUTINE FIELD_FINALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELD_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      FIELD%LABEL=""
      CALL FIELD_SCALINGS_FINALISE(FIELD,ERR,ERROR,*999)
      CALL FIELD_VARIABLES_FINALISE(FIELD,ERR,ERROR,*999)
      CALL FIELD_CREATE_VALUES_CACHE_FINALISE(FIELD%CREATE_VALUES_CACHE,ERR,ERROR,*999)
      CALL FIELD_GEOMETRIC_PARAMETERS_FINALISE(FIELD%GEOMETRIC_FIELD_PARAMETERS,ERR,ERROR,*999)
      IF(ALLOCATED(FIELD%VARIABLE_TYPE_MAP)) DEALLOCATE(FIELD%VARIABLE_TYPE_MAP)
      DEALLOCATE(FIELD)     
    ENDIF

    CALL EXITS("FIELD_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises a field
  SUBROUTINE FIELD_INITIALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the new field to initialise. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,variable_type_idx
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    CALL ENTERS("FIELD_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELD)) THEN
      CALL FLAG_ERROR("Field is already associated.",ERR,ERROR,*998)
    ELSE
      ALLOCATE(FIELD,STAT=ERR)
      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field.",ERR,ERROR,*999)      
      FIELD%GLOBAL_NUMBER=0
      FIELD%USER_NUMBER=0
      FIELD%LABEL=""
      FIELD%FIELD_FINISHED=.FALSE.
      NULLIFY(FIELD%FIELDS)
      NULLIFY(FIELD%REGION)
      FIELD%TYPE=FIELD_GEOMETRIC_TYPE
      FIELD%DEPENDENT_TYPE=FIELD_INDEPENDENT_TYPE
      NULLIFY(FIELD%DECOMPOSITION)
      FIELD%NUMBER_OF_VARIABLES=0
      NULLIFY(FIELD%GEOMETRIC_FIELD)
      NULLIFY(FIELD%GEOMETRIC_FIELD_PARAMETERS)
      NULLIFY(FIELD%CREATE_VALUES_CACHE)
      ALLOCATE(FIELD%VARIABLE_TYPE_MAP(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable type map.",ERR,ERROR,*999)
      DO variable_type_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
        NULLIFY(FIELD%VARIABLE_TYPE_MAP(variable_type_idx)%PTR)
      ENDDO !variable_type_idx
    ENDIF

    CALL EXITS("FIELD_INITIALISE")
    RETURN
999 CALL FIELD_FINALISE(FIELD,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("FIELD_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_INITIALISE")
    RETURN 1
    
  END SUBROUTINE FIELD_INITIALISE

  !
  !================================================================================================================================
  !

  !>Interpolates a field at a gauss point to give an interpolated point. PARTIAL_DERIVATIVE_TYPE controls which partial derivatives are evaluated. If it is NO_PART_DERIV then only the field values are interpolated. If it is FIRST_PART_DERIV then the field values and first partial derivatives are interpolated. If it is SECOND_PART_DERIV the the field values and first and second partial derivatives are evaluated. Old CMISS name XEXG, ZEXG
  SUBROUTINE FIELD_INTERPOLATE_GAUSS(PARTIAL_DERIVATIVE_TYPE,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER,INTERPOLATED_POINT, &
      & ERR,ERROR,*,componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PARTIAL_DERIVATIVE_TYPE !<The partial derivative type of the provided field interpolation
    INTEGER(INTG), INTENT(IN) :: QUADRATURE_SCHEME !<The quadrature scheme of the Gauss points \see BASIS_ROUTINES_QuadratureSchemes,BASIS_ROUTINES
    INTEGER(INTG), INTENT(IN) :: GAUSS_POINT_NUMBER !<The number of the Gauss point to interpolate the field at
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: INTERPOLATED_POINT !<The pointer to the interpolated point which will contain the field interpolation information at the specified Gauss point
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: component_idx,ni,nu
    INTEGER(INTG) :: startComponentIdx,endComponentIdx
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_INTERPOLATE_GAUSS",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINT)) THEN
      INTERPOLATION_PARAMETERS=>INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
      IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
        FIELD=>INTERPOLATION_PARAMETERS%FIELD
        IF(ASSOCIATED(FIELD)) THEN
          NULLIFY(COORDINATE_SYSTEM)
          CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
          IF(PRESENT(componentType)) THEN
            SELECT CASE(componentType)
            CASE(FIELD_ALL_COMPONENTS_TYPE)
              startComponentIdx=1
              endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR% &
                  & NUMBER_OF_COMPONENTS
              ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELSE
                LOCAL_ERROR="Field type "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                startComponentIdx=-INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)% &
                  & PTR%NUMBER_OF_COMPONENTS+1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELSE
                LOCAL_ERROR="Field type "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE DEFAULT
              LOCAL_ERROR="Interpolation component type "//TRIM(NUMBER_TO_VSTRING(componentType,"*",ERR,ERROR))//" is not valid."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            startComponentIdx=1
            endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          ENDIF
          SELECT CASE(PARTIAL_DERIVATIVE_TYPE)
          CASE(NO_PART_DERIV)
            DO component_idx=startComponentidx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)              
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
                  & component_idx)%PTR,NO_PART_DERIV,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER,INTERPOLATION_PARAMETERS% &
                  & PARAMETERS(:,component_idx),ERR,ERROR)
                IF(ERR/=0) GOTO 999
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(GAUSS_POINT_NUMBER, &
                  & component_idx)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//"."
              END SELECT
              CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                & ERR,ERROR,*999)
            ENDDO! component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=NO_PART_DERIV
          CASE(FIRST_PART_DERIV)
            DO component_idx=startComponentidx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
                  & component_idx)%PTR,NO_PART_DERIV,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER,INTERPOLATION_PARAMETERS% &
                  & PARAMETERS(:,component_idx),ERR,ERROR)
                IF(ERR/=0) GOTO 999
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS% &
                    & BASES(component_idx)%PTR,nu,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER, &
                    & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                  IF(ERR/=0) GOTO 999
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//"."
              END SELECT
            ENDDO! component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=FIRST_PART_DERIV
          CASE(SECOND_PART_DERIV)
            DO component_idx=startComponentidx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process the rest of partial derivatives
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !nu
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process the rest of partial derivatives
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !nu
              CASE(FIELD_NODE_BASED_INTERPOLATION)              
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS% &
                    & BASES(component_idx)%PTR,nu,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER, &
                    & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                  IF(ERR/=0) GOTO 999
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO! nu
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//"."
              END SELECT
            ENDDO !component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=SECOND_PART_DERIV
          CASE DEFAULT
            LOCAL_ERROR="The partial derivative type of "//TRIM(NUMBER_TO_VSTRING(PARTIAL_DERIVATIVE_TYPE,"*",ERR,ERROR))// &
              & " is invalid."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        ELSE
          CALL FLAG_ERROR("The interpolation parameters field is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FLAG_ERROR("Interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Interpolated point is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_INTERPOLATE_GAUSS")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATE_GAUSS",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATE_GAUSS")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATE_GAUSS

  !
  !================================================================================================================================
  !

  !>Interpolates a field to give the physical value of the field at a node. Note that as we are at a node then we do not have any xi directions and thus we can not talk about gradients of the field wrt to xi. Because derviatives of fields can be discountinuous at a node the average derivative over all the elements surrounding the node is calculated.
  SUBROUTINE FIELD_INTERPOLATE_NODE(PHYSICAL_DERIVATIVE_TYPE,PARAMETER_SET_TYPE,COMPONENT_NUMBER,NODE_NUMBER, &
    & PHYSICAL_POINT,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PHYSICAL_DERIVATIVE_TYPE !<The physical derivative type of the field interpolation \see CONSTANTS_PhysicalDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: PARAMETER_SET_TYPE !<The parameter set of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The component number to field that contains the node 
    INTEGER(INTG), INTENT(IN) :: NODE_NUMBER !<The node number in the component to interpolate the field at
    TYPE(FIELD_PHYSICAL_POINT_TYPE), POINTER :: PHYSICAL_POINT !<The pointer to the physical point for the field. On return it will contain the values.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,element,elem_idx,LOCAL_NODE_NUMBER,local_node_idx,NUMBER_OF_SURROUNDING_ELEMENTS, &
      & partial_deriv_idx,xi_idx
    REAL(DP) :: XI(3),DX_DXI(3,3),DXI_DX(3,3),DET_DX_DXI
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: ELEM_TOPOLOGY
    TYPE(DOMAIN_NODES_TYPE), POINTER :: NODES_TOPOLOGY
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: FIELD_INTERPOLATED_POINT,GEOMETRIC_INTERPOLATED_POINT
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: FIELD_INTERPOLATION_PARAMETERS,GEOMETRIC_INTERPOLATION_PARAMETERS
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE,GEOMETRIC_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_INTERPOLATE_NODE",ERR,ERROR,*999)

    IF(ASSOCIATED(PHYSICAL_POINT)) THEN
      FIELD_INTERPOLATED_POINT=>PHYSICAL_POINT%FIELD_INTERPOLATED_POINT
      IF(ASSOCIATED(FIELD_INTERPOLATED_POINT)) THEN
        GEOMETRIC_INTERPOLATED_POINT=>PHYSICAL_POINT%GEOMETRIC_INTERPOLATED_POINT
        IF(ASSOCIATED(GEOMETRIC_INTERPOLATED_POINT)) THEN
          FIELD_INTERPOLATION_PARAMETERS=>FIELD_INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
          IF(ASSOCIATED(FIELD_INTERPOLATION_PARAMETERS)) THEN
            GEOMETRIC_INTERPOLATION_PARAMETERS=>GEOMETRIC_INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
            IF(ASSOCIATED(GEOMETRIC_INTERPOLATION_PARAMETERS)) THEN
              FIELD_VARIABLE=>FIELD_INTERPOLATION_PARAMETERS%FIELD_VARIABLE
              IF(ASSOCIATED(FIELD_VARIABLE)) THEN
                GEOMETRIC_VARIABLE=>GEOMETRIC_INTERPOLATION_PARAMETERS%FIELD_VARIABLE
                IF(ASSOCIATED(GEOMETRIC_VARIABLE)) THEN
                  FIELD=>FIELD_VARIABLE%FIELD
                  IF(ASSOCIATED(FIELD)) THEN            
                    CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)            
                    IF(COMPONENT_NUMBER>0.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                          NODES_TOPOLOGY=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(NODES_TOPOLOGY)) THEN
                            IF(NODE_NUMBER>0.AND.NODE_NUMBER<=NODES_TOPOLOGY%NUMBER_OF_NODES) THEN
                              ELEM_TOPOLOGY=>DOMAIN_TOPOLOGY%ELEMENTS
                              IF(ASSOCIATED(ELEM_TOPOLOGY)) THEN
                                PHYSICAL_POINT%VALUES=0.0_DP
                                IF(PHYSICAL_DERIVATIVE_TYPE==NO_PHYSICAL_DERIV) THEN
                                  NUMBER_OF_SURROUNDING_ELEMENTS=1
                                ELSE
                                  NUMBER_OF_SURROUNDING_ELEMENTS=NODES_TOPOLOGY%NODES(NODE_NUMBER)% &
                                    & NUMBER_OF_SURROUNDING_ELEMENTS
                                  PHYSICAL_POINT%VALUES=0.0_DP
                                ENDIF
                                !Loop over the elements surrounding the node
                                DO elem_idx=1,NUMBER_OF_SURROUNDING_ELEMENTS
                                  element=NODES_TOPOLOGY%NODES(NODE_NUMBER)%SURROUNDING_ELEMENTS(elem_idx)
                                  CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(PARAMETER_SET_TYPE,element, &
                                    & FIELD_INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
                                  BASIS=>ELEM_TOPOLOGY%ELEMENTS(element)%BASIS
                                  IF(ASSOCIATED(BASIS)) THEN
                                    LOCAL_NODE_NUMBER=0
                                    DO local_node_idx=1,BASIS%NUMBER_OF_NODES
                                      IF(ELEM_TOPOLOGY%ELEMENTS(element)%ELEMENT_NODES(local_node_idx)==NODE_NUMBER) THEN
                                        LOCAL_NODE_NUMBER=local_node_idx
                                        EXIT
                                      ENDIF
                                    ENDDO
                                    IF(LOCAL_NODE_NUMBER/=0) THEN
                                      CALL BASIS_LOCAL_NODE_XI_CALCULATE(BASIS,LOCAL_NODE_NUMBER,XI,ERR,ERROR,*999)  
                                      SELECT CASE(PHYSICAL_DERIVATIVE_TYPE)
                                      CASE(NO_PHYSICAL_DERIV)
                                        DO component_idx=1,FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                                          SELECT CASE(FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                                          CASE(FIELD_CONSTANT_INTERPOLATION)
                                            PHYSICAL_POINT%VALUES(component_idx)=FIELD_INTERPOLATION_PARAMETERS% &
                                              & PARAMETERS(1,component_idx)
                                          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                            PHYSICAL_POINT%VALUES(component_idx)=FIELD_INTERPOLATION_PARAMETERS% &
                                              & PARAMETERS(1,component_idx)
                                          CASE(FIELD_NODE_BASED_INTERPOLATION)
                                            PHYSICAL_POINT%VALUES(component_idx)=BASIS_INTERPOLATE_XI( &
                                              & FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR,NO_PART_DERIV, &
                                              & XI,FIELD_INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                                            IF(ERR/=0) GOTO 999
                                          CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                            CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                          CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                            CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                          CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                            CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                          CASE DEFAULT
                                            LOCAL_ERROR="The field component interpolation type of "// &
                                              & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS(component_idx)% &
                                              & INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component index "// &
                                              & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//"."
                                          END SELECT
                                        ENDDO! component_idx
                                        PHYSICAL_POINT%PHYSICAL_DERIVATIVE_TYPE=NO_PHYSICAL_DERIV
                                      CASE(GRADIENT_PHYSICAL_DERIV)
                                        DO component_idx=1,FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                                          SELECT CASE(FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                                          CASE(FIELD_CONSTANT_INTERPOLATION)
                                            !There is no gradient for constant interpolation
                                            PHYSICAL_POINT%VALUES(component_idx)=0.0_DP                                            
                                          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                            !There is no graident for element interpolation
                                            PHYSICAL_POINT%VALUES(component_idx)=0.0_DP
                                          CASE(FIELD_NODE_BASED_INTERPOLATION)
                                            CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,element, &
                                              & GEOMETRIC_INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
                                            !Now process all the first partial derivatives
                                            DO xi_idx=1,FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                                              partial_deriv_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx)
                                              !Interpolate the field
                                              FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx) = &
                                                & BASIS_INTERPOLATE_XI(FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR, &
                                                & partial_deriv_idx,XI,FIELD_INTERPOLATION_PARAMETERS%PARAMETERS(:, &
                                                & component_idx),ERR,ERROR)
                                              IF(ERR/=0) GOTO 999
                                              CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,partial_deriv_idx, &
                                                & FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx),ERR,ERROR,*999)
                                              GEOMETRIC_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx) = &
                                                & BASIS_INTERPOLATE_XI(GEOMETRIC_INTERPOLATION_PARAMETERS%BASES(component_idx)% &
                                                & PTR,partial_deriv_idx,XI,GEOMETRIC_INTERPOLATION_PARAMETERS%PARAMETERS(:, &
                                                & component_idx),ERR,ERROR)
                                              IF(ERR/=0) GOTO 999
                                              CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,partial_deriv_idx, &
                                                & GEOMETRIC_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx), &
                                                & ERR,ERROR,*999)
                                              DX_DXI(component_idx,xi_idx)=GEOMETRIC_INTERPOLATED_POINT% &
                                                & VALUES(component_idx,partial_deriv_idx)
                                            ENDDO !xi_idx
                                          CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                            CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                          CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                            CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                          CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                            CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                          CASE DEFAULT
                                            LOCAL_ERROR="The field component interpolation type of "// &
                                              & TRIM(NUMBER_TO_VSTRING(FIELD_INTERPOLATION_PARAMETERS% &
                                              & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                                              & " is invalid for component index "// &
                                              & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//"."
                                          END SELECT
                                        ENDDO! component_idx
                                        !Form the physical derivative
                                        CALL INVERT(DX_DXI,DXI_DX,DET_DX_DXI,ERR,ERROR,*999)
                                        DO component_idx=1,FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                                          DO xi_idx=1,FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                                            partial_deriv_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx)
                                            PHYSICAL_POINT%VALUES(component_idx)=PHYSICAL_POINT%VALUES(component_idx)+ &
                                              & FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx)* &
                                              & DXI_DX(xi_idx,component_idx)
                                          ENDDO !xi_idx
                                        ENDDO !component_idx
                                        PHYSICAL_POINT%PHYSICAL_DERIVATIVE_TYPE=GRADIENT_PHYSICAL_DERIV
                                      CASE DEFAULT
                                        LOCAL_ERROR="The physical derivative type of "// &
                                          & TRIM(NUMBER_TO_VSTRING(PHYSICAL_DERIVATIVE_TYPE,"*",ERR,ERROR))//" is invalid."
                                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                      END SELECT
                                    ELSE
                                      LOCAL_ERROR="Could not find the local node for node "// &
                                        & TRIM(NUMBER_TO_VSTRING(NODE_NUMBER,"*",ERR,ERROR))//" in element number "// &
                                        & TRIM(NUMBER_TO_VSTRING(element,"*",ERR,ERROR))//"."
                                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                    ENDIF
                                  ELSE
                                    LOCAL_ERROR="The basis for element "//TRIM(NUMBER_TO_VSTRING(element,"*",ERR,ERROR))// &
                                      & " is not associated."
                                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                  ENDIF
                                ENDDO !elem_idx
                                IF(PHYSICAL_DERIVATIVE_TYPE==NO_PHYSICAL_DERIV) THEN
                                  !Now calculate the average of the interpolated physical point
                                  DO component_idx=1,FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                                    CASE(FIELD_CONSTANT_INTERPOLATION)
                                      !Do nothing
                                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                      !Do nothing
                                    CASE(FIELD_NODE_BASED_INTERPOLATION)                                      
                                      PHYSICAL_POINT%VALUES(component_idx)=PHYSICAL_POINT%VALUES(component_idx)/ &
                                        & REAL(NUMBER_OF_SURROUNDING_ELEMENTS,DP)
                                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                      CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                      CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                      CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                    CASE DEFAULT
                                      LOCAL_ERROR="The field component interpolation type of "// &
                                        & TRIM(NUMBER_TO_VSTRING(FIELD_INTERPOLATION_PARAMETERS% &
                                        & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                                        & " is invalid for component index "// &
                                        & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//"."
                                    END SELECT
                                  ENDDO !component_idx
                                ENDIF
                              ELSE
                                CALL FLAG_ERROR("Domain element topology is not associated.",ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              LOCAL_ERROR="The specified node number of "//TRIM(NUMBER_TO_VSTRING(NODE_NUMBER,"*",ERR,ERROR))// &
                                & " is invalid. The node number needs to be > 0 and <= "// &
                                & TRIM(NUMBER_TO_VSTRING(NODES_TOPOLOGY%NUMBER_OF_NODES,"*",ERR,ERROR))//"."
                              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL FLAG_ERROR("Nodes topology is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)          
                      ENDIF
                    ELSE
                      LOCAL_ERROR="The specified component number of "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " is invalid. The component number must be > 0 and <= "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    CALL FLAG_ERROR("The field variable field is not associated.",ERR,ERROR,*999)
                  ENDIF
                ELSE
                  CALL FLAG_ERROR("The geometric interpolation parameters field variable is not associated.",ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FLAG_ERROR("The field interpolation parameters field variable is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FLAG_ERROR("Geometric interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
            ENDIF
          ELSE
            CALL FLAG_ERROR("Field interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Physical point geometric interpolated point is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FLAG_ERROR("Physical point field interpolated point is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Physical point is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_INTERPOLATE_NODE")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATE_NODE",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATE_NODE")
    RETURN 1
    
  END SUBROUTINE FIELD_INTERPOLATE_NODE

  !
  !================================================================================================================================
  !

  !>Interpolates a field to give the physical value of the field at a node in another field. Note that as we are at a node then we do not have any xi directions and thus we can not talk about gradients of the field wrt to xi. Because derviatives of fields can be discountinuous at a node the average derivative over all the elements surrounding the node is calculated.
  SUBROUTINE FIELD_INTERPOLATE_FIELD_NODE(PHYSICAL_DERIVATIVE_TYPE,PARAMETER_SET_TYPE,FIELD,VARIABLE_TYPE,COMPONENT_NUMBER, &
    & NODE_NUMBER,PHYSICAL_POINT,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PHYSICAL_DERIVATIVE_TYPE !<The physical derivative type of the field interpolation \see CONSTANTS_PhysicalDerivativeConstants
    INTEGER(INTG), INTENT(IN) :: PARAMETER_SET_TYPE !<The parameter set of the field to interpolate.
    TYPE(FIELD_TYPE), POINTER :: FIELD !<The field containing the node to interpolate at.
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The variable type containing the node to interpolate at
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The component number to field that contains the node to interpolate at
    INTEGER(INTG), INTENT(IN) :: NODE_NUMBER !<The node number in the field variable component to interpolate the field at
    TYPE(FIELD_PHYSICAL_POINT_TYPE), POINTER :: PHYSICAL_POINT !<The pointer to the physical point for the field. On return it will contain the values.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,element,elem_idx,LOCAL_NODE_NUMBER,local_node_idx,NUMBER_OF_SURROUNDING_ELEMENTS, &
      & partial_deriv_idx,xi_idx
    REAL(DP) :: XI(3),DX_DXI(3,3),DXI_DX(3,3),DET_DX_DXI
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: ELEM_TOPOLOGY
    TYPE(DOMAIN_NODES_TYPE), POINTER :: NODES_TOPOLOGY
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_TYPE), POINTER :: INTERP_FIELD
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: FIELD_INTERPOLATED_POINT,GEOMETRIC_INTERPOLATED_POINT
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: FIELD_INTERPOLATION_PARAMETERS,GEOMETRIC_INTERPOLATION_PARAMETERS
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE,INTERP_VARIABLE,GEOMETRIC_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_INTERPOLATE_FIELD_NODE",ERR,ERROR,*999)

    IF(ASSOCIATED(PHYSICAL_POINT)) THEN
      FIELD_INTERPOLATED_POINT=>PHYSICAL_POINT%FIELD_INTERPOLATED_POINT
      IF(ASSOCIATED(FIELD_INTERPOLATED_POINT)) THEN
        GEOMETRIC_INTERPOLATED_POINT=>PHYSICAL_POINT%GEOMETRIC_INTERPOLATED_POINT
        IF(ASSOCIATED(GEOMETRIC_INTERPOLATED_POINT)) THEN
          FIELD_INTERPOLATION_PARAMETERS=>FIELD_INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
          IF(ASSOCIATED(FIELD_INTERPOLATION_PARAMETERS)) THEN
            GEOMETRIC_INTERPOLATION_PARAMETERS=>GEOMETRIC_INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
            IF(ASSOCIATED(GEOMETRIC_INTERPOLATION_PARAMETERS)) THEN
              INTERP_VARIABLE=>FIELD_INTERPOLATION_PARAMETERS%FIELD_VARIABLE
              IF(ASSOCIATED(INTERP_VARIABLE)) THEN
                GEOMETRIC_VARIABLE=>GEOMETRIC_INTERPOLATION_PARAMETERS%FIELD_VARIABLE
                IF(ASSOCIATED(GEOMETRIC_VARIABLE)) THEN
                  INTERP_FIELD=>INTERP_VARIABLE%FIELD
                  IF(ASSOCIATED(INTERP_FIELD)) THEN
                    NULLIFY(COORDINATE_SYSTEM)
                    CALL FIELD_COORDINATE_SYSTEM_GET(INTERP_FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
                    IF(ASSOCIATED(FIELD)) THEN
                      NULLIFY(FIELD_VARIABLE)
                      CALL FIELD_VARIABLE_GET(FIELD,VARIABLE_TYPE,FIELD_VARIABLE,ERR,ERROR,*999)
                      IF(COMPONENT_NUMBER>0.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                        DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                        IF(ASSOCIATED(DOMAIN)) THEN
                          DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                          IF(ASSOCIATED(DOMAIN_TOPOLOGY)) THEN
                            NODES_TOPOLOGY=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(NODES_TOPOLOGY)) THEN
                              IF(NODE_NUMBER>0.AND.NODE_NUMBER<=NODES_TOPOLOGY%NUMBER_OF_NODES) THEN
                                ELEM_TOPOLOGY=>DOMAIN_TOPOLOGY%ELEMENTS
                                IF(ASSOCIATED(ELEM_TOPOLOGY)) THEN
                                  PHYSICAL_POINT%VALUES=0.0_DP
                                  IF(PHYSICAL_DERIVATIVE_TYPE==NO_PHYSICAL_DERIV) THEN
                                    NUMBER_OF_SURROUNDING_ELEMENTS=1
                                  ELSE
                                    NUMBER_OF_SURROUNDING_ELEMENTS=NODES_TOPOLOGY%NODES(NODE_NUMBER)% &
                                      & NUMBER_OF_SURROUNDING_ELEMENTS
                                    PHYSICAL_POINT%VALUES=0.0_DP
                                  ENDIF
                                  !Loop over the elements surrounding the node
                                  DO elem_idx=1,NUMBER_OF_SURROUNDING_ELEMENTS
                                    element=NODES_TOPOLOGY%NODES(NODE_NUMBER)%SURROUNDING_ELEMENTS(elem_idx)
                                    CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(PARAMETER_SET_TYPE,element, &
                                      & FIELD_INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
                                    BASIS=>ELEM_TOPOLOGY%ELEMENTS(element)%BASIS
                                    IF(ASSOCIATED(BASIS)) THEN
                                      LOCAL_NODE_NUMBER=0
                                      DO local_node_idx=1,BASIS%NUMBER_OF_NODES
                                        IF(ELEM_TOPOLOGY%ELEMENTS(element)%ELEMENT_NODES(local_node_idx)==NODE_NUMBER) THEN
                                          LOCAL_NODE_NUMBER=local_node_idx
                                          EXIT
                                        ENDIF
                                      ENDDO
                                      IF(LOCAL_NODE_NUMBER/=0) THEN
                                        CALL BASIS_LOCAL_NODE_XI_CALCULATE(BASIS,LOCAL_NODE_NUMBER,XI,ERR,ERROR,*999)  
                                        SELECT CASE(PHYSICAL_DERIVATIVE_TYPE)
                                        CASE(NO_PHYSICAL_DERIV)
                                          DO component_idx=1,INTERP_VARIABLE%NUMBER_OF_COMPONENTS
                                            SELECT CASE(INTERP_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                                            CASE(FIELD_CONSTANT_INTERPOLATION)
                                              PHYSICAL_POINT%VALUES(component_idx)=FIELD_INTERPOLATION_PARAMETERS% &
                                                & PARAMETERS(1,component_idx)
                                            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                              PHYSICAL_POINT%VALUES(component_idx)=FIELD_INTERPOLATION_PARAMETERS% &
                                                & PARAMETERS(1,component_idx)
                                            CASE(FIELD_NODE_BASED_INTERPOLATION)
                                              PHYSICAL_POINT%VALUES(component_idx)=BASIS_INTERPOLATE_XI( &
                                                & FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR,NO_PART_DERIV, &
                                                & XI,FIELD_INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                                              IF(ERR/=0) GOTO 999
                                            CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                            CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                            CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                            CASE DEFAULT
                                              LOCAL_ERROR="The field component interpolation type of "// &
                                                & TRIM(NUMBER_TO_VSTRING(INTERP_VARIABLE%COMPONENTS(component_idx)% &
                                                & INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component index "// &
                                                & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//"."
                                            END SELECT
                                          ENDDO! component_idx
                                          PHYSICAL_POINT%PHYSICAL_DERIVATIVE_TYPE=NO_PHYSICAL_DERIV
                                        CASE(GRADIENT_PHYSICAL_DERIV)
                                          DO component_idx=1,INTERP_VARIABLE%NUMBER_OF_COMPONENTS
                                            SELECT CASE(INTERP_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                                            CASE(FIELD_CONSTANT_INTERPOLATION)
                                              !There is no gradient for constant interpolation
                                              PHYSICAL_POINT%VALUES(component_idx)=0.0_DP
                                            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                              !There is no graident for element interpolation
                                              PHYSICAL_POINT%VALUES(component_idx)=0.0_DP
                                            CASE(FIELD_NODE_BASED_INTERPOLATION)
                                              CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,element, &
                                                & GEOMETRIC_INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
                                              !Now process all the first partial derivatives
                                              DO xi_idx=1,FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                                                partial_deriv_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx)
                                                !Interpolate the field
                                                FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx) = &
                                                  & BASIS_INTERPOLATE_XI(FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR, &
                                                  & partial_deriv_idx,XI,FIELD_INTERPOLATION_PARAMETERS%PARAMETERS(:, &
                                                  & component_idx),ERR,ERROR)
                                                IF(ERR/=0) GOTO 999
                                                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,partial_deriv_idx, &
                                                  & FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx),ERR,ERROR,*999)
                                                GEOMETRIC_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx) = &
                                                  & BASIS_INTERPOLATE_XI(GEOMETRIC_INTERPOLATION_PARAMETERS%BASES(component_idx)% &
                                                  & PTR,partial_deriv_idx,XI,GEOMETRIC_INTERPOLATION_PARAMETERS%PARAMETERS(:, &
                                                  & component_idx),ERR,ERROR)
                                                IF(ERR/=0) GOTO 999
                                                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,partial_deriv_idx, &
                                                  & GEOMETRIC_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx), &
                                                  & ERR,ERROR,*999)
                                                DX_DXI(component_idx,xi_idx)=GEOMETRIC_INTERPOLATED_POINT% &
                                                  & VALUES(component_idx,partial_deriv_idx)
                                              ENDDO !xi_idx
                                            CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                            CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                            CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                            CASE DEFAULT
                                              LOCAL_ERROR="The field component interpolation type of "// &
                                                & TRIM(NUMBER_TO_VSTRING(FIELD_INTERPOLATION_PARAMETERS% &
                                                & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                                                & " is invalid for component index "// &
                                                & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//"."
                                            END SELECT
                                          ENDDO! component_idx
                                          !Form the physical derivative
                                          CALL INVERT(DX_DXI,DXI_DX,DET_DX_DXI,ERR,ERROR,*999)
                                          DO component_idx=1,INTERP_VARIABLE%NUMBER_OF_COMPONENTS
                                            DO xi_idx=1,FIELD_INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                                              partial_deriv_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx)
                                              PHYSICAL_POINT%VALUES(component_idx)=PHYSICAL_POINT%VALUES(component_idx)+ &
                                                & FIELD_INTERPOLATED_POINT%VALUES(component_idx,partial_deriv_idx)* &
                                                & DXI_DX(xi_idx,component_idx)
                                            ENDDO !xi_idx
                                          ENDDO !component_idx
                                          PHYSICAL_POINT%PHYSICAL_DERIVATIVE_TYPE=GRADIENT_PHYSICAL_DERIV
                                        CASE DEFAULT
                                          LOCAL_ERROR="The physical derivative type of "// &
                                            & TRIM(NUMBER_TO_VSTRING(PHYSICAL_DERIVATIVE_TYPE,"*",ERR,ERROR))//" is invalid."
                                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                        END SELECT
                                      ELSE
                                        LOCAL_ERROR="Could not find the local node for node "// &
                                          & TRIM(NUMBER_TO_VSTRING(NODE_NUMBER,"*",ERR,ERROR))//" in element number "// &
                                          & TRIM(NUMBER_TO_VSTRING(element,"*",ERR,ERROR))//"."
                                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                      ENDIF
                                    ELSE
                                      LOCAL_ERROR="The basis for element "//TRIM(NUMBER_TO_VSTRING(element,"*",ERR,ERROR))// &
                                        & " is not associated."
                                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                    ENDIF
                                  ENDDO !elem_idx
                                  IF(PHYSICAL_DERIVATIVE_TYPE==NO_PHYSICAL_DERIV) THEN
                                    !Now calculate the average of the interpolated physical point
                                    DO component_idx=1,INTERP_VARIABLE%NUMBER_OF_COMPONENTS
                                      SELECT CASE(INTERP_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                                      CASE(FIELD_CONSTANT_INTERPOLATION)
                                        !Do nothing
                                      CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                        !Do nothing
                                      CASE(FIELD_NODE_BASED_INTERPOLATION)                                      
                                        PHYSICAL_POINT%VALUES(component_idx)=PHYSICAL_POINT%VALUES(component_idx)/ &
                                          & REAL(NUMBER_OF_SURROUNDING_ELEMENTS,DP)
                                      CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                        CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                      CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                        CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                      CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                        CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                      CASE DEFAULT
                                        LOCAL_ERROR="The field component interpolation type of "// &
                                          & TRIM(NUMBER_TO_VSTRING(INTERP_VARIABLE%COMPONENTS(component_idx)% &
                                          & INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                                          & " is invalid for component index "// &
                                          & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//"."
                                      END SELECT
                                    ENDDO !component_idx
                                  ENDIF
                                ELSE
                                  CALL FLAG_ERROR("Domain element topology is not associated.",ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="The specified node number of "//TRIM(NUMBER_TO_VSTRING(NODE_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid. The node number needs to be > 0 and <= "// &
                                  & TRIM(NUMBER_TO_VSTRING(NODES_TOPOLOGY%NUMBER_OF_NODES,"*",ERR,ERROR))//"."
                                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              CALL FLAG_ERROR("Nodes topology is not associated.",ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL FLAG_ERROR("Domain topology is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)          
                        ENDIF
                      ELSE
                        LOCAL_ERROR="The specified component number of "// &
                          & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid. The component number must be > 0 and <= "// &
                          & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//"."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    CALL FLAG_ERROR("The field variable field is not associated.",ERR,ERROR,*999)
                  ENDIF
                ELSE
                  CALL FLAG_ERROR("The geometric interpolation parameters field variable is not associated.",ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FLAG_ERROR("The field interpolation parameters field variable is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FLAG_ERROR("Geometric interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
            ENDIF
          ELSE
            CALL FLAG_ERROR("Field interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Physical point geometric interpolated point is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FLAG_ERROR("Physical point field interpolated point is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Physical point is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_INTERPOLATE_FIELD_NODE")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATE_FIELD_NODE",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATE_FIELD_NODE")
    RETURN 1
    
  END SUBROUTINE FIELD_INTERPOLATE_FIELD_NODE

  !
  !================================================================================================================================
  !

  !>Interpolates a field at a face gauss point to give an interpolated point. PARTIAL_DERIVATIVE_TYPE controls which partial derivatives are evaluated. If it is NO_PART_DERIV then only the field values are interpolated. If it is FIRST_PART_DERIV then the field values and first partial derivatives are interpolated. If it is SECOND_PART_DERIV the the field values and first and second partial derivatives are evaluated.
  SUBROUTINE FIELD_INTERPOLATE_LOCAL_FACE_GAUSS(PARTIAL_DERIVATIVE_TYPE,QUADRATURE_SCHEME,LOCAL_FACE_NUMBER, &
    & GAUSS_POINT_NUMBER,INTERPOLATED_POINT,ERR,ERROR,*,componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PARTIAL_DERIVATIVE_TYPE !<The partial derivative type of the provided field interpolation
    INTEGER(INTG), INTENT(IN) :: QUADRATURE_SCHEME !<The quadrature scheme of the Gauss points \see BASIS_ROUTINES_QuadratureSchemes,BASIS_ROUTINES
    INTEGER(INTG), INTENT(IN) :: LOCAL_FACE_NUMBER !<The index number of the face to interpolate on
    INTEGER(INTG), INTENT(IN) :: GAUSS_POINT_NUMBER !<The number of the face Gauss point to interpolate the field at
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: INTERPOLATED_POINT !<The pointer to the interpolated point which will contain the field interpolation information at the specified Gauss point
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: component_idx,ni,nu,startComponentIdx,endComponentIdx
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_INTERPOLATE_LOCAL_FACE_GAUSS",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINT)) THEN
      INTERPOLATION_PARAMETERS=>INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
      IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
        FIELD=>INTERPOLATION_PARAMETERS%FIELD
        IF(ASSOCIATED(FIELD)) THEN
          NULLIFY(COORDINATE_SYSTEM)
          CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
          IF(PRESENT(componentType)) THEN
            SELECT CASE(componentType)
            CASE(FIELD_ALL_COMPONENTS_TYPE)
              startComponentIdx=1
              endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR% &
                  & NUMBER_OF_COMPONENTS
              ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELSE
                LOCAL_ERROR="Field type "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                startComponentIdx=-INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)% &
                  & PTR%NUMBER_OF_COMPONENTS+1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELSE
                LOCAL_ERROR="Field type "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE DEFAULT
              LOCAL_ERROR="Interpolation component type "//TRIM(NUMBER_TO_VSTRING(componentType,"*",ERR,ERROR))//" is not valid."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            startComponentIdx=1
            endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          ENDIF
          SELECT CASE(PARTIAL_DERIVATIVE_TYPE)
          CASE(NO_PART_DERIV)
            DO component_idx=startComponentIdx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)              
              CASE(FIELD_NODE_BASED_INTERPOLATION)
!                 INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
!                   & component_idx)%PTR,NO_PART_DERIV,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER,INTERPOLATION_PARAMETERS% &
!                   & PARAMETERS(:,component_idx),ERR,ERROR)
                INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_LOCAL_FACE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
                  & component_idx)%PTR,NO_PART_DERIV,QUADRATURE_SCHEME,LOCAL_FACE_NUMBER,GAUSS_POINT_NUMBER, &
                  & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                IF(ERR/=0) GOTO 999
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//"."
              END SELECT
              CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                & ERR,ERROR,*999)
            ENDDO! component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=NO_PART_DERIV
          CASE(FIRST_PART_DERIV)
            DO component_idx=startComponentIdx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
!                 INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
!                   & component_idx)%PTR,NO_PART_DERIV,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER,INTERPOLATION_PARAMETERS% &
!                   & PARAMETERS(:,component_idx),ERR,ERROR)
                INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_LOCAL_FACE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
                  & component_idx)%PTR,NO_PART_DERIV,QUADRATURE_SCHEME,LOCAL_FACE_NUMBER,GAUSS_POINT_NUMBER, &
                  & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                IF(ERR/=0) GOTO 999
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
!                   INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS% &
!                     & BASES(component_idx)%PTR,nu,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER, &
!                     & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_LOCAL_FACE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
                  & component_idx)%PTR,nu,QUADRATURE_SCHEME,LOCAL_FACE_NUMBER,GAUSS_POINT_NUMBER, &
                  & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                  IF(ERR/=0) GOTO 999
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//"."
              END SELECT
            ENDDO! component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=FIRST_PART_DERIV
          CASE(SECOND_PART_DERIV)
            DO component_idx=startComponentIdx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process the rest of partial derivatives
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !nu
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process the rest of partial derivatives
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !nu
              CASE(FIELD_NODE_BASED_INTERPOLATION)              
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
!                   INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_GAUSS(INTERPOLATION_PARAMETERS% &
!                     & BASES(component_idx)%PTR,nu,QUADRATURE_SCHEME,GAUSS_POINT_NUMBER, &
!                     & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_LOCAL_FACE_GAUSS(INTERPOLATION_PARAMETERS%BASES( &
                  & component_idx)%PTR,nu,QUADRATURE_SCHEME,LOCAL_FACE_NUMBER,GAUSS_POINT_NUMBER, &
                  & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                  IF(ERR/=0) GOTO 999
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO! nu
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//"."
              END SELECT
            ENDDO !component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=SECOND_PART_DERIV
          CASE DEFAULT
            LOCAL_ERROR="The partial derivative type of "//TRIM(NUMBER_TO_VSTRING(PARTIAL_DERIVATIVE_TYPE,"*",ERR,ERROR))// &
              & " is invalid."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        ELSE
          CALL FLAG_ERROR("The interpolation parameters field is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FLAG_ERROR("Interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Interpolated point is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_INTERPOLATE_LOCAL_FACE_GAUSS")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATE_LOCAL_FACE_GAUSS",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATE_LOCAL_FACE_GAUSS")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATE_LOCAL_FACE_GAUSS

  !
  !================================================================================================================================
  !

  !>Interpolates a field at a xi location to give an interpolated point. XI is the element location to be interpolated at. PARTIAL_DERIVATIVE_TYPE controls which partial derivatives are evaluated. If it is NO_PART_DERIV then only the field values are interpolated. If it is FIRST_PART_DERIV then the field values and first partial derivatives are interpolated. If it is SECOND_PART_DERIV the the field values and first and second partial derivatives are evaluated. Old CMISS name PXI
  SUBROUTINE FIELD_INTERPOLATE_XI(PARTIAL_DERIVATIVE_TYPE,XI,INTERPOLATED_POINT,ERR,ERROR,*,componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PARTIAL_DERIVATIVE_TYPE !<The partial derivative type of the provide field interpolation
    REAL(DP), INTENT(IN) :: XI(:) !<XI(ni). The ni'th Xi coordinate to evaluate the field at
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: INTERPOLATED_POINT !<The pointer to the interpolated point which will contain the field interpolation information at the specified Xi point
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: component_idx,ni,nu,startComponentIdx,endComponentIdx
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_INTERPOLATE_XI",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINT)) THEN
      INTERPOLATION_PARAMETERS=>INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
      IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
        !!TODO: Fix this check. You can have less Xi directions than the mesh number of dimensions e.g., interpolating a line
        !IF(SIZE(XI,1)>=INTERPOLATION_PARAMETERS%FIELD%DECOMPOSITION%MESH%NUMBER_OF_DIMENSIONS) THEN
        FIELD=>INTERPOLATION_PARAMETERS%FIELD
        IF(ASSOCIATED(FIELD)) THEN
          NULLIFY(COORDINATE_SYSTEM)
          CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
          IF(PRESENT(componentType)) THEN
            SELECT CASE(componentType)
            CASE(FIELD_ALL_COMPONENTS_TYPE)
              startComponentIdx=1
              endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR% &
                  & NUMBER_OF_COMPONENTS
              ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELSE
                LOCAL_ERROR="Field type "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                startComponentIdx=-INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)% &
                  & PTR%NUMBER_OF_COMPONENTS+1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELSE
                LOCAL_ERROR="Field type "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            CASE DEFAULT
              LOCAL_ERROR="Interpolation component type "//TRIM(NUMBER_TO_VSTRING(componentType,"*",ERR,ERROR))//" is not valid."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            startComponentIdx=1
            endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          ENDIF
          SELECT CASE(PARTIAL_DERIVATIVE_TYPE)
          CASE(NO_PART_DERIV)
            DO component_idx=startComponentIdx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)              
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_XI(INTERPOLATION_PARAMETERS% &
                  & BASES(component_idx)%PTR,NO_PART_DERIV,XI,INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                IF(ERR/=0) GOTO 999
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//"."
              END SELECT
              CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                & ERR,ERROR,*999)
            ENDDO !component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=NO_PART_DERIV
          CASE(FIRST_PART_DERIV)
            DO component_idx=startComponentIdx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=BASIS_INTERPOLATE_XI(INTERPOLATION_PARAMETERS% &
                  & BASES(component_idx)%PTR,NO_PART_DERIV,XI,INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),ERR,ERROR)
                IF(ERR/=0) GOTO 999
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process all the first partial derivatives
                DO ni=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_XI
                  nu=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(ni)
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_XI(INTERPOLATION_PARAMETERS% &
                    & BASES(component_idx)%PTR,nu,XI,INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx), &
                    & ERR,ERROR)
                  IF(ERR/=0) GOTO 999
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !ni
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//"."
              END SELECT
            ENDDO !component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=FIRST_PART_DERIV
          CASE(SECOND_PART_DERIV)
            DO component_idx=startComponentIdx,endComponentIdx
              SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process the rest of partial derivatives
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !nu
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                !Handle the first case of no partial derivative
                INTERPOLATED_POINT%VALUES(component_idx,1)=INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)
                CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,NO_PART_DERIV,INTERPOLATED_POINT%VALUES(component_idx,1), &
                  & ERR,ERROR,*999)
                !Now process the rest of partial derivatives
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=0.0_DP
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO !nu
              CASE(FIELD_NODE_BASED_INTERPOLATION)              
                DO nu=1,INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR%NUMBER_OF_PARTIAL_DERIVATIVES
                  INTERPOLATED_POINT%VALUES(component_idx,nu)=BASIS_INTERPOLATE_XI(INTERPOLATION_PARAMETERS% &
                    & BASES(component_idx)%PTR,nu,XI,INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx), &
                    & ERR,ERROR)
                  IF(ERR/=0) GOTO 999
                  CALL COORDINATE_INTERPOLATION_ADJUST(COORDINATE_SYSTEM,nu,INTERPOLATED_POINT%VALUES(component_idx,nu), &
                    & ERR,ERROR,*999)
                ENDDO! nu
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE DEFAULT
                LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS% &
                  & FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                  & " is invalid for component index "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//"."
              END SELECT
            ENDDO !component_idx
            INTERPOLATED_POINT%PARTIAL_DERIVATIVE_TYPE=SECOND_PART_DERIV
          CASE DEFAULT
            LOCAL_ERROR="The partial derivative type of "//TRIM(NUMBER_TO_VSTRING(PARTIAL_DERIVATIVE_TYPE,"*",ERR,ERROR))// &
              & " is invalid."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        ELSE
          CALL FLAG_ERROR("The interpolation parameters field is not associated.",ERR,ERROR,*999)
        ENDIF
        !ELSE
        !  LOCAL_ERROR="Invalid number of Xi directions. The supplied Xi has "// &
        !    & TRIM(NUMBER_TO_VSTRING(SIZE(XI,1),"*",ERR,ERROR))//" directions and the required number of directions is "// &
        !    & TRIM(NUMBER_TO_VSTRING(INTERPOLATED_POINT%INTERPOLATION_PARAMETERS%FIELD%DECOMPOSITION%MESH%NUMBER_OF_DIMENSIONS, &
        !    & "*",ERR,ERROR))
        !  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        !ENDIF
      ELSE
        CALL FLAG_ERROR("Interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Interpolated point is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_INTERPOLATE_XI")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATE_XI",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATE_XI")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATE_XI

  !
  !================================================================================================================================
  !

  !>Computes the geometric position, normal and tangent vectors at a interpolated point metrics in a field. 
  SUBROUTINE FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_INT_PT_METRIC(INTERPOLATED_POINT_METRICS,reverseNormal, &
    & POSITION,NORMAL,TANGENTS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_TYPE), POINTER, INTENT(IN) :: INTERPOLATED_POINT_METRICS !<A pointer to the interpolated point metric information to calculate the position etc. for
    LOGICAL, INTENT(IN) :: reverseNormal !<Reverse normal diretion if .TRUE.
    REAL(DP), INTENT(OUT) :: POSITION(:) !<POSITION(coordinate_idx), on exit the geometric position of the node
    REAL(DP), INTENT(OUT) :: NORMAL(:) !<NORMAL(coordinate_idx), on exit the normal vector
    REAL(DP), INTENT(OUT) :: TANGENTS(:,:) !<TANGENTS(coordinate_idx,tangent_idx), on exit the tangent vectors for the tangent_idx'th tangent at the node. There are number_of_xi-1 tangent vectors.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dimension_idx,xi_idx
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: INTERPOLATED_POINT
    TYPE(VARYING_STRING) :: LOCAL_ERROR
 
    CALL ENTERS("FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_INT_PT_METRIC",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINT_METRICS)) THEN
      IF(SIZE(POSITION,1)>=INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS) THEN
        IF(SIZE(NORMAL,1)>=INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS) THEN
          IF(SIZE(TANGENTS,1)>=INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS) THEN
            IF(SIZE(TANGENTS,2)>=INTERPOLATED_POINT_METRICS%NUMBER_OF_XI_DIMENSIONS) THEN
              INTERPOLATED_POINT=>INTERPOLATED_POINT_METRICS%INTERPOLATED_POINT
              IF(ASSOCIATED(INTERPOLATED_POINT)) THEN
                POSITION=INTERPOLATED_POINT%VALUES(1:INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS,NO_PART_DERIV)
                SELECT CASE(INTERPOLATED_POINT_METRICS%NUMBER_OF_XI_DIMENSIONS)
                CASE(1) !For lines
                  NORMAL=0.0_DP
                  DO dimension_idx=1,INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS
                    TANGENTS(dimension_idx,1)=INTERPOLATED_POINT_METRICS%DX_DXI &
                      & (dimension_idx,1)
                  ENDDO !dimension_idx 
                  TANGENTS(1:INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS,1)= &
                    & NORMALISE(TANGENTS(1:INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS,1),ERR,ERROR)
                  NORMAL(1)=TANGENTS(2,1)
                  NORMAL(2)=TANGENTS(1,1)
                  IF(ERR/=0) GOTO 999     
                CASE(2) !For faces
                  NORMAL=0.0_DP
                  DO xi_idx=1,INTERPOLATED_POINT_METRICS%NUMBER_OF_XI_DIMENSIONS
                    DO dimension_idx=1,INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS
                      TANGENTS(dimension_idx,xi_idx)=INTERPOLATED_POINT_METRICS%DX_DXI(dimension_idx,xi_idx)
                    ENDDO !dimension_idx
                    TANGENTS(1:INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS,xi_idx)= &
                      & NORMALISE(TANGENTS(1:INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS,xi_idx),ERR,ERROR)
                    IF(ERR/=0) GOTO 999
                  ENDDO !xi_idx
                  CALL CROSS_PRODUCT(TANGENTS(1:INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS,1), &
                    & TANGENTS(1:INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS,2),NORMAL,ERR,ERROR,*999)
                  IF(reverseNormal) NORMAL=-NORMAL
                CASE DEFAULT
                  LOCAL_ERROR="The interpolated metrics must be for lines/faces, dimension of " &
                    & //TRIM(NUMBER_TO_VSTRING(INTERPOLATED_POINT_METRICS%NUMBER_OF_XI_DIMENSIONS,"*",ERR,ERROR))//" is invalid."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)    
                END SELECT
              ELSE
                CALL FLAG_ERROR("Interpolated point metrics interpolated point is not associted.",ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The size of the 2nd dimension of tangents of "// &
                & TRIM(NUMBER_TO_VSTRING(SIZE(TANGENTS,2),"*",ERR,ERROR))//" is too small. The size must be >= "// &
                & TRIM(NUMBER_TO_VSTRING(INTERPOLATED_POINT_METRICS%NUMBER_OF_XI_DIMENSIONS,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The size of the 1st dimension of tangents of "// &
              & TRIM(NUMBER_TO_VSTRING(SIZE(TANGENTS,1),"*",ERR,ERROR))//" is too small. The size must be >= "// &
              & TRIM(NUMBER_TO_VSTRING(INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The size of normal of "//TRIM(NUMBER_TO_VSTRING(SIZE(NORMAL,1),"*",ERR,ERROR))// &
            & " is too small. The size must be >= "// &
            & TRIM(NUMBER_TO_VSTRING(INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)          
        ENDIF
      ELSE
        LOCAL_ERROR="The size of position of "//TRIM(NUMBER_TO_VSTRING(SIZE(POSITION,1),"*",ERR,ERROR))// &
          & " is too small. The size must be >= "// &
          & TRIM(NUMBER_TO_VSTRING(INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)          
      ENDIF
    ELSE
      CALL FLAG_ERROR("Interpolated point metrics is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"Interpolated point metrics data:",ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of X dimensions = ", &
        & INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of Xi dimensions = ", &
        & INTERPOLATED_POINT_METRICS%NUMBER_OF_XI_DIMENSIONS,ERR,ERROR,*999)
      CALL WRITE_STRING_VECTOR(GENERAL_OUTPUT_TYPE,1,1,INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS,3,3, &
        & POSITION,'("  Position    :",3(X,E13.6))','(15X,3(X,E13.6))',ERR,ERROR,*999)
      CALL WRITE_STRING_VECTOR(GENERAL_OUTPUT_TYPE,1,1,INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS,3,3, &
        & NORMAL,'("  Normal      :",3(X,E13.6))','(15X,3(X,E13.6))',ERR,ERROR,*999)
      CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"  Tangents:",ERR,ERROR,*999)
      DO xi_idx=1,INTERPOLATED_POINT_METRICS%NUMBER_OF_XI_DIMENSIONS
        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Tangent : ",xi_idx,ERR,ERROR,*999)
        CALL WRITE_STRING_VECTOR(GENERAL_OUTPUT_TYPE,1,1,INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS,3,3, &
          & TANGENTS(:,xi_idx),'("      Tangent :",3(X,E13.6))','(15X,3(X,E13.6))',ERR,ERROR,*999)        
      ENDDO !xi_idx
    ENDIF
    
    CALL EXITS("FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_INT_PT_METRIC")
    RETURN
999 CALL ERRORS("FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_INT_PT_METRIC",ERR,ERROR)
    CALL EXITS("FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_INT_PT_METRIC")
    RETURN 1
  END SUBROUTINE FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_INT_PT_METRIC

  !
  !================================================================================================================================
  !

  !>Computes the geometric position, normal and tangent vectors at a node in a field. If the node is internal to the mesh the normal and tangents are zero.
  SUBROUTINE FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_NODE(FIELD,VARIABLE_TYPE,COMPONENT_NUMBER,LOCAL_NODE_NUMBER, &
    & POSITION,NORMAL,TANGENTS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: FIELD !<A pointer to the field to interpolate the geometric information for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The variable type of the node to compute the geometric information for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The component number of the node to compute the geometric information for
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to compute the geometric information for
    REAL(DP), INTENT(OUT) :: POSITION(:) !<POSITION(coordinate_idx), on exit the geometric position of the node
    REAL(DP), INTENT(OUT) :: NORMAL(:) !<NORMAL(coordinate_idx), on exit the normal vector
    REAL(DP), INTENT(OUT) :: TANGENTS(:,:) !<TANGENTS(coordinate_idx,tangent_idx), on exit the tangent vectors for the tangent_idx'th tangent at the node. There are number_of_xi-1 tangent vectors.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DIMS,INDEX_MATCH
    INTEGER(INTG) :: nic,component_idx,derivative_idx,xi_idx,element,element_idx,local_node,local_node_idx
    REAL(DP) :: XI(3), VEC(3), DXDXI(3,3) ! Note VEC, DXDXI sizes are fixed, but it doesn't matter so much
    INTEGER(INTG) :: tangent_idx,tangent_xi_idx
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: TOPOLOGY
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMP_TOPOLOGY
    TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: DECOMP_ELEMENTS
    TYPE(FIELD_TYPE), POINTER :: GEOMETRIC_FIELD
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATION_PARAMETERS(:)
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINTS(:)
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_NODE",ERR,ERROR,*999)

    NULLIFY(FIELD_VARIABLE)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        GEOMETRIC_FIELD=>FIELD%GEOMETRIC_FIELD
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            CALL FIELD_VARIABLE_GET(FIELD,VARIABLE_TYPE,FIELD_VARIABLE,ERR,ERROR,*999)
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              DIMS=GEOMETRIC_FIELD%VARIABLES(1)%NUMBER_OF_COMPONENTS !\TODO: clean this up
!               DIMS=FIELD_VARIABLE%NUMBER_OF_COMPONENTS !\TODO: clean this up
              IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=DIMS) THEN
                DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                IF(ASSOCIATED(DOMAIN)) THEN
                  TOPOLOGY=>DOMAIN%TOPOLOGY
                  IF(ASSOCIATED(TOPOLOGY)) THEN
                    DECOMPOSITION=>FIELD%DECOMPOSITION
                    IF(ASSOCIATED(DECOMPOSITION)) THEN
                      DECOMP_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                      IF(ASSOCIATED(DECOMP_TOPOLOGY)) THEN
                        DECOMP_ELEMENTS=>DECOMP_TOPOLOGY%ELEMENTS
                        IF(ASSOCIATED(DECOMP_ELEMENTS)) THEN
                          IF(SIZE(POSITION,1)>=DIMS) THEN
                            IF(SIZE(NORMAL,1)>=DIMS) THEN
                              IF(SIZE(TANGENTS,1)>=DIMS) THEN
                                IF(SIZE(DXDXI,1)>=DIMS) THEN
                                  SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                                  CASE(FIELD_CONSTANT_INTERPOLATION)
                                    LOCAL_ERROR="Cannot compute the normal at a node for component number "// &
                                      & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" for variable type "// &
                                      & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                      & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                                      & " which has constant interpolation."
                                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                  CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                    LOCAL_ERROR="Cannot compute the normal at a node for component number "// &
                                      & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" for variable type "// &
                                      & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                      & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based&
                                      & interpolation."
                                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                  CASE(FIELD_NODE_BASED_INTERPOLATION)
                                    DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                                    IF(ASSOCIATED(DOMAIN)) THEN
                                      TOPOLOGY=>DOMAIN%TOPOLOGY
                                      IF(ASSOCIATED(TOPOLOGY)) THEN
                                        DOMAIN_ELEMENTS=>TOPOLOGY%ELEMENTS
                                        IF(ASSOCIATED(DOMAIN_ELEMENTS)) THEN
                                          DOMAIN_NODES=>TOPOLOGY%NODES
                                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                                            IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=DOMAIN_NODES%NUMBER_OF_NODES) THEN
                                              !Normal & tangent will be calculated as averages in all surrounding elements. This is
                                              !because there could be discontinuity in the surface gradients across elements.
                                              POSITION(1:DIMS)=0.0_DP
                                              DXDXI=0.0_DP
                                              NORMAL(1:DIMS)=0.0_DP
                                              CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(GEOMETRIC_FIELD, &
                                                & INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
                                              CALL FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATION_PARAMETERS, &
                                                & INTERPOLATED_POINTS,ERR,ERROR,*999)
                                              DO element_idx=1,DOMAIN_NODES%NODES(LOCAL_NODE_NUMBER)%NUMBER_OF_SURROUNDING_ELEMENTS
                                                element=DOMAIN_NODES%NODES(LOCAL_NODE_NUMBER)%SURROUNDING_ELEMENTS(element_idx)
                                                BASIS=>DOMAIN_ELEMENTS%ELEMENTS(element)%BASIS
                                                !Find local node number in the basis
                                                local_node=0
                                                DO local_node_idx=1,BASIS%NUMBER_OF_NODES
                                                  IF(DOMAIN_ELEMENTS%ELEMENTS(element)%ELEMENT_NODES(local_node_idx)== &
                                                    & LOCAL_NODE_NUMBER) THEN
                                                    local_node=local_node_idx
                                                    EXIT
                                                  ENDIF
                                                ENDDO !local_node_idx
                                                !Find the xi position of the node in the element. In most cases this will be 0,1.0 etc
                                                ! but in some cases the geometric field may not contain this node in which case xi can be
                                                ! arbitrary
                                                CALL BASIS_LOCAL_NODE_XI_CALCULATE(BASIS,local_node,XI,ERR,ERROR,*999)
                                                !Interpolate the geometric field at the xi position.
                                                CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,element, &
                                                  & INTERPOLATION_PARAMETERS(FIELD_U_VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                                                CALL FIELD_INTERPOLATE_XI(FIRST_PART_DERIV,XI(1:BASIS%NUMBER_OF_XI), &
                                                  & INTERPOLATED_POINTS(FIELD_U_VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                                                !Grab the position. This shouldn't vary between elements so do it once only
                                                IF(element_idx==1) POSITION(1:DIMS)=INTERPOLATED_POINTS(FIELD_U_VARIABLE_TYPE)% &
                                                  & PTR%VALUES(1:DIMS,NO_PART_DERIV)
                                                !Get DXDXI
                                                !\todo: What if the surrounding elements have different number of xi? then DXDXI will be different in size.
                                                !       Which one do we return in that case?
                                                DO component_idx=1,DIMS
                                                  DO xi_idx=1,BASIS%NUMBER_OF_XI
                                                    derivative_idx=PARTIAL_DERIVATIVE_FIRST_DERIVATIVE_MAP(xi_idx) !2,4,7
                                                    DXDXI(component_idx,xi_idx)=INTERPOLATED_POINTS(FIELD_U_VARIABLE_TYPE)%PTR% &
                                                      & VALUES(component_idx,derivative_idx) !dx/dxi
                                                  ENDDO
                                                ENDDO
                                                !Calculate the tangents and normal vectors
                                                IF(DOMAIN_NODES%NODES(LOCAL_NODE_NUMBER)%BOUNDARY_NODE) THEN
                                                  SELECT CASE(BASIS%TYPE)
                                                  CASE(BASIS_LAGRANGE_HERMITE_TP_TYPE)
                                                    DO nic=-BASIS%NUMBER_OF_XI_COORDINATES,BASIS%NUMBER_OF_XI_COORDINATES
                                                      IF(DECOMP_ELEMENTS%ELEMENTS(element)%ADJACENT_ELEMENTS(ABS(nic))% &
                                                        & NUMBER_OF_ADJACENT_ELEMENTS==0) THEN
                                                        IF(nic>0) THEN
                                                          INDEX_MATCH=BASIS%NUMBER_OF_NODES_XIC(ABS(nic))
                                                        ELSEIF(nic<0) THEN
                                                          INDEX_MATCH=1
                                                        ENDIF
                                                        IF(BASIS%NODE_POSITION_INDEX(local_node,ABS(nic))==INDEX_MATCH) THEN
                                                          !1D/2D/3D: tangents and normal
                                                          SELECT CASE(BASIS%NUMBER_OF_XI)
                                                          CASE(1)
                                                            !There are no tangents. We can provide a normal, but no need to sum and average,
                                                            ! since in a 1D mesh, a boundary node won't be share with other elements.
                                                            NORMAL(1:DIMS)=DXDXI(1:DIMS,1)
                                                          CASE(2)
                                                            !One tangent vector, one normal vector
                                                            TANGENTS=0.0_DP
                                                            tangent_xi_idx=OTHER_XI_DIRECTIONS2(ABS(nic))
                                                            VEC(1:DIMS)=DXDXI(1:DIMS,tangent_xi_idx)
                                                            VEC(1:DIMS)=NORMALISE(VEC(1:DIMS),ERR,ERROR)
                                                            TANGENTS(1:DIMS,1)=TANGENTS(1:DIMS,1)+ &
                                                              & VEC(1:DIMS)
                                                            !Normal is the other component in DXDXI (correct?) Ensure the direction is outward
                                                            VEC(1:DIMS)=DXDXI(1:DIMS,ABS(nic))
                                                            IF(nic<0) VEC=-VEC
                                                            NORMAL(1:DIMS)=NORMAL(1:DIMS)+ &
                                                              & NORMALISE(VEC(1:DIMS),ERR,ERROR)
                                                          CASE(3)
                                                            !Two tangent vectors, one normal vector
                                                            TANGENTS=0.0_DP
                                                            DO tangent_idx=1,2
                                                              tangent_xi_idx=OTHER_XI_DIRECTIONS3(ABS(nic),tangent_idx+1,1)
                                                              VEC(1:DIMS)=DXDXI(1:DIMS,tangent_xi_idx)
                                                              VEC(1:DIMS)=NORMALISE(VEC(1:DIMS),ERR,ERROR)
                                                              TANGENTS(1:DIMS,tangent_idx)= &
                                                                & TANGENTS(1:DIMS,tangent_idx)+VEC(1:DIMS)
                                                            ENDDO
                                                            !Calculate the normal vector
                                                            CALL CROSS_PRODUCT(TANGENTS(1:DIMS,1),TANGENTS(1:DIMS,2), &
                                                              & VEC(1:DIMS),ERR,ERROR,*999)
                                                            !Yes below is compicated, but that's what it takes to get the normals pointing outwards
                                                            IF(nic<0) VEC=-VEC
                                                            IF(ABS(nic)==2) VEC=-VEC
                                                            NORMAL(1:DIMS)=NORMAL(1:DIMS)+VEC(1:DIMS)
                                                          CASE DEFAULT
                                                            !Should never happen anyway
                                                          END SELECT
                                                        ENDIF
                                                      ENDIF
                                                    ENDDO !nic
                                                  CASE(BASIS_SIMPLEX_TYPE)
                                                    CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
      !                                               DO nic=1,BASIS%NUMBER_OF_XI_COORDINATES
      !                                                 IF(DOMAIN_ELEMENTS%ELEMENTS(element)%ADJACENT_ELEMENTS(nic)% &
      !                                                   & NUMBER_OF_ADJACENT_ELEMENTS==0) THEN
      !                                                   IF(BASIS%NODE_POSITION_INDEX(local_node,nic)==1) THEN
      !                                                     !Area coordinates
      !                                                     SELECT CASE(BASIS%NUMBER-OF_XI)
      !                                                     CASE(1)
      !                                                       
      !                                                     CASE(2)
      !                                                       
      !                                                     CASE(3)
      !                                                       
      !                                                     CASE DEFAULT
      !                                                       !Will never happen anyway
      !                                                     END SELECT
      !                                                   ENDIF
      !                                                 ENDIF
      !                                               ENDDO !nic
                                                  CASE(BASIS_SERENDIPITY_TYPE)
                                                    CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                                  CASE(BASIS_AUXILLIARY_TYPE)
                                                    CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                                  CASE(BASIS_B_SPLINE_TP_TYPE)
                                                    CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                                  CASE(BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE)
                                                    CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                                  CASE(BASIS_EXTENDED_LAGRANGE_TP_TYPE)
                                                    CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                                  CASE DEFAULT
                                                    LOCAL_ERROR="The basis type of "//TRIM(NUMBER_TO_VSTRING(BASIS%TYPE, &
                                                      & "*",ERR,ERROR))//" is invalid."
                                                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                                  END SELECT
                                                ELSE
                                                  !Node is internal to the mesh. Assign zero normal and tangents
                                                  !Actually, they were already assigned to be zero at the start so do nothing.
                                                ENDIF
                                                  !Calculate tangents from DXDXI: which xi corresponds to normal direction?
                                              ENDDO !element_idx
                                              CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINTS,ERR,ERROR,*999)
                                              CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS,ERR,ERROR,*999)

                                              !Normalise the normal vector
                                              NORMAL(1:DIMS)=NORMALISE(NORMAL(1:DIMS),ERR,ERROR)
                                              !Normalise the tangent vectors
                                              DO tangent_idx=1,BASIS%NUMBER_OF_XI-1
                                                TANGENTS(1:DIMS,tangent_idx)=NORMALISE(TANGENTS(1:DIMS,tangent_idx),ERR,ERROR)
                                              ENDDO
                                            ELSE
                                              LOCAL_ERROR="The local node number of "// &
                                                & TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                                                & " is invalid for component number "// &
                                                & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                                & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                                & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                                                & ". The local node number must be > 0 and <="// &
                                                & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NUMBER_OF_NODES,"*",ERR,ERROR))//"."
                                              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                            ENDIF
                                          ELSE
                                            LOCAL_ERROR="The domain topology nodes for component number "// &
                                              & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                              & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is not associated."
                                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                          ENDIF
                                        ELSE
                                          LOCAL_ERROR="The domain topology elements for component number "// &
                                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is not associated."
                                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                        ENDIF
                                      ELSE
                                        LOCAL_ERROR="The domain topology for component number "// &
                                          & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                          & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is not associated."
                                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                      ENDIF
                                    ELSE
                                      LOCAL_ERROR="The domain for component number "// &
                                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is not associated."
                                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                    ENDIF
                                  CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                    LOCAL_ERROR="Cannot compute the normal at a node for component number "// &
                                      & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" for variable type "// &
                                      & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                      & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                                      & " which has grid point based interpolation."
                                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                  CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                    LOCAL_ERROR="Cannot compute the normal at a node for component number "// &
                                      & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" for variable type "// &
                                      & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                      & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                                      & " which has Gauss point based interpolation."
                                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                  CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                    LOCAL_ERROR="Cannot compute the normal at a node for component number "// &
                                      & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" for variable type "// &
                                      & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                      & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                                      & " which has data point based interpolation."
                                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                  CASE DEFAULT
                                    LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING &
                                      & (FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                                      & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*", &
                                      & ERR,ERROR))//" for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                  END SELECT
                                ELSE
                                  LOCAL_ERROR="The first dimension of the supplied dx/dxi array of "// &
                                    & TRIM(NUMBER_TO_VSTRING(SIZE(DXDXI,1),"*",ERR,ERROR))// &
                                    & " is too small. The first dimension of the supplied array must be >= "// &
                                    & TRIM(NUMBER_TO_VSTRING(DIMS,"*",ERR,ERROR))//"."
                                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="The first dimension of the supplied tangent array of "// &
                                  & TRIM(NUMBER_TO_VSTRING(SIZE(TANGENTS,1),"*",ERR,ERROR))// &
                                  & " is too small. The first dimension of the supplied array must be >= "// &
                                  & TRIM(NUMBER_TO_VSTRING(DIMS,"*",ERR,ERROR))//"."
                                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              LOCAL_ERROR="The size of the supplied normal array of "//TRIM(NUMBER_TO_VSTRING(SIZE(NORMAL,1), &
                                & "*",ERR,ERROR))//" is too small. The size of the supplied array must be >= "// &
                                & TRIM(NUMBER_TO_VSTRING(DIMS,"*",ERR,ERROR))//"."
                              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            LOCAL_ERROR="The size of the supplied position array of "//TRIM(NUMBER_TO_VSTRING(SIZE(POSITION,1), &
                              & "*",ERR,ERROR))//" is too small. The size of the supplied array must be >= "// &
                              & TRIM(NUMBER_TO_VSTRING(DIMS,"*",ERR,ERROR))//"."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Decomposition elements is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Decomposition topology is not associated.",ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      CALL FLAG_ERROR("Decomposition is not associated.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    CALL FLAG_ERROR("Domain topology is not associated.",ERR,ERROR,*999)
                  ENDIF
                ELSE
                  CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field component number of "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                  & " for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                  & " is invalid. The component number must be > 0 and <= "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The supplied variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The field variable type must be > 1 and <= "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The geometric field is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"Field normal at a node:",ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Field number      = ",FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Variable type     = ",VARIABLE_TYPE,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Component number  = ",COMPONENT_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Local node number = ",LOCAL_NODE_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,DIMS,3,3,POSITION, &
        & '("  Position          :",3(X,E13.6))','(21X,3(X,E13.6))',ERR,ERROR,*999)      
      CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,DIMS,3,3,NORMAL, &
        & '("  Normal            :",3(X,E13.6))','(21X,3(X,E13.6))',ERR,ERROR,*999)      
    ENDIF
    
    CALL EXITS("FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_NODE")
    RETURN
999 CALL ERRORS("FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_NODE",ERR,ERROR)
    CALL EXITS("FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_NODE")
    RETURN 1
  END SUBROUTINE FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_NODE

  !
  !================================================================================================================================
  !

  !>Finalises the interpolated point and deallocates all memory.
  SUBROUTINE FIELD_INTERPOLATED_POINT_FINALISE(INTERPOLATED_POINT,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: INTERPOLATED_POINT !<A pointer to the interpolated point to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELD_INTERPOLATED_POINT_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINT)) THEN
      IF(ALLOCATED(INTERPOLATED_POINT%VALUES)) DEALLOCATE(INTERPOLATED_POINT%VALUES)
      DEALLOCATE(INTERPOLATED_POINT)
    ENDIF

    CALL EXITS("FIELD_INTERPOLATED_POINT_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATED_POINT_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATED_POINT_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATED_POINT_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the interpolated point for an interpolation parameters
  SUBROUTINE FIELD_INTERPOLATED_POINT_INITIALISE(INTERPOLATION_PARAMETERS,INTERPOLATED_POINT,ERR,ERROR,*,componentType)

    !Argument variables
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<A pointer to the interpolation parameters to initialise the interpolated point for
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: INTERPOLATED_POINT !<On exit, A pointer to the interpolated point that has been initialised
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,NUMBER_OF_DIMENSIONS,numberOfComponents
    TYPE(VARYING_STRING) :: DUMMY_ERROR,localError

    CALL ENTERS("FIELD_INTERPOLATED_POINT_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      IF(ASSOCIATED(INTERPOLATION_PARAMETERS%FIELD)) THEN
        IF(ASSOCIATED(INTERPOLATED_POINT)) THEN
          CALL FLAG_ERROR("Interpolated point is already associated.",ERR,ERROR,*998)
        ELSE
          ALLOCATE(INTERPOLATED_POINT,STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate interpolated point",ERR,ERROR,*999)
          INTERPOLATED_POINT%INTERPOLATION_PARAMETERS=>INTERPOLATION_PARAMETERS
          NUMBER_OF_DIMENSIONS=INTERPOLATION_PARAMETERS%FIELD%DECOMPOSITION%MESH%NUMBER_OF_DIMENSIONS
          INTERPOLATED_POINT%MAX_PARTIAL_DERIVATIVE_INDEX=PARTIAL_DERIVATIVE_MAXIMUM_MAP(NUMBER_OF_DIMENSIONS)
          !Calculate the number of components for the interpolated point
          IF(PRESENT(componentType)) THEN
            SELECT CASE(componentType)
            CASE(FIELD_ALL_COMPONENTS_TYPE)
              numberOfComponents=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                numberOfComponents=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR% &
                  & NUMBER_OF_COMPONENTS
              ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                numberOfComponents=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELSE
                localError="Field type "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                numberOfComponents=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS-INTERPOLATION_PARAMETERS% &
                  & FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR%NUMBER_OF_COMPONENTS
              ELSE
                localError="Field type "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
              ENDIF
            CASE DEFAULT
              localError="Interpolation component type "//TRIM(NUMBER_TO_VSTRING(componentType,"*",ERR,ERROR))//" is not valid."
                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
            END SELECT
          ELSE !.NOT.(PRESENT(componentType)) -default all components
            numberOfComponents=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          ENDIF
          ALLOCATE(INTERPOLATED_POINT%VALUES(numberOfComponents,INTERPOLATED_POINT%MAX_PARTIAL_DERIVATIVE_INDEX),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate interpolated point values.",ERR,ERROR,*999)
          INTERPOLATED_POINT%VALUES=0.0_DP
        ENDIF
      ELSE
        CALL FLAG_ERROR("Interpolation parameters field is not associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Interpolation parameters is not associated.",ERR,ERROR,*998)
    ENDIF

    CALL EXITS("FIELD_INTERPOLATED_POINT_INITIALISE")
    RETURN
999 CALL FIELD_INTERPOLATED_POINT_FINALISE(INTERPOLATED_POINT,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("FIELD_INTERPOLATED_POINT_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATED_POINT_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATED_POINT_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises the interpolated point and deallocates all memory.
  SUBROUTINE FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINTS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINTS(:) !<A pointer to the interpolated point to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: var_type_idx

    CALL ENTERS("FIELD_INTERPOLATED_POINTS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINTS)) THEN
      DO var_type_idx=1,SIZE(INTERPOLATED_POINTS,1)
        CALL FIELD_INTERPOLATED_POINT_FINALISE(INTERPOLATED_POINTS(var_type_idx)%PTR,ERR,ERROR,*999)
      ENDDO !var_type_idx
      DEALLOCATE(INTERPOLATED_POINTS)
    ENDIF

    CALL EXITS("FIELD_INTERPOLATED_POINTS_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATED_POINTS_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATED_POINTS_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATED_POINTS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the interpolated point for an interpolation parameters
  SUBROUTINE FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATION_PARAMETERS,INTERPOLATED_POINTS,ERR,ERROR,*,componentType)

    !Argument variables
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATION_PARAMETERS(:) !<A pointer to the interpolation parameters to initialise the interpolated point for
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINTS(:) !<On exit, A pointer to the interpolated point that has been initialised
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,var_type_idx
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    CALL ENTERS("FIELD_INTERPOLATED_POINTS_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      IF(ASSOCIATED(INTERPOLATED_POINTS)) THEN
        CALL FLAG_ERROR("Interpolated point is already associated.",ERR,ERROR,*998)
      ELSE
        ALLOCATE(INTERPOLATED_POINTS(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate interpolated points",ERR,ERROR,*999)
        DO var_type_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
          NULLIFY(INTERPOLATED_POINTS(var_type_idx)%PTR)
          IF(ASSOCIATED(INTERPOLATION_PARAMETERS(var_type_idx)%PTR)) THEN
            IF(PRESENT(componentType)) THEN
              CALL FIELD_INTERPOLATED_POINT_INITIALISE(INTERPOLATION_PARAMETERS(var_type_idx)%PTR, &
                & INTERPOLATED_POINTS(var_type_idx)%PTR,ERR,ERROR,*999,componentType)
            ELSE
              CALL FIELD_INTERPOLATED_POINT_INITIALISE(INTERPOLATION_PARAMETERS(var_type_idx)%PTR, &
                & INTERPOLATED_POINTS(var_type_idx)%PTR,ERR,ERROR,*999)
            ENDIF
          ENDIF
        ENDDO !var_type_idx
      ENDIF
    ELSE
      CALL FLAG_ERROR("Interpolation parameters is not associated.",ERR,ERROR,*998)
    ENDIF

    CALL EXITS("FIELD_INTERPOLATED_POINTS_INITIALISE")
    RETURN
999 CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINTS,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("FIELD_INTERPOLATED_POINTS_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATED_POINTS_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATED_POINTS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Calculates the interpolated point metrics and the associated interpolated point
  SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_CALCULATE(JACOBIAN_TYPE,INTERPOLATED_POINT_METRICS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_TYPE), POINTER :: INTERPOLATED_POINT_METRICS !<A pointer to the interpolated point metrics
    INTEGER(INTG), INTENT(IN) :: JACOBIAN_TYPE !<The Jacobian type of the calculation \see COORDINATE_ROUTINES_JacobianTypes,COORDINATE_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: INTERPOLATED_POINT
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS

    CALL ENTERS("FIELD_INTERPOLATED_POINT_METRICS_CALCULATE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINT_METRICS)) THEN
      INTERPOLATED_POINT=>INTERPOLATED_POINT_METRICS%INTERPOLATED_POINT
      INTERPOLATION_PARAMETERS=>INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
      INTERPOLATED_POINT_METRICS%NUMBER_OF_XI_DIMENSIONS=INTERPOLATION_PARAMETERS%NUMBER_OF_XI
      FIELD=>INTERPOLATION_PARAMETERS%FIELD
      IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE.OR.FIELD%TYPE==FIELD_FIBRE_TYPE.OR.FIELD%TYPE==FIELD_GENERAL_TYPE &
          & .OR.FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
        NULLIFY(COORDINATE_SYSTEM)
        CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
        CALL COORDINATE_METRICS_CALCULATE(COORDINATE_SYSTEM,JACOBIAN_TYPE,INTERPOLATED_POINT_METRICS,ERR,ERROR,*999)
      ELSE
        CALL FLAG_ERROR("The field is not a geometric or fibre field.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Interpolated point metrics is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_INTERPOLATED_POINT_METRICS_CALCULATE")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATED_POINT_METRICS_CALCULATE",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATED_POINT_METRICS_CALCULATE")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_CALCULATE

  !
  !================================================================================================================================
  !

  !>Finalises the interpolated point metrics and deallocates all memory.
  SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_FINALISE(INTERPOLATED_POINT_METRICS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_TYPE), POINTER :: INTERPOLATED_POINT_METRICS !<A pointer to the interpolated point metrics to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELD_INTERPOLATED_POINT_METRICS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINT_METRICS)) THEN
      IF(ALLOCATED(INTERPOLATED_POINT_METRICS%GL)) DEALLOCATE(INTERPOLATED_POINT_METRICS%GL)
      IF(ALLOCATED(INTERPOLATED_POINT_METRICS%GU)) DEALLOCATE(INTERPOLATED_POINT_METRICS%GU)
      IF(ALLOCATED(INTERPOLATED_POINT_METRICS%DX_DXI)) DEALLOCATE(INTERPOLATED_POINT_METRICS%DX_DXI)
      IF(ALLOCATED(INTERPOLATED_POINT_METRICS%DXI_DX)) DEALLOCATE(INTERPOLATED_POINT_METRICS%DXI_DX)
      DEALLOCATE(INTERPOLATED_POINT_METRICS)
    ENDIF

    CALL EXITS("FIELD_INTERPOLATED_POINT_METRICS_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATED_POINT_METRICS_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATED_POINT_METRICS_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the interpolated point metrics for an interpolated point.
  SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_INITIALISE(INTERPOLATED_POINT,INTERPOLATED_POINT_METRICS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: INTERPOLATED_POINT !A pointer to the interpolated point to initliase the interpolated point metrics for
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_TYPE), POINTER :: INTERPOLATED_POINT_METRICS !<On exit, a pointer to the interpolated point metrics that have been initialised
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: NUMBER_OF_XI_DIMENSIONS,NUMBER_OF_X_DIMENSIONS
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: DUMMY_ERROR !,LOCAL_ERROR

    CALL ENTERS("FIELD_INTERPOLATED_POINT_METRICS_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINT)) THEN
      IF(ASSOCIATED(INTERPOLATED_POINT_METRICS)) THEN
        CALL FLAG_ERROR("Interpolated point metrics is already associated.",ERR,ERROR,*998)
      ELSE
        NULLIFY(COORDINATE_SYSTEM)
        CALL FIELD_COORDINATE_SYSTEM_GET(INTERPOLATED_POINT%INTERPOLATION_PARAMETERS%FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
        NUMBER_OF_X_DIMENSIONS=COORDINATE_SYSTEM%NUMBER_OF_DIMENSIONS
        NUMBER_OF_XI_DIMENSIONS=INTERPOLATED_POINT%INTERPOLATION_PARAMETERS%FIELD%DECOMPOSITION%MESH%NUMBER_OF_DIMENSIONS
        !Size of interpolated point values may be greater than number of x dimensions, as FIELD_GEOMETRIC_GENERAL_TYPE
        !fields can have geometric components and then other non-geometric components, eg. for dependent fields with
        !geometric components.
        IF(NUMBER_OF_X_DIMENSIONS<=SIZE(INTERPOLATED_POINT%VALUES,1)) THEN
          ALLOCATE(INTERPOLATED_POINT_METRICS,STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate interpolated point metrics.",ERR,ERROR,*999)
          ALLOCATE(INTERPOLATED_POINT_METRICS%GL(NUMBER_OF_XI_DIMENSIONS,NUMBER_OF_XI_DIMENSIONS),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate interpolated point metrics convariant tensor.",ERR,ERROR,*999)
          ALLOCATE(INTERPOLATED_POINT_METRICS%GU(NUMBER_OF_XI_DIMENSIONS,NUMBER_OF_XI_DIMENSIONS),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate interpolated point metrics contravariant tensor.",ERR,ERROR,*999)
          ALLOCATE(INTERPOLATED_POINT_METRICS%DX_DXI(NUMBER_OF_X_DIMENSIONS,NUMBER_OF_XI_DIMENSIONS),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate interpolated point metrics dX_dXi.",ERR,ERROR,*999)
          ALLOCATE(INTERPOLATED_POINT_METRICS%DXI_DX(NUMBER_OF_XI_DIMENSIONS,NUMBER_OF_X_DIMENSIONS),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate interpolated point metrics dXi_dX.",ERR,ERROR,*999)
          INTERPOLATED_POINT_METRICS%INTERPOLATED_POINT=>INTERPOLATED_POINT
          INTERPOLATED_POINT_METRICS%NUMBER_OF_X_DIMENSIONS=NUMBER_OF_X_DIMENSIONS
          INTERPOLATED_POINT_METRICS%NUMBER_OF_XI_DIMENSIONS=NUMBER_OF_XI_DIMENSIONS
          INTERPOLATED_POINT_METRICS%GL=0.0_DP
          INTERPOLATED_POINT_METRICS%GU=0.0_DP
          INTERPOLATED_POINT_METRICS%DX_DXI=0.0_DP
          INTERPOLATED_POINT_METRICS%DXI_DX=0.0_DP
          INTERPOLATED_POINT_METRICS%JACOBIAN=0.0_DP
          INTERPOLATED_POINT_METRICS%JACOBIAN_TYPE=0
         !For now don't flag an error if the number of xi dimensions doesn't match the number of x dimensions.
         !Simply do not allocate the metrics information.
!        ELSE
!          LOCAL_ERROR="The number of coordinate dimensions ("//TRIM(NUMBER_TO_VSTRING(NUMBER_OF_X_DIMENSIONS,"*",ERR,ERROR))// &
!            & ") does not match the number of components of the interpolated point ("// &
!            & TRIM(NUMBER_TO_VSTRING(SIZE(INTERPOLATED_POINT%VALUES,1),"*",ERR,ERROR))//")."
!          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*998)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Interpolation point is not associated.",ERR,ERROR,*998)
    ENDIF

    CALL EXITS("FIELD_INTERPOLATED_POINT_METRICS_INITIALISE")
    RETURN
999 CALL FIELD_INTERPOLATED_POINT_METRICS_FINALISE(INTERPOLATED_POINT_METRICS,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("FIELD_INTERPOLATED_POINT_METRICS_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATED_POINT_METRICS_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATED_POINT_METRICS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises the interpolated point metrics and deallocates all memory.
  SUBROUTINE FIELD_INTERPOLATED_POINTS_METRICS_FINALISE(INTERPOLATED_POINTS_METRICS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: INTERPOLATED_POINTS_METRICS(:) !<A pointer to the interpolated point metrics to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: var_type_idx

    CALL ENTERS("FIELD_INTERPOLATED_POINTS_METRICS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINTS_METRICS)) THEN
      DO var_type_idx=1,SIZE(INTERPOLATED_POINTS_METRICS,1)
        CALL FIELD_INTERPOLATED_POINT_METRICS_FINALISE(INTERPOLATED_POINTS_METRICS(var_type_idx)%PTR,ERR,ERROR,*999)
      ENDDO !var_type_idx
      DEALLOCATE(INTERPOLATED_POINTS_METRICS)
    ENDIF

    CALL EXITS("FIELD_INTERPOLATED_POINTS_METRICS_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATED_POINTS_METRICS_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATED_POINTS_METRICS_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATED_POINTS_METRICS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the interpolated point metrics for an interpolated point.
  SUBROUTINE FIELD_INTERPOLATED_POINTS_METRICS_INITIALISE(INTERPOLATED_POINTS,INTERPOLATED_POINTS_METRICS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINTS(:) !A pointer to the interpolated pointS to initliase the interpolated point metrics for
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: INTERPOLATED_POINTS_METRICS(:) !<On exit, a pointer to the interpolated point metrics that have been initialised
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variableTypeIdx,DUMMY_ERR
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    CALL ENTERS("FIELD_INTERPOLATED_POINTS_METRICS_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATED_POINTS)) THEN
      IF(ASSOCIATED(INTERPOLATED_POINTS_METRICS)) THEN
        CALL FLAG_ERROR("Interpolated point metrics is already associated.",ERR,ERROR,*998)
      ELSE
        ALLOCATE(INTERPOLATED_POINTS_METRICS(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate interpolated points metrics.",ERR,ERROR,*999)
        !Nullify all pointers first so that finalise does not fail on error condition half way through the next loop
        DO variableTypeIdx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
          NULLIFY(INTERPOLATED_POINTS_METRICS(variableTypeIdx)%PTR)          
        ENDDO !variableTypeIdx
        DO variableTypeIdx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
          IF(ASSOCIATED(INTERPOLATED_POINTS(variableTypeIdx)%PTR)) &
            & CALL FIELD_INTERPOLATED_POINT_METRICS_INITIALISE(INTERPOLATED_POINTS(variableTypeIdx)%PTR, &
            & INTERPOLATED_POINTS_METRICS(variableTypeIdx)%PTR,ERR,ERROR,*999)
        ENDDO !variableTypeIdx
      ENDIF
    ELSE
      CALL FLAG_ERROR("Interpolation points is not associated.",ERR,ERROR,*998)
    ENDIF

    CALL EXITS("FIELD_INTERPOLATED_POINTS_METRICS_INITIALISE")
    RETURN
999 CALL FIELD_INTERPOLATED_POINTS_METRICS_FINALISE(INTERPOLATED_POINTS_METRICS,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("FIELD_INTERPOLATED_POINTS_METRICS_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATED_POINTS_METRICS_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATED_POINTS_METRICS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises the interpolation parameters and deallocates all memory
  SUBROUTINE FIELD_INTERPOLATION_PARAMETER_FINALISE(INTERPOLATION_PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<A pointer to the interpolation parameters to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELD_INTERPOLATION_PARAMETER_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      IF(ALLOCATED(INTERPOLATION_PARAMETERS%BASES)) DEALLOCATE(INTERPOLATION_PARAMETERS%BASES)
      IF(ALLOCATED(INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS)) DEALLOCATE(INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS)
      IF(ALLOCATED(INTERPOLATION_PARAMETERS%PARAMETERS)) DEALLOCATE(INTERPOLATION_PARAMETERS%PARAMETERS)
      IF(ALLOCATED(INTERPOLATION_PARAMETERS%SCALE_FACTORS)) DEALLOCATE(INTERPOLATION_PARAMETERS%SCALE_FACTORS)      
      DEALLOCATE(INTERPOLATION_PARAMETERS)
    ENDIF

    CALL EXITS("FIELD_INTERPOLATION_PARAMETER_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATION_PARAMETER_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATION_PARAMETER_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETER_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the interpolation parameters for all the variables in a field.
  SUBROUTINE FIELD_INTERPOLATION_PARAMETER_INITIALISE(FIELD_VARIABLE,INTERPOLATION_PARAMETERS,ERR,ERROR,*,componentType)

    !Argument variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE !<A pointer to the field to initialise the interpolation parameters for
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<On exit, a pointer to the initialised interpolation parameters. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: component_idx,DUMMY_ERR,numberOfComponents

    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(VARYING_STRING) :: DUMMY_ERROR,localError

    CALL ENTERS("FIELD_INTERPOLATION_PARAMETER_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELD_VARIABLE)) THEN
      FIELD=>FIELD_VARIABLE%FIELD
      IF(ASSOCIATED(FIELD)) THEN
        IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
          CALL FLAG_ERROR("Interpolation parameters is already associated.",ERR,ERROR,*998)
        ELSE
          ALLOCATE(INTERPOLATION_PARAMETERS,STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate an interpolation parameter.",ERR,ERROR,*999)
          INTERPOLATION_PARAMETERS%FIELD=>FIELD
          INTERPOLATION_PARAMETERS%FIELD_VARIABLE=>FIELD_VARIABLE
          INTERPOLATION_PARAMETERS%NUMBER_OF_XI=0
          !Calculate the number of components required 
          IF(PRESENT(componentType)) THEN
            SELECT CASE(componentType)
            CASE(FIELD_ALL_COMPONENTS_TYPE)
              numberOfComponents=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                numberOfComponents=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR% &
                  & NUMBER_OF_COMPONENTS
              ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                numberOfComponents=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              ELSE
                localError="Field type "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
              ENDIF
            CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
              IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                numberOfComponents=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS-INTERPOLATION_PARAMETERS% &
                  & FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR%NUMBER_OF_COMPONENTS
              ELSE
                localError="Field type "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                  & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
              ENDIF
            CASE DEFAULT
              localError="Interpolation component type "//TRIM(NUMBER_TO_VSTRING(componentType,"*",ERR,ERROR))//" is not valid."
                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
            END SELECT
          ELSE
            numberOfComponents=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          ENDIF
          ALLOCATE(INTERPOLATION_PARAMETERS%BASES(numberOfComponents),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate bases.",ERR,ERROR,*999)
          ALLOCATE(INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(numberOfComponents),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate interpolation type.",ERR,ERROR,*999)
          ALLOCATE(INTERPOLATION_PARAMETERS%PARAMETERS(FIELD_VARIABLE%maxNumberElementInterpolationParameters, &
            & numberOfComponents),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate parameters.",ERR,ERROR,*999)
          INTERPOLATION_PARAMETERS%PARAMETERS=0.0_DP
          IF(FIELD%SCALINGS%SCALING_TYPE/=FIELD_NO_SCALING) THEN
            ALLOCATE(INTERPOLATION_PARAMETERS%SCALE_FACTORS(FIELD_VARIABLE%maxNumberElementInterpolationParameters, &
              & numberOfComponents),STAT=ERR)
            IF(ERR/=0) CALL FLAG_ERROR("Could not allocate scale factors.",ERR,ERROR,*999)
            INTERPOLATION_PARAMETERS%SCALE_FACTORS=0.0_DP
          ENDIF
          DO component_idx=1,numberOfComponents
            NULLIFY(INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR)
          ENDDO !component_idx
          INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS=0
        ENDIF
      ELSE
        CALL FLAG_ERROR("Field variable field is not associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*998)
    ENDIF

    CALL EXITS("FIELD_INTERPOLATION_PARAMETER_INITIALISE")
    RETURN
999 CALL FIELD_INTERPOLATION_PARAMETER_FINALISE(INTERPOLATION_PARAMETERS,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("FIELD_INTERPOLATION_PARAMETER_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATION_PARAMETER_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETER_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets the interpolation parameters for a particular element. Old CMISS name XPXE, ZPZE
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(PARAMETER_SET_TYPE,ELEMENT_NUMBER,INTERPOLATION_PARAMETERS,ERR,ERROR,*, &
      & componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PARAMETER_SET_TYPE !<The field parameter set type to get the element parameters for
    INTEGER(INTG), INTENT(IN) :: ELEMENT_NUMBER !<The element number to get the element parameters for
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: component_idx,local_derivative_idx,version_idx,global_derivative_idx,element_node_idx,node_idx, &
      & element_parameter_idx,dof_idx,node_scaling_dof_idx,scaling_idx,startComponentIdx,endComponentIdx
    REAL(DP), POINTER :: FIELD_PARAMETER_SET_DATA(:),SCALE_FACTORS(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: ELEMENTS_TOPOLOGY
    TYPE(DOMAIN_NODES_TYPE), POINTER :: NODES_TOPOLOGY
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      IF(PARAMETER_SET_TYPE>0.AND.PARAMETER_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
        PARAMETER_SET=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(PARAMETER_SET_TYPE)%PTR
        IF(ASSOCIATED(PARAMETER_SET)) THEN
          NULLIFY(FIELD_PARAMETER_SET_DATA)
          CALL DISTRIBUTED_VECTOR_DATA_GET(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,ERR,ERROR,*999)
          FIELD=>INTERPOLATION_PARAMETERS%FIELD
          IF(ASSOCIATED(FIELD)) THEN
            NULLIFY(COORDINATE_SYSTEM)
            CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
            IF(PRESENT(componentType)) THEN
              SELECT CASE(componentType)
              CASE(FIELD_ALL_COMPONENTS_TYPE)
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
                IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                  startComponentIdx=1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR% &
                    & NUMBER_OF_COMPONENTS
                ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                  startComponentIdx=1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                ELSE
                  LOCAL_ERROR="Field type "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                    & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
                IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                  startComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)% &
                    & PTR%NUMBER_OF_COMPONENTS+1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                ELSE
                  LOCAL_ERROR="Field type "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                    & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE DEFAULT
                LOCAL_ERROR="Interpolation component type "//TRIM(NUMBER_TO_VSTRING(componentType,"*",ERR,ERROR))//" is not valid."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              startComponentIdx=1
              endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            ENDIF
            DO component_idx=startComponentIdx,endComponentIdx
              ELEMENTS_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%ELEMENTS
              IF(ELEMENT_NUMBER>0.AND.ELEMENT_NUMBER<=ELEMENTS_TOPOLOGY%TOTAL_NUMBER_OF_ELEMENTS) THEN
                BASIS=>ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%BASIS
                INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR=>BASIS
                IF(component_idx==1) THEN
                  INTERPOLATION_PARAMETERS%NUMBER_OF_XI=BASIS%NUMBER_OF_XI
                ELSE
                  IF(BASIS%NUMBER_OF_XI/=INTERPOLATION_PARAMETERS%NUMBER_OF_XI) &
                    & CALL FLAG_ERROR("Inconsistent number of xi directions???",ERR,ERROR,*999)
                ENDIF
                SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                CASE(FIELD_CONSTANT_INTERPOLATION)
                  dof_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% &
                    & CONSTANT_PARAM2DOF_MAP
                  INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
                  INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)
                CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                  dof_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% &
                    & ELEMENT_PARAM2DOF_MAP%ELEMENTS(ELEMENT_NUMBER)
                  INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
                  INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)
                CASE(FIELD_NODE_BASED_INTERPOLATION)
                  ELEMENTS_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%ELEMENTS
                  NODES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%NODES
                  INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=BASIS%NUMBER_OF_ELEMENT_PARAMETERS
                  SELECT CASE(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALING_TYPE)
                  CASE(FIELD_NO_SCALING)
                    DO element_node_idx=1,BASIS%NUMBER_OF_NODES
                      node_idx=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%ELEMENT_NODES(element_node_idx)
                      DO local_derivative_idx=1,BASIS%NUMBER_OF_DERIVATIVES(element_node_idx)
                        global_derivative_idx=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%ELEMENT_DERIVATIVES( &
                          & local_derivative_idx,element_node_idx)
                        version_idx=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%elementVersions(local_derivative_idx, &
                          & element_node_idx)
                        element_parameter_idx=BASIS%ELEMENT_PARAMETER_INDEX(local_derivative_idx,element_node_idx)
                        dof_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% &
                          & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(global_derivative_idx)%VERSIONS(version_idx)
                        INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)
                      ENDDO !local_derivative_idx
                    ENDDO !element_node_idx
                CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
                    scaling_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%SCALING_INDEX
                    NULLIFY(SCALE_FACTORS)
                    CALL DISTRIBUTED_VECTOR_DATA_GET(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                      & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
                    DO element_node_idx=1,BASIS%NUMBER_OF_NODES
                      node_idx=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%ELEMENT_NODES(element_node_idx)
                      DO local_derivative_idx=1,BASIS%NUMBER_OF_DERIVATIVES(element_node_idx)
                        global_derivative_idx=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%ELEMENT_DERIVATIVES( & 
                          & local_derivative_idx,element_node_idx)
                        version_idx=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%elementVersions( &
                          & local_derivative_idx,element_node_idx)
                        element_parameter_idx=BASIS%ELEMENT_PARAMETER_INDEX(global_derivative_idx,element_node_idx)
                        dof_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% &
                          & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(global_derivative_idx)%VERSIONS(version_idx)
                        node_scaling_dof_idx= &
                            & NODES_TOPOLOGY%NODES(node_idx)%DERIVATIVES(global_derivative_idx)%DOF_INDEX(version_idx)
                        !INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)* &
                        !  & INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)%SCALE_FACTORS(element_parameter_idx,ELEMENT_NUMBER)
                        !INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)* &
                        !  & INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)%SCALE_FACTORS(global_derivative_idx,node_idx)
                        INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA( &
                          & dof_idx)*SCALE_FACTORS(node_scaling_dof_idx)
                        INTERPOLATION_PARAMETERS%SCALE_FACTORS(element_parameter_idx,component_idx)=SCALE_FACTORS( &
                          & node_scaling_dof_idx)
                      ENDDO !local_derivative_idx
                    ENDDO !element_node_idx
                    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                      & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
                  CASE(FIELD_ARC_LENGTH_SCALING)
                    CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                  CASE DEFAULT
                    LOCAL_ERROR="The scaling type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%SCALINGS% &
                      & SCALING_TYPE,"*",ERR,ERROR))//" is invalid for field number "// &
                      & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  END SELECT
                CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                  CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                  CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                CASE DEFAULT
                  LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
                    & COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                    & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//" of field number "// &
                    & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ELSE
                LOCAL_ERROR="The element number of "//TRIM(NUMBER_TO_VSTRING(ELEMENT_NUMBER,"*",ERR,ERROR))// &
                  & " is invalid. The number must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(ELEMENTS_TOPOLOGY%TOTAL_NUMBER_OF_ELEMENTS,"*",ERR,ERROR))// &
                  & " for component number "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ENDDO !component_idx
            CALL COORDINATE_INTERPOLATION_PARAMETERS_ADJUST(COORDINATE_SYSTEM,INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
          ELSE
            CALL FLAG_ERROR("The interpolation parameters field is not associated.",ERR,ERROR,*999)
          ENDIF
          CALL DISTRIBUTED_VECTOR_DATA_RESTORE(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,ERR,ERROR,*999)
        ELSE
          LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(PARAMETER_SET_TYPE,"*",ERR,ERROR))// &
            & " has not been created for field number "// &
            & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(PARAMETER_SET_TYPE,"*",ERR,ERROR))// &
          & " is invalid. The number must be between 1 and "//TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))// &
          & " for field number "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Interpolation parameters is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation parameters:",ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & VARIABLE_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Parameter set type = ",PARAMETER_SET_TYPE,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Element number = ",ELEMENT_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of components = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
      DO component_idx=startComponentIdx,endComponentIdx
        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,ERR,ERROR,*999)
        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & NUMBER_OF_PARAMETERS(component_idx),ERR,ERROR,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),'("      Parameters :",4(X,E13.6))','(18X,4(X,E13.6))', &
          & ERR,ERROR,*999)
      ENDDO !component_idx
    ENDIF

    CALL EXITS("FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET

  !
  !================================================================================================================================
  !

  !>Finalises the interpolation parameters and deallocates all memory
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATION_PARAMETERS(:) !<A pointer to the interpolation parameters to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: var_type_idx

    CALL ENTERS("FIELD_INTERPOLATION_PARAMETERS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      DO var_type_idx=1,SIZE(INTERPOLATION_PARAMETERS,1)       
        CALL FIELD_INTERPOLATION_PARAMETER_FINALISE(INTERPOLATION_PARAMETERS(var_type_idx)%PTR,ERR,ERROR,*999)
      ENDDO !var_type_idx           
      DEALLOCATE(INTERPOLATION_PARAMETERS)
    ENDIF

    CALL EXITS("FIELD_INTERPOLATION_PARAMETERS_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATION_PARAMETERS_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATION_PARAMETERS_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the interpolation parameters for all the variables in a field.
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_INITIALISE(FIELD,INTERPOLATION_PARAMETERS,ERR,ERROR,*,componentType)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the interpolation parameters for
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATION_PARAMETERS(:) !<On exit, a pointer to the initialised interpolation parameters.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to interpolate
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,var_type_idx
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR

    CALL ENTERS("FIELD_INTERPOLATION_PARAMETERS_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
          CALL FLAG_ERROR("Interpolation parameters is already associated.",ERR,ERROR,*998)
        ELSE
          ALLOCATE(INTERPOLATION_PARAMETERS(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate the interpolation parameters.",ERR,ERROR,*999)
          DO var_type_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
            NULLIFY(INTERPOLATION_PARAMETERS(var_type_idx)%PTR)
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(var_type_idx)%PTR
            IF(PRESENT(componentType)) THEN
              IF(ASSOCIATED(FIELD_VARIABLE)) CALL FIELD_INTERPOLATION_PARAMETER_INITIALISE(FIELD_VARIABLE, &
                & INTERPOLATION_PARAMETERS(var_type_idx)%PTR,ERR,ERROR,*999,componentType)
            ELSE
              IF(ASSOCIATED(FIELD_VARIABLE)) CALL FIELD_INTERPOLATION_PARAMETER_INITIALISE(FIELD_VARIABLE, &
                & INTERPOLATION_PARAMETERS(var_type_idx)%PTR,ERR,ERROR,*999)
            ENDIF
          ENDDO !var_type_idx
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*998)
    ENDIF

    CALL EXITS("FIELD_INTERPOLATION_PARAMETERS_INITIALISE")
    RETURN
999 CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("FIELD_INTERPOLATION_PARAMETERS_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATION_PARAMETERS_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets the interpolation parameters for a particular line. Old CMISS name XPXE, ZPZE
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_LINE_GET(PARAMETER_SET_TYPE,LINE_NUMBER,INTERPOLATION_PARAMETERS,ERR,ERROR,*, &
      & componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PARAMETER_SET_TYPE !<The field parameter set type to get the line parameters for
    INTEGER(INTG), INTENT(IN) :: LINE_NUMBER !<The line number to get the line parameters for
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to get the interpolation parameters for
    !Local Variables
    INTEGER(INTG) :: component_idx,basis_derivative_idx,derivative_idx,basis_node_idx,version_idx,node_idx,element_parameter_idx, &
      & dof_idx,node_scaling_dof_idx,scaling_idx,startComponentIdx,endComponentIdx
    REAL(DP), POINTER :: FIELD_PARAMETER_SET_DATA(:),SCALE_FACTORS(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(DOMAIN_LINES_TYPE), POINTER :: LINES_TOPOLOGY
    TYPE(DOMAIN_NODES_TYPE), POINTER :: NODES_TOPOLOGY
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_INTERPOLATION_PARAMETERS_LINE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      IF(PARAMETER_SET_TYPE>0.AND.PARAMETER_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
        PARAMETER_SET=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(PARAMETER_SET_TYPE)%PTR
        IF(ASSOCIATED(PARAMETER_SET)) THEN
          NULLIFY(FIELD_PARAMETER_SET_DATA)
          CALL DISTRIBUTED_VECTOR_DATA_GET(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,ERR,ERROR,*999)
          FIELD=>INTERPOLATION_PARAMETERS%FIELD
          IF(ASSOCIATED(FIELD)) THEN
            NULLIFY(COORDINATE_SYSTEM)
            CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
            IF(PRESENT(componentType)) THEN
              SELECT CASE(componentType)
              CASE(FIELD_ALL_COMPONENTS_TYPE)
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
                IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                  startComponentIdx=1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR% &
                    & NUMBER_OF_COMPONENTS
                ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                  startComponentIdx=1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                ELSE
                  LOCAL_ERROR="Field type "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                    & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
                IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                  startComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)% &
                    & PTR%NUMBER_OF_COMPONENTS+1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                ELSE
                  LOCAL_ERROR="Field type "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                    & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE DEFAULT
                LOCAL_ERROR="Interpolation component type "//TRIM(NUMBER_TO_VSTRING(componentType,"*",ERR,ERROR))//" is not valid."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              startComponentIdx=1
              endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            ENDIF
            DO component_idx=startComponentIdx,endComponentIdx
              LINES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%LINES
              IF(LINE_NUMBER>0.AND.LINE_NUMBER<=LINES_TOPOLOGY%NUMBER_OF_LINES) THEN
                BASIS=>LINES_TOPOLOGY%LINES(LINE_NUMBER)%BASIS
                INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR=>BASIS
                IF(component_idx==1) THEN
                  INTERPOLATION_PARAMETERS%NUMBER_OF_XI=BASIS%NUMBER_OF_XI
                ELSE
                  IF(BASIS%NUMBER_OF_XI/=INTERPOLATION_PARAMETERS%NUMBER_OF_XI) &
                    & CALL FLAG_ERROR("Inconsistent number of xi directions???",ERR,ERROR,*999)
                ENDIF
                SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                CASE(FIELD_CONSTANT_INTERPOLATION)
                  CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                  CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_NODE_BASED_INTERPOLATION)
                  NODES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%NODES
                  INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=BASIS%NUMBER_OF_ELEMENT_PARAMETERS
                  SELECT CASE(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALING_TYPE)
                  CASE(FIELD_NO_SCALING)
                    DO basis_node_idx=1,BASIS%NUMBER_OF_NODES
                      node_idx=LINES_TOPOLOGY%LINES(LINE_NUMBER)%NODES_IN_LINE(basis_node_idx)
                      DO basis_derivative_idx=1,BASIS%NUMBER_OF_DERIVATIVES(basis_node_idx)
                        derivative_idx=LINES_TOPOLOGY%LINES(LINE_NUMBER)%DERIVATIVES_IN_LINE(1,basis_derivative_idx,basis_node_idx)
                        version_idx=LINES_TOPOLOGY%LINES(LINE_NUMBER)%DERIVATIVES_IN_LINE(2,basis_derivative_idx,basis_node_idx)
                        element_parameter_idx=BASIS%ELEMENT_PARAMETER_INDEX(basis_derivative_idx,basis_node_idx)
                        dof_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% &
                          & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                        INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)
                      ENDDO !basis_derivative_idx
                    ENDDO !basis_node_idx
                  CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
                    scaling_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%SCALING_INDEX
                    NULLIFY(SCALE_FACTORS)
                    CALL DISTRIBUTED_VECTOR_DATA_GET(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                      & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
                    DO basis_node_idx=1,BASIS%NUMBER_OF_NODES
                      node_idx=LINES_TOPOLOGY%LINES(LINE_NUMBER)%NODES_IN_LINE(basis_node_idx)
                      DO basis_derivative_idx=1,BASIS%NUMBER_OF_DERIVATIVES(basis_node_idx)
                        derivative_idx=LINES_TOPOLOGY%LINES(LINE_NUMBER)%DERIVATIVES_IN_LINE(1,basis_derivative_idx,basis_node_idx)
                        version_idx=LINES_TOPOLOGY%LINES(LINE_NUMBER)%DERIVATIVES_IN_LINE(2,basis_derivative_idx,basis_node_idx)
                        element_parameter_idx=BASIS%ELEMENT_PARAMETER_INDEX(basis_derivative_idx,basis_node_idx)
                        dof_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% &
                          & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                        node_scaling_dof_idx= &
                            & NODES_TOPOLOGY%NODES(node_idx)%DERIVATIVES(derivative_idx)%DOF_INDEX(version_idx)
                        !INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)* &
                        !  & INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)%SCALE_FACTORS(derivative_idx,node_idx)
                        INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)= &
                          & FIELD_PARAMETER_SET_DATA(dof_idx)*SCALE_FACTORS(node_scaling_dof_idx)
                        INTERPOLATION_PARAMETERS%SCALE_FACTORS(element_parameter_idx,component_idx)= &
                          & SCALE_FACTORS(node_scaling_dof_idx)
                      ENDDO !basis_derivative_idx
                    ENDDO !basis_node_idx
                  CASE(FIELD_ARC_LENGTH_SCALING)
                    CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                  CASE DEFAULT
                    LOCAL_ERROR="The scaling type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%SCALINGS% &
                      & SCALING_TYPE,"*",ERR,ERROR))//" is invalid for field number "// &
                      & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  END SELECT
                 CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                  CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                  CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                  CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                CASE DEFAULT
                  LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
                    & COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                    & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//" of field number "// &
                    & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ELSE
                LOCAL_ERROR="The line number of "//TRIM(NUMBER_TO_VSTRING(LINE_NUMBER,"*",ERR,ERROR))// &
                  & " is invalid. The number must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(LINES_TOPOLOGY%NUMBER_OF_LINES,"*",ERR,ERROR))// &
                  & " for component number "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)

              ENDIF
            ENDDO !component_idx
            CALL COORDINATE_INTERPOLATION_PARAMETERS_ADJUST(COORDINATE_SYSTEM,INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
          ELSE
            CALL FLAG_ERROR("The interpolation parameters field is not associated.",ERR,ERROR,*999)
          ENDIF
          CALL DISTRIBUTED_VECTOR_DATA_RESTORE(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,ERR,ERROR,*999)
        ELSE
          LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(PARAMETER_SET_TYPE,"*",ERR,ERROR))// &
            & " has not been created for field number "// &
            & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(PARAMETER_SET_TYPE,"*",ERR,ERROR))// &
          & " is invalid. The number must be between 1 and "//TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))// &
          & " for field number "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Interpolation parameters is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation parameters:",ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & VARIABLE_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Parameter set type = ",PARAMETER_SET_TYPE,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Line number = ",LINE_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Total number of components = ", &
        & INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Interpolation number of components = ", &
        & endComponentIdx-startComponentIdx+1,ERR,ERROR,*999)
      DO component_idx=startComponentIdx,endComponentIdx
        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,ERR,ERROR,*999)
        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & NUMBER_OF_PARAMETERS(component_idx),ERR,ERROR,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),'("      Parameters :",4(X,E13.6))','(18X,4(X,E13.6))', &
          & ERR,ERROR,*999)
      ENDDO !component_idx
    ENDIF

    CALL EXITS("FIELD_INTERPOLATION_PARAMETERS_LINE_GET")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATION_PARAMETERS_LINE_GET",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATION_PARAMETERS_LINE_GET")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_LINE_GET

  !
  !================================================================================================================================
  !
  !>Gets the interpolation parameters for a particular face.
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_FACE_GET(PARAMETER_SET_TYPE,FACE_NUMBER,INTERPOLATION_PARAMETERS,ERR,ERROR,*, &
      & componentType)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: PARAMETER_SET_TYPE !<The field parameter set type to get the face parameters for
    INTEGER(INTG), INTENT(IN) :: FACE_NUMBER !<The face number to get the face parameters for
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    INTEGER(INTG), OPTIONAL, INTENT(IN) :: componentType !<The components type to get field interpolation parameters for
    !Local Variables
    INTEGER(INTG) :: component_idx,basis_derivative_idx,derivative_idx,version_idx,basis_node_idx,node_idx,element_parameter_idx, &
      & dof_idx,node_scaling_dof_idx,scaling_idx,startComponentIdx,endComponentIdx
    REAL(DP), POINTER :: FIELD_PARAMETER_SET_DATA(:),SCALE_FACTORS(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(DOMAIN_FACES_TYPE), POINTER :: FACES_TOPOLOGY
    TYPE(DOMAIN_NODES_TYPE), POINTER :: NODES_TOPOLOGY
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_INTERPOLATION_PARAMETERS_FACE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      IF(PARAMETER_SET_TYPE>0.AND.PARAMETER_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
        PARAMETER_SET=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(PARAMETER_SET_TYPE)%PTR
        IF(ASSOCIATED(PARAMETER_SET)) THEN
          NULLIFY(FIELD_PARAMETER_SET_DATA)
          CALL DISTRIBUTED_VECTOR_DATA_GET(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,ERR,ERROR,*999)
          FIELD=>INTERPOLATION_PARAMETERS%FIELD
          IF(ASSOCIATED(FIELD)) THEN
            NULLIFY(COORDINATE_SYSTEM)
            CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
            IF(PRESENT(componentType)) THEN
              SELECT CASE(componentType)
              CASE(FIELD_ALL_COMPONENTS_TYPE)
                startComponentIdx=1
                endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
              CASE(FIELD_GEOMETRIC_COMPONENTS_TYPE)
                IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                  startComponentIdx=1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)%PTR% &
                    & NUMBER_OF_COMPONENTS
                ELSEIF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                  startComponentIdx=1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                ELSE
                  LOCAL_ERROR="Field type "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                    & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE(FIELD_NONGEOMETRIC_COMPONENTS_TYPE)
                IF(INTERPOLATION_PARAMETERS%FIELD%TYPE==FIELD_GEOMETRIC_GENERAL_TYPE) THEN
                  startComponentIdx=INTERPOLATION_PARAMETERS%FIELD%GEOMETRIC_FIELD%VARIABLE_TYPE_MAP(FIELD_U_VARIABLE_TYPE)% &
                    & PTR%NUMBER_OF_COMPONENTS+1
                  endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
                ELSE
                  LOCAL_ERROR="Field type "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%TYPE,"*",ERR,ERROR))// &
                    & " is not valid for only interpolating geometric field, use FIELD_GEOMETRIC_GENERAL_TYPE."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              CASE DEFAULT
                LOCAL_ERROR="Interpolation component type "//TRIM(NUMBER_TO_VSTRING(componentType,"*",ERR,ERROR))//" is not valid."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ELSE
              startComponentIdx=1
              endComponentIdx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            ENDIF
            DO component_idx=startComponentIdx,endComponentIdx
              FACES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%FACES
              IF(FACE_NUMBER>0.AND.FACE_NUMBER<=FACES_TOPOLOGY%NUMBER_OF_FACES) THEN
                BASIS=>FACES_TOPOLOGY%FACES(FACE_NUMBER)%BASIS
                INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR=>BASIS
                IF(component_idx==1) THEN
                  INTERPOLATION_PARAMETERS%NUMBER_OF_XI=BASIS%NUMBER_OF_XI
                ELSE
                  IF(BASIS%NUMBER_OF_XI/=INTERPOLATION_PARAMETERS%NUMBER_OF_XI) &
                    & CALL FLAG_ERROR("Inconsistent number of xi directions???",ERR,ERROR,*999)
                ENDIF
                SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
                CASE(FIELD_CONSTANT_INTERPOLATION)
                  CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                  CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_NODE_BASED_INTERPOLATION)
                  NODES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%NODES
                  INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=BASIS%NUMBER_OF_ELEMENT_PARAMETERS
                  SELECT CASE(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALING_TYPE)
                  CASE(FIELD_NO_SCALING)
                    DO basis_node_idx=1,BASIS%NUMBER_OF_NODES
                      node_idx=FACES_TOPOLOGY%FACES(FACE_NUMBER)%NODES_IN_FACE(basis_node_idx)
                      DO basis_derivative_idx=1,BASIS%NUMBER_OF_DERIVATIVES(basis_node_idx)
                        derivative_idx=FACES_TOPOLOGY%FACES(FACE_NUMBER)%DERIVATIVES_IN_FACE(1,basis_derivative_idx,basis_node_idx)
                        version_idx=FACES_TOPOLOGY%FACES(FACE_NUMBER)%DERIVATIVES_IN_FACE(2,basis_derivative_idx,basis_node_idx)
                        element_parameter_idx=BASIS%ELEMENT_PARAMETER_INDEX(basis_derivative_idx,basis_node_idx)
                        dof_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% &
                          & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                        INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)
                      ENDDO !basis_derivative_idx
                    ENDDO !basis_node_idx
                  CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
                    scaling_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%SCALING_INDEX
                    NULLIFY(SCALE_FACTORS)
                    CALL DISTRIBUTED_VECTOR_DATA_GET(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                      & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
                    DO basis_node_idx=1,BASIS%NUMBER_OF_NODES
                      node_idx=FACES_TOPOLOGY%FACES(FACE_NUMBER)%NODES_IN_FACE(basis_node_idx)
                      DO basis_derivative_idx=1,BASIS%NUMBER_OF_DERIVATIVES(basis_node_idx)
                        derivative_idx=FACES_TOPOLOGY%FACES(FACE_NUMBER)%DERIVATIVES_IN_FACE(1,basis_derivative_idx,basis_node_idx)
                        version_idx=FACES_TOPOLOGY%FACES(FACE_NUMBER)%DERIVATIVES_IN_FACE(2,basis_derivative_idx,basis_node_idx)
                        element_parameter_idx=BASIS%ELEMENT_PARAMETER_INDEX(basis_derivative_idx,basis_node_idx)
                        dof_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%PARAM_TO_DOF_MAP% &
                          & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(version_idx)
                        node_scaling_dof_idx= &
                            & NODES_TOPOLOGY%NODES(node_idx)%DERIVATIVES(derivative_idx)%DOF_INDEX(version_idx)
                        !INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)=FIELD_PARAMETER_SET_DATA(dof_idx)* &
                        !  & INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)%SCALE_FACTORS(derivative_idx,node_idx)
                        INTERPOLATION_PARAMETERS%PARAMETERS(element_parameter_idx,component_idx)= &
                          & FIELD_PARAMETER_SET_DATA(dof_idx)*SCALE_FACTORS(node_scaling_dof_idx)
                        INTERPOLATION_PARAMETERS%SCALE_FACTORS(element_parameter_idx,component_idx)= &
                          & SCALE_FACTORS(node_scaling_dof_idx)
                      ENDDO !basis_derivative_idx
                    ENDDO !basis_node_idx
                  CASE(FIELD_ARC_LENGTH_SCALING)
                    CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                  CASE DEFAULT
                    LOCAL_ERROR="The scaling type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%SCALINGS% &
                      & SCALING_TYPE,"*",ERR,ERROR))//" is invalid for field number "// &
                      & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  END SELECT
                 CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                  CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                  CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                  CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                CASE DEFAULT
                  LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
                    & COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                    & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//" of field number "// &
                    & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ELSE
                LOCAL_ERROR="The face number of "//TRIM(NUMBER_TO_VSTRING(FACE_NUMBER,"*",ERR,ERROR))// &
                  & " is invalid. The number must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FACES_TOPOLOGY%NUMBER_OF_FACES,"*",ERR,ERROR))// &
                  & " for component number "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ENDDO !component_idx
            CALL COORDINATE_INTERPOLATION_PARAMETERS_ADJUST(COORDINATE_SYSTEM,INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
          ELSE
            CALL FLAG_ERROR("The interpolation parameters field is not associated.",ERR,ERROR,*999)
          ENDIF
          CALL DISTRIBUTED_VECTOR_DATA_RESTORE(PARAMETER_SET%PARAMETERS,FIELD_PARAMETER_SET_DATA,ERR,ERROR,*999)
        ELSE
          LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(PARAMETER_SET_TYPE,"*",ERR,ERROR))// &
            & " has not been created for field number "// &
            & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(PARAMETER_SET_TYPE,"*",ERR,ERROR))// &
          & " is invalid. The number must be between 1 and "//TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))// &
          & " for field number "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Interpolation parameters is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation parameters:",ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & VARIABLE_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Parameter set type = ",PARAMETER_SET_TYPE,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Face number = ",FACE_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Total number of components = ", &
        & INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Interpolation number of components = ", &
        & endComponentIdx-startComponentIdx+1,ERR,ERROR,*999)
      DO component_idx=startComponentIdx,endComponentIdx
        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,ERR,ERROR,*999)
        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & NUMBER_OF_PARAMETERS(component_idx),ERR,ERROR,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%PARAMETERS(:,component_idx),'("      Parameters :",4(X,E13.6))','(18X,4(X,E13.6))', &
          & ERR,ERROR,*999)
      ENDDO !component_idx
    ENDIF

    CALL EXITS("FIELD_INTERPOLATION_PARAMETERS_FACE_GET")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATION_PARAMETERS_FACE_GET",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATION_PARAMETERS_FACE_GET")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_FACE_GET

  !
  !================================================================================================================================
  !

  !>Gets the interpolation scale factors for a particular element. 
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_ELEM_GET(ELEMENT_NUMBER,INTERPOLATION_PARAMETERS,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: ELEMENT_NUMBER !<The element number to get the element scale factors for
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,mk,nk,nn,np,ns,ny,scaling_idx,nv
    REAL(DP), POINTER :: SCALE_FACTORS(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: ELEMENTS_TOPOLOGY
    TYPE(DOMAIN_NODES_TYPE), POINTER :: NODES_TOPOLOGY
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_ELEM_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      SELECT CASE(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALING_TYPE)
      CASE(FIELD_NO_SCALING)
        CALL FLAG_ERROR("Can not get the scale factors for a field with no scaling.",ERR,ERROR,*999)
      CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
        DO component_idx=1,INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          ELEMENTS_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%ELEMENTS
          IF(ELEMENT_NUMBER>0.AND.ELEMENT_NUMBER<=ELEMENTS_TOPOLOGY%TOTAL_NUMBER_OF_ELEMENTS) THEN
            BASIS=>ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%BASIS
            INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR=>BASIS
            SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
            CASE(FIELD_CONSTANT_INTERPOLATION)             
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_NODE_BASED_INTERPOLATION)
              NODES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%NODES
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=BASIS%NUMBER_OF_ELEMENT_PARAMETERS
              scaling_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%SCALING_INDEX
              NULLIFY(SCALE_FACTORS)
              CALL DISTRIBUTED_VECTOR_DATA_GET(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
              DO nn=1,BASIS%NUMBER_OF_NODES
                np=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%ELEMENT_NODES(nn)
                DO mk=1,BASIS%NUMBER_OF_DERIVATIVES(nn)
                  nk=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%ELEMENT_DERIVATIVES(mk,nn)
                  nv=ELEMENTS_TOPOLOGY%ELEMENTS(ELEMENT_NUMBER)%elementVersions(mk,nn)
                  ns=BASIS%ELEMENT_PARAMETER_INDEX(mk,nn)
                  ny=NODES_TOPOLOGY%NODES(np)%DERIVATIVES(nk)%DOF_INDEX(nv)
                  INTERPOLATION_PARAMETERS%SCALE_FACTORS(ns,component_idx)=SCALE_FACTORS(ny)
                ENDDO !mk
              ENDDO !nn
              CALL DISTRIBUTED_VECTOR_DATA_RESTORE(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
            CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE DEFAULT
              LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
              & COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
              & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//" of field number "// &
              & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            LOCAL_ERROR="The element number of "//TRIM(NUMBER_TO_VSTRING(ELEMENT_NUMBER,"*",ERR,ERROR))// &
              & " is invalid. The number must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(ELEMENTS_TOPOLOGY%TOTAL_NUMBER_OF_ELEMENTS,"*",ERR,ERROR))// &
              & " for component number "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//" of field number "// &
              & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ENDDO !component_idx
      CASE(FIELD_ARC_LENGTH_SCALING)
        CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
      CASE DEFAULT
        LOCAL_ERROR="The scaling type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%SCALINGS% &
          & SCALING_TYPE,"*",ERR,ERROR))//" is invalid for field number "// &
          & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      END SELECT
    ELSE
      CALL FLAG_ERROR("Interpolation parameters is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation scale factors:",ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & VARIABLE_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Element number = ",ELEMENT_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of components = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
      DO component_idx=1,INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,ERR,ERROR,*999)
        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & NUMBER_OF_PARAMETERS(component_idx),ERR,ERROR,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%SCALE_FACTORS(:,component_idx),'("      Scale factors :",4(X,E13.6))','(21X,4(X,E13.6))', &
          & ERR,ERROR,*999)
      ENDDO !component_idx
    ENDIF

    CALL EXITS("FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_ELEM_GET")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_ELEM_GET",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_ELEM_GET")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_ELEM_GET

  !
  !================================================================================================================================
  !

  !>Gets the scale factors for a particular node.
  SUBROUTINE Field_ParameterSetNodeScaleFactorGet(field,variableType,versionNumber, &
    & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get scale factor for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to get the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    LOGICAL :: ghostNode,userNodeExists
    INTEGER(INTG) :: domainLocalNodeNumber,scalingIdx,dofIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(DOMAIN_NODES_TYPE), POINTER :: domainNodes
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetNodeScaleFactorGet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        SELECT CASE(field%SCALINGS%SCALING_TYPE)
        CASE(FIELD_NO_SCALING)
          CALL FLAG_ERROR("Can not get the scale factors for a field with no scaling.",err,error,*999)
        CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
          IF(variableType>0.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
            IF(ASSOCIATED(fieldVariable)) THEN
              IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                IF(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE==FIELD_NODE_BASED_INTERPOLATION)THEN
                  domainTopology=>fieldVariable%COMPONENTS(componentNumber)%DOMAIN%TOPOLOGY
                  CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(domainTopology,nodeUserNumber,userNodeExists, &
                    & domainLocalNodeNumber,ghostNode,err,error,*999)
                  IF(userNodeExists) THEN
                    IF(ghostNode) THEN
                      localError="Cannot get by node for user node "// &
                        & TRIM(NUMBER_TO_VSTRING(nodeUserNumber,"*",err,error))//" as it is a ghost node."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    ELSE
                      domainNodes=>domainTopology%NODES
                      IF(ASSOCIATED(domainNodes)) THEN
                        IF(derivativeNumber>0.AND.derivativeNumber<=domainNodes%NODES(domainLocalNodeNumber)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(versionNumber>0.AND.versionNumber<= &
                              & fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & NODE_PARAM2DOF_MAP%NODES(domainLocalNodeNumber)%DERIVATIVES(derivativeNumber)% &
                              & NUMBER_OF_VERSIONS) THEN
                            ! The field component number is used to determine which scaling index to use.
                            ! The number of scaling indices are set based on the number of mesh components (not field components).
                            scalingIdx=fieldVariable%COMPONENTS(componentNumber)%SCALING_INDEX
                            NULLIFY(fieldScaleFactors)
                            CALL DISTRIBUTED_VECTOR_DATA_GET(field%SCALINGS%SCALINGS(scalingIdx)%SCALE_FACTORS, &
                              & fieldScaleFactors,err,error,*999)
                            dofIdx=domainNodes%NODES(nodeUserNumber)%DERIVATIVES(derivativeNumber)%DOF_INDEX(versionNumber)
                            !dofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                            !  & NODE_PARAM2DOF_MAP%NODES(domainLocalNodeNumber)%DERIVATIVES(derivativeNumber)% &
                            !  & VERSIONS(versionNumber)
                            scaleFactor=fieldScaleFactors(dofIdx)
                            CALL DISTRIBUTED_VECTOR_DATA_RESTORE(field%SCALINGS%SCALINGS(scalingIdx)% &
                              & SCALE_FACTORS,fieldScaleFactors,ERR,ERROR,*999)
                          ELSE
                            localError="Version number "//TRIM(NUMBER_TO_VSTRING(versionNumber,"*",err,error))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NUMBER_TO_VSTRING(derivativeNumber,"*",err,error))//" of node number "// &
                              & TRIM(NUMBER_TO_VSTRING(nodeUserNumber,"*",err,error))//" of component number "// &
                              & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has a maximum of "// &
                              & TRIM(NUMBER_TO_VSTRING(domainNodes%NODES(domainLocalNodeNumber)% &
                              & DERIVATIVES(derivativeNumber)%numberOfVersions,"*",err,error))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FLAG_ERROR(localError,err,error,*999)
                          ENDIF
                        ELSE
                          localError="Derivative number "//TRIM(NUMBER_TO_VSTRING(derivativeNumber,"*",err,error))// &
                            & " is invalid for user node number "// &
                            & TRIM(NUMBER_TO_VSTRING(nodeUserNumber,"*",err,error))//" of component number "// &
                            & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has "// &
                            & TRIM(NUMBER_TO_VSTRING(domainNodes%NODES(domainLocalNodeNumber)% &
                            & NUMBER_OF_DERIVATIVES,"*",err,error))//" derivatives."
                          CALL FLAG_ERROR(localError,err,error,*999)
                        ENDIF
                      ENDIF
                    ENDIF
                  ELSE
                    localError="The specified user node number of "// &
                      & TRIM(NUMBER_TO_VSTRING(nodeUserNumber,"*",err,error))// &
                      &  " does not exist in the domain for field component number "// &
                      & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of field variable type "// &
                      & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                      & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
                    CALL FLAG_ERROR(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%COMPONENTS(componentNumber)% &
                    & INTERPOLATION_TYPE,"*",err,error))//" is not nodally based for component number "// &
                    & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of field number "// &
                    & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
                  CALL FLAG_ERROR(localError,err,error,*999)
                ENDIF
              ELSE
                localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                  & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                  & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has "// &
                  & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))// &
                  & " components."
                CALL FLAG_ERROR(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
              CALL FLAG_ERROR(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
            CALL FLAG_ERROR(localError,err,error,*999)
          ENDIF
        CASE(FIELD_ARC_LENGTH_SCALING)
          CALL FLAG_ERROR("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The scaling type of "//TRIM(NUMBER_TO_VSTRING(field%SCALINGS%SCALING_TYPE,"*",err,error))// &
            & " is invalid for field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        END SELECT
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    ENDIF

    CALL EXITS("Field_ParameterSetNodeScaleFactorGet")
    RETURN
999 CALL ERRORS("Field_ParameterSetNodeScaleFactorGet",err,error)
    CALL EXITS("Field_ParameterSetNodeScaleFactorGet")
    RETURN 1
  END SUBROUTINE Field_ParameterSetNodeScaleFactorGet

  !
  !================================================================================================================================
  !

  !>Gets the scale factors for all nodes.
  SUBROUTINE Field_ParameterSetNodeScaleFactorsGet(field,variableType,meshComponentNumber,scaleFactors,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get scale factor for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to get the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactors(:) !<The scale factor for all nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: scalingIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetNodeScaleFactorsGet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        SELECT CASE(field%SCALINGS%SCALING_TYPE)
        CASE(FIELD_NO_SCALING)
          CALL FLAG_ERROR("Can not get the scale factors for a field with no scaling.",err,error,*999)
        CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
          IF(variableType>0.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
            IF(ASSOCIATED(fieldVariable)) THEN
              !The NUMBER_OF_SCALING_INDICES is the same as the number of mesh components (not field components).  
              IF(meshComponentNumber>=1.AND.meshComponentNumber<=field%SCALINGS%NUMBER_OF_SCALING_INDICES) THEN
                scalingIdx=meshComponentNumber
                NULLIFY(fieldScaleFactors)
                CALL DISTRIBUTED_VECTOR_DATA_GET(field%SCALINGS%SCALINGS(scalingIdx)%SCALE_FACTORS, &
                  & fieldScaleFactors,err,error,*999)
                scaleFactors=fieldScaleFactors
                CALL DISTRIBUTED_VECTOR_DATA_RESTORE(field%SCALINGS%SCALINGS(scalingIdx)% &
                  & SCALE_FACTORS,fieldScaleFactors,ERR,ERROR,*999)
              ELSE
                localError="Mesh component number "//TRIM(NUMBER_TO_VSTRING(meshComponentNumber,"*",err,error))// &
                  & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                  & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has "// &
                  & TRIM(NUMBER_TO_VSTRING(field%SCALINGS%NUMBER_OF_SCALING_INDICES,"*",err,error))// &
                  & " components."
                CALL FLAG_ERROR(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
              CALL FLAG_ERROR(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
            CALL FLAG_ERROR(localError,err,error,*999)
          ENDIF
        CASE(FIELD_ARC_LENGTH_SCALING)
          CALL FLAG_ERROR("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The scaling type of "//TRIM(NUMBER_TO_VSTRING(field%SCALINGS%SCALING_TYPE,"*",err,error))// &
            & " is invalid for field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        END SELECT
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    ENDIF

    CALL EXITS("Field_ParameterSetNodeScaleFactorsGet")
    RETURN
999 CALL ERRORS("Field_ParameterSetNodeScaleFactorsGet",err,error)
    CALL EXITS("Field_ParameterSetNodeScaleFactorsGet")
    RETURN 1
  END SUBROUTINE Field_ParameterSetNodeScaleFactorsGet

  !
  !================================================================================================================================
  !

  !>Gets the number of scale factor dofs.
  SUBROUTINE Field_ParameterSetNodeNumberOfScaleFactorDofsGet(field,variableType,meshComponentNumber,numberOfScaleFactorsDofs, &
    & err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<The field to get the number of scale factor dofs for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(OUT) :: numberOfScaleFactorsDofs !<The number of scale factor dofs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: scalingIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetNodeNumberOfScaleFactorDofsGet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        SELECT CASE(field%SCALINGS%SCALING_TYPE)
        CASE(FIELD_NO_SCALING)
          CALL FLAG_ERROR("Can not get the scale factors for a field with no scaling.",err,error,*999)
        CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
          IF(variableType>0.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
            IF(ASSOCIATED(fieldVariable)) THEN
              !The NUMBER_OF_SCALING_INDICES is the same as the number of mesh components (not field components).  
              IF(meshComponentNumber>=1.AND.meshComponentNumber<=field%SCALINGS%NUMBER_OF_SCALING_INDICES) THEN
                scalingIdx=meshComponentNumber
                NULLIFY(fieldScaleFactors)
                CALL DISTRIBUTED_VECTOR_DATA_GET(field%SCALINGS%SCALINGS(scalingIdx)%SCALE_FACTORS, &
                  & fieldScaleFactors,err,error,*999)
                numberOfScaleFactorsDofs=SIZE(fieldScaleFactors,1)
                CALL DISTRIBUTED_VECTOR_DATA_RESTORE(field%SCALINGS%SCALINGS(scalingIdx)% &
                  & SCALE_FACTORS,fieldScaleFactors,ERR,ERROR,*999)
              ELSE
                localError="Mesh component number "//TRIM(NUMBER_TO_VSTRING(meshComponentNumber,"*",err,error))// &
                  & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                  & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has "// &
                  & TRIM(NUMBER_TO_VSTRING(field%SCALINGS%NUMBER_OF_SCALING_INDICES,"*",err,error))// &
                  & " components."
                CALL FLAG_ERROR(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
              CALL FLAG_ERROR(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
            CALL FLAG_ERROR(localError,err,error,*999)
          ENDIF
        CASE(FIELD_ARC_LENGTH_SCALING)
          CALL FLAG_ERROR("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The scaling type of "//TRIM(NUMBER_TO_VSTRING(field%SCALINGS%SCALING_TYPE,"*",err,error))// &
            & " is invalid for field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        END SELECT
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    ENDIF

    CALL EXITS("Field_ParameterSetNodeNumberOfScaleFactorDofsGet")
    RETURN
999 CALL ERRORS("Field_ParameterSetNodeNumberOfScaleFactorDofsGet",err,error)
    CALL EXITS("Field_ParameterSetNodeNumberOfScaleFactorDofsGet")
    RETURN 1
  END SUBROUTINE Field_ParameterSetNodeNumberOfScaleFactorDofsGet

  !
  !================================================================================================================================
  !

  !>Sets the scale factors for a particular node.
  SUBROUTINE Field_ParameterSetNodeScaleFactorSet(field,variableType,versionNumber, &
    & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to set scale factor for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    LOGICAL :: ghostNode,userNodeExists
    INTEGER(INTG) :: domainLocalNodeNumber,scalingIdx,dofIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(DOMAIN_NODES_TYPE), POINTER :: domainNodes
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetNodeScaleFactorSet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        SELECT CASE(field%SCALINGS%SCALING_TYPE)
        CASE(FIELD_NO_SCALING)
          CALL FLAG_ERROR("Can not set the scale factors for a field with no scaling.",err,error,*999)
        CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
          IF(variableType>0.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
            IF(ASSOCIATED(fieldVariable)) THEN
              IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                IF(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE==FIELD_NODE_BASED_INTERPOLATION)THEN
                  domainTopology=>fieldVariable%COMPONENTS(componentNumber)%DOMAIN%TOPOLOGY
                  CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(domainTopology,nodeUserNumber,userNodeExists, &
                    & domainLocalNodeNumber,ghostNode,err,error,*999)
                  IF(userNodeExists) THEN
                    IF(ghostNode) THEN
                      localError="Cannot update by node for user node "// &
                        & TRIM(NUMBER_TO_VSTRING(nodeUserNumber,"*",err,error))//" as it is a ghost node."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    ELSE
                      domainNodes=>domainTopology%NODES
                      IF(ASSOCIATED(domainNodes)) THEN
                        IF(derivativeNumber>0.AND.derivativeNumber<=domainNodes%NODES(domainLocalNodeNumber)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(versionNumber>0.AND.versionNumber<= &
                            & fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                            & NODE_PARAM2DOF_MAP%NODES(domainLocalNodeNumber)%DERIVATIVES(derivativeNumber)% &
                            & NUMBER_OF_VERSIONS) THEN

                            ! The field component number is used to determine which scaling index to use.
                            ! The number of scaling indices are set based on the number of mesh components (not field components).
                            scalingIdx=fieldVariable%COMPONENTS(componentNumber)%SCALING_INDEX
                            NULLIFY(fieldScaleFactors)
                            CALL DISTRIBUTED_VECTOR_DATA_GET(field%SCALINGS%SCALINGS(scalingIdx)% &
                              & SCALE_FACTORS,fieldScaleFactors,err,error,*999)
                            dofIdx=domainNodes%NODES(nodeUserNumber)%DERIVATIVES(derivativeNumber)%DOF_INDEX(versionNumber)
                            !dofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                            !  & NODE_PARAM2DOF_MAP%NODES(domainLocalNodeNumber)%DERIVATIVES(derivativeNumber)% &
                            !  & VERSIONS(versionNumber)
                            fieldScaleFactors(dofIdx)=scaleFactor
                            CALL DISTRIBUTED_VECTOR_DATA_RESTORE(field%SCALINGS%SCALINGS(scalingIdx)% &
                              & SCALE_FACTORS,fieldScaleFactors,err,error,*999)

                          ELSE
                            localError="Version number "//TRIM(NUMBER_TO_VSTRING(versionNumber,"*",err,error))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NUMBER_TO_VSTRING(derivativeNumber,"*",err,error))//" of node number "// &
                              & TRIM(NUMBER_TO_VSTRING(nodeUserNumber,"*",err,error))//" of component number "// &
                              & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has a maximum of "// &
                              & TRIM(NUMBER_TO_VSTRING(domainNodes%NODES(domainLocalNodeNumber)% &
                              & DERIVATIVES(derivativeNumber)%numberOfVersions,"*",err,error))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FLAG_ERROR(localError,err,error,*999)
                          ENDIF
                        ELSE
                          localError="Derivative number "//TRIM(NUMBER_TO_VSTRING(derivativeNumber,"*",err,error))// &
                            & " is invalid for user node number "// &
                            & TRIM(NUMBER_TO_VSTRING(nodeUserNumber,"*",err,error))//" of component number "// &
                            & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has "// &
                            & TRIM(NUMBER_TO_VSTRING(domainNodes%NODES(domainLocalNodeNumber)% &
                            & NUMBER_OF_DERIVATIVES,"*",err,error))//" derivatives."
                          CALL FLAG_ERROR(localError,err,error,*999)
                        ENDIF
                      ENDIF
                    ENDIF
                  ELSE
                    localError="The specified user node number of "// &
                      & TRIM(NUMBER_TO_VSTRING(nodeUserNumber,"*",err,error))// &
                      &  " does not exist in the domain for field component number "// &
                      & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of field variable type "// &
                      & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                      & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
                    CALL FLAG_ERROR(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%COMPONENTS(componentNumber)% &
                    & INTERPOLATION_TYPE,"*",err,error))//" is not nodally based for component number "// &
                    & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of field number "// &
                    & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
                  CALL FLAG_ERROR(localError,err,error,*999)
                ENDIF
              ELSE
                localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                  & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                  & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has "// &
                  & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))// &
                  & " components."
                CALL FLAG_ERROR(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
              CALL FLAG_ERROR(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
            CALL FLAG_ERROR(localError,err,error,*999)
          ENDIF
        CASE(FIELD_ARC_LENGTH_SCALING)
          CALL FLAG_ERROR("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The scaling type of "//TRIM(NUMBER_TO_VSTRING(field%SCALINGS%SCALING_TYPE,"*",err,error))// &
            & " is invalid for field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        END SELECT
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    ENDIF

    CALL EXITS("Field_ParameterSetNodeScaleFactorSet")
    RETURN
999 CALL ERRORS("Field_ParameterSetNodeScaleFactorSet",err,error)
    CALL EXITS("Field_ParameterSetNodeScaleFactorSet")
    RETURN 1
  END SUBROUTINE Field_ParameterSetNodeScaleFactorSet
  !
  !================================================================================================================================
  !

  !>Sets the scale factors for all nodes.
  SUBROUTINE Field_ParameterSetNodeScaleFactorsSet(field,variableType,meshComponentNumber,scaleFactors,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to set scale factor for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactors(:) !<The scale factor for all nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: scalingIdx
    REAL(DP), POINTER :: fieldScaleFactors(:)
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetNodeScaleFactorsSet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        SELECT CASE(field%SCALINGS%SCALING_TYPE)
        CASE(FIELD_NO_SCALING)
          CALL FLAG_ERROR("Can not set the scale factors for a field with no scaling.",err,error,*999)
        CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
          IF(variableType>0.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
            IF(ASSOCIATED(fieldVariable)) THEN
              !The NUMBER_OF_SCALING_INDICES is the same as the number of mesh components (not field components).  
              IF(meshComponentNumber>=1.AND.meshComponentNumber<=field%SCALINGS%NUMBER_OF_SCALING_INDICES) THEN
                scalingIdx=meshComponentNumber
                NULLIFY(fieldScaleFactors)
                CALL DISTRIBUTED_VECTOR_DATA_GET(field%SCALINGS%SCALINGS(scalingIdx)%SCALE_FACTORS, &
                  & fieldScaleFactors,err,error,*999)
                fieldScaleFactors = scaleFactors
                CALL DISTRIBUTED_VECTOR_DATA_RESTORE(field%SCALINGS%SCALINGS(scalingIdx)% &
                  & SCALE_FACTORS,fieldScaleFactors,ERR,ERROR,*999)
              ELSE
                localError="Mesh component number "//TRIM(NUMBER_TO_VSTRING(meshComponentNumber,"*",err,error))// &
                  & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                  & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has "// &
                  & TRIM(NUMBER_TO_VSTRING(field%SCALINGS%NUMBER_OF_SCALING_INDICES,"*",err,error))// &
                  & " components."
                CALL FLAG_ERROR(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
              CALL FLAG_ERROR(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
            CALL FLAG_ERROR(localError,err,error,*999)
          ENDIF
        CASE(FIELD_ARC_LENGTH_SCALING)
          CALL FLAG_ERROR("Not implemented.",err,error,*999)
        CASE DEFAULT
          localError="The scaling type of "//TRIM(NUMBER_TO_VSTRING(field%SCALINGS%SCALING_TYPE,"*",err,error))// &
            & " is invalid for field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        END SELECT
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    ENDIF

    CALL EXITS("Field_ParameterSetNodeScaleFactorsSet")
    RETURN
999 CALL ERRORS("Field_ParameterSetNodeScaleFactorsSet",err,error)
    CALL EXITS("Field_ParameterSetNodeScaleFactorsSet")
    RETURN 1
  END SUBROUTINE Field_ParameterSetNodeScaleFactorsSet

  !
  !================================================================================================================================
  !

  !>Gets the interpolation scale factors for a particular element. 
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_LINE_GET(LINE_NUMBER,INTERPOLATION_PARAMETERS,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: LINE_NUMBER !<The line number to get the element scale factors for
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,mk,nk,nn,np,ns,ny,scaling_idx,nv
    REAL(DP), POINTER :: SCALE_FACTORS(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(DOMAIN_LINES_TYPE), POINTER :: LINES_TOPOLOGY
    TYPE(DOMAIN_NODES_TYPE), POINTER :: NODES_TOPOLOGY
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_LINE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      SELECT CASE(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALING_TYPE)
      CASE(FIELD_NO_SCALING)
        CALL FLAG_ERROR("Can not scale factors for a field with no scaling.",ERR,ERROR,*999)
      CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
        DO component_idx=1,INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          LINES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%LINES
          IF(LINE_NUMBER>0.AND.LINE_NUMBER<=LINES_TOPOLOGY%NUMBER_OF_LINES) THEN
            BASIS=>LINES_TOPOLOGY%LINES(LINE_NUMBER)%BASIS
            INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR=>BASIS
            IF(component_idx==1) THEN
              INTERPOLATION_PARAMETERS%NUMBER_OF_XI=BASIS%NUMBER_OF_XI
            ELSE
              IF(BASIS%NUMBER_OF_XI/=INTERPOLATION_PARAMETERS%NUMBER_OF_XI) &
                & CALL FLAG_ERROR("Inconsistent number of xi directions???",ERR,ERROR,*999)
            ENDIF
            SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
            CASE(FIELD_CONSTANT_INTERPOLATION)             
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_NODE_BASED_INTERPOLATION)
              NODES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%NODES
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=BASIS%NUMBER_OF_ELEMENT_PARAMETERS
              scaling_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%SCALING_INDEX
              NULLIFY(SCALE_FACTORS)
              CALL DISTRIBUTED_VECTOR_DATA_GET(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
              DO nn=1,BASIS%NUMBER_OF_NODES
                np=LINES_TOPOLOGY%LINES(LINE_NUMBER)%NODES_IN_LINE(nn)
                DO mk=1,BASIS%NUMBER_OF_DERIVATIVES(nn)
                  nk=LINES_TOPOLOGY%LINES(LINE_NUMBER)%DERIVATIVES_IN_LINE(1,mk,nn)
                  nv=LINES_TOPOLOGY%LINES(LINE_NUMBER)%DERIVATIVES_IN_LINE(2,mk,nn)
                  ns=BASIS%ELEMENT_PARAMETER_INDEX(mk,nn)
                  ny=NODES_TOPOLOGY%NODES(np)%DERIVATIVES(nk)%DOF_INDEX(nv)
                  INTERPOLATION_PARAMETERS%SCALE_FACTORS(ns,component_idx)=SCALE_FACTORS(ny)
                ENDDO !mk
              ENDDO !nn
              CALL DISTRIBUTED_VECTOR_DATA_RESTORE(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
            CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE DEFAULT
              LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
              & COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
              & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//" of field number "// &
              & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            LOCAL_ERROR="The line number of "//TRIM(NUMBER_TO_VSTRING(LINE_NUMBER,"*",ERR,ERROR))// &
              & " is invalid. The number must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(LINES_TOPOLOGY%NUMBER_OF_LINES,"*",ERR,ERROR))// &
              & " for component number "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//" of field number "// &
              & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ENDDO !component_idx
      CASE(FIELD_ARC_LENGTH_SCALING)
        CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
      CASE DEFAULT
        LOCAL_ERROR="The scaling type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%SCALINGS% &
          & SCALING_TYPE,"*",ERR,ERROR))//" is invalid for field number "// &
          & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      END SELECT
    ELSE
      CALL FLAG_ERROR("Interpolation parameters is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation scale factors:",ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & VARIABLE_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Line number = ",LINE_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of components = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
      DO component_idx=1,INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,ERR,ERROR,*999)
        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & NUMBER_OF_PARAMETERS(component_idx),ERR,ERROR,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%SCALE_FACTORS(:,component_idx),'("      Scale factors :",4(X,E13.6))','(21X,4(X,E13.6))', &
          & ERR,ERROR,*999)
      ENDDO !component_idx
    ENDIF

    CALL EXITS("FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_LINE_GET")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_LINE_GET",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_LINE_GET")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_LINE_GET

  !
  !================================================================================================================================
  !

!>Gets the interpolation scale factors for a particular element. 
  SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_FACE_GET(FACE_NUMBER,INTERPOLATION_PARAMETERS,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: FACE_NUMBER !<The face number to get the element scale factors for
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: INTERPOLATION_PARAMETERS !<On return, a pointer to the interpolation parameters
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,mk,nk,nn,np,ns,ny,scaling_idx,nv
    REAL(DP), POINTER :: SCALE_FACTORS(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(DOMAIN_FACES_TYPE), POINTER :: FACES_TOPOLOGY
    TYPE(DOMAIN_NODES_TYPE), POINTER :: NODES_TOPOLOGY
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_FACE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) THEN
      SELECT CASE(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALING_TYPE)
      CASE(FIELD_NO_SCALING)
        CALL FLAG_ERROR("Can not scale factors for a field with no scaling.",ERR,ERROR,*999)
      CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
        DO component_idx=1,INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          FACES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%FACES
          IF(FACE_NUMBER>0.AND.FACE_NUMBER<=FACES_TOPOLOGY%NUMBER_OF_FACES) THEN
            BASIS=>FACES_TOPOLOGY%FACES(FACE_NUMBER)%BASIS
            INTERPOLATION_PARAMETERS%BASES(component_idx)%PTR=>BASIS
            IF(component_idx==1) THEN
              INTERPOLATION_PARAMETERS%NUMBER_OF_XI=BASIS%NUMBER_OF_XI
            ELSE
              IF(BASIS%NUMBER_OF_XI/=INTERPOLATION_PARAMETERS%NUMBER_OF_XI) &
                & CALL FLAG_ERROR("Inconsistent number of xi directions???",ERR,ERROR,*999)
            ENDIF
            SELECT CASE(INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%INTERPOLATION_TYPE)
            CASE(FIELD_CONSTANT_INTERPOLATION)             
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_NODE_BASED_INTERPOLATION)
              NODES_TOPOLOGY=>INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%DOMAIN%TOPOLOGY%NODES
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=BASIS%NUMBER_OF_ELEMENT_PARAMETERS
              scaling_idx=INTERPOLATION_PARAMETERS%FIELD_VARIABLE%COMPONENTS(component_idx)%SCALING_INDEX
              NULLIFY(SCALE_FACTORS)
              CALL DISTRIBUTED_VECTOR_DATA_GET(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
              DO nn=1,BASIS%NUMBER_OF_NODES
                np=FACES_TOPOLOGY%FACES(FACE_NUMBER)%NODES_IN_FACE(nn)
                DO mk=1,BASIS%NUMBER_OF_DERIVATIVES(nn)
                  nk=FACES_TOPOLOGY%FACES(FACE_NUMBER)%DERIVATIVES_IN_FACE(1,mk,nn)
                  nv=FACES_TOPOLOGY%FACES(FACE_NUMBER)%DERIVATIVES_IN_FACE(2,mk,nn)
                  ns=BASIS%ELEMENT_PARAMETER_INDEX(mk,nn)
                  ny=NODES_TOPOLOGY%NODES(np)%DERIVATIVES(nk)%DOF_INDEX(nv)
                  INTERPOLATION_PARAMETERS%SCALE_FACTORS(ns,component_idx)=SCALE_FACTORS(ny)
                ENDDO !mk
              ENDDO !nn
              CALL DISTRIBUTED_VECTOR_DATA_RESTORE(INTERPOLATION_PARAMETERS%FIELD%SCALINGS%SCALINGS(scaling_idx)% &
                & SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
            CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
              INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx)=1
              INTERPOLATION_PARAMETERS%PARAMETERS(1,component_idx)=1.0_DP
            CASE DEFAULT
              LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
              & COMPONENTS(component_idx)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
              & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//" of field number "// &
              & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            LOCAL_ERROR="The face number of "//TRIM(NUMBER_TO_VSTRING(FACE_NUMBER,"*",ERR,ERROR))// &
              & " is invalid. The number must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FACES_TOPOLOGY%NUMBER_OF_FACES,"*",ERR,ERROR))// &
              & " for component number "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))//" of field number "// &
              & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ENDDO !component_idx
      CASE(FIELD_ARC_LENGTH_SCALING)
        CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
      CASE DEFAULT
        LOCAL_ERROR="The scaling type of "//TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%SCALINGS% &
          & SCALING_TYPE,"*",ERR,ERROR))//" is invalid for field number "// &
          & TRIM(NUMBER_TO_VSTRING(INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      END SELECT
    ELSE
      CALL FLAG_ERROR("Interpolation parameters is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"Interpolation scale factors:",ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Field number = ",INTERPOLATION_PARAMETERS%FIELD%USER_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Field variable number = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & VARIABLE_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Face number = ",FACE_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of components = ",INTERPOLATION_PARAMETERS%FIELD_VARIABLE% &
        & NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
      DO component_idx=1,INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS
        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Component = ",component_idx,ERR,ERROR,*999)
        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Number of parameters = ",INTERPOLATION_PARAMETERS% &
          & NUMBER_OF_PARAMETERS(component_idx),ERR,ERROR,*999)
        CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,INTERPOLATION_PARAMETERS%NUMBER_OF_PARAMETERS(component_idx),4,4, &
          & INTERPOLATION_PARAMETERS%SCALE_FACTORS(:,component_idx),'("      Scale factors :",4(X,E13.6))','(21X,4(X,E13.6))', &
          & ERR,ERROR,*999)
      ENDDO !component_idx
    ENDIF

    CALL EXITS("FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_FACE_GET")
    RETURN
999 CALL ERRORS("FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_FACE_GET",ERR,ERROR)
    CALL EXITS("FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_FACE_GET")
    RETURN 1
  END SUBROUTINE FIELD_INTERPOLATION_PARAMETERS_SCALE_FACTORS_FACE_GET

  !
  !================================================================================================================================
  !

  !>Finalises the physical point and deallocates all memory.
  SUBROUTINE FIELD_PHYSICAL_POINT_FINALISE(PHYSICAL_POINT,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_PHYSICAL_POINT_TYPE), POINTER :: PHYSICAL_POINT !<A pointer to the physical point to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELD_PHYSICAL_POINT_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(PHYSICAL_POINT)) THEN
      IF(ALLOCATED(PHYSICAL_POINT%VALUES)) DEALLOCATE(PHYSICAL_POINT%VALUES)
      DEALLOCATE(PHYSICAL_POINT)
    ENDIF

    CALL EXITS("FIELD_PHYSICAL_POINT_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_PHYSICAL_POINT_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_PHYSICAL_POINT_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_PHYSICAL_POINT_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the physical point for interpolated points
  SUBROUTINE FIELD_PHYSICAL_POINT_INITIALISE(FIELD_INTERPOLATED_POINT,GEOMETRIC_INTERPOLATED_POINT,PHYSICAL_POINT, &
    & ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: FIELD_INTERPOLATED_POINT !<A pointer to the field interpolation point to initialise the physical point for
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: GEOMETRIC_INTERPOLATED_POINT !<A pointer to the geometric field interpolated point to initialise the physical point for
    TYPE(FIELD_PHYSICAL_POINT_TYPE), POINTER :: PHYSICAL_POINT !<On exit, A pointer to the physical point that has been initialised
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR
    TYPE(FIELD_TYPE), POINTER :: FIELD,GEOMETRIC_FIELD
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: FIELD_INTERPOLATION_PARAMETERS,GEOMETRIC_INTERPOLATION_PARAMETERS
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    CALL ENTERS("FIELD_PHYSICAL_POINT_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD_INTERPOLATED_POINT)) THEN
      IF(ASSOCIATED(GEOMETRIC_INTERPOLATED_POINT)) THEN
        FIELD_INTERPOLATION_PARAMETERS=>FIELD_INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
        IF(ASSOCIATED(FIELD_INTERPOLATION_PARAMETERS)) THEN
          GEOMETRIC_INTERPOLATION_PARAMETERS=>GEOMETRIC_INTERPOLATED_POINT%INTERPOLATION_PARAMETERS
          IF(ASSOCIATED(GEOMETRIC_INTERPOLATION_PARAMETERS)) THEN
            FIELD=>FIELD_INTERPOLATION_PARAMETERS%FIELD
            IF(ASSOCIATED(FIELD)) THEN
              GEOMETRIC_FIELD=>GEOMETRIC_INTERPOLATION_PARAMETERS%FIELD
              IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
                IF(ASSOCIATED(FIELD%GEOMETRIC_FIELD,GEOMETRIC_FIELD)) THEN
                  IF(ASSOCIATED(PHYSICAL_POINT)) THEN
                    CALL FLAG_ERROR("Physical point is already associated.",ERR,ERROR,*998)
                  ELSE
                    ALLOCATE(PHYSICAL_POINT,STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate physical point",ERR,ERROR,*999)
                    PHYSICAL_POINT%FIELD_INTERPOLATED_POINT=>FIELD_INTERPOLATED_POINT
                    PHYSICAL_POINT%GEOMETRIC_INTERPOLATED_POINT=>GEOMETRIC_INTERPOLATED_POINT
                    PHYSICAL_POINT%PHYSICAL_DERIVATIVE_TYPE=0
                    ALLOCATE(PHYSICAL_POINT%VALUES(FIELD_INTERPOLATION_PARAMETERS%FIELD_VARIABLE%NUMBER_OF_COMPONENTS),STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate physical point values.",ERR,ERROR,*999)
                    PHYSICAL_POINT%VALUES=0.0_DP
                  ENDIF
                ELSE
                  CALL FLAG_ERROR("The field geometric field and the specified geometric field are not associated.", &
                    & ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FLAG_ERROR("Geometric interpolation parameters field is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FLAG_ERROR("Field interpolation parameters field is not associated.",ERR,ERROR,*999)
            ENDIF
          ELSE
            CALL FLAG_ERROR("Geometric interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
          ENDIF
        ELSE
          CALL FLAG_ERROR("Field interpolated point interpolation parameters is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FLAG_ERROR("Geometric interpolated point is not associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field interpolated point is not associated.",ERR,ERROR,*998)
    ENDIF

    CALL EXITS("FIELD_PHYSICAL_POINT_INITIALISE")
    RETURN
999 CALL FIELD_PHYSICAL_POINT_FINALISE(PHYSICAL_POINT,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("FIELD_PHYSICAL_POINT_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_PHYSICAL_POINT_INITIALISE")
    RETURN 1
    
  END SUBROUTINE FIELD_PHYSICAL_POINT_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises the physical points and deallocates all memory.
  SUBROUTINE FIELD_PHYSICAL_POINTS_FINALISE(PHYSICAL_POINTS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_PHYSICAL_POINT_PTR_TYPE), POINTER :: PHYSICAL_POINTS(:) !<A pointer to the physical points to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: var_type_idx

    CALL ENTERS("FIELD_PHYSICAL_POINTS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(PHYSICAL_POINTS)) THEN
      DO var_type_idx=1,SIZE(PHYSICAL_POINTS,1)
        CALL FIELD_PHYSICAL_POINT_FINALISE(PHYSICAL_POINTS(var_type_idx)%PTR,ERR,ERROR,*999)
      ENDDO !var_type_idx
      DEALLOCATE(PHYSICAL_POINTS)
    ENDIF

    CALL EXITS("FIELD_PHYSICAL_POINTS_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_PHYSICAL_POINTS_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_PHYSICAL_POINTS_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_PHYSICAL_POINTS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the physical point for an interpolation parameters
  SUBROUTINE FIELD_PHYSICAL_POINTS_INITIALISE(FIELD_INTERPOLATED_POINTS,GEOMETRIC_INTERPOLATED_POINTS, &
    & PHYSICAL_POINTS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: FIELD_INTERPOLATED_POINTS(:) !<A pointer to the field interpolated points to initialise the physical points for
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: GEOMETRIC_INTERPOLATED_POINTS(:) !<A pointer to the geometric interpolated points to initialise the physical points for
    TYPE(FIELD_PHYSICAL_POINT_PTR_TYPE), POINTER :: PHYSICAL_POINTS(:) !<On exit, A pointer to the physical points that has been initialised. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,var_type_idx
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    CALL ENTERS("FIELD_PHYSICAL_POINTS_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELD_INTERPOLATED_POINTS)) THEN
      IF(ASSOCIATED(GEOMETRIC_INTERPOLATED_POINTS)) THEN
        IF(ASSOCIATED(PHYSICAL_POINTS)) THEN
          CALL FLAG_ERROR("Physical points is already associated.",ERR,ERROR,*998)
        ELSE
          ALLOCATE(PHYSICAL_POINTS(FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate physical points.",ERR,ERROR,*999)
          DO var_type_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES

            NULLIFY(PHYSICAL_POINTS(var_type_idx)%PTR)
            IF(ASSOCIATED(FIELD_INTERPOLATED_POINTS(var_type_idx)%PTR).AND. &
              & ASSOCIATED(GEOMETRIC_INTERPOLATED_POINTS(var_type_idx)%PTR)) &
              & CALL FIELD_PHYSICAL_POINT_INITIALISE(FIELD_INTERPOLATED_POINTS(var_type_idx)%PTR, &
              & GEOMETRIC_INTERPOLATED_POINTS(var_type_idx)%PTR,PHYSICAL_POINTS(var_type_idx)%PTR,ERR,ERROR,*999)
          ENDDO !var_type_idx
        ENDIF
      ELSE
        CALL FLAG_ERROR("Geometric interpolated points is not associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field interpolated points is not associated.",ERR,ERROR,*998)
    ENDIF
    
    CALL EXITS("FIELD_PHYSICAL_POINTS_INITIALISE")
    RETURN
999 CALL FIELD_PHYSICAL_POINTS_FINALISE(PHYSICAL_POINTS,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("FIELD_PHYSICAL_POINTS_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_PHYSICAL_POINTS_INITIALISE")
    RETURN 1
    
  END SUBROUTINE FIELD_PHYSICAL_POINTS_INITIALISE
  
  !
  !================================================================================================================================
  !

  !>Calculates the mappings to/from the degrees of freedom and the parameters for a field.
  SUBROUTINE FIELD_MAPPINGS_CALCULATE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to calculate the mappings for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx,component_idx,domain_type_idx,VARIABLE_GLOBAL_DOFS_OFFSET,NUMBER_OF_GLOBAL_VARIABLE_DOFS, &
      & NUMBER_OF_CONSTANT_DOFS,NUMBER_OF_ELEMENT_DOFS,NUMBER_OF_NODE_DOFS,NUMBER_OF_GRID_POINT_DOFS,NUMBER_OF_GAUSS_POINT_DOFS, &
      & NUMBER_OF_LOCAL_VARIABLE_DOFS,TOTAL_NUMBER_OF_VARIABLE_DOFS,NUMBER_OF_DOMAINS,variable_global_ny, &
      & variable_local_ny,domain_idx,domain_no,constant_nyy,element_ny,element_nyy,node_ny,node_nyy,grid_point_nyy, &
      & Gauss_point_nyy,version_idx,derivative_idx,ny,NUMBER_OF_COMPUTATIONAL_NODES, &
      & my_computational_node_number,domain_type_stop,start_idx,stop_idx,element_idx,node_idx,NUMBER_OF_LOCAL, NGP, MAX_NGP, &
      & gp,MPI_IERROR,NUMBER_OF_GLOBAL_DOFS,gauss_point_idx,NUMBER_OF_DATA_POINT_DOFS,data_point_nyy,dataPointIdx,elementIdx, &
      & localDataNumber,globalElementNumber
    INTEGER(INTG), ALLOCATABLE :: VARIABLE_LOCAL_DOFS_OFFSETS(:),VARIABLE_GHOST_DOFS_OFFSETS(:), &
      & localDataParamCount(:),ghostDataParamCount(:)
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_MAPPING_TYPE), POINTER :: elementsMapping,DOFS_MAPPING,FIELD_VARIABLE_DOFS_MAPPING
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_VARIABLE_COMPONENT_TYPE), POINTER :: FIELD_COMPONENT
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    TYPE(BASIS_TYPE), POINTER :: BASIS

    CALL ENTERS("FIELD_MAPPINGS_CALCULATE",ERR,ERROR,*999)
    
    IF(ASSOCIATED(FIELD)) THEN
      NUMBER_OF_COMPUTATIONAL_NODES=COMPUTATIONAL_NODES_NUMBER_GET(ERR,ERROR)
      IF(ERR/=0) GOTO 999
      my_computational_node_number=COMPUTATIONAL_NODE_NUMBER_GET(ERR,ERROR)
      IF(ERR/=0) GOTO 999
      !Calculate the number of global and local degrees of freedom for the field variables and components. Each field variable
      !component has a set of DOFs so loop over the components for each variable component and count up the DOFs.
      DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
        NUMBER_OF_CONSTANT_DOFS=0
        NUMBER_OF_ELEMENT_DOFS=0
        NUMBER_OF_NODE_DOFS=0
        NUMBER_OF_GRID_POINT_DOFS=0
        NUMBER_OF_GAUSS_POINT_DOFS=0
        NUMBER_OF_DATA_POINT_DOFS=0
        NUMBER_OF_LOCAL_VARIABLE_DOFS=0
        TOTAL_NUMBER_OF_VARIABLE_DOFS=0
        NUMBER_OF_GLOBAL_VARIABLE_DOFS=0
        DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
          FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
          SELECT CASE(FIELD_COMPONENT%INTERPOLATION_TYPE)
          CASE(FIELD_CONSTANT_INTERPOLATION)
            NUMBER_OF_CONSTANT_DOFS=NUMBER_OF_CONSTANT_DOFS+1
            NUMBER_OF_LOCAL_VARIABLE_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS+1
            TOTAL_NUMBER_OF_VARIABLE_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS+1
            NUMBER_OF_GLOBAL_VARIABLE_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS+1
          CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
            DOMAIN=>FIELD_COMPONENT%DOMAIN
            DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
            NUMBER_OF_ELEMENT_DOFS=NUMBER_OF_ELEMENT_DOFS+DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
            NUMBER_OF_LOCAL_VARIABLE_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS+DOMAIN_TOPOLOGY%ELEMENTS%NUMBER_OF_ELEMENTS
            TOTAL_NUMBER_OF_VARIABLE_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS+DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
            NUMBER_OF_GLOBAL_VARIABLE_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS+DOMAIN_TOPOLOGY%ELEMENTS%NUMBER_OF_GLOBAL_ELEMENTS
          CASE(FIELD_NODE_BASED_INTERPOLATION)
            DOMAIN=>FIELD_COMPONENT%DOMAIN
            DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
            NUMBER_OF_NODE_DOFS=NUMBER_OF_NODE_DOFS+DOMAIN_TOPOLOGY%DOFS%TOTAL_NUMBER_OF_DOFS
            NUMBER_OF_LOCAL_VARIABLE_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS+DOMAIN_TOPOLOGY%DOFS%NUMBER_OF_DOFS
            TOTAL_NUMBER_OF_VARIABLE_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS+DOMAIN_TOPOLOGY%DOFS%TOTAL_NUMBER_OF_DOFS
            NUMBER_OF_GLOBAL_VARIABLE_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS+DOMAIN_TOPOLOGY%DOFS%NUMBER_OF_GLOBAL_DOFS
          CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
            CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
          CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
            DOMAIN=>FIELD_COMPONENT%DOMAIN
            DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
            MAX_NGP = -1
            DO element_idx=1,DOMAIN_TOPOLOGY%ELEMENTS%NUMBER_OF_ELEMENTS
              BASIS=>DOMAIN_TOPOLOGY%ELEMENTS%ELEMENTS(element_idx)%BASIS
              NGP=BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%PTR%NUMBER_OF_GAUSS
              MAX_NGP=MAX(MAX_NGP,NGP)
            ENDDO !element_idx
            CALL MPI_ALLREDUCE(MPI_IN_PLACE,MAX_NGP,1,MPI_INTEGER,MPI_MAX,MPI_COMM_WORLD,MPI_IERROR)
            CALL MPI_ERROR_CHECK("MPI_ALLREDUCE",MPI_IERROR,ERR,ERROR,*999)             
            NUMBER_OF_GAUSS_POINT_DOFS=NUMBER_OF_GAUSS_POINT_DOFS+DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS*MAX_NGP
            NUMBER_OF_LOCAL_VARIABLE_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS+DOMAIN_TOPOLOGY%ELEMENTS%NUMBER_OF_ELEMENTS*MAX_NGP
            TOTAL_NUMBER_OF_VARIABLE_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS+DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS*MAX_NGP
            NUMBER_OF_GLOBAL_VARIABLE_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS+DOMAIN_TOPOLOGY%ELEMENTS%NUMBER_OF_GLOBAL_ELEMENTS*MAX_NGP
          CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
            ! Data points do not have domain topology or mappings, since they're the same across all mesh components
            decompositionTopology=>FIELD%DECOMPOSITION%TOPOLOGY
            NUMBER_OF_DATA_POINT_DOFS=NUMBER_OF_DATA_POINT_DOFS+decompositionTopology%dataPoints%totalNumberOfDataPoints
            NUMBER_OF_LOCAL_VARIABLE_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS+decompositionTopology%dataPoints%numberOfDataPoints
            TOTAL_NUMBER_OF_VARIABLE_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS+decompositionTopology% &
              & dataPoints%totalNumberOfDataPoints  
            NUMBER_OF_GLOBAL_VARIABLE_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS+decompositionTopology%dataPoints% &
              & numberOfGlobalDataPoints
          CASE DEFAULT
            LOCAL_ERROR="The interpolation type of "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%INTERPOLATION_TYPE, &
              & "*",ERR,ERROR))//" is invalid for component number "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))// &
              & " of variable type  "//TRIM(NUMBER_TO_VSTRING(FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        ENDDO !component_idx
        !Allocate the DOF to parameters (nodes, elements, gauss, components etc.) maps. 
        FIELD%VARIABLES(variable_idx)%NUMBER_OF_DOFS=NUMBER_OF_LOCAL_VARIABLE_DOFS
        FIELD%VARIABLES(variable_idx)%TOTAL_NUMBER_OF_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS
        FIELD%VARIABLES(variable_idx)%NUMBER_OF_GLOBAL_DOFS=NUMBER_OF_GLOBAL_VARIABLE_DOFS
        ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,TOTAL_NUMBER_OF_VARIABLE_DOFS),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate dof to parameter map.",ERR,ERROR,*999)
        FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_DOFS=TOTAL_NUMBER_OF_VARIABLE_DOFS
        IF(NUMBER_OF_CONSTANT_DOFS>0) THEN
          ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%CONSTANT_DOF2PARAM_MAP(NUMBER_OF_CONSTANT_DOFS),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate dof to parameter constant map.",ERR,ERROR,*999)
          FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_CONSTANT_DOFS=NUMBER_OF_CONSTANT_DOFS
        ENDIF
        IF(NUMBER_OF_ELEMENT_DOFS>0) THEN
          ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(2,NUMBER_OF_ELEMENT_DOFS),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate dof to parameter element map.",ERR,ERROR,*999)
          FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_ELEMENT_DOFS=NUMBER_OF_ELEMENT_DOFS
        ENDIF
        IF(NUMBER_OF_NODE_DOFS>0) THEN
          ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(4,NUMBER_OF_NODE_DOFS),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate dof to parameter node map.",ERR,ERROR,*999)
          FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_NODE_DOFS=NUMBER_OF_NODE_DOFS
        ENDIF
        IF(NUMBER_OF_GRID_POINT_DOFS>0) THEN
          ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%GRID_POINT_DOF2PARAM_MAP(2,NUMBER_OF_GRID_POINT_DOFS),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate dof to parameter grid point map.",ERR,ERROR,*999)
          FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_GRID_POINT_DOFS=NUMBER_OF_GRID_POINT_DOFS
        ENDIF
        IF(NUMBER_OF_GAUSS_POINT_DOFS>0) THEN
          ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%GAUSS_POINT_DOF2PARAM_MAP(3,NUMBER_OF_GAUSS_POINT_DOFS),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate dof to parameter Gauss point map.",ERR,ERROR,*999)
          FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_GAUSS_POINT_DOFS=NUMBER_OF_GAUSS_POINT_DOFS
        ENDIF
        IF(NUMBER_OF_DATA_POINT_DOFS>0) THEN
          ALLOCATE(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DATA_POINT_DOF2PARAM_MAP(3,NUMBER_OF_DATA_POINT_DOFS),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate dof to parameter Gauss point map.",ERR,ERROR,*999)
          FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_DATA_POINT_DOFS=NUMBER_OF_DATA_POINT_DOFS
        ENDIF
      ENDDO !variable_idx
      !Allocate the mapping arrays
      DECOMPOSITION=>FIELD%DECOMPOSITION
      ALLOCATE(VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1),STAT=ERR)
      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate variable local dofs offsets.",ERR,ERROR,*999)
      ALLOCATE(VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1),STAT=ERR)
      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate variable ghost dofs offsets.",ERR,ERROR,*999)
      !We want to ensure that the ghost DOFs are at the end so loop over the DOFs in two passes. The first pass will process
      !the local DOFs for each variable component and the second pass will process the ghost DOFs for each variable component.
      IF(NUMBER_OF_COMPUTATIONAL_NODES==1) THEN
        domain_type_stop=1 !Local only
      ELSE
        domain_type_stop=2 !Local+Ghosts
      ENDIF
      !Calculate the local and global numbers and set up the mappings
      DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
        constant_nyy=0
        element_nyy=0
        node_nyy=0
        grid_point_nyy=0
        Gauss_point_nyy=0
        data_point_nyy=0
        variable_local_ny=0
        FIELD_VARIABLE_DOFS_MAPPING=>FIELD%VARIABLES(variable_idx)%DOMAIN_MAPPING
        IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
          ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(FIELD%VARIABLES(variable_idx)%NUMBER_OF_GLOBAL_DOFS),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate variable dofs mapping global to local map.",ERR,ERROR,*999)
          FIELD_VARIABLE_DOFS_MAPPING%NUMBER_OF_GLOBAL=FIELD%VARIABLES(variable_idx)%NUMBER_OF_GLOBAL_DOFS
        ENDIF
        !The ordering of the DOFs with respect to components is arbitrary. Allow for two orderings: The first ordering is that
        !all the DOFs from one component are processed before all the DOFs of the next component. This is known as "separated"
        !component DOF ordering. The second ordering is to process all the components for a particular parameter (e.g., node)
        !and then process all the components for the next parameter. This is known as "contiguous" component DOF ordering.
        !Continguous component ordering only works if each of the components has the same DOF structure. For this reason
        !separate component ordering is the default.
        SELECT CASE(FIELD%VARIABLES(variable_idx)%DOF_ORDER_TYPE)
        CASE(FIELD_SEPARATED_COMPONENT_DOF_ORDER)
          !Loop over the domain types. Here domain_type_idx=1 for the non-ghosted dofs and =2 for the ghosted dofs.
          VARIABLE_GHOST_DOFS_OFFSETS=0
          DO domain_type_idx=1,domain_type_stop
            VARIABLE_GLOBAL_DOFS_OFFSET=0
            VARIABLE_LOCAL_DOFS_OFFSETS=0
            DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
              NUMBER_OF_LOCAL=0
              FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
              SELECT CASE(FIELD_COMPONENT%INTERPOLATION_TYPE)
              CASE(FIELD_CONSTANT_INTERPOLATION)
                !Only process the non-ghosted dofs for constant interpolation
                IF(domain_type_idx==1) THEN
                  variable_local_ny=variable_local_ny+1
                  !Allocate and set up global to local domain map for variable mapping
                  IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                    variable_global_ny=1+VARIABLE_GLOBAL_DOFS_OFFSET
                    CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                      & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)
                    NUMBER_OF_DOMAINS=NUMBER_OF_COMPUTATIONAL_NODES !Constant is in all domains
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(NUMBER_OF_DOMAINS), &
                      & STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map local number.", &
                      & ERR,ERROR,*999)
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(NUMBER_OF_DOMAINS), &
                      & STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map domain number.", &
                      & ERR,ERROR,*999)
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(NUMBER_OF_DOMAINS), &
                      & STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map local type.", &
                      & ERR,ERROR,*999)
                    !A constant dof is mapped to all domains.
                    FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                    DO domain_idx=1,NUMBER_OF_DOMAINS
                      domain_no=domain_idx-1
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                        & 1+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)=domain_no
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)= &
                        & DOMAIN_LOCAL_INTERNAL
                    ENDDO !domain_idx
                  ENDIF
                  constant_nyy=constant_nyy+1
                  !Setup dof to parameter map
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_CONSTANT_DOF_TYPE
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=constant_nyy
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%CONSTANT_DOF2PARAM_MAP(constant_nyy)=component_idx
                  !Setup reverse parameter to dof map
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS=1
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP=variable_local_ny
                  !Adjust the offsets
                  VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+1
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+1
                ENDIF
              CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                DOMAIN=>FIELD_COMPONENT%DOMAIN
                DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                elementsMapping=>DOMAIN%MAPPINGS%ELEMENTS
                IF(domain_type_idx==1) THEN
                  !Allocate parameter to dof map for this field variable component
                  DOFS_MAPPING=>DOMAIN%MAPPINGS%ELEMENTS
                  ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(DOMAIN_TOPOLOGY%ELEMENTS% &
                    & TOTAL_NUMBER_OF_ELEMENTS),STAT=ERR)
                  IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field component parameter to dof element map.",ERR,ERROR,*999)
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS= &
                    & DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                  !Handle global dofs domain mapping
                  DO ny=1,elementsMapping%NUMBER_OF_GLOBAL
                    !Handle field variable mappings
                    IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                      variable_global_ny=ny+VARIABLE_GLOBAL_DOFS_OFFSET
                      CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                        & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)
                      NUMBER_OF_DOMAINS=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%NUMBER_OF_DOMAINS
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                        & LOCAL_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map local number.", &
                        & ERR,ERROR,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                        & DOMAIN_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map domain number.", &
                        & ERR,ERROR,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(NUMBER_OF_DOMAINS), &
                        & STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map local type.", &
                        & ERR,ERROR,*999)
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                      DO domain_idx=1,NUMBER_OF_DOMAINS
                        domain_no=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                          & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_NUMBER(domain_idx)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)= &
                          & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)= &
                          & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_TYPE(domain_idx)
                      ENDDO !domain_idx
                    ENDIF
                  ENDDO !ny
                  start_idx=1
                  stop_idx=elementsMapping%NUMBER_OF_LOCAL
                  !Adjust the local and ghost offsets
                  IF(component_idx>1) &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+elementsMapping%NUMBER_OF_DOMAIN_LOCAL
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                    & elementsMapping%NUMBER_OF_DOMAIN_LOCAL+elementsMapping%NUMBER_OF_DOMAIN_GHOST
                ELSE
                  !Handle global dofs domain mapping. For the second pass adjust the local dof numbers to ensure that the ghost
                  !dofs are at the end of the local dofs.
                  !Adjust the ghost offsets
                  IF(component_idx>1) &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)-elementsMapping%NUMBER_OF_DOMAIN_LOCAL
                  DO ny=1,elementsMapping%NUMBER_OF_GLOBAL
                    !Adjust variable mapping local numbers
                    IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                      variable_global_ny=ny+VARIABLE_GLOBAL_DOFS_OFFSET
                      NUMBER_OF_DOMAINS=FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS
                      DO domain_idx=1,NUMBER_OF_DOMAINS
                        domain_no=FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)
                        IF(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)== &
                          & DOMAIN_LOCAL_GHOST) THEN
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                            & FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)+ &
                            & VARIABLE_GHOST_DOFS_OFFSETS(domain_no)
                        ELSE
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                            & FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)+ &
                            & VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                        ENDIF
                      ENDDO !domain_idx
                    ENDIF
                  ENDDO !ny (global)
                  start_idx=elementsMapping%NUMBER_OF_LOCAL+1
                  stop_idx=elementsMapping%TOTAL_NUMBER_OF_LOCAL
                  !Adjust the local offsets
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)-elementsMapping%NUMBER_OF_DOMAIN_GHOST
                ENDIF
                !Adjust the global offset
                VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+elementsMapping%NUMBER_OF_GLOBAL
                !Handle local dofs domain mapping
                DO element_idx=start_idx,stop_idx
                  variable_local_ny=variable_local_ny+1
                  element_nyy=element_nyy+1
                  !Setup dof to parameter map
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_ELEMENT_DOF_TYPE
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=element_nyy
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(1,element_nyy)=element_idx
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(2,element_nyy)=component_idx
                  !Setup reverse parameter to dof map
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(element_idx)=variable_local_ny
                ENDDO !element_idx
              CASE(FIELD_NODE_BASED_INTERPOLATION)
                DOMAIN=>FIELD_COMPONENT%DOMAIN
                DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                DOFS_MAPPING=>DOMAIN%MAPPINGS%DOFS
                IF(domain_type_idx==1) THEN
                  ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES( &
                    DOMAIN_TOPOLOGY%NODES%TOTAL_NUMBER_OF_NODES),STAT=ERR)
                  IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field component parameter to dof node map (nodes).",ERR,ERROR,*999)
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS = & 
                    & DOMAIN_TOPOLOGY%NODES%TOTAL_NUMBER_OF_NODES
                  !Loop through and allocate number of derivatives for each node in the domain
                  DO node_idx=1,DOMAIN_TOPOLOGY%NODES%TOTAL_NUMBER_OF_NODES
                    ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES( &
                      & DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES),STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field component parameter to dof node map (derivatives).", &
                      & ERR,ERROR,*999)
                    FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%NUMBER_OF_DERIVATIVES = & 
                      & DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                    DO derivative_idx=1,DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                      ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)% &
                        & VERSIONS(DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions),STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field component parameter to dof node map (versions).", &
                        & ERR,ERROR,*999)
                      FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)% &
                        & NUMBER_OF_VERSIONS = DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                    ENDDO !derivative_idx
                  ENDDO !node_idx
                  DO ny=1,DOFS_MAPPING%NUMBER_OF_GLOBAL
                    !Handle variable mapping
                    IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                      variable_global_ny=ny+VARIABLE_GLOBAL_DOFS_OFFSET
                      CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                        & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)
                      NUMBER_OF_DOMAINS=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%NUMBER_OF_DOMAINS
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                        & LOCAL_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map local number.", &
                        & ERR,ERROR,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                        & DOMAIN_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map domain number.", &
                        & ERR,ERROR,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(NUMBER_OF_DOMAINS), &
                        & STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map local type.", &
                        & ERR,ERROR,*999)
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                      DO domain_idx=1,NUMBER_OF_DOMAINS
                        domain_no=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                          & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_NUMBER(domain_idx)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)= &
                          & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)= &
                          & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_TYPE(domain_idx)
                      ENDDO !domain_idx
                    ENDIF
                  ENDDO !ny (global)
                  start_idx=1
                  stop_idx=DOFS_MAPPING%NUMBER_OF_LOCAL
                  !Adjust the local and ghost offsets
                  IF(component_idx>1) &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+DOFS_MAPPING%NUMBER_OF_DOMAIN_LOCAL
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                    & DOFS_MAPPING%NUMBER_OF_DOMAIN_LOCAL+DOFS_MAPPING%NUMBER_OF_DOMAIN_GHOST
                ELSE
                  !Handle global dofs domain mapping. For the second pass adjust the local dof numbers to ensure that the ghost
                  !dofs are at the end of the local dofs.
                  !Adjust the ghost offsets
                  IF(component_idx>1) &
                    VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)-DOFS_MAPPING%NUMBER_OF_DOMAIN_LOCAL
                  DO ny=1,DOFS_MAPPING%NUMBER_OF_GLOBAL
                    !Adjust variable mapping local numbers
                    IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                      variable_global_ny=ny+VARIABLE_GLOBAL_DOFS_OFFSET
                      NUMBER_OF_DOMAINS=FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS
                      DO domain_idx=1,NUMBER_OF_DOMAINS
                        domain_no=FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)
                        IF(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)== &
                          & DOMAIN_LOCAL_GHOST) THEN
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                            & FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)+ &
                            & VARIABLE_GHOST_DOFS_OFFSETS(domain_no)
                        ELSE
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                            & FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)+ &
                            & VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                         ENDIF
                      ENDDO !domain_idx
                    ENDIF
                  ENDDO !ny (global)
                  start_idx=DOFS_MAPPING%NUMBER_OF_LOCAL+1
                  stop_idx=DOFS_MAPPING%TOTAL_NUMBER_OF_LOCAL
                  !Adjust the local offsets
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)-DOFS_MAPPING%NUMBER_OF_DOMAIN_GHOST
                ENDIF
                !Adjust the global offset
                VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+DOFS_MAPPING%NUMBER_OF_GLOBAL
                !Handle local dofs domain mapping
                DO ny=start_idx,stop_idx
                  variable_local_ny=variable_local_ny+1
                  node_nyy=node_nyy+1
                  version_idx=DOMAIN%TOPOLOGY%DOFS%DOF_INDEX(1,ny)
                  derivative_idx=DOMAIN%TOPOLOGY%DOFS%DOF_INDEX(2,ny)
                  node_idx=DOMAIN%TOPOLOGY%DOFS%DOF_INDEX(3,ny)
                  !Setup dof to parameter map
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_NODE_DOF_TYPE
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=node_nyy
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(1,node_nyy)=version_idx
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(2,node_nyy)=derivative_idx
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(3,node_nyy)=node_idx
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(4,node_nyy)=component_idx
                  !Setup reverse parameter to dof map
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)% &
                    & VERSIONS(version_idx) = variable_local_ny
                ENDDO !ny
              CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
              CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                DOMAIN=>FIELD_COMPONENT%DOMAIN
                elementsMapping=>DOMAIN%MAPPINGS%ELEMENTS
                DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                IF(domain_type_idx==1) THEN ! domain_type_idx==1 --> non ghosts
                  !Allocate parameter to dof map for this field variable component
                  DOFS_MAPPING=>DOMAIN%MAPPINGS%ELEMENTS
                  ! GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(ng,element_idx). The field variable dof number of ng'th Gauss point in the element_idx'th element based parameter for this field variable component. 
                  ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(&
                   & MAX_NGP,DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS),STAT=ERR)
                  IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field component parameter to dof Gauss point map.",ERR,ERROR,*999)
                  ! this might be wasteful in worst case, but should generally be ok
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%NUMBER_OF_GAUSS_POINT_PARAMETERS= &
                  &  DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS*MAX_NGP
                  !Handle global dofs domain mapping
                  DO ny=1,elementsMapping%NUMBER_OF_GLOBAL
                   DO gp=1,MAX_NGP !
                    !Handle field variable mappings
                    IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                      variable_global_ny= (ny-1) * MAX_NGP + gp + VARIABLE_GLOBAL_DOFS_OFFSET
                      CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                        & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)
                      NUMBER_OF_DOMAINS=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%NUMBER_OF_DOMAINS
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                        & LOCAL_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map local number.", &
                        & ERR,ERROR,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                        & DOMAIN_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map domain number.", &
                        & ERR,ERROR,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(NUMBER_OF_DOMAINS), &
                        & STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map domain number.", &
                        & ERR,ERROR,*999)
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                      DO domain_idx=1,NUMBER_OF_DOMAINS
                        domain_no=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                        ! elt local number = 1 -> gp local = 1..max_ngp, etc
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                          & (DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_NUMBER(domain_idx) - 1) * MAX_NGP + gp  &
                          & + VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                        ! domain and type same as element
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)= &
                          & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)= &
                          & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_TYPE(domain_idx)
                      ENDDO !domain_idx
                    ENDIF
                   ENDDO ! gp
                  ENDDO !ny
                  start_idx=1
                  stop_idx=elementsMapping%NUMBER_OF_LOCAL
                  !Adjust the local and ghost offsets
                  IF(component_idx>1) &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                    & elementsMapping%NUMBER_OF_DOMAIN_LOCAL*MAX_NGP
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                    & (elementsMapping%NUMBER_OF_DOMAIN_LOCAL+elementsMapping%NUMBER_OF_DOMAIN_GHOST)*MAX_NGP
                ELSE !domain_type_idx==2 --> ghosts
                  !Handle global dofs domain mapping. For the second pass adjust the local dof numbers to ensure that the ghost
                  !dofs are at the end of the local dofs.
                  !Adjust the ghost offsets
                  IF(component_idx>1) &
                    VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)- &
                    & elementsMapping%NUMBER_OF_DOMAIN_LOCAL*MAX_NGP
                  DO ny=1,elementsMapping%NUMBER_OF_GLOBAL
                   DO gp=1,MAX_NGP !
                    !Adjust variable mapping local numbers
                    IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                      variable_global_ny= (ny-1) * MAX_NGP + gp + VARIABLE_GLOBAL_DOFS_OFFSET
                      NUMBER_OF_DOMAINS=FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS
                      DO domain_idx=1,NUMBER_OF_DOMAINS
                        domain_no=FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)
                        IF(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)== &
                          & DOMAIN_LOCAL_GHOST) THEN
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                            & FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)+ &
                            & VARIABLE_GHOST_DOFS_OFFSETS(domain_no)
                        ELSE
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                            & FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)+ &
                            & VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                        ENDIF
                      ENDDO !domain_idx
                    ENDIF
                   ENDDO ! gp
                  ENDDO !ny (global)
                  start_idx=elementsMapping%NUMBER_OF_LOCAL+1
                  stop_idx=elementsMapping%TOTAL_NUMBER_OF_LOCAL
                  !Adjust the local offsets
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)- &
                    & elementsMapping%NUMBER_OF_DOMAIN_GHOST*MAX_NGP
                ENDIF ! 2 passes for normal, ghost 
                !Adjust the global offset
                VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+elementsMapping%NUMBER_OF_GLOBAL*MAX_NGP
                !Handle local dofs domain mapping
                DO element_idx=start_idx,stop_idx
                 DO gp=1,MAX_NGP !
                  variable_local_ny= variable_local_ny+1
                  Gauss_point_nyy  = Gauss_point_nyy+1
                   !Setup dof to parameter map
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_GAUSS_POINT_DOF_TYPE
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=Gauss_point_nyy
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%GAUSS_POINT_DOF2PARAM_MAP(1,Gauss_point_nyy)=gp
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%GAUSS_POINT_DOF2PARAM_MAP(2,Gauss_point_nyy)=element_idx
                  FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%GAUSS_POINT_DOF2PARAM_MAP(3,Gauss_point_nyy)=component_idx
                  !Setup reverse parameter to dof map
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gp,element_idx)=variable_local_ny
                 ENDDO !gp
                ENDDO !element_idx                       
              CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                domain=>FIELD_COMPONENT%DOMAIN
                elementsMapping=>domain%MAPPINGS%ELEMENTS
                decompositionTopology=>domain%DECOMPOSITION%TOPOLOGY                
                IF(domain_type_idx==1) THEN ! domain_type_idx==1 -> non ghosts
                  !Allocate parameter to dof map for this field variable component
                  !including both local and ghost data points on this computational domain.
                  ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionTopology% &
                    & dataPoints%totalNumberOfDataPoints),STAT=ERR)
                  IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field component parameter to dof data point map.",ERR,ERROR,*999)
                  ! Number of data points
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS= &
                    & decompositionTopology%dataPoints%totalNumberOfDataPoints 
                  ALLOCATE(localDataParamCount(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1),STAT=ERR)
                  IF(ERR/=0) CALL FLAG_ERROR("Could not allocate data point parameter local count.",ERR,ERROR,*999)
                  ALLOCATE(ghostDataParamCount(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1),STAT=ERR)
                  IF(ERR/=0) CALL FLAG_ERROR("Could not allocate data point parameter ghost count.",ERR,ERROR,*999)
                  localDataParamCount=0
                  ghostDataParamCount(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)=decompositionTopology%dataPoints%numberOfDomainLocal
                  !Looping through global elements and data points in the elements
                  variable_global_ny=VARIABLE_GLOBAL_DOFS_OFFSET
                  DO elementIdx=1,elementsMapping%NUMBER_OF_GLOBAL
                    DO dataPointIdx=1,decompositionTopology%dataPoints%numberOfelementDataPoints(elementIdx)
                      IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                        variable_global_ny=variable_global_ny+1
                        CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                          & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)
                        NUMBER_OF_DOMAINS=elementsMapping%GLOBAL_TO_LOCAL_MAP(elementIdx)%NUMBER_OF_DOMAINS
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                          & LOCAL_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map local number.", &
                          & ERR,ERROR,*999)
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                          & DOMAIN_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map domain number.", &
                          & ERR,ERROR,*999)
                        ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                          & LOCAL_TYPE(NUMBER_OF_DOMAINS),STAT=ERR)
                        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map local type.", &
                          & ERR,ERROR,*999)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                        DO domain_idx=1,NUMBER_OF_DOMAINS
                          domain_no=elementsMapping%GLOBAL_TO_LOCAL_MAP(elementIdx)%DOMAIN_NUMBER(domain_idx)
                          IF(elementsMapping%GLOBAL_TO_LOCAL_MAP(elementIdx)%LOCAL_TYPE(domain_idx)== &
                            & DOMAIN_LOCAL_GHOST) THEN
                            ghostDataParamCount(domain_no)=ghostDataParamCount(domain_no)+1
                            FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                            & ghostDataParamCount(domain_no)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                          ELSE
                            localDataParamCount(domain_no)=localDataParamCount(domain_no)+1
                            FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                            & localDataParamCount(domain_no)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                          ENDIF
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)= &
                            & elementsMapping%GLOBAL_TO_LOCAL_MAP(elementIdx)%DOMAIN_NUMBER(domain_idx)
                          FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)= &
                            & elementsMapping%GLOBAL_TO_LOCAL_MAP(elementIdx)%LOCAL_TYPE(domain_idx)
                        ENDDO !domain_idx
                      ENDIF
                    ENDDO !dataPointIdx
                  ENDDO !elementIdx 
                  IF(ALLOCATED(localDataParamCount)) DEALLOCATE(localDataParamCount)
                  IF(ALLOCATED(ghostDataParamCount)) DEALLOCATE(ghostDataParamCount)
                  start_idx=1 !the start idx for the elements
                  stop_idx=elementsMapping%NUMBER_OF_LOCAL !the end idx for local elements
                  !Adjust the local and ghost offsets
                  IF(component_idx>1) THEN
                    VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                      & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                      & decompositionTopology%dataPoints%numberOfDomainLocal
                  ENDIF
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                    & decompositionTopology%dataPoints%numberOfDomainLocal+decompositionTopology%dataPoints%numberOfDomainGhost
                ELSE  ! domain_type_idx == 2 -> ghosts
                  !Handle global dofs domain mapping. For the second pass adjust the local dof numbers to ensure that the ghost
                  !dofs are at the end of the local dofs.
                  !Adjust the ghost offsets
                  IF(component_idx>1) THEN
                    VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                      & VARIABLE_GHOST_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)- &
                      & decompositionTopology%dataPoints%numberOfDomainLocal
                  ENDIF
                  !Looping through global elements and data points in the elements
                  variable_global_ny=VARIABLE_GLOBAL_DOFS_OFFSET
                  DO elementIdx=1,elementsMapping%NUMBER_OF_GLOBAL
                    DO dataPointIdx=1,decompositionTopology%dataPoints%numberOfelementDataPoints(elementIdx)
                      IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                        variable_global_ny=variable_global_ny+1
                        NUMBER_OF_DOMAINS=elementsMapping%GLOBAL_TO_LOCAL_MAP(elementIdx)%NUMBER_OF_DOMAINS
                        DO domain_idx=1,NUMBER_OF_DOMAINS
                          domain_no=elementsMapping%GLOBAL_TO_LOCAL_MAP(elementIdx)%DOMAIN_NUMBER(domain_idx)
                          IF(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)== &
                            & DOMAIN_LOCAL_GHOST) THEN
                            FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                              & FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)+ &
                              & VARIABLE_GHOST_DOFS_OFFSETS(domain_no)
                          ELSE
                            FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                              & FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)+ &
                              & VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                          ENDIF
                        ENDDO
                      ENDIF
                    ENDDO !dataPointIdx
                  ENDDO !elementIdx 
                  !Adjust the local offsets
                  VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                    & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)- &
                    & decompositionTopology%dataPoints%numberOfDomainGhost
                  start_idx=elementsMapping%NUMBER_OF_LOCAL+1 !The start index for ghost elements
                  stop_idx=elementsMapping%TOTAL_NUMBER_OF_LOCAL !The end index for local elements
                ENDIF 
                !Adjust the global offset
                VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+decompositionTopology%dataPoints%&
                  & numberOfGlobalDataPoints  
                !Handle local dofs domain mapping
                DO elementIdx=start_idx,stop_idx
                  globalElementNumber=elementsMapping%LOCAL_TO_GLOBAL_MAP(elementIdx)
                  DO dataPointIdx=1,decompositionTopology%dataPoints%numberOfelementDataPoints(globalElementNumber)
                    variable_local_ny=variable_local_ny+1 !reinitialise for every field variable, field variable dof idx
                    data_point_nyy=data_point_nyy+1 !reinitialise for every field variable, field variable data point dof idx
                    localDataNumber=decompositionTopology%dataPoints%elementDataPoint(elementIdx)%dataIndices(dataPointIdx)% &
                      & localNumber
                    !Setup dof to parameter map
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_DATA_POINT_DOF_TYPE
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=data_point_nyy
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DATA_POINT_DOF2PARAM_MAP(1,data_point_nyy)=localDataNumber
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DATA_POINT_DOF2PARAM_MAP(2,data_point_nyy)=elementIdx
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DATA_POINT_DOF2PARAM_MAP(3,data_point_nyy)=component_idx
                    !Setup reverse parameter to dof map
                    FIELD_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(localDataNumber)=variable_local_ny
                  ENDDO !dataPointIdx
                ENDDO !elementIdx 
              CASE DEFAULT
                LOCAL_ERROR="The interpolation type of "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%INTERPOLATION_TYPE, &
                  & "*",ERR,ERROR))//" is invalid for component number "//TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))// &
                  & " of variable type "//TRIM(NUMBER_TO_VSTRING(FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              END SELECT
            ENDDO !component_idx
          ENDDO !domain_type_idx
        CASE(FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER)
          !Handle the case where all components for a particular DOF parameter are processed before all the component of the next
          !parameter.
          VARIABLE_LOCAL_DOFS_OFFSETS=0
          VARIABLE_GLOBAL_DOFS_OFFSET=0
          VARIABLE_GHOST_DOFS_OFFSETS=0
          IF(FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS>=1) THEN
            SELECT CASE(FIELD%VARIABLES(variable_idx)%COMPONENTS(1)%INTERPOLATION_TYPE)
            CASE(FIELD_CONSTANT_INTERPOLATION)
              DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                variable_local_ny=1+VARIABLE_LOCAL_DOFS_OFFSETS(my_computational_node_number)
                !Allocate and set up global to local domain map for variable mapping
                IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                  variable_global_ny=1+VARIABLE_GLOBAL_DOFS_OFFSET
                  CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                    & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)
                  NUMBER_OF_DOMAINS=NUMBER_OF_COMPUTATIONAL_NODES !Constant is in all domains
                  ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(NUMBER_OF_DOMAINS), &
                    & STAT=ERR)
                  IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map local number.", &
                    & ERR,ERROR,*999)
                  ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(NUMBER_OF_DOMAINS), &
                    & STAT=ERR)
                  IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map domain number.", &
                    & ERR,ERROR,*999)
                  ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(NUMBER_OF_DOMAINS), &
                    & STAT=ERR)
                  IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map local type.", &
                    & ERR,ERROR,*999)
                  !A constant dof is mapped to all domains.
                  FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                  DO domain_idx=1,NUMBER_OF_DOMAINS
                    domain_no=domain_idx-1
                    FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                      & 1+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                    FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)=domain_no
                    FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)=DOMAIN_LOCAL_INTERNAL
                  ENDDO !domain_idx
                ENDIF
                constant_nyy=constant_nyy+1
                !Setup dof to parameter map
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_CONSTANT_DOF_TYPE
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=constant_nyy
                FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%CONSTANT_DOF2PARAM_MAP(constant_nyy)=component_idx
                !Setup reverse parameter to dof map
                FIELD_COMPONENT%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS=1
                FIELD_COMPONENT%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP=variable_local_ny
                !Adjust the offsets
                VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+1
                VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                  & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+1
              ENDDO !component_idx
            CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
              DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                DOMAIN=>FIELD_COMPONENT%DOMAIN
                DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                !Allocate parameter to dof map for this field variable component
                ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(DOMAIN_TOPOLOGY%ELEMENTS% &
                  & TOTAL_NUMBER_OF_ELEMENTS),STAT=ERR)
                IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field component parameter to dof element map.",ERR,ERROR,*999)
                FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS= &
                  & DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
              ENDDO !component_idx
              !Handle global dofs domain mapping
              element_ny=0
              DO ny=1,elementsMapping%NUMBER_OF_GLOBAL ! elementsMapping has not been associated for this case !?!
                DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                  FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                  DOMAIN=>FIELD_COMPONENT%DOMAIN
                  DOFS_MAPPING=>DOMAIN%MAPPINGS%ELEMENTS
                  !Handle field variable mappings
                  IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                    element_ny=element_ny+1
                    variable_global_ny=element_ny+VARIABLE_GLOBAL_DOFS_OFFSET
                    CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                      & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)
                    NUMBER_OF_DOMAINS=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%NUMBER_OF_DOMAINS
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(NUMBER_OF_DOMAINS), &
                      & STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map local number.", &
                      & ERR,ERROR,*999)
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(NUMBER_OF_DOMAINS), &
                      & STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map domain number.", &
                      & ERR,ERROR,*999)
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(NUMBER_OF_DOMAINS), &
                      & STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map local type.", &
                      & ERR,ERROR,*999)
                    FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                    DO domain_idx=1,NUMBER_OF_DOMAINS
                      domain_no=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                        & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_NUMBER(domain_idx)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)= &
                        & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)= &
                        & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_TYPE(domain_idx)
                    ENDDO !domain_idx
                  ENDIF
                ENDDO !component_idx
              ENDDO !ny
              !Loop over the domain types. Here domain_type_idx=1 for the non-ghosted dofs and =2 for the ghosted dofs.
              DO domain_type_idx=1,domain_type_stop
                IF(domain_type_idx==1) THEN
                  start_idx=1
                  stop_idx=elementsMapping%NUMBER_OF_LOCAL
                ELSE
                  start_idx=elementsMapping%NUMBER_OF_LOCAL+1
                  stop_idx=elementsMapping%TOTAL_NUMBER_OF_LOCAL
                ENDIF
                !Handle local dofs domain mapping
                element_ny=0
                DO element_idx=start_idx,stop_idx
                  DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                    FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                    element_ny=element_ny+1
                    variable_local_ny=element_ny+VARIABLE_LOCAL_DOFS_OFFSETS(my_computational_node_number)
                    element_nyy=element_nyy+1
                    !Setup dof to parameter map
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_ELEMENT_DOF_TYPE
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=element_nyy
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(1,element_nyy)=element_idx
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP(2,element_nyy)=component_idx
                    !Setup reverse parameter to dof map
                    FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(element_idx)=variable_local_ny
                  ENDDO !component_idx
                ENDDO !element_idx
                !Adjust the offsets
                VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                  &  VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                  & FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS* &
                  & elementsMapping%NUMBER_OF_DOMAIN_LOCAL
                IF(domain_type_idx==1) THEN
                  VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS* &
                    & elementsMapping%NUMBER_OF_GLOBAL
                ENDIF
              ENDDO !domain_type_idx
            CASE(FIELD_NODE_BASED_INTERPOLATION)
              DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                DOMAIN=>FIELD_COMPONENT%DOMAIN
                DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(DOMAIN_TOPOLOGY%NODES%TOTAL_NUMBER_OF_NODES), &
                  & STAT=ERR)
                IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field component parameter to dof node map (nodes).",ERR,ERROR,*999)
                FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS = &
                  & DOMAIN_TOPOLOGY%NODES%TOTAL_NUMBER_OF_NODES
                !Loop through and allocate number of derivatives for each node in the domain
                DO node_idx=1,DOMAIN_TOPOLOGY%NODES%TOTAL_NUMBER_OF_NODES
                  ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES( &
                    & DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES),STAT=ERR)
                  IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field component parameter to dof node map (derivatives).", &
                    & ERR,ERROR,*999)
                  FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%NUMBER_OF_DERIVATIVES = & 
                    & DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                  DO derivative_idx=1,DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                    ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)% &
                      & VERSIONS(DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions),STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field component parameter to dof node map (versions).", &
                      & ERR,ERROR,*999)
                    FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)% &
                      NUMBER_OF_VERSIONS = DOMAIN_TOPOLOGY%NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                  ENDDO !derivative_idx
                ENDDO !node_idx
              ENDDO !component_idx
              !Handle global dofs domain mapping
              !Should the contiguous components have an inner groupping for derivatives??? i.e., loop over nodes, components then
              !derivatives????
              node_ny=0
              NUMBER_OF_GLOBAL_DOFS=FIELD%VARIABLES(variable_idx)%COMPONENTS(1)%DOMAIN%MAPPINGS%DOFS%NUMBER_OF_GLOBAL
              DO ny=1,NUMBER_OF_GLOBAL_DOFS
                DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                  FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                  DOMAIN=>FIELD_COMPONENT%DOMAIN
                  DOFS_MAPPING=>DOMAIN%MAPPINGS%DOFS
                  !Handle variable mapping
                  IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                    node_ny=node_ny+1
                    variable_global_ny=node_ny+VARIABLE_GLOBAL_DOFS_OFFSET
                    CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                      & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)
                    NUMBER_OF_DOMAINS=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%NUMBER_OF_DOMAINS
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                      & LOCAL_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map local number.", &
                      & ERR,ERROR,*999)
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                      & DOMAIN_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map domain number.", &
                      & ERR,ERROR,*999)
                    ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(NUMBER_OF_DOMAINS), &
                      & STAT=ERR)
                    IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map local type.", &
                      & ERR,ERROR,*999)
                    FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                    DO domain_idx=1,NUMBER_OF_DOMAINS
                      domain_no=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                        & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_NUMBER(domain_idx)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)= &
                        & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)= &
                        & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_TYPE(domain_idx)
                    ENDDO !domain_idx
                  ENDIF
                ENDDO !component_idx
              ENDDO !ny (global)
              !Loop over the domain types. Here domain_type_idx=1 for the non-ghosted dofs and =2 for the ghosted dofs.
              DO domain_type_idx=1,domain_type_stop
                IF(domain_type_idx==1) THEN
                  start_idx=1
                  stop_idx=DOFS_MAPPING%NUMBER_OF_LOCAL
                ELSE
                  start_idx=DOFS_MAPPING%NUMBER_OF_LOCAL+1
                  stop_idx=DOFS_MAPPING%TOTAL_NUMBER_OF_LOCAL
                ENDIF
                !Handle local dofs domain mapping
                node_ny=0
                DO ny=start_idx,stop_idx
                  DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                    FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                    DOMAIN=>FIELD_COMPONENT%DOMAIN
                    node_ny=node_ny+1
                    variable_local_ny=node_ny+VARIABLE_LOCAL_DOFS_OFFSETS(my_computational_node_number)
                    node_nyy=node_nyy+1
                    version_idx=DOMAIN%TOPOLOGY%DOFS%DOF_INDEX(1,ny)
                    derivative_idx=DOMAIN%TOPOLOGY%DOFS%DOF_INDEX(2,ny)
                    node_idx=DOMAIN%TOPOLOGY%DOFS%DOF_INDEX(3,ny)
                    !Setup dof to parameter map
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_NODE_DOF_TYPE
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=node_nyy
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(1,node_nyy)=version_idx
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(2,node_nyy)=derivative_idx
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(3,node_nyy)=node_idx
                    FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP(4,node_nyy)=component_idx
                    !Setup reverse parameter to dof map
                    FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)% &
                      & VERSIONS(version_idx) = variable_local_ny
                  ENDDO !component_idx
                ENDDO !ny
                !Adjust the offsets
                VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                  & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                  & FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS* &
                  & DOFS_MAPPING%NUMBER_OF_DOMAIN_LOCAL
                IF(domain_type_idx==1) THEN
                  VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS* &
                    & DOFS_MAPPING%NUMBER_OF_GLOBAL
                ENDIF
              ENDDO !domain_type_idx
            CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
            CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
              DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                DOMAIN=>FIELD_COMPONENT%DOMAIN
                DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                !>todo find a better way than assuming NGP=MAX_NGP for all elements TODO
                ALLOCATE(FIELD_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(MAX_NGP,DOMAIN_TOPOLOGY% &
                  & ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS),STAT=ERR)
                IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field component parameter to dof gauss point map (gauss points).", &
                  & ERR,ERROR,*999)
                FIELD_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%NUMBER_OF_GAUSS_POINT_PARAMETERS= &
                  & MAX_NGP*DOMAIN_TOPOLOGY%ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
              ENDDO
              !Handle global dofs domain mapping
              element_ny=0
!              NUMBER_OF_GLOBAL_DOFS=FIELD%VARIABLES(variable_idx)%COMPONENTS(1)%DOMAIN%MAPPINGS%ELEMENTS%NUMBER_OF_GLOBAL
              NUMBER_OF_GLOBAL_DOFS=FIELD%VARIABLES(variable_idx)%COMPONENTS(1)%DOMAIN%TOPOLOGY%ELEMENTS%NUMBER_OF_ELEMENTS
              DO ny=1,NUMBER_OF_GLOBAL_DOFS
                DO gauss_point_idx=1,MAX_NGP
                  DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                    FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                    DOMAIN=>FIELD_COMPONENT%DOMAIN
                    DOFS_MAPPING=>DOMAIN%MAPPINGS%ELEMENTS
                    !Handle variable mapping
                    IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
                      element_ny=element_ny+1
                      variable_global_ny=element_ny+VARIABLE_GLOBAL_DOFS_OFFSET
                      CALL DOMAIN_MAPPINGS_MAPPING_GLOBAL_INITIALISE(FIELD_VARIABLE_DOFS_MAPPING% &
                        & GLOBAL_TO_LOCAL_MAP(variable_global_ny),ERR,ERROR,*999)
                      NUMBER_OF_DOMAINS=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%NUMBER_OF_DOMAINS
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                        & LOCAL_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map local number.", &
                        & ERR,ERROR,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)% &
                        & DOMAIN_NUMBER(NUMBER_OF_DOMAINS),STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map domain number.", &
                        & ERR,ERROR,*999)
                      ALLOCATE(FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(NUMBER_OF_DOMAINS), &
                        & STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable dofs global to local map local type.", &
                        & ERR,ERROR,*999)
                      FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%NUMBER_OF_DOMAINS=NUMBER_OF_DOMAINS
                      DO domain_idx=1,NUMBER_OF_DOMAINS
                        domain_no=DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_NUMBER(domain_idx)= &
                          & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_NUMBER(domain_idx)+VARIABLE_LOCAL_DOFS_OFFSETS(domain_no)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%DOMAIN_NUMBER(domain_idx)= &
                          & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%DOMAIN_NUMBER(domain_idx)
                        FIELD_VARIABLE_DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(variable_global_ny)%LOCAL_TYPE(domain_idx)= &
                          & DOFS_MAPPING%GLOBAL_TO_LOCAL_MAP(ny)%LOCAL_TYPE(domain_idx)
                      ENDDO !domain_idx
                    ENDIF
                  ENDDO !component_idx
                ENDDO !gauss_point_idx
              ENDDO !ny (global)
              !Loop over the domain types. Here domain_type_idx=1 for the non-ghosted dofs and =2 for the ghosted dofs.
              DO domain_type_idx=1,domain_type_stop
                IF(domain_type_idx==1) THEN
                  start_idx=1
                  stop_idx=DOFS_MAPPING%NUMBER_OF_LOCAL
                ELSE
                  start_idx=DOFS_MAPPING%NUMBER_OF_LOCAL+1
                  stop_idx=DOFS_MAPPING%TOTAL_NUMBER_OF_LOCAL
                ENDIF
                !Handle local dofs domain mapping
                element_ny=0
                DO ny=start_idx,stop_idx
                  DO gauss_point_idx=1,MAX_NGP
                    DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
                      FIELD_COMPONENT=>FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
                      DOMAIN=>FIELD_COMPONENT%DOMAIN
                      element_ny=element_ny+1
                      variable_local_ny=element_ny+VARIABLE_LOCAL_DOFS_OFFSETS(my_computational_node_number)
                      node_nyy=node_nyy+1
                      !Setup dof to parameter map
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(1,variable_local_ny)=FIELD_GAUSS_POINT_DOF_TYPE
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%DOF_TYPE(2,variable_local_ny)=node_nyy
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%GAUSS_POINT_DOF2PARAM_MAP(1,node_nyy)=gauss_point_idx
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%GAUSS_POINT_DOF2PARAM_MAP(2,node_nyy)=ny !element_idx
                      FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%GAUSS_POINT_DOF2PARAM_MAP(3,node_nyy)=component_idx
                      !Setup reverse parameter to dof map
                      FIELD_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gauss_point_idx,ny)= &
                        & variable_local_ny
                    ENDDO !component_idx
                  ENDDO !gauss_point_idx
                ENDDO !ny
                !Adjust the offsets
                VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)= &
                  & VARIABLE_LOCAL_DOFS_OFFSETS(0:DECOMPOSITION%NUMBER_OF_DOMAINS-1)+ &
                  & FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS* &
                  & DOFS_MAPPING%NUMBER_OF_DOMAIN_LOCAL*MAX_NGP
                IF(domain_type_idx==1) THEN
                  VARIABLE_GLOBAL_DOFS_OFFSET=VARIABLE_GLOBAL_DOFS_OFFSET+FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS* &
                    & DOFS_MAPPING%NUMBER_OF_GLOBAL*MAX_NGP
                ENDIF
              ENDDO !domain_type_idx
            CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
              CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
            CASE DEFAULT
              LOCAL_ERROR="The interpolation type of "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%INTERPOLATION_TYPE, &
                & "*",ERR,ERROR))//" is invalid for component number 1 of variable type "//TRIM(NUMBER_TO_VSTRING( &
                & FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ELSE
            CALL FLAG_ERROR("The field must have at least one component.",ERR,ERROR,*999)
          ENDIF
        CASE DEFAULT
          LOCAL_ERROR="The DOF order type of "//TRIM(NUMBER_TO_VSTRING(FIELD%VARIABLES(variable_idx)%DOF_ORDER_TYPE, &
              & "*",ERR,ERROR))//" is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(FIELD%VARIABLES(variable_idx)% &
              & VARIABLE_TYPE,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
        IF(ASSOCIATED(FIELD_VARIABLE_DOFS_MAPPING)) THEN
          CALL DOMAIN_MAPPINGS_LOCAL_FROM_GLOBAL_CALCULATE(FIELD_VARIABLE_DOFS_MAPPING,ERR,ERROR,*999)
        ENDIF
      ENDDO !variable_idx
      IF(ALLOCATED(VARIABLE_LOCAL_DOFS_OFFSETS)) DEALLOCATE(VARIABLE_LOCAL_DOFS_OFFSETS)
      IF(ALLOCATED(VARIABLE_GHOST_DOFS_OFFSETS)) DEALLOCATE(VARIABLE_GHOST_DOFS_OFFSETS)
 
      IF(DIAGNOSTICS1) THEN
        CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"Field DOF mappings:",ERR,ERROR,*999)
        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Field user number = ",FIELD%USER_NUMBER,ERR,ERROR,*999)
        CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of variables = ",FIELD%NUMBER_OF_VARIABLES,ERR,ERROR,*999)
        DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Variable : ",variable_idx,ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Variable type = ",FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE, &
            & ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Number of local DOFs = ",FIELD%VARIABLES(variable_idx)% &
            & NUMBER_OF_DOFS,ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Total number of local DOFs = ",FIELD%VARIABLES(variable_idx)% &
            & TOTAL_NUMBER_OF_DOFS,ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Number of global DOFs = ",FIELD%VARIABLES(variable_idx)% &
            & NUMBER_OF_GLOBAL_DOFS,ERR,ERROR,*999)
          CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"    DOF to parameter map:",ERR,ERROR,*999)
          DO variable_local_ny=1,FIELD%VARIABLES(variable_idx)%TOTAL_NUMBER_OF_DOFS
            CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      DOF : ",variable_local_ny,ERR,ERROR,*999)
            CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,2,2,2,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP% &
              & DOF_TYPE(:,variable_local_ny),'("        DOF type :",2(X,I8))','(18X,2(X,I8))',ERR,ERROR,*999)
          ENDDO !variable_local_ny
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Number of constant DOFs = ",FIELD%VARIABLES(variable_idx)% &
            & DOF_TO_PARAM_MAP%NUMBER_OF_CONSTANT_DOFS,ERR,ERROR,*999)
          IF(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_CONSTANT_DOFS>0) THEN
            CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"      Constant DOFs:",ERR,ERROR,*999)
            DO constant_nyy=1,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_CONSTANT_DOFS
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Constant DOF : ",constant_nyy,ERR,ERROR,*999)
              CALL WRITE_STRING_FMT_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"          DOF 2 Parameters : ", &
                & FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%CONSTANT_DOF2PARAM_MAP(constant_nyy),'(I8)',ERR,ERROR,*999)
            ENDDO !constant_nyy
          ENDIF
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Number of element DOFs = ",FIELD%VARIABLES(variable_idx)% &
            & DOF_TO_PARAM_MAP%NUMBER_OF_ELEMENT_DOFS,ERR,ERROR,*999)
          IF(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_ELEMENT_DOFS>0) THEN            
            CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"      Element DOFs:",ERR,ERROR,*999)
            DO element_nyy=1,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_ELEMENT_DOFS
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"        Element DOF : ",element_nyy,ERR,ERROR,*999)
              CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,2,2,2,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP% &
                & ELEMENT_DOF2PARAM_MAP(:,element_nyy),'("          DOF 2 Parameters :",2(X,I8))','(28X,2(X,I8))',ERR,ERROR,*999)
            ENDDO !element_nyy
          ENDIF
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Number of nodal DOFs = ",FIELD%VARIABLES(variable_idx)% &
            & DOF_TO_PARAM_MAP%NUMBER_OF_NODE_DOFS,ERR,ERROR,*999)
          IF(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_NODE_DOFS>0) THEN
            CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"      Nodal DOFs:",ERR,ERROR,*999)
            DO node_nyy=1,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_NODE_DOFS
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"        Node DOF : ",node_nyy,ERR,ERROR,*999)
              CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,4,4,4,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP% &
                & NODE_DOF2PARAM_MAP(:,node_nyy),'("          DOF 2 Parameters :",4(X,I8))','(28X,4(X,I8))',ERR,ERROR,*999)
            ENDDO !node_nyy
          ENDIF
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Number of grid point DOFs = ",FIELD%VARIABLES(variable_idx)% &
            & DOF_TO_PARAM_MAP%NUMBER_OF_GRID_POINT_DOFS,ERR,ERROR,*999)
          IF(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_GRID_POINT_DOFS>0) THEN
            CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"      Grid point DOFs:",ERR,ERROR,*999)
            DO grid_point_nyy=1,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_GRID_POINT_DOFS
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"        Grid point DOF : ",grid_point_nyy,ERR,ERROR,*999)
              CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,2,2,2,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP% &
                & GRID_POINT_DOF2PARAM_MAP(:,grid_point_nyy),'("          DOF 2 Parameters :",2(X,I8))','(28X,2(X,I8))', &
                & ERR,ERROR,*999)
            ENDDO !node_nyy
          ENDIF
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Number of Gauss point DOFs = ",FIELD%VARIABLES(variable_idx)% &
            & DOF_TO_PARAM_MAP%NUMBER_OF_GAUSS_POINT_DOFS,ERR,ERROR,*999)
          IF(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_GAUSS_POINT_DOFS>0) THEN
            CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"      Gauss point DOFs:",ERR,ERROR,*999)
            DO Gauss_point_nyy=1,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_GAUSS_POINT_DOFS
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"        Gauss point DOF : ",Gauss_point_nyy,ERR,ERROR,*999)
              CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,3,3,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP% &
                & GAUSS_POINT_DOF2PARAM_MAP(:,Gauss_point_nyy),'("          DOF 2 Parameters :",3(X,I8))','(28X,3(X,I8))', &
                & ERR,ERROR,*999)
            ENDDO !node_nyy
          ENDIF
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Number of data point DOFs = ",FIELD%VARIABLES(variable_idx)% &
            & DOF_TO_PARAM_MAP%NUMBER_OF_DATA_POINT_DOFS,ERR,ERROR,*999)
          IF(FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_DATA_POINT_DOFS>0) THEN
            CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"      data point DOFs:",ERR,ERROR,*999)
            DO data_point_nyy=1,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP%NUMBER_OF_DATA_POINT_DOFS
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"        data point DOF : ",data_point_nyy,ERR,ERROR,*999)
              CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,3,3,3,FIELD%VARIABLES(variable_idx)%DOF_TO_PARAM_MAP% &
                & DATA_POINT_DOF2PARAM_MAP(:,data_point_nyy),'("          DOF 2 Parameters :",3(X,I8))','(28X,3(X,I8))', &
                & ERR,ERROR,*999)
            ENDDO !node_nyy
          ENDIF
          CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"    Parameter to DOF map:",ERR,ERROR,*999)
          CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Number of components = ",FIELD%VARIABLES(variable_idx)% &
            & NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
          DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
            FIELD_COMPONENT => FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)
            CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Component : ",component_idx,ERR,ERROR,*999)
            CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"        Number of constant parameters = ", &
              & FIELD_COMPONENT%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS,ERR,ERROR,*999)
            IF(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"          Constant DOF = ", &
                & FIELD_COMPONENT%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP,ERR,ERROR,*999)
            ENDIF
            CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"        Number of element parameters = ", &
              & FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS,ERR,ERROR,*999)
            IF(FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS>0) THEN
              DO element_idx=1,FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS
                CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"          Element : ",element_idx,ERR,ERROR,*999)
                CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"            Element DOF = ", &
                  & FIELD_COMPONENT%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS(element_idx), &
                  & ERR,ERROR,*999)
              ENDDO !element_idx
            ENDIF
            CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"        Number of node parameters = ", &
              & FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,ERR,ERROR,*999)
            IF(FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS>0) THEN
              DO node_idx=1,FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS
                CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"          Node : ",node_idx,ERR,ERROR,*999)
                CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"          Number of Derivatives = ", &
                  & FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%NUMBER_OF_DERIVATIVES,ERR,ERROR,*999)
                DO derivative_idx=1,FIELD_COMPONENT%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                  CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"          Derivative : ",derivative_idx,ERR,ERROR,*999)
                  CALL WRITE_STRING_VECTOR(DIAGNOSTIC_OUTPUT_TYPE,1,1,FIELD_COMPONENT%PARAM_TO_DOF_MAP% &
                    & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%NUMBER_OF_VERSIONS,8,8,FIELD_COMPONENT% &
                    & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(derivative_idx)%VERSIONS(:), &
                    & '("              Version DOFs :",8(X,I8))','(23X,8(X,I8))',ERR,ERROR,*999)
                ENDDO !derivative_idx
              ENDDO !node_idx
            ENDIF
            CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"        Number of grid point parameters = ", &
              & FIELD_COMPONENT%PARAM_TO_DOF_MAP%GRID_POINT_PARAM2DOF_MAP%NUMBER_OF_GRID_POINT_PARAMETERS,ERR,ERROR,*999)
            IF(FIELD_COMPONENT%PARAM_TO_DOF_MAP%GRID_POINT_PARAM2DOF_MAP%NUMBER_OF_GRID_POINT_PARAMETERS>0) THEN
            ENDIF
            CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"        Number of Gauss point parameters = ", &
              & FIELD_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%NUMBER_OF_GAUSS_POINT_PARAMETERS,ERR,ERROR,*999)
            IF(FIELD_COMPONENT%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%NUMBER_OF_GAUSS_POINT_PARAMETERS>0) THEN
            ENDIF
            CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"        Number of data point parameters = ", &
              & FIELD_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS,ERR,ERROR,*999)
            IF(FIELD_COMPONENT%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP%NUMBER_OF_DATA_POINT_PARAMETERS>0) THEN
            ENDIF
          ENDDO !component_idx
        ENDDO !variable_idx
      ENDIF

    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_MAPPINGS_CALCULATE")
    RETURN
999 IF(ALLOCATED(VARIABLE_LOCAL_DOFS_OFFSETS)) DEALLOCATE(VARIABLE_LOCAL_DOFS_OFFSETS)
    IF(ALLOCATED(VARIABLE_GHOST_DOFS_OFFSETS)) DEALLOCATE(VARIABLE_GHOST_DOFS_OFFSETS)
    CALL ERRORS("FIELD_MAPPINGS_CALCULATE",ERR,ERROR)
    CALL EXITS("FIELD_MAPPINGS_CALCULATE")
    RETURN 1
  END SUBROUTINE FIELD_MAPPINGS_CALCULATE

  !
  !================================================================================================================================
  !

  !>Finalises the dofs to parameters mapping for a field varaible and deallocates all memory.
  SUBROUTINE FIELD_DOF_TO_PARAM_MAP_FINALISE(DOF_TO_PARAM_MAP,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_DOF_TO_PARAM_MAP_TYPE) :: DOF_TO_PARAM_MAP !<The dof to parameter map to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELD_DOF_TO_PARAM_MAP_FINALISE",ERR,ERROR,*999)

    IF(ALLOCATED(DOF_TO_PARAM_MAP%DOF_TYPE)) DEALLOCATE(DOF_TO_PARAM_MAP%DOF_TYPE)
    IF(ALLOCATED(DOF_TO_PARAM_MAP%CONSTANT_DOF2PARAM_MAP)) DEALLOCATE(DOF_TO_PARAM_MAP%CONSTANT_DOF2PARAM_MAP)
    IF(ALLOCATED(DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP)) DEALLOCATE(DOF_TO_PARAM_MAP%ELEMENT_DOF2PARAM_MAP)
    IF(ALLOCATED(DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP)) DEALLOCATE(DOF_TO_PARAM_MAP%NODE_DOF2PARAM_MAP)
    IF(ALLOCATED(DOF_TO_PARAM_MAP%GRID_POINT_DOF2PARAM_MAP)) DEALLOCATE(DOF_TO_PARAM_MAP%GRID_POINT_DOF2PARAM_MAP)
    IF(ALLOCATED(DOF_TO_PARAM_MAP%GAUSS_POINT_DOF2PARAM_MAP)) DEALLOCATE(DOF_TO_PARAM_MAP%GAUSS_POINT_DOF2PARAM_MAP)
    IF(ALLOCATED(DOF_TO_PARAM_MAP%DATA_POINT_DOF2PARAM_MAP)) DEALLOCATE(DOF_TO_PARAM_MAP%DATA_POINT_DOF2PARAM_MAP)
    DOF_TO_PARAM_MAP%NUMBER_OF_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_CONSTANT_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_ELEMENT_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_NODE_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_GRID_POINT_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_GAUSS_POINT_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_DATA_POINT_DOFS=0

    CALL EXITS("FIELD_DOF_TO_PARAM_MAP_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_DOF_TO_PARAM_MAP_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_DOF_TO_PARAM_FMAP_INALISE")
    RETURN 1
  END SUBROUTINE FIELD_DOF_TO_PARAM_MAP_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the dofs to parameters mappings for a field.
  SUBROUTINE FIELD_DOF_TO_PARAM_MAP_INITIALISE(DOF_TO_PARAM_MAP,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_DOF_TO_PARAM_MAP_TYPE) :: DOF_TO_PARAM_MAP !<The dof to parameter map to initialise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELD_DOF_TO_PARAM_INITIALISE",ERR,ERROR,*999)

    DOF_TO_PARAM_MAP%NUMBER_OF_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_CONSTANT_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_ELEMENT_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_NODE_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_GRID_POINT_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_GAUSS_POINT_DOFS=0
    DOF_TO_PARAM_MAP%NUMBER_OF_DATA_POINT_DOFS=0

    CALL EXITS("FIELD_DOF_TO_PARAM_MAP_INITIALISE")
    RETURN
999 CALL ERRORS("FIELD_DOF_TO_PARAM_MAP_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_DOF_TO_PARAM_MAP_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_DOF_TO_PARAM_MAP_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets the geometric field for a field identified by a pointer. \see OPENCMISS::CMISSFieldGeometricFieldGet
  SUBROUTINE FIELD_GEOMETRIC_FIELD_GET(FIELD,GEOMETRIC_FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the geometric field for
    TYPE(FIELD_TYPE), POINTER :: GEOMETRIC_FIELD !<On return, a pointer to the geometric field. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_GEOMETRIC_FIELD_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          CALL FLAG_ERROR("Geometric field is already associated.",ERR,ERROR,*999)
        ELSE
          GEOMETRIC_FIELD=>FIELD%GEOMETRIC_FIELD
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_GEOMETRIC_FIELD_GET")
    RETURN
999 CALL ERRORS("FIELD_GEOMETRIC_FIELD_GET",ERR,ERROR)
    CALL EXITS("FIELD_GEOMETRIC_FIELD_GET")
    RETURN 1
  END SUBROUTINE FIELD_GEOMETRIC_FIELD_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field. \see OPENCMISS::CMISSFieldGeometricFieldSet
  SUBROUTINE FIELD_GEOMETRIC_FIELD_SET(FIELD,GEOMETRIC_FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the geometric field for
    TYPE(FIELD_TYPE), POINTER :: GEOMETRIC_FIELD !<A pointer to the geometric field
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_GEOMETRIC_FIELD_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%GEOMETRIC_FIELD_LOCKED) THEN
            LOCAL_ERROR="The geometric field has been locked for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            IF(ASSOCIATED(FIELD%GEOMETRIC_FIELD)) THEN
              LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                & " already has a geometric field associated."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ELSE
              IF(ASSOCIATED(FIELD%DECOMPOSITION)) THEN
                IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
                  IF(GEOMETRIC_FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
                    IF(GEOMETRIC_FIELD%FIELD_FINISHED) THEN
                      IF(FIELD%DECOMPOSITION%MESH%USER_NUMBER==GEOMETRIC_FIELD%DECOMPOSITION%MESH%USER_NUMBER) THEN
                        SELECT CASE(FIELD%TYPE)
                        CASE(FIELD_FIBRE_TYPE,FIELD_GENERAL_TYPE,FIELD_MATERIAL_TYPE,FIELD_GEOMETRIC_GENERAL_TYPE)
                          FIELD%GEOMETRIC_FIELD=>GEOMETRIC_FIELD
                        CASE(FIELD_GEOMETRIC_TYPE)
                          CALL FLAG_ERROR("Can not set the geometric field for a geometric field.",ERR,ERROR,*999)
                        CASE DEFAULT
                          LOCAL_ERROR="The field type "//TRIM(NUMBER_TO_VSTRING(FIELD%TYPE,"*",ERR,ERROR))//" is invalid."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        END SELECT
                      ELSE
                        LOCAL_ERROR="The specified field is decomposed on mesh user number "// &
                          & TRIM(NUMBER_TO_VSTRING(FIELD%DECOMPOSITION%MESH%USER_NUMBER,"*",ERR,ERROR))// &
                          & " and the geometric field is decomposed on mesh user number "// &
                          & TRIM(NUMBER_TO_VSTRING(GEOMETRIC_FIELD%DECOMPOSITION%MESH%USER_NUMBER,"*",ERR,ERROR))// &
                          & ". The two fields must use the same mesh."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      CALL FLAG_ERROR("The specified geometric field has not been finished.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    CALL FLAG_ERROR("The specified geometric field is not a geometric field.",ERR,ERROR,*999)
                  ENDIF
                ELSE
                  CALL FLAG_ERROR("Geometric field is not associated.",ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FLAG_ERROR("The field does not have a decomposition associated.",ERR,ERROR,*999)
              ENDIF
            ENDIF
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_GEOMETRIC_FIELD_SET")
    RETURN
999 CALL ERRORS("FIELD_GEOMETRIC_FIELD_SET",ERR,ERROR)
    CALL EXITS("FIELD_GEOMETRIC_FIELD_SET")
    RETURN 1
  END SUBROUTINE FIELD_GEOMETRIC_FIELD_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field and locks so that no further changes can be made.
  SUBROUTINE FIELD_GEOMETRIC_FIELD_SET_AND_LOCK(FIELD,GEOMETRIC_FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the geometric field for
    TYPE(FIELD_TYPE), POINTER :: GEOMETRIC_FIELD !<A pointer to the geometric field
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_GEOMETRIC_FIELD_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_GEOMETRIC_FIELD_SET(FIELD,GEOMETRIC_FIELD,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%GEOMETRIC_FIELD_LOCKED=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_GEOMETRIC_FIELD_SET_AND_LOCK")
    RETURN
999 CALL ERRORS("FIELD_GEOMETRIC_FIELD_SET_AND_LOCK",ERR,ERROR)
    CALL EXITS("FIELD_GEOMETRIC_FIELD_SET_AND_LOCK")
    RETURN 1
  END SUBROUTINE FIELD_GEOMETRIC_FIELD_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Calculates the geometric parameters (line lengths, areas, volumes, scaling etc.) for a field.
  SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_CALCULATE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<The field to calculate the geometric parameters for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_GEOMETRIC_PARAMETERS_CALCULATE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          IF(FIELD%DECOMPOSITION%CALCULATE_LINES) THEN
            CALL FIELD_GEOMETRIC_PARAMETERS_LINE_LENGTHS_CALCULATE(FIELD,ERR,ERROR,*999)
          ENDIF
!          IF(FIELD%DECOMPOSITION%CALCULATE_FACES) THEN !temporarily commented out
!            CALL FIELD_GEOMETRIC_PARAMETERS_FACE_AREAS_CALCULATE(FIELD,ERR,ERROR,*999) 
!          ENDIF
        ELSE
          LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is not a geometric field."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_GEOMETRIC_PARAMETERS_CALCULATE")
    RETURN
999 CALL ERRORS("FIELD_GEOMETRIC_PARAMETERS_CALCULATE",ERR,ERROR)
    CALL EXITS("FIELD_GEOMETRIC_PARAMETERS_CALCULATE")
    RETURN 1
  END SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_CALCULATE

  !
  !================================================================================================================================
  !

  !>Finalises the geometric parameters and deallocates all memory.
  SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_FINALISE(GEOMETRIC_PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: GEOMETRIC_PARAMETERS !<A pointer to the geometric field parameters to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: field_idx
    TYPE(FIELD_TYPE), POINTER :: FIELD2

    CALL ENTERS("FIELD_GEOMETRIC_PARAMETERS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(GEOMETRIC_PARAMETERS)) THEN
      !Nullify the geometric field pointer of those fields using this geometric field.
      DO field_idx=1,GEOMETRIC_PARAMETERS%NUMBER_OF_FIELDS_USING
        FIELD2=>GEOMETRIC_PARAMETERS%FIELDS_USING(field_idx)%PTR
        IF(ASSOCIATED(FIELD2)) NULLIFY(FIELD2%GEOMETRIC_FIELD)
      ENDDO !field_idx
      IF(ASSOCIATED(GEOMETRIC_PARAMETERS%FIELDS_USING)) DEALLOCATE(GEOMETRIC_PARAMETERS%FIELDS_USING)
      IF(ALLOCATED(GEOMETRIC_PARAMETERS%LENGTHS)) DEALLOCATE(GEOMETRIC_PARAMETERS%LENGTHS)
!      IF(ALLOCATED(GEOMETRIC_PARAMETERS%AREAS)) DEALLOCATE(GEOMETRIC_PARAMETERS%AREAS) !temporarily commented out
      IF(ALLOCATED(GEOMETRIC_PARAMETERS%VOLUMES)) DEALLOCATE(GEOMETRIC_PARAMETERS%VOLUMES)
      DEALLOCATE(GEOMETRIC_PARAMETERS)
    ENDIF

    CALL EXITS("FIELD_GEOMETRIC_PARAMETERS_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_GEOMETRIC_PARAMETERS_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_GEOMETRIC_PARAMETERS_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the geometric parameters for a geometric field
  SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_INITIALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the geometric parameters for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: field_idx
    TYPE(FIELD_PTR_TYPE), POINTER :: NEW_FIELDS_USING(:)

    NULLIFY(NEW_FIELDS_USING)

    CALL ENTERS("FIELD_GEOMETRIC_PARAMETERS_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
        !Field is a geometric field
        ALLOCATE(FIELD%GEOMETRIC_FIELD_PARAMETERS,STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate geometric field parameters.",ERR,ERROR,*999)
        IF(FIELD%DECOMPOSITION%CALCULATE_LINES) THEN
          FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_LINES=FIELD%DECOMPOSITION%TOPOLOGY%LINES%NUMBER_OF_LINES
          ALLOCATE(FIELD%GEOMETRIC_FIELD_PARAMETERS%LENGTHS(FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_LINES),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate lengths.",ERR,ERROR,*999)
          FIELD%GEOMETRIC_FIELD_PARAMETERS%LENGTHS=0.0_DP
        ENDIF
!        IF(FIELD%DECOMPOSITION%CALCULATE_FACES) THEN !temporarily commented out
!          FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_AREAS=FIELD%DECOMPOSITION%TOPOLOGY%FACES%NUMBER_OF_FACES
!          ALLOCATE(FIELD%GEOMETRIC_FIELD_PARAMETERS%AREAS(FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_AREAS),STAT=ERR)
!          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate areas.",ERR,ERROR,*999)
!          FIELD%GEOMETRIC_FIELD_PARAMETERS%AREAS=0.0_DP
!        ENDIF
        FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_VOLUMES=0

        !The field is a geometric field so it must use itself initiallly
        ALLOCATE(FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING(1),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate fields using.",ERR,ERROR,*999)
        FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING(1)%PTR=>FIELD
        FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING=1
      ELSE
        !Field is not a geometric field
        NULLIFY(FIELD%GEOMETRIC_FIELD_PARAMETERS)
        IF(ASSOCIATED(FIELD%GEOMETRIC_FIELD)) THEN
          !Set the geometric field so that it knows that this field is using it
          ALLOCATE(NEW_FIELDS_USING(FIELD%GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING+1),STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new fields using.",ERR,ERROR,*999)
          DO field_idx=1,FIELD%GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING
            NEW_FIELDS_USING(field_idx)%PTR=>FIELD%GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING(field_idx)%PTR
          ENDDO !field_idx
          NEW_FIELDS_USING(FIELD%GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING+1)%PTR=>FIELD
          FIELD%GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING=FIELD%GEOMETRIC_FIELD% &
            & GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING+1
          IF(ASSOCIATED(FIELD%GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING)) &
            & DEALLOCATE(FIELD%GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING)
          FIELD%GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING=>NEW_FIELDS_USING
        ELSE
          CALL FLAG_ERROR("Field does not have a geometric field associated.",ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_GEOMETRIC_PARAMETERS_INITIALISE")
    RETURN
999 IF(ASSOCIATED(NEW_FIELDS_USING)) DEALLOCATE(NEW_FIELDS_USING)
    CALL ERRORS("FIELD_GEOMETRIC_PARAMETERS_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_GEOMETRIC_PARAMETERS_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets the line length between nodes of a geometric field for a given element number and element basis line number.
  SUBROUTINE Field_GeometricParametersElementLineLengthGet(field,elementNumber,elementLineNumber,lineLength,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the line length for
    INTEGER(INTG),  INTENT(IN) :: elementNumber !<The element to get the line length for
    INTEGER(INTG), INTENT(IN) :: elementLineNumber !<The element basis line to get the length for
    REAL(DP), INTENT(OUT) :: lineLength !<The line length of the chosen element line number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    TYPE(DECOMPOSITION_ELEMENT_TYPE), POINTER :: decompositionElement
    TYPE(DOMAIN_ELEMENT_TYPE), POINTER :: domainElement
    TYPE(VARYING_STRING) :: localError
    INTEGER(INTG) :: globalLineNumber

    CALL ENTERS("Field_GeometricParametersElementLineLengthGet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(field%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          IF(ASSOCIATED(field%GEOMETRIC_FIELD_PARAMETERS)) THEN
            !\todo user to global element maps not in OpenCMISS?
            IF(elementNumber>=1.AND.elementNumber<=field%DECOMPOSITION%TOPOLOGY%ELEMENTS%NUMBER_OF_ELEMENTS) THEN
              domainElement=>field%DECOMPOSITION%DOMAIN(field%DECOMPOSITION%MESH_COMPONENT_NUMBER)%PTR% &
                & TOPOLOGY%ELEMENTS%ELEMENTS(elementNumber)
              decompositionElement=>field%DECOMPOSITION%TOPOLOGY%ELEMENTS%ELEMENTS(elementNumber)
              IF(elementLineNumber>=1.AND.elementLineNumber<=domainElement%BASIS%NUMBER_OF_LOCAL_LINES) THEN
                globalLineNumber=decompositionElement%ELEMENT_LINES(elementLineNumber)
                lineLength=Field%GEOMETRIC_FIELD_PARAMETERS%LENGTHS(globalLineNumber)
              ELSE
                localError="Element basis line number  "//TRIM(NUMBER_TO_VSTRING(elementNumber,"*",err,error))// &
                  & " is not valid and needs to be >=1 and <="//TRIM(NUMBER_TO_VSTRING( &
                  & domainElement%BASIS%NUMBER_OF_LOCAL_LINES,"*",err,error))
                CALL FLAG_ERROR(localError,err,error,*999)
              ENDIF
            ELSE
              localError="Element number "//TRIM(NUMBER_TO_VSTRING(elementNumber,"*",err,error))// &
                & " is not present in this fields decomposition"
              CALL FLAG_ERROR(localError,err,error,*999)
            ENDIF
          ELSE
            localError="Geometric parameters are not associated for field number "// &
              & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
            CALL FLAG_ERROR(localError,err,error,*999)
          ENDIF
        ELSE
          localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" is not a geometric field."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    ENDIF

    CALL EXITS("Field_GeometricParametersElementLineLengthGet")
    RETURN
999 CALL ERRORS("Field_GeometricParametersElementLineLengthGet",err,error)
    CALL EXITS("Field_GeometricParametersElementLineLengthGet")
    RETURN 1
  END SUBROUTINE Field_GeometricParametersElementLineLengthGet

  !
  !================================================================================================================================
  !

  !>Calculates the line lengths from the parameters of a geometric field. Old CMISS name LINSCA
  SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_LINE_LENGTHS_CALCULATE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to calculate the line lengths for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,ITERATION_NUMBER,MAXIMUM_DIFFERENCE_LINE,ng,nl
    INTEGER(INTG), PARAMETER :: LINES_MAXIMUM_NUMBER_OF_ITERATIONS=20
    INTEGER(INTG) :: GAUSS_START(4) = [ 0,1,3,6 ]
    INTEGER(INTG) :: NUMBER_OF_GAUSS_POINTS=4
    REAL(DP) :: LAST_MAXIMUM_LENGTH_DIFFERENCE,LENGTH_DIFFERENCE,MAXIMUM_LENGTH_DIFFERENCE,XI(1),W,DERIV_NORM,LINE_LENGTH, &
      & OLD_LINE_LENGTH
! Doxygen doesn't like this
!    REAL(DP) :: XIG(10) = [ 0.500000000000000_DP, &
!      &                     0.211324865405187_DP,0.788675134594813_DP, &
!      &                     0.112701665379258_DP,0.500000000000000_DP,0.887298334620742_DP, &
!      &                     0.06943184420297349_DP,0.330009478207572_DP,0.669990521792428_DP,0.930568155797026_DP ]
!    REAL(DP) :: WIG(10) = [ 1.000000000000000_DP, &
!      &                     0.500000000000000_DP,0.500000000000000_DP, &
!      &                     0.277777777777778_DP,0.444444444444444_DP,0.277777777777778_DP,
!      &                     0.173927422568727_DP,0.326072577431273_DP,0.326072577431273_DP,0.173927422568727_DP ]
    REAL(DP) :: XIG(10),WIG(10)
    REAL(DP), PARAMETER :: LINE_INCREMENT_TOLERANCE=CONVERGENCE_TOLERANCE
    LOGICAL :: ITERATE,UPDATE_FIELDS_USING
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINT(:)
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATION_PARAMETERS(:)
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR

    XIG = [ 0.500000000000000_DP, &
      &     0.211324865405187_DP,0.788675134594813_DP, &
      &     0.112701665379258_DP,0.500000000000000_DP,0.887298334620742_DP, &
      &     0.06943184420297349_DP,0.330009478207572_DP,0.669990521792428_DP,0.930568155797026_DP ]
    WIG = [ 1.000000000000000_DP, &
      &     0.500000000000000_DP,0.500000000000000_DP, &
      &     0.277777777777778_DP,0.444444444444444_DP,0.277777777777778_DP, &
      &     0.173927422568727_DP,0.326072577431273_DP,0.326072577431273_DP,0.173927422568727_DP ]

    NULLIFY(INTERPOLATED_POINT)
    NULLIFY(INTERPOLATION_PARAMETERS)

    CALL ENTERS("FIELD_GEOMETRIC_PARAMETERS_LINE_LENGTHS_CALCULATE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          IF(ASSOCIATED(FIELD%GEOMETRIC_FIELD_PARAMETERS)) THEN            
            NULLIFY(COORDINATE_SYSTEM)
            CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
            !Iterate to find the line lengths as the line lengths depend on the scaling factors and vise versa.
            CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(FIELD,INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
            CALL FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATION_PARAMETERS,INTERPOLATED_POINT,ERR,ERROR,*999)
            ITERATE=.TRUE.
            ITERATION_NUMBER=0
            LAST_MAXIMUM_LENGTH_DIFFERENCE=0.0_DP
            DO WHILE(ITERATE.AND.ITERATION_NUMBER<=LINES_MAXIMUM_NUMBER_OF_ITERATIONS)
              MAXIMUM_LENGTH_DIFFERENCE=0.0_DP
              MAXIMUM_DIFFERENCE_LINE=1
              !Loop over the lines
              DO nl=1,FIELD%DECOMPOSITION%TOPOLOGY%LINES%NUMBER_OF_LINES
                CALL FIELD_INTERPOLATION_PARAMETERS_LINE_GET(FIELD_VALUES_SET_TYPE,nl, &
                  & INTERPOLATION_PARAMETERS(FIELD_U_VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                OLD_LINE_LENGTH=FIELD%GEOMETRIC_FIELD_PARAMETERS%LENGTHS(nl)
                LINE_LENGTH=0.0_DP
                !Integrate || dr(xi)/dt || from xi=0 to 1 to determine the arc length.
                DO ng=1,NUMBER_OF_GAUSS_POINTS
                  XI(1)=XIG(GAUSS_START(NUMBER_OF_GAUSS_POINTS)+ng)
                  W=WIG(GAUSS_START(NUMBER_OF_GAUSS_POINTS)+ng)
                  CALL FIELD_INTERPOLATE_XI(FIRST_PART_DERIV,XI,INTERPOLATED_POINT(FIELD_U_VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                  CALL COORDINATE_DERIVATIVE_NORM(COORDINATE_SYSTEM,PART_DERIV_S1, &
                    & INTERPOLATED_POINT(FIELD_U_VARIABLE_TYPE)%PTR,DERIV_NORM,ERR,ERROR,*999)
                  LINE_LENGTH=LINE_LENGTH+W*DERIV_NORM
                ENDDO !ng
                FIELD%GEOMETRIC_FIELD_PARAMETERS%LENGTHS(nl)=LINE_LENGTH
                LENGTH_DIFFERENCE=ABS(LINE_LENGTH-OLD_LINE_LENGTH)/(1.0_DP+OLD_LINE_LENGTH)
                IF(LENGTH_DIFFERENCE>MAXIMUM_LENGTH_DIFFERENCE) THEN
                  MAXIMUM_LENGTH_DIFFERENCE=LENGTH_DIFFERENCE
                  MAXIMUM_DIFFERENCE_LINE=nl
                ENDIF
              ENDDO !nl
              ITERATE=MAXIMUM_LENGTH_DIFFERENCE>LINE_INCREMENT_TOLERANCE
              IF(ITERATE) THEN
                IF(ITERATION_NUMBER==1) THEN
                  LAST_MAXIMUM_LENGTH_DIFFERENCE=MAXIMUM_LENGTH_DIFFERENCE
                ELSE IF(MAXIMUM_LENGTH_DIFFERENCE<LOOSE_TOLERANCE.AND. &
                  & MAXIMUM_LENGTH_DIFFERENCE>=LAST_MAXIMUM_LENGTH_DIFFERENCE) THEN
                  !Seems to be at a numerical limit
                  ITERATE=.FALSE.
                ELSE
                  LAST_MAXIMUM_LENGTH_DIFFERENCE=MAXIMUM_LENGTH_DIFFERENCE
                ENDIF
              ENDIF
              ITERATION_NUMBER=ITERATION_NUMBER+1
              IF(DIAGNOSTICS2) THEN
                CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"Line iteration report:",ERR,ERROR,*999)
                CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of iterations = ",ITERATION_NUMBER,ERR,ERROR,*999)
                CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Maximum length difference = ",MAXIMUM_LENGTH_DIFFERENCE, &
                  & ERR,ERROR,*999)
                CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Difference tolerance = ",LINE_INCREMENT_TOLERANCE, &
                  ERR,ERROR,*999)
                CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Maximum difference line = ",MAXIMUM_DIFFERENCE_LINE, &
                  ERR,ERROR,*999)
              ENDIF
              IF(.NOT.ITERATE.OR.ITERATION_NUMBER==LINES_MAXIMUM_NUMBER_OF_ITERATIONS) THEN
                UPDATE_FIELDS_USING=.TRUE.
              ELSE
                UPDATE_FIELDS_USING=.FALSE.
              ENDIF
              CALL FIELD_GEOMETRIC_PARAMETERS_SCALE_FACTORS_UPDATE(FIELD,UPDATE_FIELDS_USING,ERR,ERROR,*999)
            ENDDO !iterate
            CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,ERR,ERROR,*999)
            CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
          ELSE
            LOCAL_ERROR="Geometric parameters are not associated for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is not a geometric field."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"Line lengths:",ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of iterations = ",ITERATION_NUMBER,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Maximum length difference = ",MAXIMUM_LENGTH_DIFFERENCE,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Difference tolerance = ",LINE_INCREMENT_TOLERANCE,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Maximum difference line = ",MAXIMUM_DIFFERENCE_LINE,ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of lines = ",FIELD%DECOMPOSITION%TOPOLOGY%LINES%NUMBER_OF_LINES, &
        & ERR,ERROR,*999)
      DO nl=1,FIELD%DECOMPOSITION%TOPOLOGY%LINES%NUMBER_OF_LINES
        CALL WRITE_STRING_FMT_TWO_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Line ",nl,"(I8)"," length = ",FIELD% &
          & GEOMETRIC_FIELD_PARAMETERS% LENGTHS(nl),"*",ERR,ERROR,*999)
      ENDDO !nl
    ENDIF

    CALL EXITS("FIELD_GEOMETRIC_PARAMETERS_LINE_LENGTHS_CALCULATE")
    RETURN
999 IF(ASSOCIATED(INTERPOLATED_POINT)) CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,DUMMY_ERR,DUMMY_ERROR,*999)
    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS, &
      & DUMMY_ERR,DUMMY_ERROR,*999)
    CALL ERRORS("FIELD_GEOMETRIC_PARAMETERS_LINE_LENGTHS_CALCULATE",ERR,ERROR)
    CALL EXITS("FIELD_GEOMETRIC_PARAMETERS_LINE_LENGTHS_CALCULATE")
    RETURN 1
  END SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_LINE_LENGTHS_CALCULATE

  !
  !================================================================================================================================
  !

  !>Calculates the face areas from the parameters of a geometric field.
  SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_FACE_AREAS_CALCULATE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to calculate the face areas for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    INTEGER(INTG) :: DUMMY_ERR,ng,nf
    INTEGER(INTG) :: GAUSS_START(4) = [ 0,1,3,6 ]
    INTEGER(INTG) :: NUMBER_OF_GAUSS_POINTS=4
    REAL(DP) :: XI(1),W,FACE_AREA
    REAL(DP) :: XIG(10),WIG(10)
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINT(:)
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: INTERPOLATED_POINT_METRICS(:)
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATION_PARAMETERS(:)
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR

    XIG = [ 0.500000000000000_DP, &
      &     0.211324865405187_DP,0.788675134594813_DP, &
      &     0.112701665379258_DP,0.500000000000000_DP,0.887298334620742_DP, &
      &     0.06943184420297349_DP,0.330009478207572_DP,0.669990521792428_DP,0.930568155797026_DP ]
    WIG = [ 1.000000000000000_DP, &
      &     0.500000000000000_DP,0.500000000000000_DP, &
      &     0.277777777777778_DP,0.444444444444444_DP,0.277777777777778_DP, &
      &     0.173927422568727_DP,0.326072577431273_DP,0.326072577431273_DP,0.173927422568727_DP ]
    NULLIFY(INTERPOLATED_POINT)
    NULLIFY(INTERPOLATED_POINT_METRICS)
    NULLIFY(INTERPOLATION_PARAMETERS)

    CALL ENTERS("FIELD_GEOMETRIC_PARAMETERS_FACE_AREAS_CALCULATE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
          IF(ASSOCIATED(FIELD%GEOMETRIC_FIELD_PARAMETERS)) THEN
            NULLIFY(COORDINATE_SYSTEM)
            CALL FIELD_COORDINATE_SYSTEM_GET(FIELD,COORDINATE_SYSTEM,ERR,ERROR,*999)
            CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(FIELD,INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
            CALL FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATION_PARAMETERS,INTERPOLATED_POINT,ERR,ERROR,*999)
            CALL FIELD_INTERPOLATED_POINTS_METRICS_INITIALISE(INTERPOLATED_POINT,INTERPOLATED_POINT_METRICS,ERR,ERROR,*999)

            !Loop over the faces
            DO nf=1,FIELD%DECOMPOSITION%TOPOLOGY%FACES%NUMBER_OF_FACES
              CALL FIELD_INTERPOLATION_PARAMETERS_FACE_GET(FIELD_VALUES_SET_TYPE,nf, &
                & INTERPOLATION_PARAMETERS(FIELD_U_VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
              FACE_AREA=0.0_DP
              DO ng=1,NUMBER_OF_GAUSS_POINTS
                XI(1)=XIG(GAUSS_START(NUMBER_OF_GAUSS_POINTS)+ng)
                W=WIG(GAUSS_START(NUMBER_OF_GAUSS_POINTS)+ng)
                CALL FIELD_INTERPOLATE_XI(FIRST_PART_DERIV,XI,INTERPOLATED_POINT(FIELD_U_VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                CALL FIELD_INTERPOLATED_POINT_METRICS_CALCULATE(COORDINATE_JACOBIAN_AREA_TYPE, &
                  & INTERPOLATED_POINT_METRICS(FIELD_U_VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                FACE_AREA=FACE_AREA+W*INTERPOLATED_POINT_METRICS(FIELD_U_VARIABLE_TYPE)%PTR%JACOBIAN
              ENDDO !ng
              FIELD%GEOMETRIC_FIELD_PARAMETERS%AREAS(nf)=FACE_AREA
            ENDDO !nf

            CALL FIELD_INTERPOLATED_POINTS_METRICS_FINALISE(INTERPOLATED_POINT_METRICS,ERR,ERROR,*999)
            CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,ERR,ERROR,*999)
            CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS,ERR,ERROR,*999)
          ELSE
            LOCAL_ERROR="Geometric parameters are not associated for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is not a geometric field."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"Face areas:",ERR,ERROR,*999)
      CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of faces = ",FIELD%DECOMPOSITION%TOPOLOGY%FACES%NUMBER_OF_FACES, &
        & ERR,ERROR,*999)
      DO nf=1,FIELD%DECOMPOSITION%TOPOLOGY%FACES%NUMBER_OF_FACES
        CALL WRITE_STRING_FMT_TWO_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Face ",nf,"(I8)"," area = ",FIELD% &
          & GEOMETRIC_FIELD_PARAMETERS%AREAS(nf),"*",ERR,ERROR,*999)
      ENDDO !nf
    ENDIF

    CALL EXITS("FIELD_GEOMETRIC_PARAMETERS_FACE_AREAS_CALCULATE")
    RETURN
999 IF(ASSOCIATED(INTERPOLATED_POINT_METRICS)) CALL FIELD_INTERPOLATED_POINTS_METRICS_FINALISE(&
     & INTERPOLATED_POINT_METRICS,DUMMY_ERR,DUMMY_ERROR,*999)
    IF(ASSOCIATED(INTERPOLATED_POINT)) CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,DUMMY_ERR,DUMMY_ERROR,*999)
    IF(ASSOCIATED(INTERPOLATION_PARAMETERS)) CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATION_PARAMETERS, &
      & DUMMY_ERR,DUMMY_ERROR,*999)
    CALL ERRORS("FIELD_GEOMETRIC_PARAMETERS_FACE_AREAS_CALCULATE",ERR,ERROR)
    CALL EXITS("FIELD_GEOMETRIC_PARAMETERS_FACE_AREAS_CALCULATE")
    RETURN 1
  END SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_FACE_AREAS_CALCULATE

  !
  !================================================================================================================================
  !

  !>Finalises the geometric parameters for a field and deallocates all memory.
  SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_SCALE_FACTORS_UPDATE(FIELD,UPDATE_FIELDS_USING,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update the scale factors for
    LOGICAL, INTENT(IN) :: UPDATE_FIELDS_USING !<If .TRUE. then update the fields that use this fields geometric parameters.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: field_idx,LAST_FIELD_IDX
    TYPE(FIELD_TYPE), POINTER :: FIELD2

    CALL ENTERS("FIELD_GEOMETRIC_PARAMETERS_SCALE_FACTORS_UPDATE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
        IF(UPDATE_FIELDS_USING) THEN
          LAST_FIELD_IDX=FIELD%GEOMETRIC_FIELD_PARAMETERS%NUMBER_OF_FIELDS_USING
        ELSE
          LAST_FIELD_IDX=1 !The first field using will be the current field
        ENDIF
        DO field_idx=1,LAST_FIELD_IDX
          FIELD2=>FIELD%GEOMETRIC_FIELD_PARAMETERS%FIELDS_USING(field_idx)%PTR
          CALL FIELD_SCALINGS_CALCULATE(FIELD2,ERR,ERROR,*999)
        ENDDO !field_idx
      ELSE
        CALL FLAG_ERROR("Field is not geometric field.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_GEOMETRIC_PARAMETERS_SCALE_FACTORS_UPDATE")
    RETURN
999 CALL ERRORS("FIELD_GEOMETRIC_PARAMETERS_SCALE_FACTORS_UPDATE",ERR,ERROR)
    CALL EXITS("FIELD_GEOMETRIC_PARAMETERS_SCALE_FACTORS_UPDATE")
    RETURN 1
  END SUBROUTINE FIELD_GEOMETRIC_PARAMETERS_SCALE_FACTORS_UPDATE
  
  !
  !================================================================================================================================
  !

  !> Evaluate volume enclosed by specified external faces of a geometric field by integrating the product of surface
  ! area and distance from a fixed point within cavity space - approximating cone shapes.
  SUBROUTINE Field_CalculateEnclosedVolume(field, point, elems, faces, volume, err, error,*)

    ! Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<Evaluate enclosed volume for this field.
    REAL(DP), INTENT(IN) :: point(:) !<Global coordinates of arbitrary point within the enclosed volume.
    INTEGER(INTG), INTENT(IN) :: elems(:) !<Array of elements which face the enclosed volume to be evaluated.
    INTEGER(INTG), INTENT(IN) :: faces(:) !<Face number of each element specified in elems array which faces the enclosed volume.
    REAL(DP), INTENT(OUT) :: volume !<Total volume of enclosed space.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string.

    ! Local Variables
    REAL(DP) :: xi_gauss(10), w_gauss(10), xi(1), w, r
    INTEGER(INTG) :: numberOfGaussPoints=4, ng, elemIndex
    INTEGER(INTG) :: gaussStart(4)=[0,1,3,6]
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: coordinateSystem
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: interpolatedPoint(:)
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: interpolatedPointMetrics(:)
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: interpolationParameters(:)

    xi_gauss = [ 0.500000000000000_DP, &
      &     0.211324865405187_DP,0.788675134594813_DP, &
      &     0.112701665379258_DP,0.500000000000000_DP,0.887298334620742_DP, &
      &     0.06943184420297349_DP,0.330009478207572_DP,0.669990521792428_DP,0.930568155797026_DP ]
    w_gauss = [ 1.000000000000000_DP, &
      &     0.500000000000000_DP,0.500000000000000_DP, &
      &     0.277777777777778_DP,0.444444444444444_DP,0.277777777777778_DP, &
      &     0.173927422568727_DP,0.326072577431273_DP,0.326072577431273_DP,0.173927422568727_DP ]
    NULLIFY(interpolatedPoint)
    NULLIFY(interpolatedPointMetrics)
    NULLIFY(interpolationParameters)

    CALL Enters("FIeld_CalculateEnclosedVolume",err,error,*999)

    IF(.NOT.ASSOCIATED(field)) THEN
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    END IF
    IF(.NOT.field%FIELD_FINISHED) THEN
      CALL FLAG_ERROR("Field has not been finished.",err,error,*999)
    END IF
    IF(.NOT.field%type==FIELD_GEOMETRIC_TYPE) THEN
      CALL FLAG_ERROR("Field does not have a geometric type, cannot evaluate enclosed volume.",err,error,*999)
    END IF
    IF(.NOT.ASSOCIATED(field%GEOMETRIC_FIELD_PARAMETERS)) THEN
      CALL FLAG_ERROR("Field geometric field parameters are not associated.",err,error,*999)
    END IF

    NULLIFY(coordinateSystem)
    CALL FIELD_COORDINATE_SYSTEM_GET(field,coordinateSystem,err,error,*999)
    CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(field,interpolationParameters,err,error,*999)
    CALL FIELD_INTERPOLATED_POINTS_INITIALISE(interpolationParameters,interpolatedPoint,err,error,*999)
    CALL FIELD_INTERPOLATED_POINTS_METRICS_INITIALISE(interpolatedPoint,interpolatedPointMetrics,err,error,*999)

    !Loop over elements
    volume=0.0_DP
    DO elemIndex=1,SIZE(elems(:))
      CALL FIELD_INTERPOLATION_PARAMETERS_FACE_GET(FIELD_VALUES_SET_TYPE,faces(elemIndex), &
        & interpolationParameters(FIELD_U_VARIABLE_TYPE)%ptr,err,error,*999)
      DO ng=1,numberOfGaussPoints
        xi=xi_gauss(gaussStart(numberOfGaussPoints)+ng)
        w=w_gauss(gaussStart(numberOfGaussPoints)+ng)
        CALL FIELD_INTERPOLATE_XI(FIRST_PART_DERIV,xi,interpolatedPoint(FIELD_U_VARIABLE_TYPE)%ptr,err,error,*999)
        CALL FIELD_INTERPOLATED_POINT_METRICS_CALCULATE(COORDINATE_JACOBIAN_AREA_TYPE, &
          & interpolatedPointMetrics(FIELD_U_VARIABLE_TYPE)%ptr,err,error,*999) !Evaluate area at current gauss point.
        !Evaluate distance from fixed point to global gauss point position.
        r=2.0_DP
      ENDDO
    ENDDO

    CALL Exits("Field_CalculateEnclosedVolume")
    RETURN

999 CALL Errors("Field_CalculateEnclosedVolume",err,error)
    CALL Exits("Field_CalculateEnclosedVolume")
    RETURN 1
  END SUBROUTINE Field_CalculateEnclosedVolume

  !
  !================================================================================================================================
  !
  !>Gets the field label for a field for character labels. \see OPENCMISS::CMISSFieldLabelGet
  SUBROUTINE FIELD_LABEL_GET_C(FIELD,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the label for
    CHARACTER(LEN=*), INTENT(OUT) :: LABEL !<On return, the field label for the specified field
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: C_LENGTH,VS_LENGTH
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_LABEL_GET_C",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        C_LENGTH=LEN(LABEL)
        VS_LENGTH=LEN_TRIM(FIELD%LABEL)
        IF(C_LENGTH>VS_LENGTH) THEN
          LABEL=CHAR(LEN_TRIM(FIELD%LABEL))
        ELSE
          LABEL=CHAR(FIELD%LABEL,C_LENGTH)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_LABEL_GET_C")
    RETURN
999 CALL ERRORS("FIELD_LABEL_GET_C",ERR,ERROR)
    CALL EXITS("FIELD_LABEL_GET_C")
    RETURN 1
  END SUBROUTINE FIELD_LABEL_GET_C

  !
  !================================================================================================================================
  !

  !>Gets the field label for a field for varying string labels. \see OPENCMISS::CMISSFieldLabelGet
  SUBROUTINE FIELD_LABEL_GET_VS(FIELD,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the label for
    TYPE(VARYING_STRING), INTENT(OUT) :: LABEL !<On return, the field label for the specified field
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_LABEL_GET_VS",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LABEL=FIELD%LABEL
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_LABEL_GET_VS")
    RETURN
999 CALL ERRORS("FIELD_LABEL_GET_VS",ERR,ERROR)
    CALL EXITS("FIELD_LABEL_GET_VS")
    RETURN 1
  END SUBROUTINE FIELD_LABEL_GET_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the field label for a field for character labels. \see OPENCMISS::CMISSFieldLabelSet
  SUBROUTINE FIELD_LABEL_SET_C(FIELD,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the type for
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The field label to set
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_LABEL_SET_C",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%LABEL_LOCKED) THEN
            LOCAL_ERROR="The field label has been locked for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            FIELD%LABEL=LABEL
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_LABEL_SET_C")
    RETURN
999 CALL ERRORS("FIELD_LABEL_SET_C",ERR,ERROR)
    CALL EXITS("FIELD_LABEL_SET_C")
    RETURN 1
  END SUBROUTINE FIELD_LABEL_SET_C
  
 !
  !================================================================================================================================
  !

  !>Sets/changes the field label for a field for varying string labels. \see OPENCMISS::CMISSFieldLabelSet
  SUBROUTINE FIELD_LABEL_SET_VS(FIELD,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the type for
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The field label to set
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_LABEL_SET_VS",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%LABEL_LOCKED) THEN
            LOCAL_ERROR="The field label has been locked for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            FIELD%LABEL=LABEL
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_LABEL_SET_VS")
    RETURN
999 CALL ERRORS("FIELD_LABEL_SET_VS",ERR,ERROR)
    CALL EXITS("FIELD_LABEL_SET_VS")
    RETURN 1
  END SUBROUTINE FIELD_LABEL_SET_VS
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the field label for a field for character labels and locks it so that no further changes can be made.
  SUBROUTINE FIELD_LABEL_SET_AND_LOCK_C(FIELD,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the type for
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The field label to set 
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_LABEL_SET_AND_LOCK_C",ERR,ERROR,*999)
    
    CALL FIELD_LABEL_SET(FIELD,LABEL,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%LABEL_LOCKED=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_LABEL_SET_AND_LOCK_C")
    RETURN
999 CALL ERRORS("FIELD_LABEL_SET_AND_LOCK_C",ERR,ERROR)
    CALL EXITS("FIELD_LABEL_SET_AND_LOCK_C")
    RETURN 1
  END SUBROUTINE FIELD_LABEL_SET_AND_LOCK_C

  !
  !================================================================================================================================
  !

  !>Sets/changes the field label for a field for varying string labels and locks it so that no further changes can be made.
  SUBROUTINE FIELD_LABEL_SET_AND_LOCK_VS(FIELD,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the type for
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The field label to set 
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_LABEL_SET_AND_LOCK_VS",ERR,ERROR,*999)
    
    CALL FIELD_LABEL_SET(FIELD,LABEL,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%LABEL_LOCKED=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_LABEL_SET_AND_LOCK_VS")
    RETURN
999 CALL ERRORS("FIELD_LABEL_SET_AND_LOCK_VS",ERR,ERROR)
    CALL EXITS("FIELD_LABEL_SET_AND_LOCK_VS")
    RETURN 1
  END SUBROUTINE FIELD_LABEL_SET_AND_LOCK_VS

  !
  !================================================================================================================================
  !

  !>Gets the mesh decomposition for a field. \see OPENCMISS::CMISSFieldMeshDecompositionGet
  SUBROUTINE FIELD_MESH_DECOMPOSITION_GET(FIELD,MESH_DECOMPOSITION,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the decomposition for
    TYPE(DECOMPOSITION_TYPE), POINTER :: MESH_DECOMPOSITION !<On return, a pointer to the mesh decomposition for the field. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("FIELD_MESH_DECOMPOSITION_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(ASSOCIATED(MESH_DECOMPOSITION)) THEN
          CALL FLAG_ERROR("Mesh decomposition is already associated.",ERR,ERROR,*999)
        ELSE
          NULLIFY(MESH_DECOMPOSITION)
          MESH_DECOMPOSITION=>FIELD%DECOMPOSITION
          IF(.NOT.ASSOCIATED(MESH_DECOMPOSITION)) CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_MESH_DECOMPOSITION_GET")
    RETURN
999 CALL ERRORS("FIELD_MESH_DECOMPOSITION_GET",ERR,ERROR)
    CALL EXITS("FIELD_MESH_DECOMPOSITION_GET")
    RETURN 1
  END SUBROUTINE FIELD_MESH_DECOMPOSITION_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh decomposition for a field. \see OPENCMISS::CMISSFieldMeshDecompositionSet
  SUBROUTINE FIELD_MESH_DECOMPOSITION_SET(FIELD,MESH_DECOMPOSITION,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the decomposition for
    TYPE(DECOMPOSITION_TYPE), POINTER :: MESH_DECOMPOSITION !<A pointer to the mesh decomposition to set
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(INTERFACE_TYPE), POINTER :: MESH_INTERFACE,FIELD_INTERFACE
    TYPE(REGION_TYPE), POINTER :: MESH_REGION,FIELD_REGION,PARENT_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_MESH_DECOMPOSITION_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%DECOMPOSITION_LOCKED) THEN
            LOCAL_ERROR="The mesh decomposition has been locked for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            IF(ASSOCIATED(MESH_DECOMPOSITION)) THEN
              MESH=>MESH_DECOMPOSITION%MESH
              IF(ASSOCIATED(MESH)) THEN
                NULLIFY(MESH_INTERFACE)
                MESH_REGION=>MESH%REGION
                IF(ASSOCIATED(MESH_REGION)) THEN
                  NULLIFY(FIELD_INTERFACE)
                  FIELD_REGION=>FIELD%REGION
                  IF(ASSOCIATED(FIELD_REGION)) THEN
                    IF(MESH_REGION%USER_NUMBER==FIELD_REGION%USER_NUMBER) THEN
                      FIELD%DECOMPOSITION=>MESH_DECOMPOSITION
                    ELSE
                      LOCAL_ERROR="Inconsitent regions. The field is defined on region number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%REGION%USER_NUMBER,"*",ERR,ERROR))// &
                        & " and the mesh decomposition is defined on region number "//&
                        & TRIM(NUMBER_TO_VSTRING(MESH_DECOMPOSITION%MESH%REGION%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    FIELD_INTERFACE=>FIELD%INTERFACE
                    IF(ASSOCIATED(FIELD_INTERFACE)) THEN
                      PARENT_REGION=>FIELD_INTERFACE%PARENT_REGION
                      IF(ASSOCIATED(PARENT_REGION)) THEN
                        LOCAL_ERROR="Inconsitent setup. The field is defined on interface number "// &
                          & TRIM(NUMBER_TO_VSTRING(FIELD_INTERFACE%USER_NUMBER,"*",ERR,ERROR))// &
                          & " of parent region number "//TRIM(NUMBER_TO_VSTRING(PARENT_REGION%USER_NUMBER,"*",ERR,ERROR))// &
                          & " and the mesh decomposition is defined on region number "// &
                          & TRIM(NUMBER_TO_VSTRING(MESH_REGION%USER_NUMBER,"*",ERR,ERROR))//"."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ELSE
                        CALL FLAG_ERROR("Field interface has no parent region.",ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      LOCAL_ERROR="Region or interface is not associated for field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ENDIF
                ELSE
                  MESH_INTERFACE=>MESH%INTERFACE
                  IF(ASSOCIATED(MESH_INTERFACE)) THEN
                    PARENT_REGION=>MESH_INTERFACE%PARENT_REGION
                    IF(ASSOCIATED(PARENT_REGION)) THEN
                      FIELD_REGION=>FIELD%REGION
                      IF(ASSOCIATED(FIELD_REGION)) THEN
                        LOCAL_ERROR="Inconsitent setup. The field is defined on region number "// &
                          & TRIM(NUMBER_TO_VSTRING(FIELD_REGION%USER_NUMBER,"*",ERR,ERROR))// &
                          & " and the mesh decomposition is defined on interface number "// &
                          & TRIM(NUMBER_TO_VSTRING(MESH_INTERFACE%USER_NUMBER,"*",ERR,ERROR))// &
                          & " of parent region number "//TRIM(NUMBER_TO_VSTRING(PARENT_REGION%USER_NUMBER,"*",ERR,ERROR))//"."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ELSE
                        FIELD_INTERFACE=>FIELD%INTERFACE
                        IF(ASSOCIATED(FIELD_INTERFACE)) THEN
                          PARENT_REGION=>FIELD_INTERFACE%PARENT_REGION
                          IF(ASSOCIATED(PARENT_REGION)) THEN
                            IF(MESH_INTERFACE%USER_NUMBER==FIELD_INTERFACE%USER_NUMBER) THEN
                              FIELD%DECOMPOSITION=>MESH_DECOMPOSITION
                            ELSE
                              LOCAL_ERROR="Inconsitent interfaces. The field is defined on interface number "// &
                                & TRIM(NUMBER_TO_VSTRING(FIELD_INTERFACE%USER_NUMBER,"*",ERR,ERROR))// &
                                & " of parent region number "// &
                                & TRIM(NUMBER_TO_VSTRING(PARENT_REGION%USER_NUMBER,"*",ERR,ERROR))// &
                                & " and the mesh decomposition is defined on region number "//&
                                & TRIM(NUMBER_TO_VSTRING(MESH_REGION%USER_NUMBER,"*",ERR,ERROR))//"."
                              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)

                            ENDIF
                          ELSE
                            CALL FLAG_ERROR("Field interface parent region is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Region or interface is not associated for field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)                        
                        ENDIF
                      ENDIF
                    ELSE
                      CALL FLAG_ERROR("Mesh interface parent region is not associated.",ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="Region or interface is not associated for mesh number "// &
                      & TRIM(NUMBER_TO_VSTRING(MESH%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)                        
                  ENDIF
                ENDIF
              ELSE
                CALL FLAG_ERROR("Mesh is not associated for the mesh decomposition.",ERR,ERROR,*999)
              ENDIF
            ELSE
              CALL FLAG_ERROR("Mesh decomposition is not assocaited.",ERR,ERROR,*999)
            ENDIF
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_MESH_DECOMPOSITION_SET")
    RETURN
999 CALL ERRORS("FIELD_MESH_DECOMPOSITION_SET",ERR,ERROR)
    CALL EXITS("FIELD_MESH_DECOMPOSITION_SET")
    RETURN 1
  END SUBROUTINE FIELD_MESH_DECOMPOSITION_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh decomposition for a field and locks so that no further changes can be made.
  SUBROUTINE FIELD_MESH_DECOMPOSITION_SET_AND_LOCK(FIELD,MESH_DECOMPOSITION,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the decomposition for
    TYPE(DECOMPOSITION_TYPE), POINTER :: MESH_DECOMPOSITION !<A pointer to the mesh decomposition to set
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_MESH_DECOMPOSITION_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_MESH_DECOMPOSITION_SET(FIELD,MESH_DECOMPOSITION,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%DECOMPOSITION_LOCKED=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_MESH_DECOMPOSITION_SET_AND_LOCK")
    RETURN
999 CALL ERRORS("FIELD_MESH_DECOMPOSITION_SET_AND_LOCK",ERR,ERROR)
    CALL EXITS("FIELD_MESH_DECOMPOSITION_SET_AND_LOCK")
    RETURN 1
  END SUBROUTINE FIELD_MESH_DECOMPOSITION_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Sets/changes the data projection for a field. \see OPENCMISS::CMISSFieldDataProjectionSet
  SUBROUTINE Field_DataProjectionSet(field,dataProjection,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to set the decomposition for
    TYPE(DATA_PROJECTION_TYPE), POINTER :: dataProjection !<A pointer to the data projection to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_DataProjectionSet",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",err,error))// &
          & " has been finished."
        CALL FLAG_ERROR(localError,err,error,*999)
      ELSE
        IF(ASSOCIATED(field%CREATE_VALUES_CACHE)) THEN
          IF(field%CREATE_VALUES_CACHE%DataProjectionLocked) THEN
            localError="The data projection has been locked for field number "// &
              & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FLAG_ERROR(localError,ERR,ERROR,*999)
          ELSE
            IF(ASSOCIATED(dataProjection)) THEN
              field%DataProjection=>dataProjection
            ELSE
              CALL FLAG_ERROR("Data projection is not associated.",err,error,*999)
            ENDIF
          ENDIF
        ELSE
          localError="Field create values cache is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    ENDIF

    CALL EXITS("Field_DataProjectionSet")
    RETURN
999 CALL ERRORS("Field_DataProjectionSet",err,error)
    CALL EXITS("Field_DataProjectionSet")
    RETURN 1
  END SUBROUTINE Field_DataProjectionSet

  !
  !================================================================================================================================
  !

  !>Checks the number of field components for a field variable.
  SUBROUTINE FIELD_NUMBER_OF_COMPONENTS_CHECK(FIELD,VARIABLE_TYPE,NUMBER_OF_COMPONENTS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the number of components
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_COMPONENTS !The number of components in the field variable to check
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_NUMBER_OF_COMPONENTS_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%NUMBER_OF_COMPONENTS/=NUMBER_OF_COMPONENTS) THEN
              LOCAL_ERROR="Invalid number of components. The number components for variable type "// &
                & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " which does not correspond to the specified number of components of "// &
                & TRIM(NUMBER_TO_VSTRING(NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          ENDIF
        ELSE
          LOCAL_ERROR="The supplied variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The field variable type must be > 1 and <= "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_NUMBER_OF_COMPONENTS_CHECK")
    RETURN
999 CALL ERRORS("FIELD_NUMBER_OF_COMPONENTS_CHECK",ERR,ERROR)
    CALL EXITS("FIELD_NUMBER_OF_COMPONENTS_CHECK")
    RETURN 1
  END SUBROUTINE FIELD_NUMBER_OF_COMPONENTS_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the number of field components for a field variable. \see OPENCMISS::CMISSFieldNumberOfComponentsGet
  SUBROUTINE FIELD_NUMBER_OF_COMPONENTS_GET(FIELD,VARIABLE_TYPE,NUMBER_OF_COMPONENTS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the number of components
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(OUT) :: NUMBER_OF_COMPONENTS !<On return, the number of components in the field variable
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_NUMBER_OF_COMPONENTS_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            NUMBER_OF_COMPONENTS=FIELD_VARIABLE%NUMBER_OF_COMPONENTS
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          ENDIF
        ELSE
          LOCAL_ERROR="The supplied variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The field variable type must be > 1 and <= "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_NUMBER_OF_COMPONENTS_GET")
    RETURN
999 CALL ERRORS("FIELD_NUMBER_OF_COMPONENTS_GET",ERR,ERROR)
    CALL EXITS("FIELD_NUMBER_OF_COMPONENTS_GET")
    RETURN 1
  END SUBROUTINE FIELD_NUMBER_OF_COMPONENTS_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of field components for a field variable. \see OPENCMISS::CMISSFieldNumberOfComponentsSet
  SUBROUTINE FIELD_NUMBER_OF_COMPONENTS_SET(FIELD,VARIABLE_TYPE,NUMBER_OF_COMPONENTS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the number of components
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_COMPONENTS !<The number of components to be set.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,NEW_NUMBER_OF_COMPONENTS,OLD_NUMBER_OF_COMPONENTS,OVERLAP_NUMBER_OF_COMPONENTS,variable_idx
    INTEGER(INTG), ALLOCATABLE :: NEW_INTERPOLATION_TYPE(:,:),NEW_MESH_COMPONENT_NUMBER(:,:)
    LOGICAL, ALLOCATABLE ::NEW_COMPONENT_LABELS_LOCKED(:,:), NEW_INTERPOLATION_TYPE_LOCKED(:,:), &
      & NEW_MESH_COMPONENT_NUMBER_LOCKED(:,:)
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    TYPE(VARYING_STRING), ALLOCATABLE :: NEW_COMPONENT_LABELS(:,:)

    CALL ENTERS("FIELD_NUMBER_OF_COMPONENTS_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
              IF(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED(VARIABLE_TYPE)) THEN
                LOCAL_ERROR="The number of components has been locked for variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ELSE
                SELECT CASE(FIELD%CREATE_VALUES_CACHE%DIMENSION(VARIABLE_TYPE))
                CASE(FIELD_SCALAR_DIMENSION_TYPE)
                  IF(NUMBER_OF_COMPONENTS/=1) THEN
                    LOCAL_ERROR="Scalar fields cannot have "//TRIM(NUMBER_TO_VSTRING(NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                CASE(FIELD_VECTOR_DIMENSION_TYPE)
                  IF(NUMBER_OF_COMPONENTS>0) THEN
                    IF(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)/=NUMBER_OF_COMPONENTS) THEN
                      OLD_NUMBER_OF_COMPONENTS=MAXVAL(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS)
                      NEW_NUMBER_OF_COMPONENTS=NUMBER_OF_COMPONENTS
                        DO variable_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
                        IF (FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_idx) > NEW_NUMBER_OF_COMPONENTS) THEN 
                          IF (variable_idx /= VARIABLE_TYPE) THEN
                            NEW_NUMBER_OF_COMPONENTS=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_idx)
                          ENDIF
                        ENDIF
                      ENDDO
                      OVERLAP_NUMBER_OF_COMPONENTS=MIN(OLD_NUMBER_OF_COMPONENTS,NEW_NUMBER_OF_COMPONENTS)
                      ALLOCATE(NEW_COMPONENT_LABELS(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new component labels.",ERR,ERROR,*999)
                      ALLOCATE(NEW_COMPONENT_LABELS_LOCKED(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new component labels locked.",ERR,ERROR,*999)
                      ALLOCATE(NEW_INTERPOLATION_TYPE(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new interpolation type.",ERR,ERROR,*999)
                      ALLOCATE(NEW_INTERPOLATION_TYPE_LOCKED(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new interpolation type locked.",ERR,ERROR,*999)
                      ALLOCATE(NEW_MESH_COMPONENT_NUMBER(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new mesh component number.",ERR,ERROR,*999)
                      ALLOCATE(NEW_MESH_COMPONENT_NUMBER_LOCKED(NEW_NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
                      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new mesh component number locked.",ERR,ERROR,*999)

                      NEW_COMPONENT_LABELS=''
                      NEW_COMPONENT_LABELS_LOCKED=.FALSE.
                      NEW_INTERPOLATION_TYPE=0
                      NEW_INTERPOLATION_TYPE_LOCKED=.FALSE.
                      NEW_MESH_COMPONENT_NUMBER=0                   
                      NEW_MESH_COMPONENT_NUMBER_LOCKED=.FALSE.
                      NEW_COMPONENT_LABELS(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
                        & FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
                      NEW_COMPONENT_LABELS_LOCKED(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
                        & FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
                      NEW_INTERPOLATION_TYPE(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
                        & FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
                      NEW_INTERPOLATION_TYPE_LOCKED(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
                        & FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
                      NEW_MESH_COMPONENT_NUMBER(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
                        & FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
                      NEW_MESH_COMPONENT_NUMBER_LOCKED(1:OVERLAP_NUMBER_OF_COMPONENTS,:) = &
                        & FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(1:OVERLAP_NUMBER_OF_COMPONENTS,:)
                      !Update remaining terms
                      IF(OLD_NUMBER_OF_COMPONENTS<NUMBER_OF_COMPONENTS) THEN
                        DO variable_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
                          DO component_idx=OLD_NUMBER_OF_COMPONENTS+1,NUMBER_OF_COMPONENTS
                            NEW_COMPONENT_LABELS(component_idx,variable_idx)= &
                              & TRIM(NUMBER_TO_VSTRING(component_idx,"*",ERR,ERROR))
                            IF(ERR/=0) GOTO 999
                          ENDDO
                          NEW_INTERPOLATION_TYPE(OLD_NUMBER_OF_COMPONENTS+1:NUMBER_OF_COMPONENTS,variable_idx) = &
                            & FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(1,variable_idx)
                          NEW_MESH_COMPONENT_NUMBER(OLD_NUMBER_OF_COMPONENTS+1:NUMBER_OF_COMPONENTS,variable_idx) = &
                            & FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(1,variable_idx)
                        ENDDO
                      ENDIF

                      CALL MOVE_ALLOC(NEW_COMPONENT_LABELS,FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS)
                      CALL MOVE_ALLOC(NEW_COMPONENT_LABELS_LOCKED,FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED)
                      CALL MOVE_ALLOC(NEW_INTERPOLATION_TYPE,FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE)
                      CALL MOVE_ALLOC(NEW_INTERPOLATION_TYPE_LOCKED,FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED)
                      CALL MOVE_ALLOC(NEW_MESH_COMPONENT_NUMBER,FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER)
                      CALL MOVE_ALLOC(NEW_MESH_COMPONENT_NUMBER_LOCKED,FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED)

                      FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(VARIABLE_TYPE)=NUMBER_OF_COMPONENTS
                    ENDIF
                  ELSE
                    LOCAL_ERROR="Vector fields cannot have "//TRIM(NUMBER_TO_VSTRING(NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                CASE(FIELD_TENSOR_DIMENSION_TYPE)
                  CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                CASE DEFAULT
                  LOCAL_ERROR="Field dimension "//TRIM(NUMBER_TO_VSTRING(FIELD%CREATE_VALUES_CACHE%DIMENSION( &
                    & VARIABLE_TYPE),"*",ERR,ERROR))//" is not valid."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                END SELECT
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_NUMBER_OF_COMPONENTS_SET")
    RETURN
999 IF(ALLOCATED(NEW_COMPONENT_LABELS)) DEALLOCATE(NEW_COMPONENT_LABELS)
    IF(ALLOCATED(NEW_COMPONENT_LABELS_LOCKED)) DEALLOCATE(NEW_COMPONENT_LABELS_LOCKED)
    IF(ALLOCATED(NEW_INTERPOLATION_TYPE)) DEALLOCATE(NEW_INTERPOLATION_TYPE)
    IF(ALLOCATED(NEW_INTERPOLATION_TYPE_LOCKED)) DEALLOCATE(NEW_INTERPOLATION_TYPE_LOCKED)
    IF(ALLOCATED(NEW_MESH_COMPONENT_NUMBER)) DEALLOCATE(NEW_MESH_COMPONENT_NUMBER)
    IF(ALLOCATED(NEW_MESH_COMPONENT_NUMBER_LOCKED)) DEALLOCATE(NEW_MESH_COMPONENT_NUMBER_LOCKED)
    CALL ERRORS("FIELD_NUMBER_OF_COMPONENTS_SET",ERR,ERROR)
    CALL EXITS("FIELD_NUMBER_OF_COMPONENTS_SET")
    RETURN 1
  END SUBROUTINE FIELD_NUMBER_OF_COMPONENTS_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of field components for a field variable and locks so that no further changes can be made.
  SUBROUTINE FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK(FIELD,VARIABLE_TYPE,NUMBER_OF_COMPONENTS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the number of components
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_COMPONENTS !<The number of components to be set.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_NUMBER_OF_COMPONENTS_SET(FIELD,VARIABLE_TYPE,NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED(VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK")
    RETURN
999 CALL ERRORS("FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK",ERR,ERROR)
    CALL EXITS("FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK")
    RETURN 1
  END SUBROUTINE FIELD_NUMBER_OF_COMPONENTS_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Checks the number of variables for a field.
  SUBROUTINE FIELD_NUMBER_OF_VARIABLES_CHECK(FIELD,NUMBER_OF_VARIABLES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the number of variables for
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_VARIABLES !<The number of variables in the specified field to check
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_NUMBER_OF_VARIABLES_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(FIELD%NUMBER_OF_VARIABLES/=NUMBER_OF_VARIABLES) THEN
          LOCAL_ERROR="Invalid number of variables. The number of variables for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%NUMBER_OF_VARIABLES,"*",ERR,ERROR))// &
            & " which is does correspond to the specified number of variables of "// &
            & TRIM(NUMBER_TO_VSTRING(NUMBER_OF_VARIABLES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
       ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_NUMBER_OF_VARIABLES_CHECK")
    RETURN
999 CALL ERRORS("FIELD_NUMBER_OF_VARIABLES_CHECK",ERR,ERROR)
    CALL EXITS("FIELD_NUMBER_OF_VARIABLES_CHECK")
    RETURN 1
  END SUBROUTINE FIELD_NUMBER_OF_VARIABLES_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the number of variables for a field. \see OPENCMISS::CMISSFieldNumberOfVariablesGet
  SUBROUTINE FIELD_NUMBER_OF_VARIABLES_GET(FIELD,NUMBER_OF_VARIABLES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the number of variables for
    INTEGER(INTG), INTENT(OUT) :: NUMBER_OF_VARIABLES !<On return, the number of variables in the specified field
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_NUMBER_OF_VARIABLES_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        NUMBER_OF_VARIABLES=FIELD%NUMBER_OF_VARIABLES
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_NUMBER_OF_VARIABLES_GET")
    RETURN
999 CALL ERRORS("FIELD_NUMBER_OF_VARIABLES_GET",ERR,ERROR)
    CALL EXITS("FIELD_NUMBER_OF_VARIABLES_GET")
    RETURN 1
  END SUBROUTINE FIELD_NUMBER_OF_VARIABLES_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of variables for a field. \see OPENCMISS::CMISSFieldNumberOfVariablesSet
  SUBROUTINE FIELD_NUMBER_OF_VARIABLES_SET(FIELD,NUMBER_OF_VARIABLES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the number of variables for
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_VARIABLES !<The number of variables to set for the field
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx,variable_idx2,variable_type
    INTEGER(INTG), ALLOCATABLE :: OLD_VARIABLE_TYPES(:)
    LOGICAL :: FOUND
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_NUMBER_OF_VARIABLES_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_VARIABLES_LOCKED) THEN
            LOCAL_ERROR="The number of variables has been locked field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            IF(NUMBER_OF_VARIABLES>0.AND.NUMBER_OF_VARIABLES<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
              IF(FIELD%NUMBER_OF_VARIABLES/=NUMBER_OF_VARIABLES) THEN
                ALLOCATE(OLD_VARIABLE_TYPES(FIELD%NUMBER_OF_VARIABLES),STAT=ERR)
                IF(ERR/=0) CALL FLAG_ERROR("Could not allocate old variable types.",ERR,ERROR,*999)
                OLD_VARIABLE_TYPES(1:FIELD%NUMBER_OF_VARIABLES)=FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(1: &
                  & FIELD%NUMBER_OF_VARIABLES)
                DEALLOCATE(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES)
                ALLOCATE(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(NUMBER_OF_VARIABLES),STAT=ERR)
                IF(ERR/=0) CALL FLAG_ERROR("Could not allocate variable types.",ERR,ERROR,*999)
                FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES=0
                IF(NUMBER_OF_VARIABLES<FIELD%NUMBER_OF_VARIABLES) THEN
                  FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(1:NUMBER_OF_VARIABLES)=OLD_VARIABLE_TYPES(1:NUMBER_OF_VARIABLES)
                  DO variable_idx=NUMBER_OF_VARIABLES+1,FIELD%NUMBER_OF_VARIABLES
                    variable_type=OLD_VARIABLE_TYPES(variable_idx)
                    FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)=""
                    FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED(variable_type)=.FALSE.
                    FIELD%CREATE_VALUES_CACHE%DIMENSION(variable_type)=0
                    FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED(variable_type)=.FALSE.
                    FIELD%CREATE_VALUES_CACHE%DATA_TYPES(variable_type)=0
                    FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED(variable_type)=.FALSE.
                    FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES(variable_type)=0
                    FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED(variable_type)=.FALSE.
                    FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_type)=0
                    FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED(variable_type)=.FALSE.
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(:,variable_type)=0
                    FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(:,variable_type)=.FALSE.
                    FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(:,variable_type)=0
                    FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(:,variable_type)=.FALSE.
                  ENDDO !variable_idx
                ELSE
                  FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(1:FIELD%NUMBER_OF_VARIABLES)= &
                    & OLD_VARIABLE_TYPES(1:FIELD%NUMBER_OF_VARIABLES)
                  DO variable_idx=FIELD%NUMBER_OF_VARIABLES+1,NUMBER_OF_VARIABLES
                    !Find the next available variable type
                    DO variable_type=1,FIELD_NUMBER_OF_VARIABLE_TYPES
                      FOUND=.FALSE.
                      DO variable_idx2=1,FIELD%NUMBER_OF_VARIABLES
                        IF(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(variable_idx2)==variable_type) THEN
                          FOUND=.TRUE.
                          EXIT
                        ENDIF
                      ENDDO !variable_idx2
                      IF(.NOT.FOUND) EXIT
                    ENDDO !variable_type
                    IF(FOUND) THEN
                      CALL FLAG_ERROR("Could not find free variable type???",ERR,ERROR,*999)
                    ELSE
                      FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(variable_idx)=variable_type
                      SELECT CASE(variable_type)
                      CASE(FIELD_U_VARIABLE_TYPE)
                        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)="U"
                      CASE(FIELD_DELUDELN_VARIABLE_TYPE)
                        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)="del U/del n"
                      CASE(FIELD_DELUDELT_VARIABLE_TYPE)
                        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)="del U/del t"
                      CASE(FIELD_DEL2UDELT2_VARIABLE_TYPE)
                        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)="del^2 U/del t^2"
                      CASE(FIELD_V_VARIABLE_TYPE)
                        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)="V"
                      CASE(FIELD_DELVDELN_VARIABLE_TYPE)
                        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)="del V/del n"
                      CASE DEFAULT
                        LOCAL_ERROR="The variable type of "//TRIM(NUMBER_TO_VSTRING(variable_type,"*",ERR,ERROR))//" is invalid."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      END SELECT
                      FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED(variable_type)=.FALSE.
                      FIELD%CREATE_VALUES_CACHE%DIMENSION(variable_type)=FIELD%CREATE_VALUES_CACHE%DIMENSION( &
                        & OLD_VARIABLE_TYPES(1))
                      FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED(variable_type)=.FALSE.
                      FIELD%CREATE_VALUES_CACHE%DATA_TYPES(variable_type)=FIELD%CREATE_VALUES_CACHE%DATA_TYPES( &
                        & OLD_VARIABLE_TYPES(1))
                      FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED(variable_type)=.FALSE.
                      FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES(variable_type)=FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES( &
                        & OLD_VARIABLE_TYPES(1))
                      FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED(variable_type)=.FALSE.
                      FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_type)=FIELD%CREATE_VALUES_CACHE% &
                        & NUMBER_OF_COMPONENTS(OLD_VARIABLE_TYPES(1))
                      FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED(variable_type)=.FALSE.
                      FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS(:,variable_type)=FIELD%CREATE_VALUES_CACHE% &
                        COMPONENT_LABELS(:,FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(OLD_VARIABLE_TYPES(1)))
                      FIELD%CREATE_VALUES_CACHE%COMPONENT_LABELS_LOCKED(:,variable_type)=.FALSE.
                      FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(:,variable_type)=FIELD%CREATE_VALUES_CACHE% &
                        INTERPOLATION_TYPE(:,FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(OLD_VARIABLE_TYPES(1)))
                      FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(:,variable_type)=.FALSE.
                      FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(:,variable_type)=FIELD%CREATE_VALUES_CACHE% &
                        MESH_COMPONENT_NUMBER(:,FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(OLD_VARIABLE_TYPES(1)))
                      FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(:,variable_type)=.FALSE.
                    ENDIF
                  ENDDO !variable_idx
                ENDIF
                DEALLOCATE(OLD_VARIABLE_TYPES)
                FIELD%NUMBER_OF_VARIABLES=NUMBER_OF_VARIABLES
              ENDIF
            ELSE
              LOCAL_ERROR="The specified number of variables of "//TRIM(NUMBER_TO_VSTRING(NUMBER_OF_VARIABLES,"*",ERR,ERROR))// &
                & " is invalid. The number of variables must be between 1 and "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_NUMBER_OF_VARIABLES_SET")
    RETURN
999 IF(ALLOCATED(OLD_VARIABLE_TYPES)) DEALLOCATE(OLD_VARIABLE_TYPES)
    CALL ERRORS("FIELD_NUMBER_OF_VARIABLES_SET",ERR,ERROR)
    CALL EXITS("FIELD_NUMBER_OF_VARIABLES_SET")
    RETURN 1
  END SUBROUTINE FIELD_NUMBER_OF_VARIABLES_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of variables for a field and locks so that no further changes can be made.
  SUBROUTINE FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK(FIELD,NUMBER_OF_VARIABLES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the number of variables for
    INTEGER(INTG), INTENT(IN) :: NUMBER_OF_VARIABLES !<The number of variables to set for the field
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_NUMBER_OF_VARIABLES_SET(FIELD,NUMBER_OF_VARIABLES,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%NUMBER_OF_VARIABLES_LOCKED=.TRUE.

      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF    
 
    CALL EXITS("FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK")
    RETURN
999 CALL ERRORS("FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK",ERR,ERROR)
    CALL EXITS("FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK")
    RETURN 1
  END SUBROUTINE FIELD_NUMBER_OF_VARIABLES_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Adds the alpha times the parameter set values from one parameter set type to another parameter set type \todo make this call distributed vector add??? 
  SUBROUTINE FIELD_PARAMETER_SETS_ADD_DP(FIELD,VARIABLE_TYPE,ALPHA,FIELD_FROM_SET_TYPE,FIELD_TO_SET_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add the parameter sets for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    REAL(DP), INTENT(IN) :: ALPHA(:) !<The multiplicative factor for the add.
    INTEGER(INTG), INTENT(IN) :: FIELD_FROM_SET_TYPE(:) !<The field parameter set identifier to add the parameters from \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_TO_SET_TYPE !<The field parameter set identifier to add the parameters to \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx,parameter_set_idx
    REAL(DP) :: VALUE
    TYPE(REAL_DP_PTR_TYPE) :: FIELD_FROM_PARAMETERS(SIZE(FIELD_FROM_SET_TYPE,1))
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: FIELD_FROM_PARAMETER_SET,FIELD_TO_PARAMETER_SET
    TYPE(FIELD_PARAMETER_SET_PTR_TYPE) :: FIELD_FROM_PARAMETER_SETS(SIZE(FIELD_FROM_SET_TYPE,1))
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SETS_ADD_DP",ERR,ERROR,*999)
    
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            !Check the to set type input
            IF(FIELD_TO_SET_TYPE>0.AND.FIELD_TO_SET_TYPE<FIELD_NUMBER_OF_SET_TYPES) THEN
              FIELD_TO_PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_TO_SET_TYPE)%PTR
              IF(ASSOCIATED(FIELD_TO_PARAMETER_SET)) THEN
                IF(SIZE(ALPHA,1)==SIZE(FIELD_FROM_SET_TYPE,1)) THEN
                  DO parameter_set_idx=1,SIZE(FIELD_FROM_SET_TYPE,1)
                    IF(FIELD_FROM_SET_TYPE(parameter_set_idx)>0.AND. &
                      & FIELD_FROM_SET_TYPE(parameter_set_idx)<FIELD_NUMBER_OF_SET_TYPES) THEN
                      FIELD_FROM_PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_FROM_SET_TYPE( &
                      & parameter_set_idx))%PTR
                      IF(ASSOCIATED(FIELD_TO_PARAMETER_SET)) THEN
                        FIELD_FROM_PARAMETER_SETS(parameter_set_idx)%PTR=>FIELD_FROM_PARAMETER_SET
                        NULLIFY(FIELD_FROM_PARAMETERS(parameter_set_idx)%PTR)
                        CALL DISTRIBUTED_VECTOR_DATA_GET(FIELD_FROM_PARAMETER_SETS(parameter_set_idx)%PTR%PARAMETERS, &
                          & FIELD_FROM_PARAMETERS(parameter_set_idx)%PTR,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="The field from set type of "// &
                          & TRIM(NUMBER_TO_VSTRING(FIELD_FROM_SET_TYPE(parameter_set_idx),"*",ERR,ERROR))// &
                          & " in parameter set index "//TRIM(NUMBER_TO_VSTRING(parameter_set_idx,"*",ERR,ERROR))// &
                          & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & "."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      LOCAL_ERROR="The field from set type of "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD_FROM_SET_TYPE(parameter_set_idx),"*",ERR,ERROR))// &
                        & " for parameter set index "//TRIM(NUMBER_TO_VSTRING(parameter_set_idx,"*",ERR,ERROR))// &
                        & " is invalid. The field parameter set type must be between 1 and "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ENDDO !parameter_set_idx
                  !Do not need to do an update here as each rank already has the values.
                  !Add the field dofs
                  DO dof_idx=1,FIELD_VARIABLE%TOTAL_NUMBER_OF_DOFS
                    VALUE=0.0_DP
                    DO parameter_set_idx=1,SIZE(FIELD_FROM_SET_TYPE,1)
                      VALUE=VALUE+ALPHA(parameter_set_idx)*FIELD_FROM_PARAMETERS(parameter_set_idx)%PTR(dof_idx)
                    ENDDO !parameter_set_idx
                    CALL DISTRIBUTED_VECTOR_VALUES_ADD(FIELD_TO_PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                  ENDDO !dof_idx
                  !Restore the from parameter set transfer
                  DO parameter_set_idx=1,SIZE(FIELD_FROM_SET_TYPE,1)
                    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(FIELD_FROM_PARAMETER_SETS(parameter_set_idx)%PTR%PARAMETERS, &
                      & FIELD_FROM_PARAMETERS(parameter_set_idx)%PTR,ERR,ERROR,*999)
                  ENDDO !parameter_set_idx
                ELSE
                  LOCAL_ERROR="The size of the alpha array ("//TRIM(NUMBER_TO_VSTRING(SIZE(ALPHA,1),"*",ERR,ERROR))// &
                    & ") does not match the size of the from set type array ("// &
                    & TRIM(NUMBER_TO_VSTRING(SIZE(FIELD_FROM_SET_TYPE,1),"*",ERR,ERROR))//"."
                ENDIF
              ELSE
                LOCAL_ERROR="The field to set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_TO_SET_TYPE,"*",ERR,ERROR))// &
                  & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field to set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_TO_SET_TYPE,"*",ERR,ERROR))// &
                & " is invalid. The field parameter set type must be between 1 and "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_PARAMETER_SETS_ADD_DP")

    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SETS_ADD_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SETS_ADD_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SETS_ADD_DP
  
 !
  !================================================================================================================================
  !

  !>Adds the alpha times the parameter set values from one parameter set type to another parameter set type \todo make this call distributed vector add???
  SUBROUTINE FIELD_PARAMETER_SETS_ADD_DP1(FIELD,VARIABLE_TYPE,ALPHA,FIELD_FROM_SET_TYPE,FIELD_TO_SET_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add the parameter sets for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINE
    REAL(DP), INTENT(IN) :: ALPHA !<The multiplicative factor for the add.
    INTEGER(INTG), INTENT(IN) :: FIELD_FROM_SET_TYPE !<The field parameter set identifier to add the parameters from
    INTEGER(INTG), INTENT(IN) :: FIELD_TO_SET_TYPE !<The field parameter set identifier to add the parameters to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELD_PARAMETER_SETS_ADD_DP1",ERR,ERROR,*999)
    
    CALL FIELD_PARAMETER_SETS_ADD_DP(FIELD,VARIABLE_TYPE,[ALPHA],[FIELD_FROM_SET_TYPE],FIELD_TO_SET_TYPE,ERR,ERROR,*999)
    
    CALL EXITS("FIELD_PARAMETER_SETS_ADD_DP1")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SETS_ADD_DP1",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SETS_ADD_DP1")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SETS_ADD_DP1
  
  !
  !================================================================================================================================
  !

  !>Copys the parameter set from one parameter set type to another parameter set type \todo make this call distributed vector copy???
  SUBROUTINE FIELD_PARAMETER_SETS_COPY(FIELD,VARIABLE_TYPE,FIELD_FROM_SET_TYPE,FIELD_TO_SET_TYPE,ALPHA,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to copy the parameters set for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to copy \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_FROM_SET_TYPE !<The field parameter set identifier to copy the parameters from \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_TO_SET_TYPE !<The field parameter set identifier to copy the parameters to \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(DP), INTENT(IN) :: ALPHA !<The multiplicative factor for the copy.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: FIELD_FROM_PARAMETER_SET,FIELD_TO_PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SETS_COPY",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            !Check the from set type input
            IF(FIELD_FROM_SET_TYPE>0.AND.FIELD_FROM_SET_TYPE<FIELD_NUMBER_OF_SET_TYPES) THEN
              FIELD_FROM_PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_FROM_SET_TYPE)%PTR
              IF(ASSOCIATED(FIELD_FROM_PARAMETER_SET)) THEN
                !Check the from set type input
                IF(FIELD_TO_SET_TYPE>0.AND.FIELD_TO_SET_TYPE<FIELD_NUMBER_OF_SET_TYPES) THEN
                  FIELD_TO_PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_TO_SET_TYPE)%PTR
                  !Do not need to do an update here as each rank already has the values.
                  IF(ASSOCIATED(FIELD_TO_PARAMETER_SET)) THEN
                    CALL DISTRIBUTED_VECTOR_COPY(FIELD_FROM_PARAMETER_SET%PARAMETERS,FIELD_TO_PARAMETER_SET%PARAMETERS, &
                      & ALPHA,ERR,ERROR,*999)
                  ELSE
                    ! CHECK what needs to be done here: LagrangeMultipliersField does not have SET_TYPE==PREVIOUS_VALUES
                    IF(ASSOCIATED(FIELD%INTERFACE)) THEN
                      !OK if LagrangeMultipliersField?
                    ELSE
                      LOCAL_ERROR="The field to set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_TO_SET_TYPE,"*",ERR,ERROR))// &
                        & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field to set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_TO_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field from set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_FROM_SET_TYPE,"*",ERR,ERROR))// &
                  & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field from set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_FROM_SET_TYPE,"*",ERR,ERROR))// &
                & " is invalid. The field parameter set type must be between 1 and "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SETS_COPY")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SETS_COPY",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SETS_COPY")
    RETURN 1
    
  END SUBROUTINE FIELD_PARAMETER_SETS_COPY

  !
  !================================================================================================================================
  !
  
  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable.
  SUBROUTINE FIELD_PARAMETERS_TO_FIELD_PARAMETERS_COMPONENT_COPY(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
    & FROM_COMPONENT_NUMBER,TO_FIELD,TO_VARIABLE_TYPE,TO_PARAMETER_SET_TYPE,TO_COMPONENT_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FROM_FIELD !<A pointer to the field to copy from
    INTEGER(INTG), INTENT(IN) :: FROM_VARIABLE_TYPE !<The field variable type to copy from
    INTEGER(INTG), INTENT(IN) :: FROM_PARAMETER_SET_TYPE !<The field parameter set type to copy from
    INTEGER(INTG), INTENT(IN) :: FROM_COMPONENT_NUMBER !<The field variable component number to copy from
    TYPE(FIELD_TYPE), POINTER :: TO_FIELD !<A pointer to the field to copy to
    INTEGER(INTG), INTENT(IN) :: TO_VARIABLE_TYPE !<The field variable type to copy to
    INTEGER(INTG), INTENT(IN) :: TO_PARAMETER_SET_TYPE !<The parameter set type to copy to
    INTEGER(INTG), INTENT(IN) :: TO_COMPONENT_NUMBER !<The field variable component to copy to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: elem_idx,deriv_idx,version_idx,local_ny,node_idx,VALUE_INTG,gausspoint_idx
    INTEGER(INTG), POINTER :: FROM_PARAMETER_DATA_INTG(:)
    REAL(SP) :: VALUE_SP
    REAL(SP), POINTER :: FROM_PARAMETER_DATA_SP(:)
    REAL(DP) :: VALUE_DP
    REAL(DP), POINTER :: FROM_PARAMETER_DATA_DP(:)
    LOGICAL :: VALUE_L
    LOGICAL, POINTER :: FROM_PARAMETER_DATA_L(:)
    TYPE(DOMAIN_TYPE), POINTER :: FROM_DOMAIN,TO_DOMAIN
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: FROM_DOMAIN_ELEMENTS
    TYPE(DOMAIN_NODES_TYPE), POINTER :: FROM_DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: FROM_DOMAIN_TOPOLOGY
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FROM_FIELD_VARIABLE,TO_FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    NULLIFY(FROM_PARAMETER_DATA_INTG)
    NULLIFY(FROM_PARAMETER_DATA_SP)
    NULLIFY(FROM_PARAMETER_DATA_DP)
    NULLIFY(FROM_PARAMETER_DATA_L)
    
    CALL ENTERS("FIELD_PARAMETERS_TO_FIELD_PARAMETERS_COMPONENT_COPY",ERR,ERROR,*999)
    
    IF(ASSOCIATED(FROM_FIELD)) THEN
      IF(FROM_FIELD%FIELD_FINISHED) THEN
        IF(FROM_VARIABLE_TYPE>0.AND.FROM_VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FROM_FIELD_VARIABLE=>FROM_FIELD%VARIABLE_TYPE_MAP(FROM_VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FROM_FIELD_VARIABLE)) THEN
            IF(FROM_COMPONENT_NUMBER>=1.AND.FROM_COMPONENT_NUMBER<=FROM_FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN  
              IF(ASSOCIATED(TO_FIELD)) THEN
                IF(TO_FIELD%FIELD_FINISHED) THEN
                  IF(TO_VARIABLE_TYPE>0.AND.TO_VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
                    TO_FIELD_VARIABLE=>TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR
                    IF(ASSOCIATED(TO_FIELD_VARIABLE)) THEN
                      IF(TO_COMPONENT_NUMBER>=1.AND.TO_COMPONENT_NUMBER<=TO_FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                        FROM_DOMAIN=>FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%DOMAIN
                        TO_DOMAIN=>TO_FIELD_VARIABLE%COMPONENTS(TO_COMPONENT_NUMBER)%DOMAIN
                        IF(ASSOCIATED(FROM_DOMAIN)) THEN
                          IF(ASSOCIATED(FROM_DOMAIN,TO_DOMAIN)) THEN
                            IF(FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%INTERPOLATION_TYPE== &
                              & TO_FIELD_VARIABLE%COMPONENTS(TO_COMPONENT_NUMBER)%INTERPOLATION_TYPE) THEN
                              IF(FROM_FIELD_VARIABLE%DATA_TYPE==TO_FIELD_VARIABLE%DATA_TYPE) THEN
                                SELECT CASE(FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                                CASE(FIELD_CONSTANT_INTERPOLATION)
                                  SELECT CASE(FROM_FIELD_VARIABLE%DATA_TYPE)
                                  CASE(FIELD_INTG_TYPE)
                                    CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                      & FROM_PARAMETER_DATA_INTG,ERR,ERROR,*999)
                                    local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                      & CONSTANT_PARAM2DOF_MAP
                                    VALUE_INTG=FROM_PARAMETER_DATA_INTG(local_ny)
                                    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(TO_FIELD,TO_VARIABLE_TYPE,TO_PARAMETER_SET_TYPE, &
                                      & TO_COMPONENT_NUMBER,VALUE_INTG,ERR,ERROR,*999)
                                    CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                      & FROM_PARAMETER_DATA_INTG,ERR,ERROR,*999)
                                  CASE(FIELD_SP_TYPE)
                                    CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                      & FROM_PARAMETER_DATA_SP,ERR,ERROR,*999)
                                    local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                      & CONSTANT_PARAM2DOF_MAP
                                    VALUE_SP=FROM_PARAMETER_DATA_SP(local_ny)
                                    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(TO_FIELD,TO_VARIABLE_TYPE,TO_PARAMETER_SET_TYPE, &
                                      & TO_COMPONENT_NUMBER,VALUE_SP,ERR,ERROR,*999)
                                    CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                      & FROM_PARAMETER_DATA_SP,ERR,ERROR,*999)
                                  CASE(FIELD_DP_TYPE)
                                    CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                      & FROM_PARAMETER_DATA_DP,ERR,ERROR,*999)
                                    local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                      & CONSTANT_PARAM2DOF_MAP
                                    VALUE_DP=FROM_PARAMETER_DATA_DP(local_ny)
                                    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(TO_FIELD,TO_VARIABLE_TYPE,TO_PARAMETER_SET_TYPE, &
                                      & TO_COMPONENT_NUMBER,VALUE_DP,ERR,ERROR,*999)
                                    CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                      & FROM_PARAMETER_DATA_DP,ERR,ERROR,*999)
                                  CASE(FIELD_L_TYPE)
                                    CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                      & FROM_PARAMETER_DATA_L,ERR,ERROR,*999)
                                    local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                      & CONSTANT_PARAM2DOF_MAP
                                    VALUE_L=FROM_PARAMETER_DATA_L(local_ny)
                                    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(TO_FIELD,TO_VARIABLE_TYPE,TO_PARAMETER_SET_TYPE, &
                                      & TO_COMPONENT_NUMBER,VALUE_L,ERR,ERROR,*999)
                                    CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                      & FROM_PARAMETER_DATA_L,ERR,ERROR,*999)
                                   CASE DEFAULT
                                    LOCAL_ERROR="The from field variable data type of "// &
                                      & TRIM(NUMBER_TO_VSTRING(FROM_FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                                      & " is invalid."
                                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                  END SELECT
                                CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                                  FROM_DOMAIN_TOPOLOGY=>FROM_DOMAIN%TOPOLOGY
                                  IF(ASSOCIATED(FROM_DOMAIN_TOPOLOGY)) THEN
                                    FROM_DOMAIN_ELEMENTS=>FROM_DOMAIN_TOPOLOGY%ELEMENTS
                                    IF(ASSOCIATED(FROM_DOMAIN_ELEMENTS)) THEN
                                      SELECT CASE(FROM_FIELD_VARIABLE%DATA_TYPE)
                                      CASE(FIELD_INTG_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_INTG,ERR,ERROR,*999)
                                        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                          local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                            & ELEMENT_PARAM2DOF_MAP%ELEMENTS(elem_idx)
                                          VALUE_INTG=FROM_PARAMETER_DATA_INTG(local_ny)
                                          CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT(TO_FIELD,TO_VARIABLE_TYPE, &
                                            & TO_PARAMETER_SET_TYPE,elem_idx,TO_COMPONENT_NUMBER,VALUE_INTG,ERR,ERROR,*999)
                                        ENDDO !elem_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_INTG,ERR,ERROR,*999)
                                      CASE(FIELD_SP_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_SP,ERR,ERROR,*999)
                                        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                          local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                            & ELEMENT_PARAM2DOF_MAP%ELEMENTS(elem_idx)
                                          VALUE_SP=FROM_PARAMETER_DATA_SP(local_ny)
                                          CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT(TO_FIELD,TO_VARIABLE_TYPE, &
                                            & TO_PARAMETER_SET_TYPE,elem_idx,TO_COMPONENT_NUMBER,VALUE_SP,ERR,ERROR,*999)
                                        ENDDO !elem_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_SP,ERR,ERROR,*999)
                                      CASE(FIELD_DP_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_DP,ERR,ERROR,*999)
                                        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                          local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                            & ELEMENT_PARAM2DOF_MAP%ELEMENTS(elem_idx)
                                          VALUE_DP=FROM_PARAMETER_DATA_DP(local_ny)
                                          CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT(TO_FIELD,TO_VARIABLE_TYPE, &

                                            & TO_PARAMETER_SET_TYPE,elem_idx,TO_COMPONENT_NUMBER,VALUE_DP,ERR,ERROR,*999)
                                        ENDDO !elem_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_DP,ERR,ERROR,*999)
                                      CASE(FIELD_L_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_L,ERR,ERROR,*999)
                                        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                          local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                            & ELEMENT_PARAM2DOF_MAP%ELEMENTS(elem_idx)
                                          VALUE_L=FROM_PARAMETER_DATA_L(local_ny)
                                          CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT(TO_FIELD,TO_VARIABLE_TYPE, &
                                            & TO_PARAMETER_SET_TYPE,elem_idx,TO_COMPONENT_NUMBER,VALUE_L,ERR,ERROR,*999)
                                        ENDDO !elem_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_L,ERR,ERROR,*999)
                                      CASE DEFAULT
                                        LOCAL_ERROR="The from field variable data type of "// &
                                          & TRIM(NUMBER_TO_VSTRING(FROM_FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                                          & " is invalid."
                                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                      END SELECT
                                    ELSE
                                      CALL FLAG_ERROR("From domain topology elements is not associated.",ERR,ERROR,*999)
                                    ENDIF
                                  ELSE
                                    CALL FLAG_ERROR("From domain topology is not associated.",ERR,ERROR,*999)
                                  ENDIF
                                CASE(FIELD_NODE_BASED_INTERPOLATION)
                                  FROM_DOMAIN_TOPOLOGY=>FROM_DOMAIN%TOPOLOGY
                                  IF(ASSOCIATED(FROM_DOMAIN_TOPOLOGY)) THEN
                                    FROM_DOMAIN_NODES=>FROM_DOMAIN_TOPOLOGY%NODES
                                    IF(ASSOCIATED(FROM_DOMAIN_NODES)) THEN
                                      SELECT CASE(FROM_FIELD_VARIABLE%DATA_TYPE)
                                      CASE(FIELD_INTG_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_INTG,ERR,ERROR,*999)
                                        DO node_idx=1,FROM_DOMAIN_NODES%TOTAL_NUMBER_OF_NODES
                                          DO deriv_idx=1,FROM_DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                                            DO version_idx=1,FROM_DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)% &
                                              & numberOfVersions
                                              local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                                & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(deriv_idx)%VERSIONS(version_idx)
                                              VALUE_INTG=FROM_PARAMETER_DATA_INTG(local_ny)
                                              CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE(TO_FIELD,TO_VARIABLE_TYPE, &
                                                & TO_PARAMETER_SET_TYPE,version_idx,deriv_idx,node_idx,TO_COMPONENT_NUMBER, &
                                                & VALUE_INTG,ERR,ERROR,*999)
                                            ENDDO !version_idx
                                          ENDDO !deriv_idx
                                        ENDDO !node_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_INTG,ERR,ERROR,*999)
                                      CASE(FIELD_SP_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_SP,ERR,ERROR,*999)
                                        DO node_idx=1,FROM_DOMAIN_NODES%TOTAL_NUMBER_OF_NODES
                                          DO deriv_idx=1,FROM_DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                                            DO version_idx=1,FROM_DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)% &
                                              & numberOfVersions
                                              local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                                & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(deriv_idx)%VERSIONS(version_idx)
                                              VALUE_SP=FROM_PARAMETER_DATA_SP(local_ny)
                                              CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE(TO_FIELD,TO_VARIABLE_TYPE, &
                                                & TO_PARAMETER_SET_TYPE,version_idx,deriv_idx,node_idx,TO_COMPONENT_NUMBER, &
                                                & VALUE_SP,ERR,ERROR,*999)
                                            ENDDO !version_idx
                                          ENDDO !deriv_idx
                                        ENDDO !node_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_SP,ERR,ERROR,*999)
                                      CASE(FIELD_DP_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_DP,ERR,ERROR,*999)
                                        DO node_idx=1,FROM_DOMAIN_NODES%TOTAL_NUMBER_OF_NODES
                                          DO deriv_idx=1,FROM_DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                                            DO version_idx=1,FROM_DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)% &
                                              & numberOfVersions
                                              local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                                & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(deriv_idx)%VERSIONS(version_idx)
                                              VALUE_DP=FROM_PARAMETER_DATA_DP(local_ny)
                                              CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE(TO_FIELD,TO_VARIABLE_TYPE, &
                                                & TO_PARAMETER_SET_TYPE,version_idx,deriv_idx,node_idx,TO_COMPONENT_NUMBER, &
                                                & VALUE_DP,ERR,ERROR,*999)
                                            ENDDO !version_idx
                                          ENDDO !deriv_idx
                                        ENDDO !node_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_DP,ERR,ERROR,*999)
                                      CASE(FIELD_L_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_L,ERR,ERROR,*999)
                                        DO node_idx=1,FROM_DOMAIN_NODES%TOTAL_NUMBER_OF_NODES
                                          DO deriv_idx=1,FROM_DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                                            DO version_idx=1,FROM_DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(deriv_idx)% &
                                              & numberOfVersions
                                              local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                                & NODE_PARAM2DOF_MAP%NODES(node_idx)%DERIVATIVES(deriv_idx)%VERSIONS(version_idx)
                                              VALUE_L=FROM_PARAMETER_DATA_L(local_ny)
                                              CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE(TO_FIELD,TO_VARIABLE_TYPE, &
                                                & TO_PARAMETER_SET_TYPE,version_idx,deriv_idx,node_idx,TO_COMPONENT_NUMBER, &
                                                & VALUE_L,ERR,ERROR,*999)
                                            ENDDO !version_idx
                                          ENDDO !deriv_idx
                                        ENDDO !node_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_L,ERR,ERROR,*999)
                                     CASE DEFAULT
                                        LOCAL_ERROR="The from field variable data type of "// &
                                          & TRIM(NUMBER_TO_VSTRING(FROM_FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                                          & " is invalid."
                                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                      END SELECT
                                    ELSE
                                      CALL FLAG_ERROR("From domain topology nodes is not associated.",ERR,ERROR,*999)
                                    ENDIF
                                  ELSE
                                    CALL FLAG_ERROR("From domain topology is not associated.",ERR,ERROR,*999)
                                  ENDIF
                                CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                                  CALL FLAG_ERROR("Not implmented.",ERR,ERROR,*999)
                                CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                                  ! gp based.
                                  FROM_DOMAIN_TOPOLOGY=>FROM_DOMAIN%TOPOLOGY
                                  IF(ASSOCIATED(FROM_DOMAIN_TOPOLOGY)) THEN
                                    FROM_DOMAIN_ELEMENTS=>FROM_DOMAIN_TOPOLOGY%ELEMENTS
                                    IF(ASSOCIATED(FROM_DOMAIN_ELEMENTS)) THEN
                                      SELECT CASE(FROM_FIELD_VARIABLE%DATA_TYPE)
                                      CASE(FIELD_INTG_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_INTG,ERR,ERROR,*999)
                                        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                          DO gausspoint_idx=1,size(FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)% &
                                              & PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)
                                            local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gausspoint_idx,elem_idx)
                                            VALUE_INTG=FROM_PARAMETER_DATA_INTG(local_ny)
                                            local_ny=TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR%&
                                              &COMPONENTS(TO_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gausspoint_idx,elem_idx)
                                            CALL DISTRIBUTED_VECTOR_VALUES_SET(TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR%&
                                            & PARAMETER_SETS%SET_TYPE(TO_PARAMETER_SET_TYPE)%PTR%PARAMETERS,local_ny,VALUE_INTG,&
                                            & ERR,ERROR,*999)
                                          ENDDO !gausspoint_idx
                                        ENDDO !elem_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_INTG,ERR,ERROR,*999)
                                      CASE(FIELD_SP_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_SP,ERR,ERROR,*999)
                                        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                          DO gausspoint_idx=1,size(FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)% &
                                              & PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)
                                            local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gausspoint_idx,elem_idx)
                                            VALUE_SP=FROM_PARAMETER_DATA_SP(local_ny)
                                            local_ny=TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR%&
                                              &COMPONENTS(TO_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gausspoint_idx,elem_idx)
                                            CALL DISTRIBUTED_VECTOR_VALUES_SET(TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR%&
                                            & PARAMETER_SETS%SET_TYPE(TO_PARAMETER_SET_TYPE)%PTR%PARAMETERS,local_ny,VALUE_SP,&
                                            & ERR,ERROR,*999)
                                          ENDDO !gausspoint_idx
                                        ENDDO !elem_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_SP,ERR,ERROR,*999)
                                      CASE(FIELD_DP_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_DP,ERR,ERROR,*999)
                                        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                          DO gausspoint_idx=1,size(FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)% &
                                              & PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)
                                            local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gausspoint_idx,elem_idx)
                                            VALUE_DP=FROM_PARAMETER_DATA_DP(local_ny)
                                            local_ny=TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR%&
                                            &COMPONENTS(TO_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gausspoint_idx,elem_idx)
                                            CALL DISTRIBUTED_VECTOR_VALUES_SET(TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR%&
                                            & PARAMETER_SETS%SET_TYPE(TO_PARAMETER_SET_TYPE)%PTR%PARAMETERS,local_ny,VALUE_DP,&
                                            & ERR,ERROR,*999)
                                          ENDDO !gausspoint_idx
                                        ENDDO !elem_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_DP,ERR,ERROR,*999)
                                      CASE(FIELD_L_TYPE)
                                        CALL FIELD_PARAMETER_SET_DATA_GET(FROM_FIELD,FROM_VARIABLE_TYPE,FROM_PARAMETER_SET_TYPE, &
                                          & FROM_PARAMETER_DATA_L,ERR,ERROR,*999)
                                        DO elem_idx=1,FROM_DOMAIN_ELEMENTS%TOTAL_NUMBER_OF_ELEMENTS
                                          DO gausspoint_idx=1,size(FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)% &
                                              & PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)
                                            local_ny=FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gausspoint_idx,elem_idx)
                                            VALUE_L=FROM_PARAMETER_DATA_L(local_ny)
                                            local_ny=TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR%&
                                              &COMPONENTS(TO_COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gausspoint_idx,elem_idx)
                                            CALL DISTRIBUTED_VECTOR_VALUES_SET(TO_FIELD%VARIABLE_TYPE_MAP(TO_VARIABLE_TYPE)%PTR%&
                                            & PARAMETER_SETS%SET_TYPE(TO_PARAMETER_SET_TYPE)%PTR%PARAMETERS,local_ny,VALUE_L,&
                                            & ERR,ERROR,*999)
                                          ENDDO !gausspoint_idx
                                        ENDDO !elem_idx
                                        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FROM_FIELD,FROM_VARIABLE_TYPE, &
                                          & FROM_PARAMETER_SET_TYPE,FROM_PARAMETER_DATA_L,ERR,ERROR,*999)
                                      CASE DEFAULT
                                        CALL FLAG_ERROR("Invalid data type or not implemented.",ERR,ERROR,*999)
                                      END SELECT
                                    ELSE
                                      CALL FLAG_ERROR("From domain topology elements is not associated.",ERR,ERROR,*999)
                                    ENDIF
                                  ELSE
                                    CALL FLAG_ERROR("From domain topology is not associated.",ERR,ERROR,*999)
                                  ENDIF
                                ! / gp based
                                CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                                  CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
                                CASE DEFAULT
                                  LOCAL_ERROR="The from field variable component interpolation type of "// &
                                    & TRIM(NUMBER_TO_VSTRING(FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)% &
                                    & INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid."
                                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                END SELECT
                              ELSE
                                LOCAL_ERROR="The from field variable data type of "// &
                                  & TRIM(NUMBER_TO_VSTRING(FROM_FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                                  & " does not match the to variable data type of "// &
                                  & TRIM(NUMBER_TO_VSTRING(TO_FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))//"."
                                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              LOCAL_ERROR="The from field variable component interpolation type of "// &
                                & TRIM(NUMBER_TO_VSTRING(FROM_FIELD_VARIABLE%COMPONENTS(FROM_COMPONENT_NUMBER)% &
                                & INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                                & " does not match the to variable component interpolation type of "// &
                                & TRIM(NUMBER_TO_VSTRING(TO_FIELD_VARIABLE%COMPONENTS(TO_COMPONENT_NUMBER)% &
                                & INTERPOLATION_TYPE,"*",ERR,ERROR))//"."
                              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                           ELSE
                            CALL FLAG_ERROR("The from field variable component domain is not associated with the "// &
                              & "to field variable component domain.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("The from variable component domain is not associated.",ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="To component number "//TRIM(NUMBER_TO_VSTRING(TO_COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for to variable type "//TRIM(NUMBER_TO_VSTRING(TO_VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(TO_FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                          & TRIM(NUMBER_TO_VSTRING(TO_FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                          & " components."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      LOCAL_ERROR="The to field variable type of "//TRIM(NUMBER_TO_VSTRING(TO_VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(TO_FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The to field variable type of "//TRIM(NUMBER_TO_VSTRING(TO_VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " is invalid. The variable type must be between 1 and "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="To field number "//TRIM(NUMBER_TO_VSTRING(TO_FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                    & " has not been finished."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FLAG_ERROR("The to field is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="From component number "//TRIM(NUMBER_TO_VSTRING(FROM_COMPONENT_NUMBER,"*",ERR,ERROR))// &
                & " is invalid for from variable type "//TRIM(NUMBER_TO_VSTRING(FROM_VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NUMBER_TO_VSTRING(FROM_FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                & TRIM(NUMBER_TO_VSTRING(FROM_FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                & " components."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The from field variable type of "//TRIM(NUMBER_TO_VSTRING(FROM_VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FROM_FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The from field variable type of "//TRIM(NUMBER_TO_VSTRING(FROM_VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="From field number "//TRIM(NUMBER_TO_VSTRING(FROM_FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("The from field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_PARAMETERS_TO_FIELD_PARAMETERS_COMPONENT_COPY")
    RETURN
999 CALL ERRORS("FIELD_PARAMETERS_TO_FIELD_PARAMETERS_COMPONENT_COPY",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETERS_TO_FIELD_PARAMETERS_COMPONENT_COPY")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETERS_TO_FIELD_PARAMETERS_COMPONENT_COPY


  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for the constant of the field variable component. \see OPENCMISS::CMISSFieldParameterSetAddConstant
  SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add to
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_CONSTANT_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                    & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)              
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_CONSTANT_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for the constant of the field variable component. \see OPENCMISS::CMISSFieldParameterSetAddConstant
  SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add to
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_CONSTANT_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                    & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)              
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_CONSTANT_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for the constant of the field variable component. \see OPENCMISS::CMISSFieldParameterSetAddConstant
  SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add to
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_CONSTANT_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                    & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)              
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_CONSTANT_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for the constant of the field variable component. \see OPENCMISS::CMISSFieldParameterSetAddConstant
  SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add to
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_CONSTANT_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                    & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                    & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)              
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_CONSTANT_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_CONSTANT_L")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_CONSTANT_L

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: GLOBAL_DOF_NUMBER
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  !Note that dofs are slightly different from other mappings in that all the local dofs are not all at the start.
                  !This is because the dof indicies are from combined field components. Thus need to check that a ghost value is
                  !not being set.
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL) THEN
                    GLOBAL_DOF_NUMBER=FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(DOF_NUMBER)
                    IF(FIELD_VARIABLE%DOMAIN_MAPPING%GLOBAL_TO_LOCAL_MAP(GLOBAL_DOF_NUMBER)%LOCAL_TYPE(1)/=DOMAIN_LOCAL_GHOST) THEN
                      CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                    ELSE
                      LOCAL_ERROR="The field dof number of "//TRIM(NUMBER_TO_VSTRING(DOF_NUMBER,"*",ERR,ERROR))// &
                        & " is invalid as it is a ghost dof for this domain."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NUMBER_TO_VSTRING(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)              
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: GLOBAL_DOF_NUMBER
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  !Note that dofs are slightly different from other mappings in that all the local dofs are not all at the start.
                  !This is because the dof indicies are from combined field components. Thus need to check that a ghost value is
                  !not being set.
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL) THEN
                    GLOBAL_DOF_NUMBER=FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(DOF_NUMBER)
                    IF(FIELD_VARIABLE%DOMAIN_MAPPING%GLOBAL_TO_LOCAL_MAP(GLOBAL_DOF_NUMBER)%LOCAL_TYPE(1)/=DOMAIN_LOCAL_GHOST) THEN
                      CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                    ELSE
                      LOCAL_ERROR="The field dof number of "//TRIM(NUMBER_TO_VSTRING(DOF_NUMBER,"*",ERR,ERROR))// &
                        & " is invalid as it is a ghost dof for this domain."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NUMBER_TO_VSTRING(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)              
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: GLOBAL_DOF_NUMBER
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  !Note that dofs are slightly different from other mappings in that all the local dofs are not all at the start.
                  !This is because the dof indicies are from combined field components. Thus need to check that a ghost value is
                  !not being set.
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL) THEN
                    GLOBAL_DOF_NUMBER=FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(DOF_NUMBER)
                    IF(FIELD_VARIABLE%DOMAIN_MAPPING%GLOBAL_TO_LOCAL_MAP(GLOBAL_DOF_NUMBER)%LOCAL_TYPE(1)/=DOMAIN_LOCAL_GHOST) THEN
                      CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                    ELSE
                      LOCAL_ERROR="The field dof number of "//TRIM(NUMBER_TO_VSTRING(DOF_NUMBER,"*",ERR,ERROR))// &
                        & " is invalid as it is a ghost dof for this domain."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NUMBER_TO_VSTRING(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)              
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: GLOBAL_DOF_NUMBER
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  !Note that dofs are slightly different from other mappings in that all the local dofs are not all at the start.
                  !This is because the dof indicies are from combined field components. Thus need to check that a ghost value is
                  !not being set.
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL) THEN
                    GLOBAL_DOF_NUMBER=FIELD_VARIABLE%DOMAIN_MAPPING%LOCAL_TO_GLOBAL_MAP(DOF_NUMBER)
                    IF(FIELD_VARIABLE%DOMAIN_MAPPING%GLOBAL_TO_LOCAL_MAP(GLOBAL_DOF_NUMBER)%LOCAL_TYPE(1)/=DOMAIN_LOCAL_GHOST) THEN
                      CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                    ELSE
                      LOCAL_ERROR="The field dof number of "//TRIM(NUMBER_TO_VSTRING(DOF_NUMBER,"*",ERR,ERROR))// &
                        & " is invalid as it is a ghost dof for this domain."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NUMBER_TO_VSTRING(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)              
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_DOF_L

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular user element of the field variable component. \see OPENCMISS::CMISSFieldParameterSetAddElement
  SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_ELEMENT_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          IF(GHOST_ELEMENT) THEN
                            LOCAL_ERROR="Cannot add element for user element "// &
                              & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))//" as it is a ghost element."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                            CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)              
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_ELEMENT_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular user element of the field variable component.\see OPENCMISS::CMISSFieldParameterSetAddElement 
  SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_ELEMENT_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          IF(GHOST_ELEMENT) THEN
                            LOCAL_ERROR="Cannot add element for user element "// &
                              & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))//" as it is a ghost element."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                            CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &

                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)              
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_ELEMENT_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular user element of the field variable component.\see OPENCMISS::CMISSFieldParameterSetAddElement 
  SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_ELEMENT_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          IF(GHOST_ELEMENT) THEN
                            LOCAL_ERROR="Cannot add element for user element "// &
                              & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))//" as it is a ghost element."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                            CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)              
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_ELEMENT_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular user element of the field variable component. \see OPENCMISS::CMISSFieldParameterSetAddElement
  SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_ELEMENT_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          IF(GHOST_ELEMENT) THEN
                            LOCAL_ERROR="Cannot add element for user element "// &
                              & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))//" as it is a ghost element."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                            CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)              
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_ELEMENT_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_ELEMENT_L")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_ELEMENT_L

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      IF(LOCAL_ELEMENT_NUMBER>0.AND.LOCAL_ELEMENT_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS( &
                          & LOCAL_ELEMENT_NUMBER)                      
                        CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Local element number "//TRIM(NUMBER_TO_VSTRING(LOCAL_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                          & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" elements."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)              
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      IF(LOCAL_ELEMENT_NUMBER>0.AND.LOCAL_ELEMENT_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS( &
                          & LOCAL_ELEMENT_NUMBER)                      
                        CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Local element number "//TRIM(NUMBER_TO_VSTRING(LOCAL_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                          & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" elements."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)              
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      IF(LOCAL_ELEMENT_NUMBER>0.AND.LOCAL_ELEMENT_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS( &
                          & LOCAL_ELEMENT_NUMBER)                      
                        CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Local element number "//TRIM(NUMBER_TO_VSTRING(LOCAL_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                          & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" elements."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)              
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      IF(LOCAL_ELEMENT_NUMBER>0.AND.LOCAL_ELEMENT_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS( &
                          & LOCAL_ELEMENT_NUMBER)                      
                        CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Local element number "//TRIM(NUMBER_TO_VSTRING(LOCAL_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                          & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" elements."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)              
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_ELEMENT_L

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular user node, derivative and version of the field variable component. \see OPENCMISS::CMISSFieldParameterSetAddNode
  SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_NODE_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                            IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          IF(GHOST_NODE) THEN
                            LOCAL_ERROR="Cannot add node for user node "// &
                              & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" as it is a ghost node."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(DOMAIN_NODES)) THEN
                              IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                  & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & NUMBER_OF_VERSIONS) THEN
                                  dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                    & VERSIONS(VERSION_NUMBER)
                                  CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                                ELSE
                                  LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                    & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                    & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for user node number "// &
                                  & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_NODE_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_NODE_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_NODE_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular user node, derivative and version of the field variable component. \see OPENCMISS::CMISSFieldParameterSetAddNode
  SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_NODE_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                            IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          IF(GHOST_NODE) THEN
                            LOCAL_ERROR="Cannot add node for user node "// &
                              & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" as it is a ghost node."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(DOMAIN_NODES)) THEN
                              IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                  & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & NUMBER_OF_VERSIONS) THEN
                                  dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                    & VERSIONS(VERSION_NUMBER)
                                  CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                                ELSE
                                  LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                    & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                    & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for user node number "// &
                                  & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_NODE_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_NODE_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_NODE_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular user node, derivative and version of the field variable component. \see OPENCMISS::CMISSFieldParameterSetAddNode
  SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_NODE_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                            IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          IF(GHOST_NODE) THEN
                            LOCAL_ERROR="Cannot add node for user node "// &
                              & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" as it is a ghost node."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(DOMAIN_NODES)) THEN
                              IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                  & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & NUMBER_OF_VERSIONS) THEN
                                  dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                    & VERSIONS(VERSION_NUMBER)
                                  CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                                ELSE
                                  LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                    & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                    & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for user node number "// &
                                  & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_NODE_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_NODE_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_NODE_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular user node, derivative and version of the field variable component. \see OPENCMISS::CMISSFieldParameterSetAddNode
  SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_NODE_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                            IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          IF(GHOST_NODE) THEN
                            LOCAL_ERROR="Cannot add node for user node "// &
                              & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" as it is a ghost node."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(DOMAIN_NODES)) THEN
                              IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                  & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & NUMBER_OF_VERSIONS) THEN
                                  dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                    & VERSIONS(VERSION_NUMBER)
                                  CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                                ELSE
                                  LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                    & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                    & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*", &
                                  & ERR,ERROR))//" is invalid for user node number "// &
                                  & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_NODE_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_NODE_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_NODE_L")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_NODE_L

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: FIELD_NODES
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      FIELD_NODES=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP
                      IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=FIELD_NODES%NUMBER_OF_NODE_PARAMETERS) THEN
                        IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                            & FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS) THEN
                            dof_idx=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                              & VERSIONS(VERSION_NUMBER)
                            CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ELSE
                            LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                              & TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                              & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                              & TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                              & DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS,"*",ERR,ERROR))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid for user node number "// &
                            & TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                            & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Local node number "//TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" nodes."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_INTG

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(SP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: FIELD_NODES
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      FIELD_NODES=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP
                      IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=FIELD_NODES%NUMBER_OF_NODE_PARAMETERS) THEN
                        IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                            & FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS) THEN
                            dof_idx=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                              & VERSIONS(VERSION_NUMBER)
                            CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ELSE
                            LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                              & TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                              & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                              & TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                              & DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS,"*",ERR,ERROR))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid for user node number "// &
                            & TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                            & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Local node number "//TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" nodes."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_SP

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    REAL(DP), INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: FIELD_NODES
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      FIELD_NODES=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP
                      IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=FIELD_NODES%NUMBER_OF_NODE_PARAMETERS) THEN
                        IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                            & FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS) THEN
                            dof_idx=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                              & VERSIONS(VERSION_NUMBER)
                            CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ELSE
                            LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                              & TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                              & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                              & TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                              & DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS,"*",ERR,ERROR))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid for user node number "// &
                            & TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                            & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Local node number "//TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" nodes."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_DP

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to add
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to add \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to add
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to add
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to add
    LOGICAL, INTENT(IN) :: VALUE !<The value to add
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: FIELD_NODES
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      FIELD_NODES=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP
                      IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=FIELD_NODES%NUMBER_OF_NODE_PARAMETERS) THEN
                        IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                            & FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS) THEN
                            dof_idx=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                              & VERSIONS(VERSION_NUMBER)
                            CALL DISTRIBUTED_VECTOR_VALUES_ADD(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ELSE
                            LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                              & TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                              & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                              & TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                              & DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS,"*",ERR,ERROR))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid for user node number "// &
                            & TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                            & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Local node number "//TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" nodes."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS( &
                        & COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))//" is invalid for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_ADD_LOCAL_NODE_L

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type set type for a field variable. If the field parameter set has already been
  !>created then an error will be raised. \see OPENCMISS::CMISSFieldParameterSetCreate
  SUBROUTINE FIELD_PARAMETER_SET_CREATE(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to create the parameter set for
    INTEGER(INTG),  INTENT(IN) :: VARIABLE_TYPE !<The variable type to create the parameter set for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,parameter_set_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: NEW_PARAMETER_SET
    TYPE(FIELD_PARAMETER_SET_PTR_TYPE), POINTER :: NEW_PARAMETER_SETS(:)
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR,DUMMY_ERROR

    NULLIFY(NEW_PARAMETER_SET)
    NULLIFY(NEW_PARAMETER_SETS)

    CALL ENTERS("FIELD_PARAMETER_SET_CREATE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
        FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
        IF(ASSOCIATED(FIELD_VARIABLE)) THEN
          !Check the set type input
          IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<FIELD_NUMBER_OF_SET_TYPES) THEN
            !Check if this set type has already been created
            IF(ASSOCIATED(FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE)) THEN
              IF(ASSOCIATED(FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR)) THEN
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " has already been created for variable type of "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ENDIF
            ALLOCATE(NEW_PARAMETER_SET,STAT=ERR)
            IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new parameter set.",ERR,ERROR,*999)
            CALL FIELD_PARAMETER_SET_INITIALISE(NEW_PARAMETER_SET,ERR,ERROR,*999)
            NEW_PARAMETER_SET%SET_INDEX=FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS+1
            NEW_PARAMETER_SET%SET_TYPE=FIELD_SET_TYPE
            NULLIFY(NEW_PARAMETER_SET%PARAMETERS)
            CALL DISTRIBUTED_VECTOR_CREATE_START(FIELD_VARIABLE%DOMAIN_MAPPING,NEW_PARAMETER_SET%PARAMETERS,ERR,ERROR,*999)
            SELECT CASE(FIELD_VARIABLE%DATA_TYPE)
            CASE(FIELD_INTG_TYPE)
              CALL DISTRIBUTED_VECTOR_DATA_TYPE_SET(NEW_PARAMETER_SET%PARAMETERS,DISTRIBUTED_MATRIX_VECTOR_INTG_TYPE, &
                & ERR,ERROR,*999)
            CASE(FIELD_SP_TYPE)
              CALL DISTRIBUTED_VECTOR_DATA_TYPE_SET(NEW_PARAMETER_SET%PARAMETERS,DISTRIBUTED_MATRIX_VECTOR_SP_TYPE, &
                & ERR,ERROR,*999)
            CASE(FIELD_DP_TYPE)
              CALL DISTRIBUTED_VECTOR_DATA_TYPE_SET(NEW_PARAMETER_SET%PARAMETERS,DISTRIBUTED_MATRIX_VECTOR_DP_TYPE, &
                & ERR,ERROR,*999)
            CASE(FIELD_L_TYPE)
              CALL DISTRIBUTED_VECTOR_DATA_TYPE_SET(NEW_PARAMETER_SET%PARAMETERS,DISTRIBUTED_MATRIX_VECTOR_L_TYPE, &
                & ERR,ERROR,*999)
            CASE DEFAULT
              LOCAL_ERROR="The field data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " is invalid for variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
            CALL DISTRIBUTED_VECTOR_CREATE_FINISH(NEW_PARAMETER_SET%PARAMETERS,ERR,ERROR,*999)
            SELECT CASE(FIELD_VARIABLE%DATA_TYPE)
            CASE(FIELD_INTG_TYPE)
              CALL DISTRIBUTED_VECTOR_ALL_VALUES_SET(NEW_PARAMETER_SET%PARAMETERS,0_INTG,ERR,ERROR,*999)
            CASE(FIELD_SP_TYPE)
              CALL DISTRIBUTED_VECTOR_ALL_VALUES_SET(NEW_PARAMETER_SET%PARAMETERS,0.0_SP,ERR,ERROR,*999)
            CASE(FIELD_DP_TYPE)
              CALL DISTRIBUTED_VECTOR_ALL_VALUES_SET(NEW_PARAMETER_SET%PARAMETERS,0.0_DP,ERR,ERROR,*999)
            CASE(FIELD_L_TYPE)
              CALL DISTRIBUTED_VECTOR_ALL_VALUES_SET(NEW_PARAMETER_SET%PARAMETERS,.FALSE.,ERR,ERROR,*999)
            END SELECT
            !Add the new parameter set to the list of parameter sets
            ALLOCATE(NEW_PARAMETER_SETS(FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS+1),STAT=ERR)
            IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new parameter sets.",ERR,ERROR,*999)
            IF(ASSOCIATED(FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS)) THEN
              DO parameter_set_idx=1,FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS
                NEW_PARAMETER_SETS(parameter_set_idx)%PTR=>FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS(parameter_set_idx)%PTR
              ENDDO !parameter_set_idx
              DEALLOCATE(FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS)
            ENDIF
            NEW_PARAMETER_SETS(FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS+1)%PTR=>NEW_PARAMETER_SET
            ALLOCATE(FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS(FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS+1), &
              & STAT=ERR)
            IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field parameter sets parameter sets.",ERR,ERROR,*999)
            DO parameter_set_idx=1,FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS+1
              FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS(parameter_set_idx)%PTR=>NEW_PARAMETER_SETS(parameter_set_idx)%PTR
            ENDDO !parameter_set_idx
            DEALLOCATE(NEW_PARAMETER_SETS)
            FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS=FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS+1
            FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR=>NEW_PARAMETER_SET
          ELSE
            LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The field parameter set type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
          & " is invalid. The variable type must be between 1 and "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_CREATE")
    RETURN
999 CALL FIELD_PARAMETER_SET_FINALISE(NEW_PARAMETER_SET,DUMMY_ERR,DUMMY_ERROR,*998)
998 IF(ASSOCIATED(NEW_PARAMETER_SETS)) DEALLOCATE(NEW_PARAMETER_SETS)
    CALL ERRORS("FIELD_PARAMETER_SET_CREATE",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_CREATE")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_CREATE

  !
  !================================================================================================================================
  !

  !>Checks whether a field parameter set has been created
  SUBROUTINE FIELD_PARAMETER_SET_CREATED(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETER_SET_CREATED,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field
    INTEGER(INTG),  INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check the parameter set creation for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    LOGICAL, INTENT(OUT) :: PARAMETER_SET_CREATED
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_CREATED",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
        FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
        IF(ASSOCIATED(FIELD_VARIABLE)) THEN
          !Check the set type input
          IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
            !Check if this set type has been created
            IF(ASSOCIATED(FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR)) THEN
              PARAMETER_SET_CREATED=.TRUE.
            ELSE
              PARAMETER_SET_CREATED=.FALSE.
            END IF
          ELSE
            LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The field parameter set type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
          & " is invalid. The variable type must be between 1 and "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_CREATED")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_CREATED",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_CREATED")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_CREATED

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type fieldSetType for a field variable if it does not already exist,
  !>otherwise it will do nothing.
  SUBROUTINE Field_ParameterSetEnsureCreated(field,variableType,fieldSetType,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to create the parameter set for
    INTEGER(INTG),  INTENT(IN) :: variableType !<The variable type to create the parameter set for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local variables
    LOGICAL :: parameterSetCreated

    CALL ENTERS("Field_ParameterSetEnsureCreated",err,error,*999)

    CALL FIELD_PARAMETER_SET_CREATED(field,variableType,fieldSetType,parameterSetCreated,err,error,*999)
    IF(.NOT.parameterSetCreated) THEN
      CALL FIELD_PARAMETER_SET_CREATE(field,variableType,fieldSetType,err,error,*999)
    END IF

    CALL EXITS("Field_ParameterSetEnsureCreated")
    RETURN
999 CALL ERRORS("Field_ParameterSetEnsureCreated",err,error)
    CALL EXITS("Field_ParameterSetEnsureCreated")
    RETURN 1
  END SUBROUTINE Field_ParameterSetEnsureCreated

  !
  !================================================================================================================================
  !

  !>Destroys the parameter set of type set type for a field variable and deallocates all memory. \see OPENCMISS::CMISSFieldParameterSetDestroy
  SUBROUTINE FIELD_PARAMETER_SET_DESTROY(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to destroy a parameter set for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to destroy the parameter set for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: parameter_set_idx,SET_INDEX
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_PARAMETER_SET_PTR_TYPE), POINTER :: NEW_PARAMETER_SETS(:)
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    NULLIFY(NEW_PARAMETER_SETS)

    CALL ENTERS("FIELD_PARAMETER_SET_DESTROY",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
        FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
        IF(ASSOCIATED(FIELD_VARIABLE)) THEN
          !Check the set type input
          IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<FIELD_NUMBER_OF_SET_TYPES) THEN
            !Check if the set type has been created
            PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
            IF(ASSOCIATED(PARAMETER_SET)) THEN
              SET_INDEX=PARAMETER_SET%SET_INDEX
              ALLOCATE(NEW_PARAMETER_SETS(FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS-1),STAT=ERR)
              IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new parameter sets",ERR,ERROR,*999)
              DO parameter_set_idx=1,FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS
                IF(parameter_set_idx<SET_INDEX) THEN
                  NEW_PARAMETER_SETS(parameter_set_idx)%PTR=>FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS(parameter_set_idx)%PTR
                ELSE IF(parameter_set_idx>SET_INDEX) THEN
                  NEW_PARAMETER_SETS(parameter_set_idx-1)%PTR=>FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS(parameter_set_idx)%PTR
                  NEW_PARAMETER_SETS(parameter_set_idx-1)%PTR%SET_INDEX=NEW_PARAMETER_SETS(parameter_set_idx-1)%PTR%SET_INDEX-1
                ENDIF
              ENDDO !parameter_set_idx
              DEALLOCATE(FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS)
              FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS=>NEW_PARAMETER_SETS
              FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS=FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS-1
              NULLIFY(FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR)
              CALL FIELD_PARAMETER_SET_FINALISE(PARAMETER_SET,ERR,ERROR,*999)
            ELSE
              LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                & " has not been created for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The field parameter set type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
          & " is invalid. The variable type must be between 1 and "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_DESTROY")
    RETURN
999 IF(ASSOCIATED(NEW_PARAMETER_SETS)) DEALLOCATE(NEW_PARAMETER_SETS)
    CALL ERRORS("FIELD_PARAMETER_SET_DESTROY",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_DESTROY")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DESTROY

  !
  !================================================================================================================================
  !

  !>Finalises the parameter set for a field and deallocates all memory.
  SUBROUTINE FIELD_PARAMETER_SET_FINALISE(FIELD_PARAMETER_SET,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: FIELD_PARAMETER_SET !<A pointer to the field parameter set to destroy
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELD_PARAMETER_SET_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD_PARAMETER_SET)) THEN
      IF(ASSOCIATED(FIELD_PARAMETER_SET%PARAMETERS)) CALL DISTRIBUTED_VECTOR_DESTROY(FIELD_PARAMETER_SET%PARAMETERS,ERR,ERROR,*999)
      DEALLOCATE(FIELD_PARAMETER_SET)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_FINALISE

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field integer parameter set array. The pointer must be restored with a call to FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_RESTORE call. Note: the values can be used for read operations but a FIELD_ROUTINES::FIELD_PARAMETER_SET_UPDATE call must be used to change any values. \see OPENCMISS::CMISSFieldParameterSetDataGet
  SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), POINTER :: PARAMETERS(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_DATA_GET_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(PARAMETERS)) THEN
        CALL FLAG_ERROR("Parameters is already associated.",ERR,ERROR,*999)
      ELSE
        NULLIFY(PARAMETERS)
        IF(FIELD%FIELD_FINISHED) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(PARAMETER_SET)) THEN
                    CALL DISTRIBUTED_VECTOR_DATA_GET(PARAMETER_SET%PARAMETERS,PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " does not correspond to the integer data type of the given parameters array."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
            & " has not been finished."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_DATA_GET_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_DATA_GET_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_DATA_GET_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_INTG

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field single precision parameter set array. The pointer must be restored with a call to FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_RESTORE call. Note: the values can be used for read operations but a FIELD_ROUTINES::FIELD_PARAMETER_SET_UPDATE call must be used to change any values. \see OPENCMISS::CMISSFieldParameterSetDataGet
  SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(SP), POINTER :: PARAMETERS(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_DATA_GET_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(PARAMETERS)) THEN
        CALL FLAG_ERROR("Parameters is already associated.",ERR,ERROR,*999)
      ELSE
        NULLIFY(PARAMETERS)
        IF(FIELD%FIELD_FINISHED) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(PARAMETER_SET)) THEN
                    CALL DISTRIBUTED_VECTOR_DATA_GET(PARAMETER_SET%PARAMETERS,PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " does not correspond to the single precision data type of the given parameters array."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
            & " has not been finished."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_DATA_GET_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_DATA_GET_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_DATA_GET_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_SP

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field double precision parameter set array. The pointer must be restored with a call to FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_RESTORE call. Note: the values can be used for read operations but a FIELD_ROUTINES::FIELD_PARAMETER_SET_UPDATE call must be used to change any values. \see OPENCMISS::CMISSFieldParameterSetDataGet
  SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(DP), POINTER :: PARAMETERS(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_DATA_GET_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(PARAMETERS)) THEN
        CALL FLAG_ERROR("Parameters is already associated.",ERR,ERROR,*999)
      ELSE
        NULLIFY(PARAMETERS)
        IF(FIELD%FIELD_FINISHED) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(PARAMETER_SET)) THEN
                    CALL DISTRIBUTED_VECTOR_DATA_GET(PARAMETER_SET%PARAMETERS,PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " does not correspond to the double precision data type of the given parameters array."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
            & " has not been finished."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_DATA_GET_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_DATA_GET_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_DATA_GET_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_DP

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field logical parameter set array. The pointer must be restored with a call to FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_RESTORE call. Note: the values can be used for read operations but a FIELD_ROUTINES::FIELD_PARAMETER_SET_UPDATE call must be used to change any values. \see OPENCMISS::CMISSFieldParameterSetDataGet
  SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    LOGICAL, POINTER :: PARAMETERS(:) !<On return, a pointer to the field parameter set data
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_DATA_GET_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(PARAMETERS)) THEN
        CALL FLAG_ERROR("Parameters is already associated.",ERR,ERROR,*999)
      ELSE
        NULLIFY(PARAMETERS)
        IF(FIELD%FIELD_FINISHED) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(PARAMETER_SET)) THEN
                    CALL DISTRIBUTED_VECTOR_DATA_GET(PARAMETER_SET%PARAMETERS,PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " does not correspond to the logical data type of the given parameters array."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
            & " has not been finished."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_DATA_GET_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_DATA_GET_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_DATA_GET_L")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_GET_L

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable integer parameter set array that was obtained with FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_GET. \see OPENCMISS::CMISSFieldParameterSetDataRestore
  SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field varaible type to restore the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), POINTER :: PARAMETERS(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_DATA_RESTORE_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(ASSOCIATED(PARAMETERS)) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(PARAMETER_SET)) THEN
                    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(PARAMETER_SET%PARAMETERS,PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created on variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FLAG_ERROR("Parameters is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given parameters array."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_DATA_RESTORE_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_DATA_RESTORE_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_DATA_RESTORE_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_INTG

   !
  !================================================================================================================================
  !

  !>Restores the specified field variable single precision parameter set array that was obtained with FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_GET. \see OPENCMISS::CMISSFieldParameterSetDataRestore
  SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field varaible type to restore the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(SP), POINTER :: PARAMETERS(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_DATA_RESTORE_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(ASSOCIATED(PARAMETERS)) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(PARAMETER_SET)) THEN
                    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(PARAMETER_SET%PARAMETERS,PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created on variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FLAG_ERROR("Parameters is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given parameters array."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_DATA_RESTORE_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_DATA_RESTORE_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_DATA_RESTORE_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_SP

   !
  !================================================================================================================================
  !

  !>Restores the specified field variable double precision parameter set array that was obtained with FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_GET. \see OPENCMISS::CMISSFieldParameterSetDataRestore
  SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field varaible type to restore the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    REAL(DP), POINTER :: PARAMETERS(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_DATA_RESTORE_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(ASSOCIATED(PARAMETERS)) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(PARAMETER_SET)) THEN
                    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(PARAMETER_SET%PARAMETERS,PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created on variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FLAG_ERROR("Parameters is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given parameters array."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_DATA_RESTORE_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_DATA_RESTORE_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_DATA_RESTORE_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_DP

   !
  !================================================================================================================================
  !

  !>Restores the specified field variable logical parameter set array that was obtained with FIELD_ROUTINES::FIELD_PARAMETER_SET_DATA_GET. \see OPENCMISS::CMISSFieldParameterSetDataRestore
  SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETERS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to restore the parameter set from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field varaible type to restore the parameter set data for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    LOGICAL, POINTER :: PARAMETERS(:) !<The pointer to the field parameter set data obtained with the parameter set get call
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_DATA_RESTORE_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(ASSOCIATED(PARAMETERS)) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                  IF(ASSOCIATED(PARAMETER_SET)) THEN
                    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(PARAMETER_SET%PARAMETERS,PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                      & " has not been created on variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                CALL FLAG_ERROR("Parameters is not associated.",ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given parameters array."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_DATA_RESTORE_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_DATA_RESTORE_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_DATA_RESTORE_L")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_DATA_RESTORE_L

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified parameter set for the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_GET(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,PARAMETER_SET,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the parameter set for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the parameter set for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to get \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET !<On return, a pointer to the specified parameter set. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string

    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(ASSOCIATED(PARAMETER_SET)) THEN
              CALL FLAG_ERROR("Parameter set is already associated.",ERR,ERROR,*999)
            ELSE
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(.NOT.ASSOCIATED(PARAMETER_SET)) THEN
                  LOCAL_ERROR="The field parameter set type of "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on variable type "// &
                    & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                    & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_PARAMETER_SET_GET")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified constant of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetConstant
  SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_GET_CONSTANT_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DISTRIBUTED_VECTOR_VALUES_GET(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)

                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_GET_CONSTANT_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET_CONSTANT_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_CONSTANT_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_INTG

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetConstant
  SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_GET_CONSTANT_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DISTRIBUTED_VECTOR_VALUES_GET(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_GET_CONSTANT_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET_CONSTANT_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_CONSTANT_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_SP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetConstant
  SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_GET_CONSTANT_DP",ERR,ERROR,*999)


    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DISTRIBUTED_VECTOR_VALUES_GET(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_GET_CONSTANT_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET_CONSTANT_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_CONSTANT_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_DP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetConstant
  SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_GET_CONSTANT_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DISTRIBUTED_VECTOR_VALUES_GET(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_GET_CONSTANT_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET_CONSTANT_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_CONSTANT_L")

    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_CONSTANT_L
  
  !
  !================================================================================================================================
  !
  
  !>Returns from the given parameter set an integer value for the specified data point of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetDataPoint
  SUBROUTINE Field_ParameterSetGetDataPointIntg(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalDataPointNumber,DofIdx
    LOGICAL :: userDataPointExists,ghostDataPoint
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetGetDataPointIntg",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          CALL DecompositionTopologyDataPointCheckExists(decompositionTopology,userDataPointNumber, &
                            & userDataPointExists,decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                          IF(userDataPointExists) THEN
                            DofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)       
                            CALL DISTRIBUTED_VECTOR_VALUES_GET(parameterSet%PARAMETERS,DofIdx,value,err,error,*999)
                          ELSE
                            localError="The specified user data point number of "// &
                              & TRIM(NUMBER_TO_VSTRING(userDataPointNumber,"*",ERR,ERROR))// &
                              &  " does not exist in the decomposition for field component number "// &
                              & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                            CALL FLAG_ERROR(localError,err,error,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FLAG_ERROR(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))
                  CALL FLAG_ERROR(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FLAG_ERROR(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
            CALL FLAG_ERROR(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    ENDIF
    
    CALL EXITS("Field_ParameterSetGetDataPointIntg")
    RETURN
999 CALL ERRORS("Field_ParameterSetGetDataPointIntg",err,error)
    CALL EXITS("Field_ParameterSetGetDataPointIntg")
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetDataPointIntg
  
  !
  !================================================================================================================================
  !
  
  !>Returns from the given parameter set a single precision value for the specified data point of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetDataPoint
  SUBROUTINE Field_ParameterSetGetDataPointSP(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err,error,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalDataPointNumber,DofIdx
    LOGICAL :: userDataPointExists,ghostDataPoint
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetGetDataPointSP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          CALL DecompositionTopologyDataPointCheckExists(decompositionTopology,userDataPointNumber, &
                            & userDataPointExists,decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                          IF(userDataPointExists) THEN
                            DofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)       
                            CALL DISTRIBUTED_VECTOR_VALUES_GET(parameterSet%PARAMETERS,DofIdx,value,err,error,*999)
                          ELSE
                            localError="The specified user data point number of "// &
                              & TRIM(NUMBER_TO_VSTRING(userDataPointNumber,"*",ERR,ERROR))// &
                              &  " does not exist in the decomposition for field component number "// &
                              & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                            CALL FLAG_ERROR(localError,err,error,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FLAG_ERROR(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))
                  CALL FLAG_ERROR(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FLAG_ERROR(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
            CALL FLAG_ERROR(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    ENDIF
    
    CALL EXITS("Field_ParameterSetGetDataPointSP")
    RETURN
999 CALL ERRORS("Field_ParameterSetGetDataPointSP",err,error)
    CALL EXITS("Field_ParameterSetGetDataPointSP")
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetDataPointSP
  
  !
  !================================================================================================================================
  !
  
  !>Returns from the given parameter set a double precision value for the specified data point of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetDataPoint
  SUBROUTINE Field_ParameterSetGetDataPointDP(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err,error,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalDataPointNumber,DofIdx
    LOGICAL :: userDataPointExists,ghostDataPoint
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetGetDataPointDP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          CALL DecompositionTopologyDataPointCheckExists(decompositionTopology,userDataPointNumber, &
                            & userDataPointExists,decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                          IF(userDataPointExists) THEN
                            DofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)       
                            CALL DISTRIBUTED_VECTOR_VALUES_GET(parameterSet%PARAMETERS,DofIdx,value,err,error,*999)
                          ELSE
                            localError="The specified user data point number of "// &
                              & TRIM(NUMBER_TO_VSTRING(userDataPointNumber,"*",ERR,ERROR))// &
                              &  " does not exist in the decomposition for field component number "// &
                              & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                            CALL FLAG_ERROR(localError,err,error,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FLAG_ERROR(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))
                  CALL FLAG_ERROR(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FLAG_ERROR(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
            CALL FLAG_ERROR(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    ENDIF
    
    CALL EXITS("Field_ParameterSetGetDataPointDP")
    RETURN
999 CALL ERRORS("Field_ParameterSetGetDataPointDP",err,error)
    CALL EXITS("Field_ParameterSetGetDataPointDP")
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetDataPointDP
  
  !
  !================================================================================================================================
  !
  
  !>Returns from the given parameter set a logical value for the specified data point of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetDataPoint
  SUBROUTINE Field_ParameterSetGetDataPointL(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err,error,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalDataPointNumber,DofIdx
    LOGICAL :: userDataPointExists,ghostDataPoint
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetGetDataPointL",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          CALL DecompositionTopologyDataPointCheckExists(decompositionTopology,userDataPointNumber, &
                            & userDataPointExists,decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                          IF(userDataPointExists) THEN
                            DofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)       
                            CALL DISTRIBUTED_VECTOR_VALUES_GET(parameterSet%PARAMETERS,DofIdx,value,err,error,*999)
                          ELSE
                            localError="The specified user data point number of "// &
                              & TRIM(NUMBER_TO_VSTRING(userDataPointNumber,"*",ERR,ERROR))// &
                              &  " does not exist in the decomposition for field component number "// &
                              & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                            CALL FLAG_ERROR(localError,err,error,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FLAG_ERROR(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))
                  CALL FLAG_ERROR(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FLAG_ERROR(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the logical data type of the given value."
              CALL FLAG_ERROR(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
            CALL FLAG_ERROR(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    ENDIF
    
    CALL EXITS("Field_ParameterSetGetDataPointL")
    RETURN
999 CALL ERRORS("Field_ParameterSetGetDataPointL",err,error)
    CALL EXITS("Field_ParameterSetGetDataPointL")
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetDataPointL

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified element of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetElement
  SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_GET_ELEMENT_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                            & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                          CALL DISTRIBUTED_VECTOR_VALUES_GET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_GET_ELEMENT_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET_ELEMENT_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_ELEMENT_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_INTG

  !
  !================================================================================================================================
  !


  !>Returns from the given parameter set a single precision value for the specified element of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetElement
  SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)


    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_GET_ELEMENT_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                            & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                          CALL DISTRIBUTED_VECTOR_VALUES_GET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_GET_ELEMENT_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET_ELEMENT_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_ELEMENT_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_SP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetElement
  SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_GET_ELEMENT_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                            & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                          CALL DISTRIBUTED_VECTOR_VALUES_GET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_GET_ELEMENT_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET_ELEMENT_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_ELEMENT_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_DP

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified element of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetElement
  SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_GET_ELEMENT_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                            & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                          CALL DISTRIBUTED_VECTOR_VALUES_GET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_GET_ELEMENT_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET_ELEMENT_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_ELEMENT_L")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_ELEMENT_L

  !
  !================================================================================================================================
  !

  !>Returns the parameter set integer value for a specified local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to get
    INTEGER(INTG), INTENT(OUT) :: VALUE !<On return, the value of the specified local dof.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL) THEN
                    CALL DISTRIBUTED_VECTOR_VALUES_GET(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NUMBER_TO_VSTRING(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_INTG

  !
  !================================================================================================================================
  !

  !>Returns the parameter set single precision value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to get
    REAL(SP), INTENT(OUT) :: VALUE !<On return, the value of the specified dof
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL) THEN
                    CALL DISTRIBUTED_VECTOR_VALUES_GET(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NUMBER_TO_VSTRING(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_SP

  !
  !================================================================================================================================
  !

  !>Returns the parameter set double precision value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to get
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the value of the specified dof
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL) THEN
                    CALL DISTRIBUTED_VECTOR_VALUES_GET(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NUMBER_TO_VSTRING(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_DP

  !
  !================================================================================================================================
  !

  !>Returns the parameter set logical value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to get
    LOGICAL, INTENT(OUT) :: VALUE !<On return, the value of the specified dof.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_L",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL) THEN
                    CALL DISTRIBUTED_VECTOR_VALUES_GET(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NUMBER_TO_VSTRING(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DOMAIN_MAPPING%TOTAL_NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_LOCAL_DOF_L")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_LOCAL_DOF_L

  !
  !================================================================================================================================
  !

   !>Returns from the given parameter set a integer value for the specified local node, derivative and version of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetNode
 SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_GET_NODE_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                            IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                              & NUMBER_OF_DERIVATIVES) THEN
                              IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                & NUMBER_OF_VERSIONS) THEN
                                dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & VERSIONS(VERSION_NUMBER)
                                CALL DISTRIBUTED_VECTOR_VALUES_GET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                              ELSE
                                LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for derivative number "// &
                                  & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                  & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                  & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                  & "(note version numbers are indexed directly from the value the user specifies during "// &
                                  & "element creation and no record is kept of the total number of versions the user sets."// &
                                  & "The maximum version number the user sets defines the total number of versions allocated)."
                                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                & " is invalid for user node number "// &
                                & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_GET_NODE_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET_NODE_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_NODE_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_INTG

  !
  !================================================================================================================================
  !

   !>Returns from the given parameter set a single precision value for the specified local node, derivative and version of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetNode
  SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_GET_NODE_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                            IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                              & NUMBER_OF_DERIVATIVES) THEN
                              IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                & NUMBER_OF_VERSIONS) THEN
                                dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & VERSIONS(VERSION_NUMBER)
                                CALL DISTRIBUTED_VECTOR_VALUES_GET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                              ELSE
                                LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for derivative number "// &
                                  & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                  & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                  & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                  & "(note version numbers are indexed directly from the value the user specifies during "// &
                                  & "element creation and no record is kept of the total number of versions the user sets."// &
                                  & "The maximum version number the user sets defines the total number of versions allocated)."
                                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                & " is invalid for user node number "// &
                                & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_GET_NODE_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET_NODE_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_NODE_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_SP

  !
  !================================================================================================================================
  !

   !>Returns from the given parameter set a double precision value for the specified local node, derivative and version of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetNode
 SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_GET_NODE_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                            IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                              & NUMBER_OF_DERIVATIVES) THEN
                              IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                & NUMBER_OF_VERSIONS) THEN
                                dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & VERSIONS(VERSION_NUMBER)
                                CALL DISTRIBUTED_VECTOR_VALUES_GET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                              ELSE
                                LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for derivative number "// &
                                  & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                  & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                  & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                  & "(note version numbers are indexed directly from the value the user specifies during "// &
                                  & "element creation and no record is kept of the total number of versions the user sets."// &
                                  & "The maximum version number the user sets defines the total number of versions allocated)."
                                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                & " is invalid for user node number "// &
                                & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_GET_NODE_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET_NODE_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_NODE_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_DP

  !
  !================================================================================================================================
  !

   !>Returns from the given parameter set a logical value for the specified local node, derivative and version of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetNode
 SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The node number to get the value for
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_GET_NODE_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                          IF(ASSOCIATED(DOMAIN_NODES)) THEN
                            IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                              & NUMBER_OF_DERIVATIVES) THEN
                              IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                & NUMBER_OF_VERSIONS) THEN
                                dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & VERSIONS(VERSION_NUMBER)
                                CALL DISTRIBUTED_VECTOR_VALUES_GET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                              ELSE
                                LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for derivative number "// &
                                  & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                  & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                  & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                  & "(note version numbers are indexed directly from the value the user specifies during "// &
                                  & "element creation and no record is kept of the total number of versions the user sets."// &
                                  & "The maximum version number the user sets defines the total number of versions allocated)."
                                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                & " is invalid for user node number "// &
                                & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL FLAG_ERROR("Domain topology nodes is not associated.",ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_GET_NODE_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET_NODE_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_NODE_L")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_NODE_L

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified local node, derivative and version of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalNode_Intg(field,variableType,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_NODES_TYPE), POINTER :: domainNodes
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetGetLocalNode_Intg",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainNodes=>domainTopology%nodes
                          IF(ASSOCIATED(domainNodes)) THEN
                            IF(localNodeNumber>0.AND.localNodeNumber<=domainNodes%TOTAL_NUMBER_OF_NODES) THEN
                              IF(derivativeNumber>0.AND.derivativeNumber<=domainNodes%nodes(localNodeNumber)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(versionNumber>0.AND.versionNumber<=domainNodes%nodes(localNodeNumber)%derivatives( &
                                  & derivativeNumber)%numberOfVersions) THEN
                                  dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(localNodeNumber)%derivatives(derivativeNumber)% &
                                    & versions(versionNumber)
                                  CALL DISTRIBUTED_VECTOR_VALUES_GET(parameterSet%parameters,dofIdx,value,err,error,*999)
                                ELSE
                                  localError="Version number "//TRIM(NUMBER_TO_VSTRING(versionNumber,"*",err,error))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NUMBER_TO_VSTRING(derivativeNumber,"*",ERR,ERROR))//" of local node number "// &
                                    & TRIM(NUMBER_TO_VSTRING(localNodeNumber,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NUMBER_TO_VSTRING(domainNodes%nodes(localNodeNumber)%derivatives( &
                                    & derivativeNumber)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FLAG_ERROR(localError,err,error,*999)
                                ENDIF
                              ELSE
                                localError="Derivative number "//TRIM(NUMBER_TO_VSTRING(derivativeNumber,"*",ERR,ERROR))// &
                                  & " is invalid for local node number "// &
                                  & TRIM(NUMBER_TO_VSTRING(localNodeNumber,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NUMBER_TO_VSTRING(domainNodes%nodes(localNodeNumber)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              localError="The specified local node number of "// &
                                & TRIM(NUMBER_TO_VSTRING(localNodeNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NUMBER_TO_VSTRING(domainNodes%TOTAL_NUMBER_OF_NODES,"*",ERR,ERROR))//" local nodes."
                              CALL FLAG_ERROR(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FLAG_ERROR("Domain topology nodes is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("Field_ParameterSetGetLocalNode_Intg")
    RETURN
999 CALL ERRORS("Field_ParameterSetGetLocalNode_Intg",ERR,ERROR)
    CALL EXITS("Field_ParameterSetGetLocalNode_Intg")
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalNode_Intg
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified local node, derivative and version of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalNode_Sp(field,variableType,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_NODES_TYPE), POINTER :: domainNodes
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetGetLocalNode_Sp",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainNodes=>domainTopology%nodes
                          IF(ASSOCIATED(domainNodes)) THEN
                            IF(localNodeNumber>0.AND.localNodeNumber<=domainNodes%TOTAL_NUMBER_OF_NODES) THEN
                              IF(derivativeNumber>0.AND.derivativeNumber<=domainNodes%nodes(localNodeNumber)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(versionNumber>0.AND.versionNumber<=domainNodes%nodes(localNodeNumber)%derivatives( &
                                  & derivativeNumber)%numberOfVersions) THEN
                                  dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(localNodeNumber)%derivatives(derivativeNumber)% &
                                    & versions(versionNumber)
                                  CALL DISTRIBUTED_VECTOR_VALUES_GET(parameterSet%parameters,dofIdx,value,err,error,*999)
                                ELSE
                                  localError="Version number "//TRIM(NUMBER_TO_VSTRING(versionNumber,"*",err,error))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NUMBER_TO_VSTRING(derivativeNumber,"*",ERR,ERROR))//" of local node number "// &
                                    & TRIM(NUMBER_TO_VSTRING(localNodeNumber,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NUMBER_TO_VSTRING(domainNodes%nodes(localNodeNumber)%derivatives( &
                                    & derivativeNumber)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FLAG_ERROR(localError,err,error,*999)
                                ENDIF
                              ELSE
                                localError="Derivative number "//TRIM(NUMBER_TO_VSTRING(derivativeNumber,"*",ERR,ERROR))// &
                                  & " is invalid for local node number "// &
                                  & TRIM(NUMBER_TO_VSTRING(localNodeNumber,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NUMBER_TO_VSTRING(domainNodes%nodes(localNodeNumber)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              localError="The specified local node number of "// &
                                & TRIM(NUMBER_TO_VSTRING(localNodeNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NUMBER_TO_VSTRING(domainNodes%TOTAL_NUMBER_OF_NODES,"*",ERR,ERROR))//" local nodes."
                              CALL FLAG_ERROR(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FLAG_ERROR("Domain topology nodes is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("Field_ParameterSetGetLocalNode_Sp")
    RETURN
999 CALL ERRORS("Field_ParameterSetGetLocalNode_Sp",ERR,ERROR)
    CALL EXITS("Field_ParameterSetGetLocalNode_Sp")
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalNode_Sp
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified local node, derivative and version of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalNode_Dp(field,variableType,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_NODES_TYPE), POINTER :: domainNodes
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetGetLocalNode_Dp",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainNodes=>domainTopology%nodes
                          IF(ASSOCIATED(domainNodes)) THEN
                            IF(localNodeNumber>0.AND.localNodeNumber<=domainNodes%TOTAL_NUMBER_OF_NODES) THEN
                              IF(derivativeNumber>0.AND.derivativeNumber<=domainNodes%nodes(localNodeNumber)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(versionNumber>0.AND.versionNumber<=domainNodes%nodes(localNodeNumber)%derivatives( &
                                  & derivativeNumber)%numberOfVersions) THEN
                                  dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(localNodeNumber)%derivatives(derivativeNumber)% &
                                    & versions(versionNumber)
                                  CALL DISTRIBUTED_VECTOR_VALUES_GET(parameterSet%parameters,dofIdx,value,err,error,*999)
                                ELSE
                                  localError="Version number "//TRIM(NUMBER_TO_VSTRING(versionNumber,"*",err,error))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NUMBER_TO_VSTRING(derivativeNumber,"*",ERR,ERROR))//" of local node number "// &
                                    & TRIM(NUMBER_TO_VSTRING(localNodeNumber,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NUMBER_TO_VSTRING(domainNodes%nodes(localNodeNumber)%derivatives( &
                                    & derivativeNumber)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FLAG_ERROR(localError,err,error,*999)
                                ENDIF
                              ELSE
                                localError="Derivative number "//TRIM(NUMBER_TO_VSTRING(derivativeNumber,"*",ERR,ERROR))// &
                                  & " is invalid for local node number "// &
                                  & TRIM(NUMBER_TO_VSTRING(localNodeNumber,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NUMBER_TO_VSTRING(domainNodes%nodes(localNodeNumber)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              localError="The specified local node number of "// &
                                & TRIM(NUMBER_TO_VSTRING(localNodeNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NUMBER_TO_VSTRING(domainNodes%TOTAL_NUMBER_OF_NODES,"*",ERR,ERROR))//" local nodes."
                              CALL FLAG_ERROR(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FLAG_ERROR("Domain topology nodes is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("Field_ParameterSetGetLocalNode_Dp")
    RETURN
999 CALL ERRORS("Field_ParameterSetGetLocalNode_Dp",ERR,ERROR)
    CALL EXITS("Field_ParameterSetGetLocalNode_Dp")
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalNode_Dp
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified local node, derivative and version of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalNode_L(field,variableType,fieldSetType,versionNumber,derivativeNumber,localNodeNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number to get the value for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number to get the value for
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_NODES_TYPE), POINTER :: domainNodes
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetGetLocalNode_L",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainNodes=>domainTopology%nodes
                          IF(ASSOCIATED(domainNodes)) THEN
                            IF(localNodeNumber>0.AND.localNodeNumber<=domainNodes%TOTAL_NUMBER_OF_NODES) THEN
                              IF(derivativeNumber>0.AND.derivativeNumber<=domainNodes%nodes(localNodeNumber)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(versionNumber>0.AND.versionNumber<=domainNodes%nodes(localNodeNumber)%derivatives( &
                                  & derivativeNumber)%numberOfVersions) THEN
                                  dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(localNodeNumber)%derivatives(derivativeNumber)% &
                                    & versions(versionNumber)
                                  CALL DISTRIBUTED_VECTOR_VALUES_GET(parameterSet%parameters,dofIdx,value,err,error,*999)
                                ELSE
                                  localError="Version number "//TRIM(NUMBER_TO_VSTRING(versionNumber,"*",err,error))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NUMBER_TO_VSTRING(derivativeNumber,"*",ERR,ERROR))//" of local node number "// &
                                    & TRIM(NUMBER_TO_VSTRING(localNodeNumber,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NUMBER_TO_VSTRING(domainNodes%nodes(localNodeNumber)%derivatives( &
                                    & derivativeNumber)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FLAG_ERROR(localError,err,error,*999)
                                ENDIF
                              ELSE
                                localError="Derivative number "//TRIM(NUMBER_TO_VSTRING(derivativeNumber,"*",ERR,ERROR))// &
                                  & " is invalid for local node number "// &
                                  & TRIM(NUMBER_TO_VSTRING(localNodeNumber,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NUMBER_TO_VSTRING(domainNodes%nodes(localNodeNumber)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                              ENDIF
                            ELSE
                              localError="The specified local node number of "// &
                                & TRIM(NUMBER_TO_VSTRING(localNodeNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NUMBER_TO_VSTRING(domainNodes%TOTAL_NUMBER_OF_NODES,"*",ERR,ERROR))//" local nodes."
                              CALL FLAG_ERROR(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FLAG_ERROR("Domain topology nodes is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FLAG_ERROR(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("Field_ParameterSetGetLocalNode_L")
    RETURN
999 CALL ERRORS("Field_ParameterSetGetLocalNode_L",ERR,ERROR)
    CALL EXITS("Field_ParameterSetGetLocalNode_L")
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalNode_L

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified local element of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalElement_Intg(field,variableType,fieldSetType,localElementNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: domainElements
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetGetLocalElement_Intg",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainElements=>domainTopology%elements
                          IF(ASSOCIATED(domainElements)) THEN
                            IF(localElementNumber>0.AND.localElementNumber<=domainElements%TOTAL_NUMBER_OF_ELEMENTS) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(localElementNumber)
                              CALL DISTRIBUTED_VECTOR_VALUES_GET(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified local element number of "// &
                                & TRIM(NUMBER_TO_VSTRING(localElementNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NUMBER_TO_VSTRING(domainElements%TOTAL_NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//" local elements."
                              CALL FLAG_ERROR(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FLAG_ERROR("Domain topology elements is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("Field_ParameterSetGetLocalElement_Intg")
    RETURN
999 CALL ERRORS("Field_ParameterSetGetLocalElement_Intg",ERR,ERROR)
    CALL EXITS("Field_ParameterSetGetLocalElement_Intg")
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalElement_Intg

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified local element of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalElement_Sp(field,variableType,fieldSetType,localElementNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(SP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: domainElements
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetGetLocalElement_Sp",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainElements=>domainTopology%elements
                          IF(ASSOCIATED(domainElements)) THEN
                            IF(localElementNumber>0.AND.localElementNumber<=domainElements%TOTAL_NUMBER_OF_ELEMENTS) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(localElementNumber)
                              CALL DISTRIBUTED_VECTOR_VALUES_GET(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified local element number of "// &
                                & TRIM(NUMBER_TO_VSTRING(localElementNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NUMBER_TO_VSTRING(domainElements%TOTAL_NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//" local elements."
                              CALL FLAG_ERROR(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FLAG_ERROR("Domain topology elements is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("Field_ParameterSetGetLocalElement_Sp")
    RETURN
999 CALL ERRORS("Field_ParameterSetGetLocalElement_Sp",ERR,ERROR)
    CALL EXITS("Field_ParameterSetGetLocalElement_Sp")
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalElement_Sp

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified local element of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalElement_Dp(field,variableType,fieldSetType,localElementNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: domainElements
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetGetLocalElement_Dp",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainElements=>domainTopology%elements
                          IF(ASSOCIATED(domainElements)) THEN
                            IF(localElementNumber>0.AND.localElementNumber<=domainElements%TOTAL_NUMBER_OF_ELEMENTS) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(localElementNumber)
                              CALL DISTRIBUTED_VECTOR_VALUES_GET(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified local element number of "// &
                                & TRIM(NUMBER_TO_VSTRING(localElementNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NUMBER_TO_VSTRING(domainElements%TOTAL_NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//" local elements."
                              CALL FLAG_ERROR(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FLAG_ERROR("Domain topology elements is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("Field_ParameterSetGetLocalElement_Dp")
    RETURN
999 CALL ERRORS("Field_ParameterSetGetLocalElement_Dp",ERR,ERROR)
    CALL EXITS("Field_ParameterSetGetLocalElement_Dp")
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalElement_Dp

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified local element of a field
  !>variable component.
 SUBROUTINE Field_ParameterSetGetLocalElement_L(field,variableType,fieldSetType,localElementNumber, &
   & componentNumber,VALUE,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: localElementNumber !<The local element number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to get the value for
    LOGICAL, INTENT(OUT) :: value !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx
    TYPE(DOMAIN_TYPE), POINTER :: domain
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: domainElements
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: domainTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetGetLocalElement_L",ERR,ERROR,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%ptr
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      domain=>fieldVariable%components(componentNumber)%domain
                      IF(ASSOCIATED(domain)) THEN
                        domainTopology=>domain%topology
                        IF(ASSOCIATED(domainTopology)) THEN
                          domainElements=>domainTopology%elements
                          IF(ASSOCIATED(domainElements)) THEN
                            IF(localElementNumber>0.AND.localElementNumber<=domainElements%TOTAL_NUMBER_OF_ELEMENTS) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & ELEMENT_PARAM2DOF_MAP%ELEMENTS(localElementNumber)
                              CALL DISTRIBUTED_VECTOR_VALUES_GET(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified local element number of "// &
                                & TRIM(NUMBER_TO_VSTRING(localElementNumber,"*",ERR,ERROR))// &
                                &  " does not exist in the domain for field component number "// &
                                & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                                & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                                & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                & TRIM(NUMBER_TO_VSTRING(domainElements%TOTAL_NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//" local elements."
                              CALL FLAG_ERROR(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FLAG_ERROR("Domain topology elements is not associated.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Domain topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not get by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(localError,ERR,ERROR,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(localError,ERR,ERROR,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FLAG_ERROR(localError,ERR,ERROR,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(localError,ERR,ERROR,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(localError,ERR,ERROR,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("Field_ParameterSetGetLocalElement_L")
    RETURN
999 CALL ERRORS("Field_ParameterSetGetLocalElement_L",ERR,ERROR)
    CALL EXITS("Field_ParameterSetGetLocalElement_L")
    RETURN 1
  END SUBROUTINE Field_ParameterSetGetLocalElement_L

  !
  !================================================================================================================================
  !

!!\todo The interface here is wrong it should by GAUSS_POINT_NUMBER and then USER_ELEMENT_NUMBER. Should also think about quadrature schemes?
  
 !>Returns from the given parameter set a double precision value for the specified gauss point of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetGaussPoint
  SUBROUTINE FIELD_PARAMETER_SET_GET_GAUSS_POINT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,GAUSS_POINT_NUMBER, &
    & COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the value for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to get the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to get the value for
    INTEGER(INTG), INTENT(IN) :: GAUSS_POINT_NUMBER   !<The gauss point number to get the value for

    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to get the value for
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the value
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_GET_GAUSS_POINT_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not get by gauss point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by gauss point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by gauss point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not get by gauss point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          IF(GAUSS_POINT_NUMBER >= 1 .AND. GAUSS_POINT_NUMBER <= SIZE(FIELD_VARIABLE% & ! TODO: could check for actual # of gp
                            & COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)) THEN
                            dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(GAUSS_POINT_NUMBER,DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                            CALL DISTRIBUTED_VECTOR_VALUES_GET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ELSE
                            LOCAL_ERROR="The specified gauss point number "// &
                              & TRIM(NUMBER_TO_VSTRING(GAUSS_POINT_NUMBER,"*",ERR,ERROR))// &
                              & " is not within the expected range."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_GET_GAUSS_POINT_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_GET_GAUSS_POINT_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_GAUSS_POINT_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_GAUSS_POINT_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular data point of the field variable component.  \see CMISSFieldParameterSetUpdateElementDataPoint
  SUBROUTINE Field_ParameterSetUpdateElementDataPointDP(field,variableType,fieldSetType,userElementNumber,dataPointIndex, &
  & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number the data point is projected on
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The index of the data point projected on the element
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalElementNumber,dataPointLocalNumber,dofIdx
    LOGICAL :: ghostElement,userElementExists
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(DATA_PROJECTION_TYPE), POINTER :: dataProjection
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetUpdateElementDataPointDP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not update by gauss point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has gauss point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          dataProjection=>field%dataProjection
                          IF(ASSOCIATED(dataProjection)) THEN
                            ! Use element topology to check if data point is on current computational node
                            CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(decompositionTopology,userElementNumber, &
                              & userElementExists,decompositionLocalElementNumber,ghostElement,err,error,*999)
                            IF(userElementExists) THEN
                              IF(ghostElement) THEN
                                localError="Cannot update by data point for user element "// &
                                  & TRIM(NUMBER_TO_VSTRING(userElementNumber,"*",err,error))//" as it is a ghost element."
                                CALL FLAG_ERROR(localError,err,error,*999)
                              ELSE
                                dataPointLocalNumber = decompositionTopology%dataPoints% &
                                  & elementDataPoint(decompositionLocalElementNumber)%dataIndices(dataPointIndex)%localNumber
                                IF(dataPointLocalNumber >= 1 .AND. dataPointLocalNumber <= fieldVariable% &
                                  & COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP%DATA_POINT_PARAM2DOF_MAP% &
                                  & NUMBER_OF_DATA_POINT_PARAMETERS) THEN
                                  dofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                                    & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(dataPointLocalNumber)
                                  CALL DISTRIBUTED_VECTOR_VALUES_SET(parameterSet%PARAMETERS,dofIdx,value,err,error,*999)
                                ELSE
                                  localError="The specified data point index "// &
                                    & TRIM(NUMBER_TO_VSTRING(dataPointLocalNumber,"*",err,error))// &
                                    & " is not within the expected range."
                                  CALL FLAG_ERROR(localError,err,error,*999)
                                ENDIF
                              ENDIF
                            ELSE
                              localError="The specified user element number of "// &
                                & TRIM(NUMBER_TO_VSTRING(userElementNumber,"*",err,error))// &
                                & " does not exist in the decomposition for field component number "// &
                                & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of field variable type "// &
                                & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                                & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
                              CALL FLAG_ERROR(localError,err,error,*999)
                            ENDIF
                          ELSE
                            CALL FLAG_ERROR("Data point projection not associated on provided field.",err,error,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FLAG_ERROR(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))
                  CALL FLAG_ERROR(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FLAG_ERROR(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
            CALL FLAG_ERROR(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    ENDIF

    CALL EXITS("Field_ParameterSetUpdateElementDataPointDP")
    RETURN
999 CALL ERRORS("Field_ParameterSetUpdateElementDataPointDP",err,error)
    CALL EXITS("Field_ParameterSetUpdateElementDataPointDP")
    RETURN 1
  END SUBROUTINE Field_ParameterSetUpdateElementDataPointDP

  !
  !================================================================================================================================
  !

  !>Initialises the parameter set for a field.
  SUBROUTINE FIELD_PARAMETER_SET_INITIALISE(FIELD_PARAMETER_SET,ERR,ERROR,*)

   !Argument variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: FIELD_PARAMETER_SET !<The field parameter set to initialise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELD_PARAMETER_SET_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD_PARAMETER_SET)) THEN
      FIELD_PARAMETER_SET%SET_INDEX=0
      FIELD_PARAMETER_SET%SET_TYPE=0
    ELSE
      CALL FLAG_ERROR("Field parameter set is not associated",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_INITIALISE")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_INITIALISE

  !
  !================================================================================================================================
  !

  !>Outputs the parameter set for a field variable.
  SUBROUTINE FIELD_PARAMETER_SET_OUTPUT(ID,FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,ERR,ERROR,*)

   !Argument variables
    INTEGER(INTG), INTENT(IN) :: ID !<The ID of the output stream
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to output the parameter set for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to output the parameter set for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to output
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("FIELD_PARAMETER_SET_OUTPUT",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
              PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
              IF(ASSOCIATED(PARAMETER_SET)) THEN
                CALL DISTRIBUTED_VECTOR_OUTPUT(ID,PARAMETER_SET%PARAMETERS,ERR,ERROR,*999)
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                & " is invalid. The field parameter set type must be between 1 and "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_OUTPUT")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_OUTPUT",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_OUTPUT")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_OUTPUT

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the constant of the field variable component. \see OPENCMISS::CMISSFieldParameterSetUpdateConstant
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    INTEGER, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the constant of the field variable component. \see OPENCMISS::CMISSFieldParameterSetUpdateConstant
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."

                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the constant of the field variable component. \see OPENCMISS::CMISSFieldParameterSetUpdateConstant
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the constant of the field variable component. \see OPENCMISS::CMISSFieldParameterSetUpdateConstant
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      IF(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NUMBER_OF_CONSTANT_PARAMETERS>0) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%CONSTANT_PARAM2DOF_MAP
                        CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " does not have any constant parameters."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by constant for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_CONSTANT_L")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_CONSTANT_L
  
  !
  !================================================================================================================================
  !
  
  !>Update the given parameter set an integer value for the specified data point of a field variable component. \see OPENCMISS::CMISSFieldParameterSetUpdateDataPoint
  SUBROUTINE Field_ParameterSetUpdateDataPointIntg(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to Update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    INTEGER(INTG), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalDataPointNumber,DofIdx
    LOGICAL :: userDataPointExists,ghostDataPoint
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetUpdateDataPointIntg",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          CALL DecompositionTopologyDataPointCheckExists(decompositionTopology,userDataPointNumber, &
                            & userDataPointExists,decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                          IF(userDataPointExists) THEN
                            DofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)       
                            CALL DISTRIBUTED_VECTOR_VALUES_SET(parameterSet%PARAMETERS,DofIdx,value,err,error,*999)
                          ELSE
                            localError="The specified user data point number of "// &
                              & TRIM(NUMBER_TO_VSTRING(userDataPointNumber,"*",ERR,ERROR))// &
                              &  " does not exist in the decomposition for field component number "// &
                              & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                            CALL FLAG_ERROR(localError,err,error,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FLAG_ERROR(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))
                  CALL FLAG_ERROR(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FLAG_ERROR(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
            CALL FLAG_ERROR(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    ENDIF
    
    CALL EXITS("Field_ParameterSetUpdateDataPointIntg")
    RETURN
999 CALL ERRORS("Field_ParameterSetUpdateDataPointIntg",err,error)
    CALL EXITS("Field_ParameterSetUpdateDataPointIntg")
    RETURN 1
  END SUBROUTINE Field_ParameterSetUpdateDataPointIntg
  
  !
  !================================================================================================================================
  !
  
  !>Update the given parameter set a single precision value for the specified data point of a field variable component. \see OPENCMISS::CMISSFieldParameterSetUpdateDataPoint
  SUBROUTINE Field_ParameterSetUpdateDataPointSP(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, & 
      & err,error,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to Update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalDataPointNumber,DofIdx
    LOGICAL :: userDataPointExists,ghostDataPoint
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetUpdateDataPointSP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          CALL DecompositionTopologyDataPointCheckExists(decompositionTopology,userDataPointNumber, &
                            & userDataPointExists,decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                          IF(userDataPointExists) THEN
                            DofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)       
                            CALL DISTRIBUTED_VECTOR_VALUES_SET(parameterSet%PARAMETERS,DofIdx,value,err,error,*999)
                          ELSE
                            localError="The specified user data point number of "// &
                              & TRIM(NUMBER_TO_VSTRING(userDataPointNumber,"*",ERR,ERROR))// &
                              &  " does not exist in the decomposition for field component number "// &
                              & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                            CALL FLAG_ERROR(localError,err,error,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FLAG_ERROR(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))
                  CALL FLAG_ERROR(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FLAG_ERROR(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
            CALL FLAG_ERROR(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    ENDIF
    
    CALL EXITS("Field_ParameterSetUpdateDataPointSP")
    RETURN
999 CALL ERRORS("Field_ParameterSetUpdateDataPointSP",err,error)
    CALL EXITS("Field_ParameterSetUpdateDataPointSP")
    RETURN 1
  END SUBROUTINE Field_ParameterSetUpdateDataPointSP
  
  !
  !================================================================================================================================
  !
  
  !>Update the given parameter set a double precision value for the specified data point of a field variable component. \see OPENCMISS::CMISSFieldParameterSetUpdateDataPoint
  SUBROUTINE Field_ParameterSetUpdateDataPointDP(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to Update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalDataPointNumber,DofIdx
    LOGICAL :: userDataPointExists,ghostDataPoint
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetUpdateDataPointDP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          CALL DecompositionTopologyDataPointCheckExists(decompositionTopology,userDataPointNumber, &
                            & userDataPointExists,decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                          IF(userDataPointExists) THEN
                            DofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)       
                            CALL DISTRIBUTED_VECTOR_VALUES_SET(parameterSet%PARAMETERS,DofIdx,value,err,error,*999)
                          ELSE
                            localError="The specified user data point number of "// &
                              & TRIM(NUMBER_TO_VSTRING(userDataPointNumber,"*",ERR,ERROR))// &
                              &  " does not exist in the decomposition for field component number "// &
                              & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                            CALL FLAG_ERROR(localError,err,error,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FLAG_ERROR(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))
                  CALL FLAG_ERROR(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FLAG_ERROR(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
            CALL FLAG_ERROR(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    ENDIF
    
    CALL EXITS("Field_ParameterSetUpdateDataPointDP")
    RETURN
999 CALL ERRORS("Field_ParameterSetUpdateDataPointDP",err,error)
    CALL EXITS("Field_ParameterSetUpdateDataPointDP")
    RETURN 1
  END SUBROUTINE Field_ParameterSetUpdateDataPointDP
  
  !
  !================================================================================================================================
  !
  
  !>Update the given parameter set a logical value for the specified data point of a field variable component. \see OPENCMISS::CMISSFieldParameterSetUpdateDataPoint
  SUBROUTINE Field_ParameterSetUpdateDataPointL(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
      & err,error,*)
    
    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to Update the value for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to Update the value for \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber !<The data point number to Update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to Update the value for
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: decompositionLocalDataPointNumber,DofIdx
    LOGICAL :: userDataPointExists,ghostDataPoint
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("Field_ParameterSetUpdateDataPointL",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%COMPONENTS(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      localError="Can not Update by data point for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      decomposition=>field%DECOMPOSITION
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%TOPOLOGY
                        IF(ASSOCIATED(decompositionTopology)) THEN
                          CALL DecompositionTopologyDataPointCheckExists(decompositionTopology,userDataPointNumber, &
                            & userDataPointExists,decompositionLocalDataPointNumber,ghostDataPoint,err,error,*999)
                          IF(userDataPointExists) THEN
                            DofIdx=fieldVariable%COMPONENTS(componentNumber)%PARAM_TO_DOF_MAP% &
                              & DATA_POINT_PARAM2DOF_MAP%DATA_POINTS(decompositionLocalDataPointNumber)       
                            CALL DISTRIBUTED_VECTOR_VALUES_SET(parameterSet%PARAMETERS,DofIdx,value,err,error,*999)
                          ELSE
                            localError="The specified user data point number of "// &
                              & TRIM(NUMBER_TO_VSTRING(userDataPointNumber,"*",ERR,ERROR))// &
                              &  " does not exist in the decomposition for field component number "// &
                              & TRIM(NUMBER_TO_VSTRING(componentNumber,"*",ERR,ERROR))//" of field variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(variableType,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",ERR,ERROR))//"."
                            CALL FLAG_ERROR(localError,err,error,*999)
                          ENDIF
                        ELSE
                          CALL FLAG_ERROR("Field decomposition topology is not associated.",err,error,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable% &
                        & COMPONENTS(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
                      CALL FLAG_ERROR(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NUMBER_TO_VSTRING(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FLAG_ERROR(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))
                  CALL FLAG_ERROR(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))
                CALL FLAG_ERROR(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the logical data type of the given value."
              CALL FLAG_ERROR(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))//"."
            CALL FLAG_ERROR(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NUMBER_TO_VSTRING(field%USER_NUMBER,"*",err,error))// &
          & " has not been finished."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",err,error,*999)
    ENDIF
    
    CALL EXITS("Field_ParameterSetUpdateDataPointL")
    RETURN
999 CALL ERRORS("Field_ParameterSetUpdateDataPointL",err,error)
    CALL EXITS("Field_ParameterSetUpdateDataPointL")
    RETURN 1
  END SUBROUTINE Field_ParameterSetUpdateDataPointL

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to update
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
!!TODO: Allow to specify a global number and then have it all update accordingly???
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL) THEN
                    CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NUMBER_TO_VSTRING(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
!!TODO: Allow to specify a global number and then have it all update accordingly???
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL) THEN
                    CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NUMBER_TO_VSTRING(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
!!TODO: Allow to specify a global number and then have it all update accordingly???
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL) THEN
                    CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NUMBER_TO_VSTRING(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DOF_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: DOF_NUMBER !<The dof number to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L",ERR,ERROR,*999)

!!TODO: Allow multiple dof number and values updates.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
!!TODO: Allow to specify a global number and then have it all update accordingly???
                  IF(DOF_NUMBER>0.AND.DOF_NUMBER<=FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL) THEN
                    CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,DOF_NUMBER,VALUE,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The field dof number of "//TRIM(NUMBER_TO_VSTRING(DOF_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. It must be >0 and <="// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & " for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_L

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision values for all local dof of the field variable.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VALUES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    REAL(DP), INTENT(IN) :: VALUES(:) !<The values to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  !\todo: Allow to specify a global number and then have it all update accordingly???
                  IF(SIZE(VALUES)==FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL) THEN
                    !\todo: set the vector values directly without looping
                    DO dof=1,FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL
                      CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,dof,VALUES(dof),ERR,ERROR,*999)
                    ENDDO
                  ELSE
                    LOCAL_ERROR="The size of the parameter vector ("//TRIM(NUMBER_TO_VSTRING(SIZE(VALUES),"*",ERR,ERROR))// &
                      & ") does not match the number of dofs for this field ("// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DOMAIN_MAPPING%NUMBER_OF_LOCAL,"*",ERR,ERROR))// &
                      & ".)"
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_DOF_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular user element of the field variable component. \see CMISSFieldParameterSetUpdateElement
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          IF(GHOST_ELEMENT) THEN
                            LOCAL_ERROR="Cannot update by element for user element "// &
                              & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))//" as it is a ghost element."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                            CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &

                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular user element of the field variable component.  \see CMISSFieldParameterSetUpdateElement
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          IF(GHOST_ELEMENT) THEN
                            LOCAL_ERROR="Cannot update by element for user element "// &
                              & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))//" as it is a ghost element."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                            CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular user element of the field variable component.  \see CMISSFieldParameterSetUpdateElement
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          IF(GHOST_ELEMENT) THEN
                            LOCAL_ERROR="Cannot update by element for user element "// &
                              & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))//" as it is a ghost element."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                            CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular user element of the field variable component. \see CMISSFieldParameterSetUpdateElement
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,USER_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER,dof_idx
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      DECOMPOSITION=>FIELD%DECOMPOSITION
                      IF(ASSOCIATED(DECOMPOSITION)) THEN
                        DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                          & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                        IF(USER_ELEMENT_EXISTS) THEN
                          IF(GHOST_ELEMENT) THEN
                            LOCAL_ERROR="Cannot update by element for user element "// &
                              & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))//" as it is a ghost element."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                              & ELEMENT_PARAM2DOF_MAP%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)
                            CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user element number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_ELEMENT_L")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_ELEMENT_L

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER, &
    & COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      IF(LOCAL_ELEMENT_NUMBER>0.AND.LOCAL_ELEMENT_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS( &
                          & LOCAL_ELEMENT_NUMBER)
                        CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Local element number "//TRIM(NUMBER_TO_VSTRING(LOCAL_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                          & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" elements."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."

                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      IF(LOCAL_ELEMENT_NUMBER>0.AND.LOCAL_ELEMENT_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS( &
                          & LOCAL_ELEMENT_NUMBER)
                        CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Local element number "//TRIM(NUMBER_TO_VSTRING(LOCAL_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                          & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" elements."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      IF(LOCAL_ELEMENT_NUMBER>0.AND.LOCAL_ELEMENT_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS( &
                          & LOCAL_ELEMENT_NUMBER)
                        CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Local element number "//TRIM(NUMBER_TO_VSTRING(LOCAL_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                          & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" elements."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular local element of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,LOCAL_ELEMENT_NUMBER,COMPONENT_NUMBER, &
    & VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: LOCAL_ELEMENT_NUMBER !<The local element number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: ny
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      IF(LOCAL_ELEMENT_NUMBER>0.AND.LOCAL_ELEMENT_NUMBER<=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                        & PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%NUMBER_OF_ELEMENT_PARAMETERS) THEN
                        ny=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%ELEMENT_PARAM2DOF_MAP%ELEMENTS( &
                          & LOCAL_ELEMENT_NUMBER)
                        CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,ny,VALUE,ERR,ERROR,*999)
                      ELSE
                        LOCAL_ERROR="Local element number "//TRIM(NUMBER_TO_VSTRING(LOCAL_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)% &
                          & PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" elements."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has node based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_ELEMENT_L

  !
  !================================================================================================================================
  !

  !>Finishes the parameter set update for a field variable. \see OPENCMISS::CMISSFieldParameterSetUpdateFinish
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_FINISH(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,ERR,ERROR,*)

     !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to finish the update for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_FINISH",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
              PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
              IF(ASSOCIATED(PARAMETER_SET)) THEN
                CALL DISTRIBUTED_VECTOR_UPDATE_FINISH(PARAMETER_SET%PARAMETERS,ERR,ERROR,*999)
                IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE.AND.FIELD_SET_TYPE==FIELD_VALUES_SET_TYPE) THEN
                  !Geometric field values have changed so update the geometric parameters (e.g., lines etc.)
                  CALL FIELD_GEOMETRIC_PARAMETERS_CALCULATE(FIELD,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                & " is invalid. The field parameter set type must be between 1 and "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_FINISH")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_FINISH",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_FINISH")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_FINISH

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular user node, derivative and version of the field variable component. \see OPENCMISS::CMISSFieldParameterSetUpdateNode
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_NODE_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                            IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          IF(GHOST_NODE) THEN
                            LOCAL_ERROR="Cannot update by node for user node "// &
                              & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" as it is a ghost node."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(DOMAIN_NODES)) THEN
                              IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                  & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & NUMBER_OF_VERSIONS) THEN
                                  dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                    & VERSIONS(VERSION_NUMBER)
                                  CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                                ELSE
                                  LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                    & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                    & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for user node number "// &
                                  & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_NODE_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_NODE_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_NODE_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular user node, derivative and version of the field variable component. \see OPENCMISS::CMISSFieldParameterSetUpdateNode
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_NODE_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                            IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          IF(GHOST_NODE) THEN
                            LOCAL_ERROR="Cannot update by node for user node "// &
                              & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" as it is a ghost node."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(DOMAIN_NODES)) THEN
                              IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                  & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & NUMBER_OF_VERSIONS) THEN
                                  dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                    & VERSIONS(VERSION_NUMBER)
                                  CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                                ELSE
                                  LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                    & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                    & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for user node number "// &
                                  & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_NODE_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_NODE_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_NODE_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular user node, derivative and version of the field variable component. \see OPENCMISS::CMISSFieldParameterSetUpdateNode
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_NODE_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                            IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          IF(GHOST_NODE) THEN
                            LOCAL_ERROR="Cannot update by node for user node "// &
                              & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" as it is a ghost node."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(DOMAIN_NODES)) THEN
                              IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                  & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & NUMBER_OF_VERSIONS) THEN
                                  dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                    & VERSIONS(VERSION_NUMBER)
                                  CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                                ELSE
                                  LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                    & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                    & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for user node number "// &
                                  & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_NODE_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_NODE_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_NODE_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular user node, derivative and version of the field variable component. \see OPENCMISS::CMISSFieldParameterSetUpdateNode
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & USER_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: USER_NODE_NUMBER !<The user node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: DOMAIN_LOCAL_NODE_NUMBER,dof_idx
    LOGICAL :: GHOST_NODE,USER_NODE_EXISTS
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DOMAIN_TOPOLOGY
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_NODE_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      DOMAIN=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%DOMAIN
                      IF(ASSOCIATED(DOMAIN)) THEN
                        DOMAIN_TOPOLOGY=>DOMAIN%TOPOLOGY
                        CALL DOMAIN_TOPOLOGY_NODE_CHECK_EXISTS(DOMAIN_TOPOLOGY,USER_NODE_NUMBER,USER_NODE_EXISTS, &
                          & DOMAIN_LOCAL_NODE_NUMBER,GHOST_NODE,ERR,ERROR,*999)
                        IF(USER_NODE_EXISTS) THEN
                          IF(GHOST_NODE) THEN
                            LOCAL_ERROR="Cannot update by node for user node "// &
                              & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" as it is a ghost node."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ELSE
                            DOMAIN_NODES=>DOMAIN_TOPOLOGY%NODES
                            IF(ASSOCIATED(DOMAIN_NODES)) THEN
                              IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                & NUMBER_OF_DERIVATIVES) THEN
                                IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                                  & FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                  & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                  & NUMBER_OF_VERSIONS) THEN
                                  dof_idx=FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP% &
                                    & NODE_PARAM2DOF_MAP%NODES(DOMAIN_LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                                    & VERSIONS(VERSION_NUMBER)
                                  CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                                ELSE
                                  LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                                    & " is invalid for derivative number "// &
                                    & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                                    & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                    & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                    & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                    & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                                    & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                    & DERIVATIVES(DERIVATIVE_NUMBER)%numberOfVersions,"*",ERR,ERROR))//" versions "// &
                                    & "(note version numbers are indexed directly from the value the user specifies during "// &
                                    & "element creation and no record is kept of the total number of versions the user sets."// &
                                    & "The maximum version number the user sets defines the total number of versions allocated)."
                                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ELSE
                                LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                                  & " is invalid for user node number "// &
                                  & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                                  & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                                  & TRIM(NUMBER_TO_VSTRING(DOMAIN_NODES%NODES(DOMAIN_LOCAL_NODE_NUMBER)% &
                                  & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                              ENDIF
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The specified user node number of "// &
                            & TRIM(NUMBER_TO_VSTRING(USER_NODE_NUMBER,"*",ERR,ERROR))// &
                            &  " does not exist in the domain for field component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of field variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("Domain is not associated.",ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not add element for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_NODE_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_NODE_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_NODE_L")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_NODE_L

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    INTEGER(INTG), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: FIELD_NODES
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      FIELD_NODES=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP
                      IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=FIELD_NODES%NUMBER_OF_NODE_PARAMETERS) THEN
                        IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                            & FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS) THEN
                            dof_idx=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                              & VERSIONS(VERSION_NUMBER)
                            CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ELSE
                            LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                              & TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                              & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                              & TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                              & DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS,"*",ERR,ERROR))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid for user node number "// &
                            & TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                            & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Local node number "//TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" nodes."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the integer data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_INTG

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(SP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: FIELD_NODES
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      FIELD_NODES=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP
                      IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=FIELD_NODES%NUMBER_OF_NODE_PARAMETERS) THEN
                        IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                            & FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS) THEN
                            dof_idx=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                              & VERSIONS(VERSION_NUMBER)
                            CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ELSE
                            LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                              & TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                              & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                              & TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                              & DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS,"*",ERR,ERROR))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid for user node number "// &
                            & TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                            & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Local node number "//TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" nodes."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_SP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    REAL(DP), INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: FIELD_NODES
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      FIELD_NODES=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP
                      IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=FIELD_NODES%NUMBER_OF_NODE_PARAMETERS) THEN
                        IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                            & FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS) THEN
                            dof_idx=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                              & VERSIONS(VERSION_NUMBER)
                            CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ELSE
                            LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                              & TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                              & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                              & TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                              & DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS,"*",ERR,ERROR))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid for user node number "// &
                            & TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                            & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Local node number "//TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" nodes."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_DP

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for a particular local node, derivative and version of the field variable component.
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,VERSION_NUMBER,DERIVATIVE_NUMBER, &
    & LOCAL_NODE_NUMBER,COMPONENT_NUMBER,VALUE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to finish the update for \see FIELD_ROUTINES_ParameterSetTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: VERSION_NUMBER !<The node derivative version number to add
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The node derivative number to update
    INTEGER(INTG), INTENT(IN) :: LOCAL_NODE_NUMBER !<The local node number to update
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER !<The field variable component number to update
    LOGICAL, INTENT(IN) :: VALUE !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: dof_idx
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: FIELD_NODES
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            IF(FIELD_VARIABLE%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  IF(COMPONENT_NUMBER>=1.AND.COMPONENT_NUMBER<=FIELD_VARIABLE%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has constant interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has element based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      FIELD_NODES=>FIELD_VARIABLE%COMPONENTS(COMPONENT_NUMBER)%PARAM_TO_DOF_MAP%NODE_PARAM2DOF_MAP
                      IF(LOCAL_NODE_NUMBER>0.AND.LOCAL_NODE_NUMBER<=FIELD_NODES%NUMBER_OF_NODE_PARAMETERS) THEN
                        IF(DERIVATIVE_NUMBER>0.AND.DERIVATIVE_NUMBER<=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                          & NUMBER_OF_DERIVATIVES) THEN
                          IF(VERSION_NUMBER>0.AND.VERSION_NUMBER<= &
                            & FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS) THEN
                            dof_idx=FIELD_NODES%NODES(LOCAL_NODE_NUMBER)%DERIVATIVES(DERIVATIVE_NUMBER)% &
                              & VERSIONS(VERSION_NUMBER)
                            CALL DISTRIBUTED_VECTOR_VALUES_SET(PARAMETER_SET%PARAMETERS,dof_idx,VALUE,ERR,ERROR,*999)
                          ELSE
                            LOCAL_ERROR="Version number "//TRIM(NUMBER_TO_VSTRING(VERSION_NUMBER,"*",ERR,ERROR))// &
                              & " is invalid for derivative number "// &
                              & TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))//" of node number "// &
                              & TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                              & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                              & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has a maximum of "// &
                              & TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                              & DERIVATIVES(DERIVATIVE_NUMBER)%NUMBER_OF_VERSIONS,"*",ERR,ERROR))//" versions "// &
                              & "(note version numbers are indexed directly from the value the user specifies during "// &
                              & "element creation and no record is kept of the total number of versions the user sets."// &
                              & "The maximum version number the user sets defines the total number of versions allocated)."
                            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Derivative number "//TRIM(NUMBER_TO_VSTRING(DERIVATIVE_NUMBER,"*",ERR,ERROR))// &
                            & " is invalid for user node number "// &
                            & TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))//" of component number "// &
                            & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NODES(LOCAL_NODE_NUMBER)% &
                            & NUMBER_OF_DERIVATIVES,"*",ERR,ERROR))//" derivatives."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Local node number "//TRIM(NUMBER_TO_VSTRING(LOCAL_NODE_NUMBER,"*",ERR,ERROR))// &
                          & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                          & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                          & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD_NODES%NUMBER_OF_NODE_PARAMETERS,"*",ERR,ERROR))//" nodes."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has grid point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has Gauss point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      LOCAL_ERROR="Can not update by node for component number "// &
                        & TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))//" of variable type "// &
                        & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                        & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has data point based interpolation."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    CASE DEFAULT
                      LOCAL_ERROR="The field component interpolation type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE% &
                        & COMPONENTS(COMPONENT_NUMBER)%INTERPOLATION_TYPE,"*",ERR,ERROR))// &
                        & " is invalid for component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                        & " of variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                        & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    END SELECT
                  ELSE
                    LOCAL_ERROR="Component number "//TRIM(NUMBER_TO_VSTRING(COMPONENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid for variable type "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                      & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))// &
                      & " components."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                & " does not correspond to the logical data type of the given value."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and  "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_LOCAL_NODE_L

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given integer value for a particular gauss point of the field variable component.  \see CMISSFieldParameterSetUpdateGaussPoint
  SUBROUTINE FieldParameterSetUpdateGaussPointIntg(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    INTEGER, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx,localElementNumber
    LOGICAL :: ghostElement,userElementExists
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL Enters("FieldParameterSetUpdateGaussPointDP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_INTG_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      decomposition=>field%decomposition
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%topology
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(decompositionTopology,userElementNumber, &
                          & userElementExists,localElementNumber,ghostElement,err,error,*999)
                        IF(userElementExists) THEN
                          IF(ghostElement) THEN
                            localError="Cannot update by Gauss point for user element "// &
                              & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
                            CALL FlagError(localError,err,error,*999)
                          ELSE
                            ! TODO: could check for actual # of gp
                            IF(gaussPointNumber>=1.AND.gaussPointNumber<= SIZE(fieldVariable% &
                              & components(componentNumber)%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gaussPointNumber,localElementNumber)
                              CALL DISTRIBUTED_VECTOR_VALUES_SET(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified Gauss point number "// &
                                & TRIM(NumberToVString(gaussPointNumber,"*",err,error))// &
                                & " is not within the expected range."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          localError="The specified user element number of "// &
                            & TRIM(NumberToVString(userElementNumber,"*",err,error))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field variable type "// &
                            & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                            & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has data point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the integer data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    CALL Exits("FieldParameterSetUpdateGaussPointIntg")
    RETURN
999 CALL Errors("FieldParameterSetUpdateGaussPointIntg",err,error)
    CALL Exits("FieldParameterSetUpdateGaussPointIntg")
    RETURN 1
    
  END SUBROUTINE FieldParameterSetUpdateGaussPointIntg

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given single precision value for a particular gauss point of the field variable component.  \see CMISSFieldParameterSetUpdateGaussPoint
  SUBROUTINE FieldParameterSetUpdateGaussPointSP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(SP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx,localElementNumber
    LOGICAL :: ghostElement,userElementExists
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL Enters("FieldParameterSetUpdateGaussPointSP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_SP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      decomposition=>field%decomposition
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%topology
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(decompositionTopology,userElementNumber, &
                          & userElementExists,localElementNumber,ghostElement,err,error,*999)
                        IF(userElementExists) THEN
                          IF(ghostElement) THEN
                            localError="Cannot update by Gauss point for user element "// &
                              & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
                            CALL FlagError(localError,err,error,*999)
                          ELSE
                            ! TODO: could check for actual # of gp
                            IF(gaussPointNumber>=1.AND.gaussPointNumber<= SIZE(fieldVariable% &
                              & components(componentNumber)%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gaussPointNumber,localElementNumber)
                              CALL DISTRIBUTED_VECTOR_VALUES_SET(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified Gauss point number "// &
                                & TRIM(NumberToVString(gaussPointNumber,"*",err,error))// &
                                & " is not within the expected range."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          localError="The specified user element number of "// &
                            & TRIM(NumberToVString(userElementNumber,"*",err,error))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field variable type "// &
                            & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                            & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has data point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the single precision data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    CALL Exits("FieldParameterSetUpdateGaussPointSP")
    RETURN
999 CALL Errors("FieldParameterSetUpdateGaussPointSP",err,error)
    CALL Exits("FieldParameterSetUpdateGaussPointSP")
    RETURN 1
    
  END SUBROUTINE FieldParameterSetUpdateGaussPointSP

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given double precision value for a particular gauss point of the field variable component.  \see CMISSFieldParameterSetUpdateGaussPoint
  SUBROUTINE FieldParameterSetUpdateGaussPointDP(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    REAL(DP), INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx,localElementNumber
    LOGICAL :: ghostElement,userElementExists
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL Enters("FieldParameterSetUpdateGaussPointDP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_DP_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      decomposition=>field%decomposition
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%topology
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(decompositionTopology,userElementNumber, &
                          & userElementExists,localElementNumber,ghostElement,err,error,*999)
                        IF(userElementExists) THEN
                          IF(ghostElement) THEN
                            localError="Cannot update by Gauss point for user element "// &
                              & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
                            CALL FlagError(localError,err,error,*999)
                          ELSE
                            ! TODO: could check for actual # of gp
                            IF(gaussPointNumber>=1.AND.gaussPointNumber<= SIZE(fieldVariable% &
                              & components(componentNumber)%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gaussPointNumber,localElementNumber)
                              CALL DISTRIBUTED_VECTOR_VALUES_SET(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified Gauss point number "// &
                                & TRIM(NumberToVString(gaussPointNumber,"*",err,error))// &
                                & " is not within the expected range."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          localError="The specified user element number of "// &
                            & TRIM(NumberToVString(userElementNumber,"*",err,error))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field variable type "// &
                            & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                            & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has data point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the double precision data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    CALL Exits("FieldParameterSetUpdateGaussPointDP")
    RETURN
999 CALL Errors("FieldParameterSetUpdateGaussPointDP",err,error)
    CALL Exits("FieldParameterSetUpdateGaussPointDP")
    RETURN 1
    
  END SUBROUTINE FieldParameterSetUpdateGaussPointDP

  !
  !================================================================================================================================
  !

!!\todo Should also think about quadrature schemes?

  !>Updates the given parameter set with the given logical value for a particular gauss point of the field variable component.  \see CMISSFieldParameterSetUpdateGaussPoint
  SUBROUTINE FieldParameterSetUpdateGaussPointL(field,variableType,fieldSetType,gaussPointNumber,userElementNumber, &
    & componentNumber,value,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to update
    INTEGER(INTG), INTENT(IN) :: variableType!<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The field parameter set identifier
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number to update
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The element number to update
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component to update
    LOGICAL, INTENT(IN) :: value !<The value to update to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: dofIdx,localElementNumber
    LOGICAL :: ghostElement,userElementExists
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: decompositionTopology
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: parameterSet
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: fieldVariable
    TYPE(VARYING_STRING) :: localError

    CALL Enters("FieldParameterSetUpdateGaussPointDP",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(field%FIELD_FINISHED) THEN
        IF(variableType>=1.AND.variableType<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          fieldVariable=>field%VARIABLE_TYPE_MAP(variableType)%PTR
          IF(ASSOCIATED(fieldVariable)) THEN
            IF(fieldVariable%DATA_TYPE==FIELD_L_TYPE) THEN
              IF(fieldSetType>0.AND.fieldSetType<=FIELD_NUMBER_OF_SET_TYPES) THEN
                parameterSet=>fieldVariable%PARAMETER_SETS%SET_TYPE(fieldSetType)%PTR
                IF(ASSOCIATED(parameterSet)) THEN
                  IF(componentNumber>=1.AND.componentNumber<=fieldVariable%NUMBER_OF_COMPONENTS) THEN
                    SELECT CASE(fieldVariable%components(componentNumber)%INTERPOLATION_TYPE)
                    CASE(FIELD_CONSTANT_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has constant interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_ELEMENT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has element based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_NODE_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has node based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GRID_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(FIELD%USER_NUMBER,"*",err,error))//" which has grid point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE(FIELD_GAUSS_POINT_BASED_INTERPOLATION)
                      decomposition=>field%decomposition
                      IF(ASSOCIATED(decomposition)) THEN
                        decompositionTopology=>decomposition%topology
                        CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(decompositionTopology,userElementNumber, &
                          & userElementExists,localElementNumber,ghostElement,err,error,*999)
                        IF(userElementExists) THEN
                          IF(ghostElement) THEN
                            localError="Cannot update by Gauss point for user element "// &
                              & TRIM(NumberToVString(userElementNumber,"*",err,error))//" as it is a ghost element."
                            CALL FlagError(localError,err,error,*999)
                          ELSE
                            ! TODO: could check for actual # of gp
                            IF(gaussPointNumber>=1.AND.gaussPointNumber<= SIZE(fieldVariable% &
                              & components(componentNumber)%PARAM_TO_DOF_MAP%GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS,1)) THEN
                              dofIdx=fieldVariable%components(componentNumber)%PARAM_TO_DOF_MAP% &
                                & GAUSS_POINT_PARAM2DOF_MAP%GAUSS_POINTS(gaussPointNumber,localElementNumber)
                              CALL DISTRIBUTED_VECTOR_VALUES_SET(parameterSet%parameters,dofIdx,value,err,error,*999)
                            ELSE
                              localError="The specified Gauss point number "// &
                                & TRIM(NumberToVString(gaussPointNumber,"*",err,error))// &
                                & " is not within the expected range."
                              CALL FlagError(localError,err,error,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          localError="The specified user element number of "// &
                            & TRIM(NumberToVString(userElementNumber,"*",err,error))// &
                            & " does not exist in the decomposition for field component number "// &
                            & TRIM(NumberToVString(componentNumber,"*",err,error))//" of field variable type "// &
                            & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                            & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                          CALL FlagError(localError,err,error,*999)
                        ENDIF
                      ELSE
                        CALL FlagError("Field decomposition is not associated.",err,error,*999)
                      ENDIF
                    CASE(FIELD_DATA_POINT_BASED_INTERPOLATION)
                      localError="Can not update by Gauss point for component number "// &
                        & TRIM(NumberToVString(componentNumber,"*",err,error))//" of variable type "// &
                        & TRIM(NumberToVString(variableType,"*",err,error))//" of field number "// &
                        & TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has data point based interpolation."
                      CALL FlagError(localError,err,error,*999)
                    CASE DEFAULT
                      localError="The field component interpolation type of "//TRIM(NumberToVString(fieldVariable% &
                        & components(componentNumber)%INTERPOLATION_TYPE,"*",err,error))// &
                        & " is invalid for component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                        & " of variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                        & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
                      CALL FlagError(localError,err,error,*999)
                    END SELECT
                  ELSE
                    localError="Component number "//TRIM(NumberToVString(componentNumber,"*",err,error))// &
                      & " is invalid for variable type "//TRIM(NumberToVString(variableType,"*",err,error))// &
                      & " of field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" which has "// &
                      & TRIM(NumberToVString(fieldVariable%NUMBER_OF_COMPONENTS,"*",err,error))//" components."
                    CALL FlagError(localError,err,error,*999)
                  ENDIF
                ELSE
                  localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                    & " has not been created on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))
                  CALL FlagError(localError,err,error,*999)
                ENDIF
              ELSE
                localError="The field parameter set type of "//TRIM(NumberToVString(fieldSetType,"*",err,error))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NumberToVString(FIELD_NUMBER_OF_SET_TYPES,"*",err,error))//"."
                CALL FlagError(localError,err,error,*999)
              ENDIF
            ELSE
              localError="The field variable data type of "//TRIM(NumberToVString(fieldVariable%DATA_TYPE,"*",err,error))// &
                & " does not correspond to the logical data type of the given value."
              CALL FlagError(localError,err,error,*999)
            ENDIF
          ELSE
            localError="The specified field variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
              & " has not been defined on field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="The specified variable type of "//TRIM(NumberToVString(variableType,"*",err,error))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NumberToVString(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",err,error))//"."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        localError="Field number "//TRIM(NumberToVString(field%USER_NUMBER,"*",err,error))//" has not been finished."
        CALL FlagError(localError,err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    CALL Exits("FieldParameterSetUpdateGaussPointL")
    RETURN
999 CALL Errors("FieldParameterSetUpdateGaussPointL",err,error)
    CALL Exits("FieldParameterSetUpdateGaussPointL")
    RETURN 1
    
  END SUBROUTINE FieldParameterSetUpdateGaussPointL

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative and returns double precision values. \see OPENCMISS::CMISSFieldParameterSetInterpolateXI
  SUBROUTINE FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_XI_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DERIVATIVE_NUMBER, &
    & USER_ELEMENT_NUMBER,XI,VALUES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to interpolate. \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier.
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to interpolate.
    REAL(DP), INTENT(IN) :: XI(:) !<The set of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: VALUES(:) !<On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string.
    !Local Variables
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATED_PARAMETERS(:)
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINT(:)
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    INTEGER(INTG) :: numberOfComponents
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_XI_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        DECOMPOSITION=>FIELD%DECOMPOSITION
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  DOMAIN_ELEMENTS=>FIELD_VARIABLE%COMPONENTS(DECOMPOSITION%MESH_COMPONENT_NUMBER)%DOMAIN%TOPOLOGY%ELEMENTS
                  IF(USER_ELEMENT_NUMBER>0.AND.USER_ELEMENT_NUMBER<=DOMAIN_ELEMENTS%NUMBER_OF_ELEMENTS) THEN
                    CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(FIELD,INTERPOLATED_PARAMETERS,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATED_PARAMETERS,INTERPOLATED_POINT,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,USER_ELEMENT_NUMBER, &
                      & INTERPOLATED_PARAMETERS(VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                    CALL FIELD_NUMBER_OF_COMPONENTS_GET(FIELD,VARIABLE_TYPE,numberOfComponents,ERR,ERROR,*999)
                    IF(SIZE(VALUES)==numberOfComponents) THEN
                      IF(SIZE(XI)==DOMAIN_ELEMENTS%ELEMENTS(USER_ELEMENT_NUMBER)%BASIS%NUMBER_OF_XI) THEN
                        CALL FIELD_INTERPOLATE_XI(DERIVATIVE_NUMBER,XI(:),INTERPOLATED_POINT(VARIABLE_TYPE)%PTR, &
                          & ERR,ERROR,*999)
                        VALUES(1:numberOfComponents)=INTERPOLATED_POINT(VARIABLE_TYPE)%PTR% &
                          & VALUES(1:numberOfComponents,DERIVATIVE_NUMBER)
                      ELSE
                        LOCAL_ERROR="The specified xi to interpolate the field at are invalid. "// &
                          & "The supplied size is "// &
                          & TRIM(NUMBER_TO_VSTRING(SIZE(XI),"*",ERR,ERROR))//" and should be "// &
                          & TRIM(NUMBER_TO_VSTRING(DOMAIN_ELEMENTS%ELEMENTS(USER_ELEMENT_NUMBER)%BASIS%NUMBER_OF_XI,"*", &
                          & ERR,ERROR))//" for this field."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      LOCAL_ERROR="The number of the coordinate values to return the interpolated field to is invalid. "// &
                        & "The supplied size is "//TRIM(NUMBER_TO_VSTRING(SIZE(VALUES),"*",ERR,ERROR))//" and should be "// &
                        & TRIM(NUMBER_TO_VSTRING(numberOfComponents,"*", &
                        & ERR,ERROR))//" for this field."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                    !Finalise the interpolated point and parameters
                    CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATED_PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The specified element number of "//TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. The element number must be between 1 and "// &
                      & TRIM(NUMBER_TO_VSTRING(DOMAIN_ELEMENTS%NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " does not correspond to the double precision data type of the given value."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and  "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
            CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_XI_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_XI_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_XI_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_XI_DP

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of xi locations for the specified element and derviative and returns double precision values. \see OPENCMISS::CMISSFieldParameterSetInterpolateXI
  SUBROUTINE FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_XI_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DERIVATIVE_NUMBER, &
    & USER_ELEMENT_NUMBER,XI,VALUES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to interpolate. \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier.
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to interpolate.
    REAL(DP), INTENT(IN) :: XI(:,:) !<The sets of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: VALUES(:,:) !<On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string.
    !Local Variables
    INTEGER(INTG) :: xi_set
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATED_PARAMETERS(:)
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINT(:)
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    INTEGER(INTG) :: numberOfComponents
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_XI_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        DECOMPOSITION=>FIELD%DECOMPOSITION
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  DOMAIN_ELEMENTS=>FIELD_VARIABLE%COMPONENTS(DECOMPOSITION%MESH_COMPONENT_NUMBER)%DOMAIN%TOPOLOGY%ELEMENTS
                  IF(USER_ELEMENT_NUMBER>0.AND.USER_ELEMENT_NUMBER<=DOMAIN_ELEMENTS%NUMBER_OF_ELEMENTS) THEN
                    CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(FIELD,INTERPOLATED_PARAMETERS,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATED_PARAMETERS,INTERPOLATED_POINT,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,USER_ELEMENT_NUMBER, &
                      & INTERPOLATED_PARAMETERS(VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                    CALL FIELD_NUMBER_OF_COMPONENTS_GET(FIELD,VARIABLE_TYPE,numberOfComponents,ERR,ERROR,*999)
                    IF(SIZE(VALUES,1)==numberOfComponents) THEN
                      IF(SIZE(XI,1)==DOMAIN_ELEMENTS%ELEMENTS(USER_ELEMENT_NUMBER)%BASIS%NUMBER_OF_XI) THEN
                        IF(SIZE(VALUES,2)==SIZE(XI,2)) THEN
                          DO xi_set=1,SIZE(XI,2)
                            CALL FIELD_INTERPOLATE_XI(DERIVATIVE_NUMBER,XI(:,xi_set),INTERPOLATED_POINT(VARIABLE_TYPE)%PTR, &
                              & ERR,ERROR,*999)
                            VALUES(1:numberOfComponents,xi_set)=INTERPOLATED_POINT(VARIABLE_TYPE)%PTR% &
                              & VALUES(1:numberOfComponents,DERIVATIVE_NUMBER)
                          ENDDO
                        ELSE
                          LOCAL_ERROR="The number of xi sets in the field interpolated values output array is "// &
                            & "not the same as the number to be interpolated."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="The specified xi values to interpolate the field at are invalid. "// &
                          & "The supplied size is "// &
                          & TRIM(NUMBER_TO_VSTRING(SIZE(XI,1),"*",ERR,ERROR))//" and should be "// &
                          & TRIM(NUMBER_TO_VSTRING(DOMAIN_ELEMENTS%ELEMENTS(USER_ELEMENT_NUMBER)%BASIS%NUMBER_OF_XI,"*", &
                          & ERR,ERROR))//" for this field."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      LOCAL_ERROR="The number of the coordinate values to return the interpolated field to is invalid. "// &
                        & "The supplied size is "//TRIM(NUMBER_TO_VSTRING(SIZE(VALUES,1),"*",ERR,ERROR))//" and should be "// &
                        & TRIM(NUMBER_TO_VSTRING(numberOfComponents,"*",ERR,ERROR))//" for this field."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ENDIF
                    !Finalise the interpolated point and parameters
                    CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATED_PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The specified element number of "//TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. The element number must be between 1 and "// &
                      & TRIM(NUMBER_TO_VSTRING(DOMAIN_ELEMENTS%NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " does not correspond to the double precision data type of the given value."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and  "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
            CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_XI_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_XI_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_XI_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_XI_DP

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified Gauss point for the specified element and derviative and returns double precision values. \see OPENCMISS::CMISSFieldParameterSetInterpolateGauss
  SUBROUTINE FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_GAUSS_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DERIVATIVE_NUMBER, &
    & USER_ELEMENT_NUMBER,SCHEME,GAUSS_POINT,VALUES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to interpolate. \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier.
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to interpolate.
    INTEGER(INTG), INTENT(IN) :: SCHEME !<The quadrature scheme to interpolate the field for.
    INTEGER(INTG), INTENT(IN) :: GAUSS_POINT !<The Gauss point to interpolate the field at.
    REAL(DP), INTENT(OUT) :: VALUES(:) !<On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string.
    !Local Variables
    TYPE(QUADRATURE_SCHEME_TYPE), POINTER :: QUADRATURE_SCHEME
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATED_PARAMETERS(:)
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINT(:)
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    INTEGER(INTG) :: numberOfComponents
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_GAUSS_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        DECOMPOSITION=>FIELD%DECOMPOSITION
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  DOMAIN_ELEMENTS=>FIELD_VARIABLE%COMPONENTS(DECOMPOSITION%MESH_COMPONENT_NUMBER)%DOMAIN%TOPOLOGY%ELEMENTS
                  IF(USER_ELEMENT_NUMBER>0.AND.USER_ELEMENT_NUMBER<=DOMAIN_ELEMENTS%NUMBER_OF_ELEMENTS) THEN
                    CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(FIELD,INTERPOLATED_PARAMETERS,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATED_PARAMETERS,INTERPOLATED_POINT,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,USER_ELEMENT_NUMBER, &
                      & INTERPOLATED_PARAMETERS(VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                    CALL FIELD_NUMBER_OF_COMPONENTS_GET(FIELD,VARIABLE_TYPE,numberOfComponents,ERR,ERROR,*999)
                    QUADRATURE_SCHEME=>DOMAIN_ELEMENTS%ELEMENTS(USER_ELEMENT_NUMBER)%BASIS%QUADRATURE% &
                      & QUADRATURE_SCHEME_MAP(SCHEME)%PTR
                    IF(ASSOCIATED(QUADRATURE_SCHEME)) THEN
                      IF(SIZE(VALUES)==numberOfComponents) THEN
                        IF(GAUSS_POINT>0.AND.GAUSS_POINT<=QUADRATURE_SCHEME%NUMBER_OF_GAUSS) THEN
                          CALL FIELD_INTERPOLATE_GAUSS(DERIVATIVE_NUMBER,SCHEME,GAUSS_POINT, &
                            & INTERPOLATED_POINT(VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                          VALUES(1:numberOfComponents)=INTERPOLATED_POINT(VARIABLE_TYPE)%PTR% &
                            & VALUES(1:numberOfComponents,DERIVATIVE_NUMBER)
                        ELSE
                          LOCAL_ERROR="The specified Gauss point number of "// & 
                            & TRIM(NUMBER_TO_VSTRING(GAUSS_POINT,"*",ERR,ERROR))//"is invalid for "// &
                            & "the specified quadrature scheme of the specified element for this field which has "// &
                            & TRIM(NUMBER_TO_VSTRING(QUADRATURE_SCHEME%NUMBER_OF_GAUSS,"*",ERR,ERROR))//" Gauss points."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="The number of the coordinate values to return the interpolated field to is invalid. "// &
                          & "The supplied size is "//TRIM(NUMBER_TO_VSTRING(SIZE(VALUES),"*",ERR,ERROR))//" and should be "// &
                          & TRIM(NUMBER_TO_VSTRING(numberOfComponents,"*",ERR,ERROR))//" for this field."
                        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                      ENDIF
                    ELSE
                      CALL FLAG_ERROR("The specified quadrature scheme is not associated the specified element's basis.", &
                        & ERR,ERROR,*999)
                    ENDIF
                    !Finalise the interpolated point and parameters
                    CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,ERR,ERROR,*999)
                    CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATED_PARAMETERS,ERR,ERROR,*999)
                  ELSE
                    LOCAL_ERROR="The specified element number of "//TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                      & " is invalid. The element number must be between 1 and "// &
                      & TRIM(NUMBER_TO_VSTRING(DOMAIN_ELEMENTS%NUMBER_OF_ELEMENTS,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " does not correspond to the double precision data type of the given value."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and  "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
            CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_GAUSS_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_GAUSS_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_GAUSS_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_GAUSS_DP

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of Gauss points for the specified element and derviative and returns double precision values. If no Gauss points are specified then all Gauss points are interpolated. \see OPENCMISS::CMISSFieldParameterSetInterpolateGauss
  SUBROUTINE FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_GAUSS_DP(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DERIVATIVE_NUMBER, &
    & USER_ELEMENT_NUMBER,SCHEME,GAUSS_POINTS,VALUES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to interpolate. \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier.
    INTEGER(INTG), INTENT(IN) :: DERIVATIVE_NUMBER !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: USER_ELEMENT_NUMBER !<The user element number to interpolate.
    INTEGER(INTG), INTENT(IN) :: SCHEME !<The quadrature scheme to interpolate the field for.
    INTEGER(INTG), INTENT(IN) :: GAUSS_POINTS(:) !<The Gauss points to interpolate the field at.
    REAL(DP), INTENT(OUT) :: VALUES(:,:) !<On return, the interpolated field values.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string.
    !Local Variables
    INTEGER(INTG) :: Gauss_point
    INTEGER(INTG) :: DECOMPOSITION_LOCAL_ELEMENT_NUMBER
    LOGICAL :: GHOST_ELEMENT,USER_ELEMENT_EXISTS
    TYPE(QUADRATURE_SCHEME_TYPE), POINTER :: QUADRATURE_SCHEME
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: INTERPOLATED_PARAMETERS(:)
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: INTERPOLATED_POINT(:)
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DECOMPOSITION_TOPOLOGY
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DOMAIN_ELEMENTS
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    INTEGER(INTG) :: numberOfComponents
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_GAUSS_DP",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        DECOMPOSITION=>FIELD%DECOMPOSITION
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_VARIABLE%DATA_TYPE==FIELD_DP_TYPE) THEN
                IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                  DOMAIN_ELEMENTS=>FIELD_VARIABLE%COMPONENTS(DECOMPOSITION%MESH_COMPONENT_NUMBER)%DOMAIN%TOPOLOGY%ELEMENTS
                  DECOMPOSITION_TOPOLOGY=>DECOMPOSITION%TOPOLOGY
                  CALL DECOMPOSITION_TOPOLOGY_ELEMENT_CHECK_EXISTS(DECOMPOSITION_TOPOLOGY,USER_ELEMENT_NUMBER, &
                    & USER_ELEMENT_EXISTS,DECOMPOSITION_LOCAL_ELEMENT_NUMBER,GHOST_ELEMENT,ERR,ERROR,*999)
                  IF(USER_ELEMENT_EXISTS) THEN
                    IF(GHOST_ELEMENT) THEN
                      LOCAL_ERROR="Cannot interpolate Gauss points for user element "// &
                        & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))//" as it is a ghost element."
                      CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                    ELSE
                      CALL FIELD_INTERPOLATION_PARAMETERS_INITIALISE(FIELD,INTERPOLATED_PARAMETERS,ERR,ERROR,*999)
                      CALL FIELD_INTERPOLATED_POINTS_INITIALISE(INTERPOLATED_PARAMETERS,INTERPOLATED_POINT,ERR,ERROR,*999)
                      CALL FIELD_INTERPOLATION_PARAMETERS_ELEMENT_GET(FIELD_VALUES_SET_TYPE,DECOMPOSITION_LOCAL_ELEMENT_NUMBER, &
                        & INTERPOLATED_PARAMETERS(VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                      CALL FIELD_NUMBER_OF_COMPONENTS_GET(FIELD,VARIABLE_TYPE,numberOfComponents,ERR,ERROR,*999)
                      QUADRATURE_SCHEME=>DOMAIN_ELEMENTS%ELEMENTS(DECOMPOSITION_LOCAL_ELEMENT_NUMBER)%BASIS%QUADRATURE% &
                        & QUADRATURE_SCHEME_MAP(SCHEME)%PTR
                      IF(ASSOCIATED(QUADRATURE_SCHEME)) THEN
                        IF(SIZE(VALUES,1)==numberOfComponents) THEN
                          IF(SIZE(GAUSS_POINTS)==0) THEN !Interpolate all Gauss points.
                            IF(SIZE(VALUES,2)==QUADRATURE_SCHEME%NUMBER_OF_GAUSS) THEN
                              DO Gauss_point=1,QUADRATURE_SCHEME%NUMBER_OF_GAUSS
                                CALL FIELD_INTERPOLATE_GAUSS(DERIVATIVE_NUMBER,SCHEME,Gauss_point, &
                                  & INTERPOLATED_POINT(VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                                VALUES(1:numberOfComponents,Gauss_point)=INTERPOLATED_POINT(VARIABLE_TYPE)%PTR% &
                                  & VALUES(1:numberOfComponents,DERIVATIVE_NUMBER)
                              ENDDO
                            ELSE
                              LOCAL_ERROR="The number of Gauss points in the field interpolated values output array is "// & 
                                & "invalid. For returning the interpolated field values at all element Gauss points, the "//&
                                & "output array is required to be allocated for "// &
                                & TRIM(NUMBER_TO_VSTRING(QUADRATURE_SCHEME%NUMBER_OF_GAUSS,"*",ERR,ERROR))// &
                                & " Gauss points for the specified quadrature scheme."
                              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                          ELSE !Interpolate only at the specified Gauss points.
                            IF(SIZE(VALUES,2)==SIZE(GAUSS_POINTS)) THEN
                              DO Gauss_point=1,SIZE(GAUSS_POINTS)
                                IF(GAUSS_POINTS(Gauss_point)>0.AND.GAUSS_POINTS(Gauss_point)<=QUADRATURE_SCHEME% &
                                  & NUMBER_OF_GAUSS) THEN
                                  CALL FIELD_INTERPOLATE_GAUSS(DERIVATIVE_NUMBER,SCHEME,GAUSS_POINTS(Gauss_point), &
                                    & INTERPOLATED_POINT(VARIABLE_TYPE)%PTR,ERR,ERROR,*999)
                                  VALUES(:,Gauss_point)=INTERPOLATED_POINT(VARIABLE_TYPE)%PTR%VALUES(:,DERIVATIVE_NUMBER)
                                ELSE
                                  LOCAL_ERROR="The specified Gauss point number of "// & 
                                    & TRIM(NUMBER_TO_VSTRING(GAUSS_POINTS(Gauss_point),"*",ERR,ERROR))//"is invalid for "// &
                                    & "the specified quadrature scheme of the specified element for this field which has "// &
                                    & TRIM(NUMBER_TO_VSTRING(QUADRATURE_SCHEME%NUMBER_OF_GAUSS,"*",ERR,ERROR))//" Gauss points."
                                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                                ENDIF
                              ENDDO
                            ELSE
                              LOCAL_ERROR="The number of Gauss points in the field interpolated values output array is "// &
                                & "not the same as the number to be interpolated."
                              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                          ENDIF
                        ELSE
                          LOCAL_ERROR="The number of the coordinate values to return the interpolated field to is invalid. "// &
                            & "The supplied size is "//TRIM(NUMBER_TO_VSTRING(SIZE(VALUES,1),"*",ERR,ERROR))//" and should be "// &
                            & TRIM(NUMBER_TO_VSTRING(numberOfComponents,"*",ERR,ERROR))//" for this field."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        CALL FLAG_ERROR("The specified quadrature scheme is not associated the specified element's basis.", &
                          & ERR,ERROR,*999)
                      ENDIF
                      !Finalise the interpolated point and parameters
                      CALL FIELD_INTERPOLATED_POINTS_FINALISE(INTERPOLATED_POINT,ERR,ERROR,*999)
                      CALL FIELD_INTERPOLATION_PARAMETERS_FINALISE(INTERPOLATED_PARAMETERS,ERR,ERROR,*999)
                    ENDIF
                  ELSE
                    LOCAL_ERROR="The specified user element number of "// &
                      & TRIM(NUMBER_TO_VSTRING(USER_ELEMENT_NUMBER,"*",ERR,ERROR))// &
                      & " does not exist in the decomposition for field variable type "// &
                      & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                      & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  ENDIF
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " is invalid. The field parameter set type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field variable data type of "//TRIM(NUMBER_TO_VSTRING(FIELD_VARIABLE%DATA_TYPE,"*",ERR,ERROR))// &
                  & " does not correspond to the double precision data type of the given value."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The specified field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and  "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
            CALL FLAG_ERROR("Field decomposition is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_GAUSS_DP")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_GAUSS_DP",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_GAUSS_DP")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_GAUSS_DP

  !
  !================================================================================================================================
  !

  !>Starts the parameter set update for a field variable. \see OPENCMISS::CMISSFieldParameterSetUpdateStart
  SUBROUTINE FIELD_PARAMETER_SET_UPDATE_START(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to start the update for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier to update
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_UPDATE_START",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
        FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
        IF(ASSOCIATED(FIELD_VARIABLE)) THEN
          IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
            PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
            IF(ASSOCIATED(PARAMETER_SET)) THEN
              CALL DISTRIBUTED_VECTOR_UPDATE_START(PARAMETER_SET%PARAMETERS,ERR,ERROR,*999)
            ELSE
              LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The field parameter set type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
          & " is invalid. The variable type must be between 1 and "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_START")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_UPDATE_START",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_UPDATE_START")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_UPDATE_START

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set distributed vector. 
  SUBROUTINE FIELD_PARAMETER_SET_VECTOR_GET(FIELD,VARIABLE_TYPE,FIELD_SET_TYPE,DISTRIBUTED_VECTOR,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the parameter set vector from
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to update \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    INTEGER(INTG), INTENT(IN) :: FIELD_SET_TYPE !<The field parameter set identifier
    TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: DISTRIBUTED_VECTOR !<On return, a pointer to the field parameter set distributed vector. Must not be associated on entry
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: PARAMETER_SET
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_PARAMETER_SET_VECTOR_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(DISTRIBUTED_VECTOR)) THEN
        CALL FLAG_ERROR("Distributed vector is already associated.",ERR,ERROR,*999)
      ELSE
        NULLIFY(DISTRIBUTED_VECTOR)
        IF(FIELD%FIELD_FINISHED) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(ASSOCIATED(FIELD_VARIABLE)) THEN
              IF(FIELD_SET_TYPE>0.AND.FIELD_SET_TYPE<=FIELD_NUMBER_OF_SET_TYPES) THEN
                PARAMETER_SET=>FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE(FIELD_SET_TYPE)%PTR
                IF(ASSOCIATED(PARAMETER_SET)) THEN
                  DISTRIBUTED_VECTOR=>PARAMETER_SET%PARAMETERS
                  IF(.NOT.ASSOCIATED(DISTRIBUTED_VECTOR)) &
                    & CALL FLAG_ERROR("Call parameter set distributed vector is not associated.",ERR,ERROR,*999)
                ELSE
                  LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                    & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                ENDIF
              ELSE
                LOCAL_ERROR="The field parameter set type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SET_TYPE,"*",ERR,ERROR))// &
                  & " is invalid. The field parameter set type must be between 1 and "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_SET_TYPES,"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
            & " has not been finished."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SET_VECTOR_GET")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SET_VECTOR_GET",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_VECTOR_GET")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_VECTOR_GET

  !
  !================================================================================================================================
  !

  !>Finalises the parameter sets for a field and deallocates all memory.
  SUBROUTINE FIELD_PARAMETER_SETS_FINALISE(FIELD_VARIABLE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_VARIABLE_TYPE) :: FIELD_VARIABLE !<A pointer to the field variable to finalise the parameter sets for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: parameter_set_idx

    CALL ENTERS("FIELD_PARAMETER_SETS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE)) DEALLOCATE(FIELD_VARIABLE%PARAMETER_SETS%SET_TYPE)
    IF(ASSOCIATED(FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS)) THEN
      DO parameter_set_idx=1,SIZE(FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS,1)
        CALL FIELD_PARAMETER_SET_FINALISE(FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS(parameter_set_idx)%PTR,ERR,ERROR,*999)
      ENDDO !parameter_set_idx
      DEALLOCATE(FIELD_VARIABLE%PARAMETER_SETS%PARAMETER_SETS)
    ENDIF
    FIELD_VARIABLE%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS=0

    CALL EXITS("FIELD_PARAMETER_SETS_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_PARAMETER_SETS_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SETS_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SETS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the parameter sets for a field.
  SUBROUTINE FIELD_PARAMETER_SETS_INITIALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the variable parameter sets for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR
    !Local Variables
    INTEGER(INTG) :: DUMMY_ERR,parameter_set_idx,variable_idx
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    CALL ENTERS("FIELD_PARAMETER_SETS_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELD)) THEN
      DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES        
        FIELD%VARIABLES(variable_idx)%PARAMETER_SETS%FIELD_VARIABLE=>FIELD%VARIABLES(variable_idx)
        FIELD%VARIABLES(variable_idx)%PARAMETER_SETS%NUMBER_OF_PARAMETER_SETS=0
        NULLIFY(FIELD%VARIABLES(variable_idx)%PARAMETER_SETS%PARAMETER_SETS)
        ALLOCATE(FIELD%VARIABLES(variable_idx)%PARAMETER_SETS%SET_TYPE(FIELD_NUMBER_OF_SET_TYPES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field parameter sets set types.",ERR,ERROR,*999)
        DO parameter_set_idx=1,FIELD_NUMBER_OF_SET_TYPES
          NULLIFY(FIELD%VARIABLES(variable_idx)%PARAMETER_SETS%SET_TYPE(parameter_set_idx)%PTR)
        ENDDO !parameter_set_idx
        !Create a field values parameter set
        CALL FIELD_PARAMETER_SET_CREATE(FIELD,FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,ERR,ERROR,*999)
      ENDDO !variable_idx
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*998)
    ENDIF

    CALL EXITS("FIELD_PARAMETER_SETS_INITIALISE")
    RETURN
999 DO variable_idx=1,FIELD_NUMBER_OF_VARIABLE_TYPES
      IF(ASSOCIATED(FIELD%VARIABLE_TYPE_MAP(variable_idx)%PTR)) &
        & CALL FIELD_PARAMETER_SETS_FINALISE(FIELD%VARIABLE_TYPE_MAP(variable_idx)%PTR,DUMMY_ERR,DUMMY_ERROR,*998)
    ENDDO !variable_idx
998 CALL ERRORS("FIELD_PARAMETER_SETS_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SETS_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SETS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Returns the region for a field accounting for regions and interfaces
  SUBROUTINE FIELD_REGION_GET(FIELD,REGION,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the region for
    TYPE(REGION_TYPE), POINTER :: REGION !<On return, the fields region. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_REGION_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(REGION)) THEN
        CALL FLAG_ERROR("Region is already associated.",ERR,ERROR,*999)
      ELSE
        NULLIFY(REGION)
        NULLIFY(INTERFACE)
        REGION=>FIELD%REGION
        IF(.NOT.ASSOCIATED(REGION)) THEN          
          INTERFACE=>FIELD%INTERFACE
          IF(ASSOCIATED(INTERFACE)) THEN
            PARENT_REGION=>INTERFACE%PARENT_REGION
            IF(ASSOCIATED(PARENT_REGION)) THEN
              REGION=>PARENT_REGION              
            ELSE
              LOCAL_ERROR="The parent region not associated for field number "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" of interface number "// &
                & TRIM(NUMBER_TO_VSTRING(INTERFACE%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The region or interface is not associated for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_REGION_GET")
    RETURN
999 CALL ERRORS("FIELD_REGION_GET",ERR,ERROR)
    CALL EXITS("FIELD_REGION_GET")
    RETURN 1
  END SUBROUTINE FIELD_REGION_GET

  !
  !================================================================================================================================
  !

  !>Finalises the scaling for a field scaling index and deallocates all memory.
  SUBROUTINE FIELD_SCALING_FINALISE(FIELD,SCALING_INDEX,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to finalise the scalings for
    INTEGER(INTG), INTENT(IN) :: SCALING_INDEX !<The scaling index to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_SCALING_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(SCALING_INDEX>0.AND.SCALING_INDEX<=FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES) THEN
        !IF(ALLOCATED(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS))  &
        !  & DEALLOCATE(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS)
        IF(ASSOCIATED(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS)) &
          & CALL DISTRIBUTED_VECTOR_DESTROY(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS,ERR,ERROR,*999)
      ELSE
        LOCAL_ERROR="The scaling index of "//TRIM(NUMBER_TO_VSTRING(SCALING_INDEX,"*",ERR,ERROR))// &
          & " is invalid for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES,"*",ERR,ERROR))// &
          & " scaling indices."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_SCALING_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_SCALING_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_SCALING_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_SCALING_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the scalings for a field scaling index corresponding to a mesh component index.
  SUBROUTINE FIELD_SCALING_INITIALISE(FIELD,SCALING_INDEX,MESH_COMPONENT_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the scaling for
    INTEGER(INTG), INTENT(IN) :: SCALING_INDEX !<The scaling index to initialise
    INTEGER(INTG), INTENT(IN) :: MESH_COMPONENT_NUMBER !<The mesh component number to initialise for the scaling
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_SCALING_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(SCALING_INDEX>0.AND.SCALING_INDEX<=FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES) THEN
        IF(MESH_COMPONENT_NUMBER>0.AND.MESH_COMPONENT_NUMBER<=FIELD%DECOMPOSITION%MESH%NUMBER_OF_COMPONENTS) THEN
          FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%MESH_COMPONENT_NUMBER=MESH_COMPONENT_NUMBER
          FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%MAX_NUMBER_OF_ELEMENT_PARAMETERS=FIELD%DECOMPOSITION% &
            & DOMAIN(MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY%ELEMENTS%MAXIMUM_NUMBER_OF_ELEMENT_PARAMETERS
          FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%MAX_NUMBER_OF_DERIVATIVES=FIELD%DECOMPOSITION% &
            & DOMAIN(MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY%NODES%MAXIMUM_NUMBER_OF_DERIVATIVES
          NULLIFY(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS)
          SELECT CASE(FIELD%SCALINGS%SCALING_TYPE)
          CASE(FIELD_NO_SCALING)
            !Do nothing
          CASE(FIELD_UNIT_SCALING,FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
            !ALLOCATE(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)% &
            !  & MAX_NUMBER_OF_DERIVATIVES,FIELD%DECOMPOSITION%DOMAIN(MESH_COMPONENT_NUMBER)%PTR%TOPOLOGY% &
            !  & NODES%TOTAL_NUMBER_OF_NODES),STAT=ERR)
            !IF(ERR/=0) CALL FLAG_ERROR("Could not allocate scale factors",ERR,ERROR,*999)
            !FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS=1.0_DP
            CALL DISTRIBUTED_VECTOR_CREATE_START(FIELD%DECOMPOSITION%DOMAIN(MESH_COMPONENT_NUMBER)%PTR%MAPPINGS%DOFS, &
              & FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS,ERR,ERROR,*999)
            CALL DISTRIBUTED_VECTOR_DATA_TYPE_SET(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS, &
              & DISTRIBUTED_MATRIX_VECTOR_DP_TYPE,ERR,ERROR,*999)
            CALL DISTRIBUTED_VECTOR_CREATE_FINISH(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS,ERR,ERROR,*999)
            IF(FIELD%TYPE==FIELD_GEOMETRIC_TYPE) THEN
              !Initialise the scalings to 1.0 for a geometric field. Other field types will be setup in FIELD_SCALINGS_CALCULATE
              CALL DISTRIBUTED_VECTOR_ALL_VALUES_SET(FIELD%SCALINGS%SCALINGS(SCALING_INDEX)%SCALE_FACTORS,1.0_DP,ERR,ERROR,*999)
            ENDIF
          CASE(FIELD_ARC_LENGTH_SCALING)
            CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)
          CASE DEFAULT
            LOCAL_ERROR="The scaling type of "//TRIM(NUMBER_TO_VSTRING(FIELD%SCALINGS%SCALING_TYPE,"*",ERR,ERROR))// &
              & " is invalid for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        ELSE
          LOCAL_ERROR="The mesh component number of "//TRIM(NUMBER_TO_VSTRING(SCALING_INDEX,"*",ERR,ERROR))// &
            & " is invalid for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
            & " which is associated with a mesh which has "//TRIM(NUMBER_TO_VSTRING(FIELD%DECOMPOSITION% &
            & MESH%NUMBER_OF_COMPONENTS,"*",ERR,ERROR))//" mesh components."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="The scaling index of "//TRIM(NUMBER_TO_VSTRING(SCALING_INDEX,"*",ERR,ERROR))// &
          & " is invalid for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " which has "//TRIM(NUMBER_TO_VSTRING(FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES,"*",ERR,ERROR))// &
          & " scaling indices."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_SCALING_INITIALISE")
    RETURN
999 CALL ERRORS("FIELD_SCALING_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_SCALING_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_SCALING_INITIALISE

  !
  !================================================================================================================================
  !

  !>Calculates the scale factors from the geometric field associated with the field.
  SUBROUTINE FIELD_SCALINGS_CALCULATE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to calculate the scalings for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: MESH_COMPONENT_NUMBER,xi_direction,ni1,ni2,version_idx,derivative_idx,nk2,local_node_line_idx, &
      & adjacent_local_node_line_idx,node_line_idx,node_idx,partial_derivative_idx,nu1,nu2,dof_idx,ny1,ny2,ny3,scaling_idx
    REAL(DP) :: LENGTH1,LENGTH2,MEAN_LENGTH,TEMP,NUMBER_OF_LINE_VERSIONS1,NUMBER_OF_LINE_VERSIONS2,VALUE
    REAL(DP), POINTER :: SCALE_FACTORS(:)
    LOGICAL :: FOUND
    TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: DECOMPOSITION_LINES
    TYPE(DOMAIN_TYPE), POINTER :: DOMAIN
    TYPE(DOMAIN_LINES_TYPE), POINTER :: DOMAIN_LINES
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DOMAIN_NODES
    TYPE(FIELD_TYPE), POINTER :: GEOMETRIC_FIELD
    TYPE(FIELD_SCALING_TYPE), POINTER :: FIELD_SCALING
    TYPE(FIELD_SCALINGS_TYPE), POINTER :: FIELD_SCALINGS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_SCALINGS_CALCULATE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      FIELD_SCALINGS=>FIELD%SCALINGS
      IF(ASSOCIATED(FIELD_SCALINGS)) THEN
        GEOMETRIC_FIELD=>FIELD%GEOMETRIC_FIELD
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          SELECT CASE(FIELD_SCALINGS%SCALING_TYPE)
          CASE(FIELD_NO_SCALING)
            !Do nothing
            NULLIFY(DOMAIN)
          CASE(FIELD_UNIT_SCALING)
            DO scaling_idx=1,FIELD_SCALINGS%NUMBER_OF_SCALING_INDICES
              FIELD_SCALING=>FIELD_SCALINGS%SCALINGS(scaling_idx)
              MESH_COMPONENT_NUMBER=FIELD_SCALING%MESH_COMPONENT_NUMBER
              DOMAIN=>FIELD%DECOMPOSITION%DOMAIN(MESH_COMPONENT_NUMBER)%PTR
              CALL DISTRIBUTED_VECTOR_ALL_VALUES_SET(FIELD_SCALING%SCALE_FACTORS,1.0_DP,ERR,ERROR,*999)
              CALL DISTRIBUTED_VECTOR_UPDATE_START(FIELD_SCALING%SCALE_FACTORS,ERR,ERROR,*999)
              CALL DISTRIBUTED_VECTOR_UPDATE_FINISH(FIELD_SCALING%SCALE_FACTORS,ERR,ERROR,*999)
            ENDDO !scaling_idx
          CASE(FIELD_ARC_LENGTH_SCALING)
            CALL FLAG_ERROR("Not implemented.",ERR,ERROR,*999)

          CASE(FIELD_ARITHMETIC_MEAN_SCALING,FIELD_GEOMETRIC_MEAN_SCALING,FIELD_HARMONIC_MEAN_SCALING)
            DO scaling_idx=1,FIELD_SCALINGS%NUMBER_OF_SCALING_INDICES
              FIELD_SCALING=>FIELD_SCALINGS%SCALINGS(scaling_idx)
              MESH_COMPONENT_NUMBER=FIELD_SCALING%MESH_COMPONENT_NUMBER
              DOMAIN=>FIELD%DECOMPOSITION%DOMAIN(MESH_COMPONENT_NUMBER)%PTR
              DOMAIN_NODES=>DOMAIN%TOPOLOGY%NODES
              IF(FIELD%DECOMPOSITION%CALCULATE_LINES) THEN
                DOMAIN_LINES=>DOMAIN%TOPOLOGY%LINES
                DECOMPOSITION_LINES=>FIELD%DECOMPOSITION%TOPOLOGY%LINES
              ENDIF
              NULLIFY(SCALE_FACTORS)
              CALL DISTRIBUTED_VECTOR_DATA_GET(FIELD_SCALING%SCALE_FACTORS,SCALE_FACTORS,ERR,ERROR,*999)
              DO node_idx=1,DOMAIN_NODES%NUMBER_OF_NODES
                DO derivative_idx=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                  partial_derivative_idx=DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%PARTIAL_DERIVATIVE_INDEX
                  SELECT CASE(partial_derivative_idx)
                  CASE(NO_PART_DERIV)
                    DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                      dof_idx=DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%DOF_INDEX(version_idx)
                      CALL DISTRIBUTED_VECTOR_VALUES_SET(FIELD_SCALING%SCALE_FACTORS,dof_idx,1.0_DP,ERR,ERROR,*999)
                    ENDDO
                  CASE(PART_DERIV_S1,PART_DERIV_S2,PART_DERIV_S3)
                    IF(FIELD%DECOMPOSITION%CALCULATE_LINES) THEN
                      IF(partial_derivative_idx==PART_DERIV_S1) THEN
                        xi_direction=1
                      ELSE IF(partial_derivative_idx==PART_DERIV_S2) THEN
                        xi_direction=2
                      ELSE
                        xi_direction=3
                      ENDIF
                      LENGTH1 = 0.0_DP
                      LENGTH2 = 0.0_DP
                      NUMBER_OF_LINE_VERSIONS1 = 0.0_DP
                      NUMBER_OF_LINE_VERSIONS2 = 0.0_DP
                      DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                        !Find a line of the correct Xi direction going through this node
                        FOUND=.FALSE.
                        DO node_line_idx=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_NODE_LINES
                          local_node_line_idx=DOMAIN_NODES%NODES(node_idx)%NODE_LINES(node_line_idx)
                          IF(DECOMPOSITION_LINES%LINES(local_node_line_idx)%XI_DIRECTION==xi_direction) THEN
                            FOUND=.TRUE.
                            EXIT
                          ENDIF
                        ENDDO !node_line_idx
                        IF(FOUND) THEN
                          IF(DOMAIN_LINES%LINES(local_node_line_idx)%NODES_IN_LINE(1)==node_idx) THEN !Current node at the beginning of the line
                            adjacent_local_node_line_idx=DECOMPOSITION_LINES%LINES(local_node_line_idx)%ADJACENT_LINES(0)
                          ELSE !Current node at the end of the line
                            adjacent_local_node_line_idx=DECOMPOSITION_LINES%LINES(local_node_line_idx)%ADJACENT_LINES(1)
                          ENDIF
                          !Average line lengths for the different versions (division by the number of lines is done after all the line lengths are added together)
                          LENGTH1=LENGTH1+GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%LENGTHS(local_node_line_idx)
                          NUMBER_OF_LINE_VERSIONS1=NUMBER_OF_LINE_VERSIONS1+1
                          IF(adjacent_local_node_line_idx/=0) THEN !Adjacent node and therefore lines exist
                            LENGTH2=LENGTH2+GEOMETRIC_FIELD%GEOMETRIC_FIELD_PARAMETERS%LENGTHS(adjacent_local_node_line_idx)
                            NUMBER_OF_LINE_VERSIONS2=NUMBER_OF_LINE_VERSIONS2+1
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Could not find a line in the Xi "//TRIM(NUMBER_TO_VSTRING(xi_direction,"*",ERR,ERROR))// &
                            & " direction going through node number "//TRIM(NUMBER_TO_VSTRING(node_idx,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ENDDO !version_idx
                      !Division by the numer of version for this node derivative, completing the calculation for the average line lengths
                      LENGTH1 = LENGTH1/NUMBER_OF_LINE_VERSIONS1
                      IF(adjacent_local_node_line_idx==0) THEN !No adjacent node ie end of mesh 
                        MEAN_LENGTH=LENGTH1
                      ELSE !Adjacent node and therefore lines exist
                        LENGTH2 = LENGTH2/NUMBER_OF_LINE_VERSIONS2
                        SELECT CASE(FIELD_SCALINGS%SCALING_TYPE)
                        CASE(FIELD_ARITHMETIC_MEAN_SCALING)
                          MEAN_LENGTH=(LENGTH1+LENGTH2)/2.0_DP
                        CASE(FIELD_GEOMETRIC_MEAN_SCALING)
                          MEAN_LENGTH=sqrt(LENGTH1*LENGTH2)
                        CASE(FIELD_HARMONIC_MEAN_SCALING)
                          TEMP=LENGTH1*LENGTH2
                          IF(ABS(TEMP)>ZERO_TOLERANCE) THEN
                            MEAN_LENGTH=2.0_DP*TEMP/(LENGTH1+LENGTH2)
                          ELSE
                            MEAN_LENGTH=0.0_DP
                          ENDIF
                        CASE DEFAULT
                          LOCAL_ERROR="The scaling type of "// &
                            & TRIM(NUMBER_TO_VSTRING(FIELD_SCALINGS%SCALING_TYPE,"*",ERR,ERROR))//" is invalid."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        END SELECT
                      ENDIF
                      DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                        dof_idx=DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%DOF_INDEX(version_idx)
                        CALL DISTRIBUTED_VECTOR_VALUES_SET(FIELD_SCALING%SCALE_FACTORS,dof_idx,MEAN_LENGTH,ERR,ERROR,*999)
                      ENDDO !version_idx
                    ENDIF
                  CASE(PART_DERIV_S1_S2,PART_DERIV_S1_S3,PART_DERIV_S2_S3,PART_DERIV_S1_S2_S3)
                    DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                      dof_idx=DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%DOF_INDEX(version_idx)
                      IF(partial_derivative_idx==PART_DERIV_S1_S2) THEN
                        ni1=1
                        nu1=PART_DERIV_S1
                        ni2=2
                        nu2=PART_DERIV_S2
                      ELSE IF(partial_derivative_idx==PART_DERIV_S1_S3) THEN
                        ni1=1
                        nu1=PART_DERIV_S1
                        ni2=3
                        nu2=PART_DERIV_S3
                      ELSE IF(partial_derivative_idx==PART_DERIV_S2_S3) THEN
                        ni1=2
                        nu1=PART_DERIV_S2
                        ni2=3
                        nu2=PART_DERIV_S3
                      ELSE
                        ni1=1
                        nu1=PART_DERIV_S1
                        ni2=2
                        nu2=PART_DERIV_S2
                      ENDIF
  !!TODO: Shouldn't have to search for the derivative_idx directions. Store them somewhere.
                      !Find the first direction derivative_idx
                      FOUND=.FALSE.
                      DO nk2=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                        IF(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(nk2)%PARTIAL_DERIVATIVE_INDEX==nu1) THEN
                          ny1=DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(nk2)%DOF_INDEX(version_idx)
                          FOUND=.TRUE.
                          EXIT
                        ENDIF
                      ENDDO !nk2
                      IF(FOUND) THEN
                        !Find the second direction derivative_idx
                        FOUND=.FALSE.
                        DO nk2=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                          IF(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(nk2)%PARTIAL_DERIVATIVE_INDEX==nu2) THEN
                            ny2=DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(nk2)%DOF_INDEX(version_idx)
                            FOUND=.TRUE.
                            EXIT
                          ENDIF
                        ENDDO !nk2
                        IF(FOUND) THEN
                          IF(partial_derivative_idx==PART_DERIV_S1_S2_S3) THEN
                            !Find the third direction derivative_idx
                            FOUND=.FALSE.
                            DO nk2=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
                              IF(DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(nk2)%PARTIAL_DERIVATIVE_INDEX==PART_DERIV_S3) THEN
                                ny3=DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(nk2)%DOF_INDEX(version_idx)
                                FOUND=.TRUE.
                                EXIT
                              ENDIF
                            ENDDO !nk2
                            IF(FOUND) THEN
                              CALL DISTRIBUTED_VECTOR_VALUES_SET(FIELD_SCALING%SCALE_FACTORS,dof_idx, &
                                SCALE_FACTORS(ny1)*SCALE_FACTORS(ny2)*SCALE_FACTORS(ny3),ERR,ERROR,*999)
                            ELSE
                              LOCAL_ERROR="Could not find the first partial derivative in the s3 direction index for "//&
                                & "local node number "//TRIM(NUMBER_TO_VSTRING(node_idx,"*",ERR,ERROR))//"."
                              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                            ENDIF
                          ELSE
                            CALL DISTRIBUTED_VECTOR_VALUES_SET(FIELD_SCALING%SCALE_FACTORS,dof_idx,SCALE_FACTORS(ny1)* &
                              & SCALE_FACTORS(ny2),ERR,ERROR,*999)
                          ENDIF
                        ELSE
                          LOCAL_ERROR="Could not find the first partial derivative in the s"// &
                            & TRIM(NUMBER_TO_VSTRING(ni2,"*",ERR,ERROR))//" direction index for "//&
                            & "local node number "//TRIM(NUMBER_TO_VSTRING(node_idx,"*",ERR,ERROR))//"."
                          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                        ENDIF
                      ELSE
                        LOCAL_ERROR="Could not find the first partial derivative in the s"// &
                          & TRIM(NUMBER_TO_VSTRING(ni1,"*",ERR,ERROR))//" direction index for "//&
                          & "local node number "//TRIM(NUMBER_TO_VSTRING(node_idx,"*",ERR,ERROR))//"."
                      ENDIF
                    ENDDO !version_idx
                  CASE DEFAULT
                    LOCAL_ERROR="The partial derivative index of "//TRIM(NUMBER_TO_VSTRING(partial_derivative_idx,"*", &
                      & ERR,ERROR))//" for derivative number "//TRIM(NUMBER_TO_VSTRING(derivative_idx,"*",ERR,ERROR))// &
                      & " of local node number "//TRIM(NUMBER_TO_VSTRING(node_idx,"*",ERR,ERROR))//" is invalid."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
                  END SELECT
                ENDDO !derivative_idx
              ENDDO !node_idx
              CALL DISTRIBUTED_VECTOR_UPDATE_START(FIELD_SCALING%SCALE_FACTORS,ERR,ERROR,*999)
              CALL DISTRIBUTED_VECTOR_UPDATE_FINISH(FIELD_SCALING%SCALE_FACTORS,ERR,ERROR,*999)
            ENDDO !scaling_idx
          CASE DEFAULT
            LOCAL_ERROR="The scaling type of "//TRIM(NUMBER_TO_VSTRING(FIELD_SCALINGS%SCALING_TYPE,"*",ERR,ERROR))// &
              & " is invalid."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          END SELECT
        ELSE
          CALL FLAG_ERROR("Field geometric field is not associated.",ERR,ERROR,*999)
        ENDIF
      ELSE
        CALL FLAG_ERROR("Field scalings is not associated.",ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    IF(DIAGNOSTICS1) THEN
      IF(FIELD_SCALINGS%SCALING_TYPE /= FIELD_NO_SCALING) THEN
        IF(ASSOCIATED(DOMAIN))THEN
          DOMAIN_NODES=>DOMAIN%TOPOLOGY%NODES
          CALL WRITE_STRING(DIAGNOSTIC_OUTPUT_TYPE,"Scale Factors for nodes in the domain:",ERR,ERROR,*999)
          DO node_idx=1,DOMAIN_NODES%NUMBER_OF_NODES
            CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"Node : ",node_idx,ERR,ERROR,*999)
            CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Number of Derivatives = ", &
              & DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES,ERR,ERROR,*999)
            DO derivative_idx=1,DOMAIN_NODES%NODES(node_idx)%NUMBER_OF_DERIVATIVES
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"  Derivative : ",derivative_idx,ERR,ERROR,*999)
              CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Number of Versions = ", &
                & DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions,ERR,ERROR,*999)
              DO version_idx=1,DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%numberOfVersions
                CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"    Version : ",version_idx,ERR,ERROR,*999)
                dof_idx=DOMAIN_NODES%NODES(node_idx)%DERIVATIVES(derivative_idx)%DOF_INDEX(version_idx)
                CALL DISTRIBUTED_VECTOR_VALUES_GET(FIELD_SCALING%SCALE_FACTORS,dof_idx,VALUE,ERR,ERROR,*999)
                CALL WRITE_STRING_VALUE(DIAGNOSTIC_OUTPUT_TYPE,"      Scale Factor : ",VALUE,ERR,ERROR,*999)
              ENDDO !version_idx
            ENDDO !derivative_idx
          ENDDO !node_idx
        ENDIF
      ENDIF
    ENDIF

    CALL EXITS("FIELD_SCALINGS_CALCULATE")
    RETURN
999 CALL ERRORS("FIELD_SCALINGS_CALCULATE",ERR,ERROR)
    CALL EXITS("FIELD_SCALINGS_CALCULATE")
    RETURN 1
  END SUBROUTINE FIELD_SCALINGS_CALCULATE

  !
  !================================================================================================================================
  !

  !>Finalises the scalings for a field and deallocates all memory.
  SUBROUTINE FIELD_SCALINGS_FINALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to finalise the scalings for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: scaling_idx

    CALL ENTERS("FIELD_SCALINGS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      DO scaling_idx=1,FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES
        CALL FIELD_SCALING_FINALISE(FIELD,scaling_idx,ERR,ERROR,*999)
      ENDDO !scaling_idx
      IF(ALLOCATED(FIELD%SCALINGS%SCALINGS)) DEALLOCATE(FIELD%SCALINGS%SCALINGS)
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_SCALINGS_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_SCALINGS_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_SCALINGS_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_SCALINGS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the scaling parameters sets for a field.
  SUBROUTINE FIELD_SCALINGS_INITIALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the scalings for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,DUMMY_ERR,NUMBER_OF_MESH_COMPONENTS,scaling_idx,variable_idx
    INTEGER(INTG), ALLOCATABLE :: MESH_COMPONENTS(:),MESH_COMPONENTS_MAP(:)
    TYPE(LIST_TYPE), POINTER :: MESH_COMPONENTS_LIST
    TYPE(VARYING_STRING) :: DUMMY_ERROR

    NULLIFY(MESH_COMPONENTS_LIST)

    CALL ENTERS("FIELD_SCALINGS_INITIALISE",ERR,ERROR,*997)

    IF(ASSOCIATED(FIELD)) THEN
      !Calculate the mesh component numbers involved in the field
      CALL LIST_CREATE_START(MESH_COMPONENTS_LIST,ERR,ERROR,*999)
      CALL LIST_DATA_TYPE_SET(MESH_COMPONENTS_LIST,LIST_INTG_TYPE,ERR,ERROR,*999)
      CALL LIST_INITIAL_SIZE_SET(MESH_COMPONENTS_LIST,FIELD%DECOMPOSITION%MESH%NUMBER_OF_COMPONENTS,ERR,ERROR,*999)
      CALL LIST_CREATE_FINISH(MESH_COMPONENTS_LIST,ERR,ERROR,*999)
      DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
        DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
          CALL LIST_ITEM_ADD(MESH_COMPONENTS_LIST,FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%MESH_COMPONENT_NUMBER, &
            & ERR,ERROR,*999)
        ENDDO !component_idx
      ENDDO !variable_idx
      CALL LIST_REMOVE_DUPLICATES(MESH_COMPONENTS_LIST,ERR,ERROR,*999)
      CALL LIST_DETACH_AND_DESTROY(MESH_COMPONENTS_LIST,NUMBER_OF_MESH_COMPONENTS,MESH_COMPONENTS,ERR,ERROR,*999)
      ALLOCATE(MESH_COMPONENTS_MAP(FIELD%DECOMPOSITION%MESH%NUMBER_OF_COMPONENTS),STAT=ERR)
      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate mesh components map.",ERR,ERROR,*999)
      MESH_COMPONENTS_MAP=0
      DO component_idx=1,NUMBER_OF_MESH_COMPONENTS
        MESH_COMPONENTS_MAP(MESH_COMPONENTS(component_idx))=component_idx
      ENDDO !component_idx
      !Allocate the scaling indices and initialise them
      FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES=NUMBER_OF_MESH_COMPONENTS
      ALLOCATE(FIELD%SCALINGS%SCALINGS(FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES),STAT=ERR)
      IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field scalings.",ERR,ERROR,*999)
      DO scaling_idx=1,FIELD%SCALINGS%NUMBER_OF_SCALING_INDICES
        CALL FIELD_SCALING_INITIALISE(FIELD,scaling_idx,MESH_COMPONENTS(scaling_idx),ERR,ERROR,*999)
      ENDDO !scaling_idx
      !Set the scaling index for all the field variable components
      DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
        DO component_idx=1,FIELD%VARIABLES(variable_idx)%NUMBER_OF_COMPONENTS
          FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%SCALING_INDEX= &
            & MESH_COMPONENTS_MAP(FIELD%VARIABLES(variable_idx)%COMPONENTS(component_idx)%MESH_COMPONENT_NUMBER)
        ENDDO !component_idx
      ENDDO !variable_idx
      DEALLOCATE(MESH_COMPONENTS)
      IF(FIELD%TYPE/=FIELD_GEOMETRIC_TYPE) CALL FIELD_SCALINGS_CALCULATE(FIELD,ERR,ERROR,*999)
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*997)
    ENDIF

    CALL EXITS("FIELD_SCALINGS_INITIALISE")
    RETURN
999 IF(ALLOCATED(MESH_COMPONENTS)) DEALLOCATE(MESH_COMPONENTS)
    IF(ASSOCIATED(MESH_COMPONENTS_LIST)) CALL LIST_DESTROY(MESH_COMPONENTS_LIST,ERR,ERROR,*998)
998 CALL FIELD_SCALINGS_FINALISE(FIELD,DUMMY_ERR,DUMMY_ERROR,*997)
997 CALL ERRORS("FIELD_SCALINGS_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_SCALINGS_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_SCALINGS_INITIALISE

  !
  !================================================================================================================================
  !

  !>Checks the scaling type for a field.
  SUBROUTINE FIELD_SCALING_TYPE_CHECK(FIELD,SCALING_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the scaling type for
    INTEGER(INTG), INTENT(IN) :: SCALING_TYPE !<The scaling type for the specified field to check \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_SCALING_TYPE_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        SELECT CASE(SCALING_TYPE)
        CASE(FIELD_NO_SCALING)
          IF(FIELD%SCALINGS%SCALING_TYPE/=FIELD_NO_SCALING) THEN
            LOCAL_ERROR="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%SCALINGS%SCALING_TYPE,"*",ERR,ERROR))// &
              & " which is not no scaling."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_UNIT_SCALING)
          IF(FIELD%SCALINGS%SCALING_TYPE/=FIELD_UNIT_SCALING) THEN
            LOCAL_ERROR="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%SCALINGS%SCALING_TYPE,"*",ERR,ERROR))// &
              & " which is not unit scaling."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_ARC_LENGTH_SCALING)
          IF(FIELD%SCALINGS%SCALING_TYPE/=FIELD_ARC_LENGTH_SCALING) THEN
            LOCAL_ERROR="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%SCALINGS%SCALING_TYPE,"*",ERR,ERROR))// &
              & " which is not arc length scaling."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_ARITHMETIC_MEAN_SCALING)
          IF(FIELD%SCALINGS%SCALING_TYPE/=FIELD_ARITHMETIC_MEAN_SCALING) THEN
            LOCAL_ERROR="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%SCALINGS%SCALING_TYPE,"*",ERR,ERROR))// &

              & " which is not arithmetic mean scaling."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_GEOMETRIC_MEAN_SCALING)
          IF(FIELD%SCALINGS%SCALING_TYPE/=FIELD_GEOMETRIC_MEAN_SCALING) THEN
            LOCAL_ERROR="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%SCALINGS%SCALING_TYPE,"*",ERR,ERROR))// &

              & " which is not geometric mean scaling."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_HARMONIC_MEAN_SCALING)
          IF(FIELD%SCALINGS%SCALING_TYPE/=FIELD_HARMONIC_MEAN_SCALING) THEN
            LOCAL_ERROR="Invalid scaling type. The scaling type for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%SCALINGS%SCALING_TYPE,"*",ERR,ERROR))// &
              & " which is not harmonic mean scaling."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE DEFAULT
          LOCAL_ERROR="The specified scaling type of "//TRIM(NUMBER_TO_VSTRING(SCALING_TYPE,"*",ERR,ERROR))// &
            & " is invalid."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        END SELECT
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_SCALING_TYPE_CHECK")
    RETURN
999 CALL ERRORS("FIELD_SCALING_TYPE_CHECK",ERR,ERROR)
    CALL EXITS("FIELD_SCALING_TYPE_CHECK")
    RETURN 1
  END SUBROUTINE FIELD_SCALING_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the scaling type for a field. \see OPENCMISS::CMISSFieldScalingTypeGet
  SUBROUTINE FIELD_SCALING_TYPE_GET(FIELD,SCALING_TYPE,ERR,ERROR,*)

    !Argument variables
     TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the scaling type for
    INTEGER(INTG), INTENT(OUT) :: SCALING_TYPE !<On return, the scaling type for the specified field to get \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_SCALING_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        SCALING_TYPE=FIELD%SCALINGS%SCALING_TYPE
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_SCALING_TYPE_GET")
    RETURN
999 CALL ERRORS("FIELD_SCALING_TYPE_GET",ERR,ERROR)
    CALL EXITS("FIELD_SCALING_TYPE_GET")
    RETURN 1
  END SUBROUTINE FIELD_SCALING_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field. \see OPENCMISS::CMISSFieldScalingTypeSet
  SUBROUTINE FIELD_SCALING_TYPE_SET(FIELD,SCALING_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the scaling type for
    INTEGER(INTG), INTENT(IN) :: SCALING_TYPE !<The scaling type to set \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_SCALING_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%SCALING_TYPE_LOCKED) THEN
            LOCAL_ERROR="The field scaling type has been locked for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            SELECT CASE(SCALING_TYPE)
            CASE(FIELD_NO_SCALING)
              FIELD%SCALINGS%SCALING_TYPE=FIELD_NO_SCALING
            CASE(FIELD_UNIT_SCALING)
              FIELD%SCALINGS%SCALING_TYPE=FIELD_UNIT_SCALING
            CASE(FIELD_ARC_LENGTH_SCALING)
              FIELD%SCALINGS%SCALING_TYPE=FIELD_ARC_LENGTH_SCALING
            CASE(FIELD_ARITHMETIC_MEAN_SCALING)
              FIELD%SCALINGS%SCALING_TYPE=FIELD_ARITHMETIC_MEAN_SCALING
            CASE(FIELD_GEOMETRIC_MEAN_SCALING)
              FIELD%SCALINGS%SCALING_TYPE=FIELD_GEOMETRIC_MEAN_SCALING
            CASE(FIELD_HARMONIC_MEAN_SCALING)
              FIELD%SCALINGS%SCALING_TYPE=FIELD_HARMONIC_MEAN_SCALING
            CASE DEFAULT
              LOCAL_ERROR="The specified scaling type of "//TRIM(NUMBER_TO_VSTRING(SCALING_TYPE,"*",ERR,ERROR))// &
                & " is invalid."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_SCALING_TYPE_SET")
    RETURN
999 CALL ERRORS("FIELD_SCALING_TYPE_SET",ERR,ERROR)
    CALL EXITS("FIELD_SCALING_TYPE_SET")
    RETURN 1
  END SUBROUTINE FIELD_SCALING_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field and locks it so that no further changes can be made.
  SUBROUTINE FIELD_SCALING_TYPE_SET_AND_LOCK(FIELD,SCALING_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the scaling type for
    INTEGER(INTG), INTENT(IN) :: SCALING_TYPE !<The scaling type to set \see FIELD_ROUTINES_ScalingTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_SCALING_TYPE_SET_AND_LOCK",ERR,ERROR,*999)

    CALL FIELD_SCALING_TYPE_SET(FIELD,SCALING_TYPE,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%SCALING_TYPE_LOCKED=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_SCALING_TYPE_SET_AND_LOCK")
    RETURN
999 CALL ERRORS("FIELD_SCALING_TYPE_SET_AND_LOCK",ERR,ERROR)
    CALL EXITS("FIELD_SCALING_TYPE_SET_AND_LOCK")
    RETURN 1
  END SUBROUTINE FIELD_SCALING_TYPE_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Checks the field type for a field.
  SUBROUTINE FIELD_TYPE_CHECK(FIELD,TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the type for
    INTEGER(INTG), INTENT(IN) :: TYPE !<The field type to check \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_TYPE_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        SELECT CASE(TYPE)
        CASE(FIELD_GEOMETRIC_TYPE)
          IF(FIELD%TYPE/=FIELD_GEOMETRIC_TYPE) THEN
            LOCAL_ERROR="Invalid field type. The field type for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%TYPE,"*",ERR,ERROR))// &
              & " which is not a geometric field."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_FIBRE_TYPE)
          IF(FIELD%TYPE/=FIELD_FIBRE_TYPE) THEN
            LOCAL_ERROR="Invalid field type. The field type for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%TYPE,"*",ERR,ERROR))// &
              & " which is not a fibre field."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_GENERAL_TYPE)
          IF(FIELD%TYPE/=FIELD_GENERAL_TYPE) THEN
            LOCAL_ERROR="Invalid field type. The field type for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%TYPE,"*",ERR,ERROR))// &
              & " which is not a general field."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_MATERIAL_TYPE)
          IF(FIELD%TYPE/=FIELD_MATERIAL_TYPE) THEN
            LOCAL_ERROR="Invalid field type. The field type for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%TYPE,"*",ERR,ERROR))// &
              & " which is not a material field."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE(FIELD_GEOMETRIC_GENERAL_TYPE)
          IF(FIELD%TYPE/=FIELD_GEOMETRIC_GENERAL_TYPE) THEN
            LOCAL_ERROR="Invalid field type. The field type for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%TYPE,"*",ERR,ERROR))// &
              & " which is not a geometric general field."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        CASE DEFAULT
          LOCAL_ERROR="The specified field type of "//TRIM(NUMBER_TO_VSTRING(TYPE,"*",ERR,ERROR))//" is invalid."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)          
        END SELECT
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_TYPE_CHECK")
    RETURN
999 CALL ERRORS("FIELD_TYPE_CHECK",ERR,ERROR)
    CALL EXITS("FIELD_TYPE_CHECK")
    RETURN 1
  END SUBROUTINE FIELD_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the field type for a field. \see OPENCMISS::CMISSFieldTypeGet
  SUBROUTINE FIELD_TYPE_GET(FIELD,TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the type for
    INTEGER(INTG), INTENT(OUT) :: TYPE !<On return, the field type for the specified field \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_TYPE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        TYPE=FIELD%TYPE
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_TYPE_GET")
    RETURN
999 CALL ERRORS("FIELD_TYPE_GET",ERR,ERROR)
    CALL EXITS("FIELD_TYPE_GET")
    RETURN 1
  END SUBROUTINE FIELD_TYPE_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field type for a field. \see OPENCMISS::CMISSFieldTypeSet
  SUBROUTINE FIELD_TYPE_SET(FIELD,TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: TYPE !<The field type to set \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_TYPE_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%TYPE_LOCKED) THEN
            LOCAL_ERROR="The field type has been locked for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            SELECT CASE(TYPE)
            CASE(FIELD_GEOMETRIC_TYPE)
              FIELD%TYPE=FIELD_GEOMETRIC_TYPE
              FIELD%GEOMETRIC_FIELD=>FIELD
            CASE(FIELD_FIBRE_TYPE)
              FIELD%TYPE=FIELD_FIBRE_TYPE
              NULLIFY(FIELD%GEOMETRIC_FIELD)
            CASE(FIELD_GENERAL_TYPE)
              FIELD%TYPE=FIELD_GENERAL_TYPE
              NULLIFY(FIELD%GEOMETRIC_FIELD)
            CASE(FIELD_MATERIAL_TYPE)
              FIELD%TYPE=FIELD_MATERIAL_TYPE
              NULLIFY(FIELD%GEOMETRIC_FIELD)
            CASE(FIELD_GEOMETRIC_GENERAL_TYPE)
              FIELD%TYPE=FIELD_GEOMETRIC_GENERAL_TYPE
              NULLIFY(FIELD%GEOMETRIC_FIELD)
            CASE DEFAULT
              LOCAL_ERROR="The specified field type of "//TRIM(NUMBER_TO_VSTRING(TYPE,"*",ERR,ERROR))//" is invalid."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            END SELECT
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_TYPE_SET")
    RETURN
999 CALL ERRORS("FIELD_TYPE_SET",ERR,ERROR)
    CALL EXITS("FIELD_TYPE_SET")
    RETURN 1
  END SUBROUTINE FIELD_TYPE_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field type for a field and locks it so that no further changes can be made.
  SUBROUTINE FIELD_TYPE_SET_AND_LOCK(FIELD,TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: TYPE !<The field type to set \see FIELD_ROUTINES_FieldTypes,FIELD_ROUTINES
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_TYPE_SET_AND_LOCK",ERR,ERROR,*999)
    
    CALL FIELD_TYPE_SET(FIELD,TYPE,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%TYPE_LOCKED=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_TYPE_SET_AND_LOCK")
    RETURN
999 CALL ERRORS("FIELD_TYPE_SET_AND_LOCK",ERR,ERROR)
    CALL EXITS("FIELD_TYPE_SET_AND_LOCK")
    RETURN 1
  END SUBROUTINE FIELD_TYPE_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Finds and returns in FIELD a pointer to the field identified by USER_NUMBER in the given list of FIELDS. If no field with that USER_NUMBER exists FIELD is left nullified.
  SUBROUTINE FIELD_USER_NUMBER_FIND_GENERIC(USER_NUMBER,FIELDS,FIELD,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: USER_NUMBER !<The field user number to find
    TYPE(FIELDS_TYPE), POINTER :: FIELDS !<The list of fields containing the field
    TYPE(FIELD_TYPE), POINTER :: FIELD !<On return, a pointer to the field with the given user number. If no field with that user number exists in the region the FIELD is null. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: field_idx

    CALL ENTERS("FIELD_USER_NUMBER_FIND_GENERIC",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELDS)) THEN
      IF(ASSOCIATED(FIELD)) THEN
        CALL FLAG_ERROR("Field is already associated.",ERR,ERROR,*999)
      ELSE
        NULLIFY(FIELD)
        field_idx=1
        DO WHILE(field_idx<=FIELDS%NUMBER_OF_FIELDS.AND..NOT.ASSOCIATED(FIELD))
          IF(FIELDS%FIELDS(field_idx)%PTR%USER_NUMBER==USER_NUMBER) THEN
            FIELD=>FIELDS%FIELDS(field_idx)%PTR
          ELSE
            field_idx=field_idx+1
          ENDIF
        ENDDO
      ENDIF
    ELSE
      CALL FLAG_ERROR("Fields is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_USER_NUMBER_FIND_GENERIC")
    RETURN
999 CALL ERRORS("FIELD_USER_NUMBER_FIND_GENERIC",ERR,ERROR)
    CALL EXITS("FIELD_USER_NUMBER_FIND_GENERIC")
    RETURN 1
  END SUBROUTINE FIELD_USER_NUMBER_FIND_GENERIC

  !
  !================================================================================================================================
  !

  !>Finds and returns in FIELD a pointer to the field identified by USER_NUMBER in the given INTERFACE. If no field with that USER_NUMBER exists FIELD is left nullified.
  SUBROUTINE FIELD_USER_NUMBER_FIND_INTERFACE(USER_NUMBER,INTERFACE,FIELD,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: USER_NUMBER !<The field user number to find
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE !<A pointer to the interface containing the field
    TYPE(FIELD_TYPE), POINTER :: FIELD !<On exit, a pointer to the field with the given user number. If no field with that user number exists in the region the FIELD is null. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
 
    CALL ENTERS("FIELD_USER_NUMBER_FIND_INTERFACE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERFACE)) THEN
      CALL FIELD_USER_NUMBER_FIND_GENERIC(USER_NUMBER,INTERFACE%FIELDS,FIELD,ERR,ERROR,*999)
    ELSE
      CALL FLAG_ERROR("Interface is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_USER_NUMBER_FIND_INTERFACE")
    RETURN
999 CALL ERRORS("FIELD_USER_NUMBER_FIND_INTERFACE",ERR,ERROR)
    CALL EXITS("FIELD_USER_NUMBER_FIND_INTERFACE")
    RETURN 1
  END SUBROUTINE FIELD_USER_NUMBER_FIND_INTERFACE

  !
  !================================================================================================================================
  !

  !>Finds and returns in FIELD a pointer to the field identified by USER_NUMBER in the given REGION. If no field with that USER_NUMBER exists FIELD is left nullified.
  SUBROUTINE FIELD_USER_NUMBER_FIND_REGION(USER_NUMBER,REGION,FIELD,ERR,ERROR,*)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: USER_NUMBER !<The field user number to find
    TYPE(REGION_TYPE), POINTER :: REGION !<A pointer to the region containing the field
    TYPE(FIELD_TYPE), POINTER :: FIELD !<On exit, a pointer to the field with the given user number. If no field with that user number exists in the region the FIELD is null. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELD_USER_NUMBER_FIND_REGION",ERR,ERROR,*999)

    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND_GENERIC(USER_NUMBER,REGION%FIELDS,FIELD,ERR,ERROR,*999)
    ELSE
      CALL FLAG_ERROR("Region is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_USER_NUMBER_FIND_REGION")
    RETURN
999 CALL ERRORS("FIELD_USER_NUMBER_FIND_REGION",ERR,ERROR)
    CALL EXITS("FIELD_USER_NUMBER_FIND_REGION")
    RETURN 1
  END SUBROUTINE FIELD_USER_NUMBER_FIND_REGION

  !
  !================================================================================================================================
  !

  !>Finalises a field variable and deallocates all memory.
  SUBROUTINE FIELD_VARIABLE_FINALISE(FIELD_VARIABLE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_VARIABLE_TYPE) :: FIELD_VARIABLE !<The field variable to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELD_VARIABLE_FINALISE",ERR,ERROR,*999)

    FIELD_VARIABLE%VARIABLE_LABEL=""
    CALL FIELD_VARIABLE_COMPONENTS_FINALISE(FIELD_VARIABLE,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD_VARIABLE%DOMAIN_MAPPING)) THEN
      CALL DOMAIN_MAPPINGS_MAPPING_FINALISE(FIELD_VARIABLE%DOMAIN_MAPPING,ERR,ERROR,*999)
    ENDIF
    CALL FIELD_DOF_TO_PARAM_MAP_FINALISE(FIELD_VARIABLE%DOF_TO_PARAM_MAP,ERR,ERROR,*999)
    CALL FIELD_PARAMETER_SETS_FINALISE(FIELD_VARIABLE,ERR,ERROR,*999)


    CALL EXITS("FIELD_VARIABLE_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_VARIABLE_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_FINALISE

  !
  !================================================================================================================================
  !

  !>Returns a pointer to a field variable
  SUBROUTINE FIELD_VARIABLE_GET(FIELD,VARIABLE_TYPE,FIELD_VARIABLE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the variable for.
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The type of field variable to set. \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE !<On exit, a pointer to the field variable. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_VARIABLE_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>=1.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            CALL FLAG_ERROR("Field variable is already associated.",ERR,ERROR,*999)
          ELSE
            NULLIFY(FIELD_VARIABLE)
            FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
            IF(.NOT.ASSOCIATED(FIELD_VARIABLE)) THEN
              LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been defined on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The field variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_VARIABLE_GET")
    RETURN
999 CALL ERRORS("FIELD_VARIABLE_GET",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_GET")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_GET

  !
  !================================================================================================================================
  !

  !>Initialises a field variable.
  SUBROUTINE FIELD_VARIABLE_INITIALISE(FIELD,VARIABLE_NUMBER,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the variable for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_NUMBER !<The variable number of the field to initialise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: component_idx,DUMMY_ERR,variable_type
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: DUMMY_ERROR,LOCAL_ERROR

    CALL ENTERS("FIELD_VARIABLE_INITIALISE",ERR,ERROR,*998)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        IF(VARIABLE_NUMBER>=1.AND.VARIABLE_NUMBER<=FIELD%NUMBER_OF_VARIABLES) THEN
          NULLIFY(FIELD%VARIABLES(VARIABLE_NUMBER)%FIELD)
          NULLIFY(FIELD%VARIABLES(VARIABLE_NUMBER)%REGION)
          NULLIFY(FIELD%VARIABLES(VARIABLE_NUMBER)%DOMAIN_MAPPING)
          !!TODO this should be done via a field_parameter_sets_initialise call
          NULLIFY(FIELD%VARIABLES(VARIABLE_NUMBER)%PARAMETER_SETS%SET_TYPE)
          NULLIFY(FIELD%VARIABLES(VARIABLE_NUMBER)%PARAMETER_SETS%PARAMETER_SETS)
          FIELD%VARIABLES(VARIABLE_NUMBER)%VARIABLE_NUMBER=VARIABLE_NUMBER
          variable_type=FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(VARIABLE_NUMBER)
          IF(variable_type>=1.AND.variable_type<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            FIELD%VARIABLES(VARIABLE_NUMBER)%VARIABLE_TYPE=FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(VARIABLE_NUMBER)
          ELSE
            LOCAL_ERROR="A field variable type of "//TRIM(NUMBER_TO_VSTRING(variable_type,"*",ERR,ERROR))// &
              & " for variable number "//TRIM(NUMBER_TO_VSTRING(VARIABLE_NUMBER,"*",ERR,ERROR))// &
              & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
              & " is invalid. The number must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*998)
          ENDIF
          FIELD%VARIABLE_TYPE_MAP(FIELD%VARIABLES(VARIABLE_NUMBER)%VARIABLE_TYPE)%PTR=>FIELD%VARIABLES(VARIABLE_NUMBER)
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(FIELD%VARIABLES(VARIABLE_NUMBER)%VARIABLE_TYPE)%PTR
          FIELD_VARIABLE%VARIABLE_LABEL=""
          FIELD_VARIABLE%VARIABLE_LABEL=FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)
          FIELD_VARIABLE%FIELD=>FIELD
          FIELD_VARIABLE%REGION=>FIELD%REGION
          FIELD_VARIABLE%DIMENSION=FIELD%CREATE_VALUES_CACHE%DIMENSION(variable_type)
          FIELD_VARIABLE%DATA_TYPE=FIELD%CREATE_VALUES_CACHE%DATA_TYPES(variable_type)
          FIELD_VARIABLE%DOF_ORDER_TYPE=FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES(variable_type)
          IF(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_type)>0) THEN
            FIELD_VARIABLE%NUMBER_OF_COMPONENTS=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_type)
            CALL FIELD_VARIABLE_COMPONENTS_INITIALISE(FIELD,variable_type,ERR,ERROR,*999)
          ELSE
            LOCAL_ERROR="The number of components of "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_type),"*",ERR,ERROR))// &
              & " for variable type "//TRIM(NUMBER_TO_VSTRING(variable_type,"*",ERR,ERROR))// &
              & " of field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
              & " is invalid. The number must be > 0."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
          FIELD_VARIABLE%maxNumberElementInterpolationParameters=-1
          FIELD_VARIABLE%maxNumberNodeInterpolationParameters=-1
          DO component_idx=1,FIELD_VARIABLE%NUMBER_OF_COMPONENTS
            IF(FIELD_VARIABLE%COMPONENTS(component_idx)%maxNumberElementInterpolationParameters> &
              & FIELD_VARIABLE%maxNumberElementInterpolationParameters) FIELD_VARIABLE% &
              & maxNumberElementInterpolationParameters=FIELD_VARIABLE%COMPONENTS(component_idx)% &
              & maxNumberElementInterpolationParameters
            IF(FIELD_VARIABLE%COMPONENTS(component_idx)%maxNumberNodeInterpolationParameters> &
              & FIELD_VARIABLE%maxNumberNodeInterpolationParameters) FIELD_VARIABLE% &
              & maxNumberNodeInterpolationParameters=FIELD_VARIABLE%COMPONENTS(component_idx)% &
              & maxNumberNodeInterpolationParameters
          ENDDO !component_idx
          FIELD_VARIABLE%NUMBER_OF_DOFS=0
          FIELD_VARIABLE%TOTAL_NUMBER_OF_DOFS=0
          FIELD_VARIABLE%NUMBER_OF_GLOBAL_DOFS=0
          ALLOCATE(FIELD_VARIABLE%DOMAIN_MAPPING,STAT=ERR)
          IF(ERR/=0) CALL FLAG_ERROR("Could not allocate field variable domain mapping.",ERR,ERROR,*999)
          CALL DOMAIN_MAPPINGS_MAPPING_INITIALISE(FIELD_VARIABLE%DOMAIN_MAPPING, &
            & FIELD%DECOMPOSITION%NUMBER_OF_DOMAINS,ERR,ERROR,*999)
          CALL FIELD_DOF_TO_PARAM_MAP_INITIALISE(FIELD_VARIABLE%DOF_TO_PARAM_MAP,ERR,ERROR,*999)
        ELSE
          LOCAL_ERROR="Variable number "//TRIM(NUMBER_TO_VSTRING(VARIABLE_NUMBER,"*",ERR,ERROR))// &
            & " is invalid for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" which has "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%NUMBER_OF_VARIABLES,"*",ERR,ERROR))//" variables."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*998)
        ENDIF
      ELSE
        CALL FLAG_ERROR("Field create values cache is not associated.",ERR,ERROR,*998)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*998)
    ENDIF

    CALL EXITS("FIELD_VARIABLE_INITIALISE")
    RETURN
999 CALL FIELD_VARIABLE_FINALISE(FIELD_VARIABLE,DUMMY_ERR,DUMMY_ERROR,*998)
998 CALL ERRORS("FIELD_VARIABLE_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_INITIALISE

  !
  !================================================================================================================================
  !

  !>Gets the label for a field variable for character labels. \see OPENCMISS::CMISSFieldVariableLabelGet
  SUBROUTINE FIELD_VARIABLE_LABEL_GET_C(FIELD,VARIABLE_TYPE,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    CHARACTER(LEN=*), INTENT(OUT) :: LABEL !<On return, the field variable label
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER :: C_LENGTH,VS_LENGTH
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("FIELD_VARIABLE_LABEL_GET_C",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            C_LENGTH=LEN(LABEL)
            VS_LENGTH=LEN_TRIM(FIELD_VARIABLE%VARIABLE_LABEL)
            IF(C_LENGTH>VS_LENGTH) THEN
              LABEL=CHAR(LEN_TRIM(FIELD_VARIABLE%VARIABLE_LABEL))
            ELSE
              LABEL=CHAR(FIELD_VARIABLE%VARIABLE_LABEL,C_LENGTH)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_VARIABLE_LABEL_GET_C")
    RETURN
999 CALL ERRORS("FIELD_VARIABLE_LABEL_GET_C",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_LABEL_GET_C")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_GET_C

  !
  !================================================================================================================================
  !

  !>Gets the label for a field variable for varying string labels. \see OPENCMISS::CMISSFieldVariableLabelGet
  SUBROUTINE FIELD_VARIABLE_LABEL_GET_VS(FIELD,VARIABLE_TYPE,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    TYPE(VARYING_STRING), INTENT(OUT) :: LABEL !<On return, the field variable label
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: FIELD_VARIABLE
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("FIELD_VARIABLE_LABEL_GET_VS",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
          FIELD_VARIABLE=>FIELD%VARIABLE_TYPE_MAP(VARIABLE_TYPE)%PTR
          IF(ASSOCIATED(FIELD_VARIABLE)) THEN
            LABEL=FIELD_VARIABLE%VARIABLE_LABEL
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
            & " is invalid. The variable type must be between 1 and "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_VARIABLE_LABEL_GET_VS")
    RETURN
999 CALL ERRORS("FIELD_VARIABLE_LABEL_GET_VS",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_LABEL_GET_VS")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_GET_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for character labels. \see OPENCMISS::CMISSFieldVariableLabelSet
  SUBROUTINE FIELD_VARIABLE_LABEL_SET_C(FIELD,VARIABLE_TYPE,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_VARIABLE_LABEL_SET_C",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
              IF(FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED(VARIABLE_TYPE)) THEN
                LOCAL_ERROR="The field variable label has been locked for for variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ELSE
                FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(VARIABLE_TYPE)=LABEL
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &

              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_VARIABLE_LABEL_SET_C")
    RETURN
999 CALL ERRORS("FIELD_VARIABLE_LABEL_SET_C",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_LABEL_SET_C")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_SET_C

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for varying string labels. \see OPENCMISS::CMISSFieldVariableLabelSet
  SUBROUTINE FIELD_VARIABLE_LABEL_SET_VS(FIELD,VARIABLE_TYPE,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the dimension for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The label to set/change
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_VARIABLE_LABEL_SET_VS",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(VARIABLE_TYPE>0.AND.VARIABLE_TYPE<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
            IF(ANY(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES==VARIABLE_TYPE)) THEN
              IF(FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED(VARIABLE_TYPE)) THEN
                LOCAL_ERROR="The field variable label has been locked for for variable type "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ELSE
                FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(VARIABLE_TYPE)=LABEL
              ENDIF
            ELSE
              LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
                & " has not been created on field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ELSE
            LOCAL_ERROR="The field variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))// &
              & " is invalid. The variable type must be between 1 and "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_VARIABLE_LABEL_SET_VS")
    RETURN
999 CALL ERRORS("FIELD_VARIABLE_LABEL_SET_VS",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_LABEL_SET_VS")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_SET_VS

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for character labels and locks so that no further changes can be made.
  SUBROUTINE FIELD_VARIABLE_LABEL_SET_AND_LOCK_C(FIELD,VARIABLE_TYPE,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    CHARACTER(LEN=*), INTENT(IN) :: LABEL !<The label to set/change 
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_C",ERR,ERROR,*999)

    CALL FIELD_VARIABLE_LABEL_SET(FIELD,VARIABLE_TYPE,LABEL,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED(VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_C")
    RETURN
999 CALL ERRORS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_C",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_C")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_SET_AND_LOCK_C

  !
  !================================================================================================================================
  !

  !>Sets/changes the label for a field variable for varying string labels and locks so that no further changes can be made.
  SUBROUTINE FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS(FIELD,VARIABLE_TYPE,LABEL,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set/change the label for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type \see FIELD_ROUTINES_VariableTypes,FIELD_ROUTINES 
    TYPE(VARYING_STRING), INTENT(IN) :: LABEL !<The label to set/change 
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS",ERR,ERROR,*999)

    CALL FIELD_VARIABLE_LABEL_SET(FIELD,VARIABLE_TYPE,LABEL,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED(VARIABLE_TYPE)=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF
    
    CALL EXITS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS")
    RETURN
999 CALL ERRORS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_LABEL_SET_AND_LOCK_VS

  !
  !================================================================================================================================
  !

  !>Checks the field variable types for a field.
  SUBROUTINE FIELD_VARIABLE_TYPES_CHECK(FIELD,VARIABLE_TYPES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the variable types for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPES(:) !<VARIABLE_TYPES(variable_idx). The field variable type for the variable_idx'th field variable to check
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_VARIABLE_TYPES_CHECK",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(SIZE(VARIABLE_TYPES,1)>=FIELD%NUMBER_OF_VARIABLES) THEN
          DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
            IF(VARIABLE_TYPES(variable_idx)>=1.AND.VARIABLE_TYPES(variable_idx)<=FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
              IF(FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE/=VARIABLE_TYPES(variable_idx)) THEN
                LOCAL_ERROR="Invalid variable type. The variable type for variable index number "// &
                  & TRIM(NUMBER_TO_VSTRING(variable_idx,"*",ERR,ERROR))//" of field number "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" is "// &
                  & TRIM(NUMBER_TO_VSTRING(FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE,"*",ERR,ERROR))// &
                  & " which is does correspond to the specified variable_type of "// &
                  & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPES(variable_idx),"*",ERR,ERROR))//"."
                CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
              ENDIF
            ELSE
              LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPES(variable_idx),"*",ERR,ERROR))// &
                & " at position number "//TRIM(NUMBER_TO_VSTRING(variable_idx,"*",ERR,ERROR))// &
                & " is invalid. The variable type must be between 1 and "// &
                & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)                  
            ENDIF
          ENDDO !variable_idx
        ELSE
          LOCAL_ERROR="Invalid variable types. The size of the specified variable types array is "// &
            & TRIM(NUMBER_TO_VSTRING(SIZE(VARIABLE_TYPES,1),"*",ERR,ERROR))//" and it must be >= "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%NUMBER_OF_VARIABLES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_VARIABLE_TYPES_CHECK")
    RETURN
999 CALL ERRORS("FIELD_VARIABLE_TYPES_CHECK",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_TYPES_CHECK")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_TYPES_CHECK

  !
  !================================================================================================================================
  !

  !>Checks the field contains the given field variable type.
  SUBROUTINE FIELD_VARIABLE_TYPE_CHECK(FIELD,VARIABLE_TYPE,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to check the variable type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPE !<The field variable type to check for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx
    LOGICAL :: VARIABLE_FOUND
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_VARIABLE_TYPE_CHECK",ERR,ERROR,*999)

    VARIABLE_FOUND=.FALSE.
    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
          IF(FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE==VARIABLE_TYPE) THEN
            VARIABLE_FOUND=.TRUE.
            CYCLE
          END IF
        ENDDO !variable_idx
        IF(.NOT.VARIABLE_FOUND) THEN
          CALL FLAG_ERROR("Field does not have a variable type of "// &
            & TRIM(NUMBER_TO_VSTRING(VARIABLE_TYPE,"*",ERR,ERROR))//".",ERR,ERROR,*999)
        END IF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      END IF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_VARIABLE_TYPE_CHECK")
    RETURN
999 CALL ERRORS("FIELD_VARIABLE_TYPE_CHECK",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_TYPE_CHECK")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_TYPE_CHECK

  !
  !================================================================================================================================
  !

  !>Gets the field variable types for a field. \see OPENCMISS::CMISSFieldVariableTypesGet
  SUBROUTINE FIELD_VARIABLE_TYPES_GET(FIELD,VARIABLE_TYPES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to get the variable types for
    INTEGER(INTG), INTENT(OUT) :: VARIABLE_TYPES(:) !<VARIABLE_TYPES(variable_idx). On return, the field variable type variable_idx'th field variable
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_VARIABLE_TYPES_GET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        IF(SIZE(VARIABLE_TYPES,1)>=FIELD%NUMBER_OF_VARIABLES) THEN
          VARIABLE_TYPES=0
          DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
            VARIABLE_TYPES(variable_idx)=FIELD%VARIABLES(variable_idx)%VARIABLE_TYPE
          ENDDO !variable_idx
        ELSE
          LOCAL_ERROR="Invalid variable types. The size of the specified variable types array is "// &
            & TRIM(NUMBER_TO_VSTRING(SIZE(VARIABLE_TYPES,1),"*",ERR,ERROR))//" and it must be >= "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%NUMBER_OF_VARIABLES,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has not been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_VARIABLE_TYPES_GET")
    RETURN
999 CALL ERRORS("FIELD_VARIABLE_TYPES_GET",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_TYPES_GET")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_TYPES_GET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field variable types for a field. \see OPENCMISS::CMISSFieldVariableTypesSet
  SUBROUTINE FIELD_VARIABLE_TYPES_SET(FIELD,VARIABLE_TYPES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPES(:) !<VARIABLE_TYPES(variable_idx). The field variable type for the variable_idx'th field variable to set 
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: NUMBER_OF_COMPONENTS,old_variable_type,variable_idx,variable_idx2,variable_type
    INTEGER(INTG) :: OLD_DIMENSION(FIELD_NUMBER_OF_VARIABLE_TYPES),OLD_DATA_TYPES(FIELD_NUMBER_OF_VARIABLE_TYPES), &
      & OLD_DOF_ORDER_TYPES(FIELD_NUMBER_OF_VARIABLE_TYPES),OLD_NUMBER_OF_COMPONENTS(FIELD_NUMBER_OF_VARIABLE_TYPES)
    INTEGER(INTG), ALLOCATABLE :: OLD_VARIABLE_TYPES(:),OLD_INTERPOLATION_TYPE(:,:),OLD_MESH_COMPONENT_NUMBER(:,:)
    LOGICAL :: OLD_DIMENSION_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES),OLD_DATA_TYPES_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES), &
      & OLD_DOF_ORDER_TYPES_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES), &
      & OLD_NUMBER_OF_COMPONENTS_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES),OLD_LABELS_LOCKED(FIELD_NUMBER_OF_VARIABLE_TYPES)
    LOGICAL, ALLOCATABLE :: OLD_INTERPOLATION_TYPE_LOCKED(:,:),OLD_MESH_COMPONENT_NUMBER_LOCKED(:,:)
    TYPE(VARYING_STRING) :: LOCAL_ERROR,OLD_LABELS(FIELD_NUMBER_OF_VARIABLE_TYPES)

    CALL ENTERS("FIELD_VARIABLE_TYPES_SET",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(FIELD%FIELD_FINISHED) THEN
        LOCAL_ERROR="Field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
          & " has been finished."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ELSE
        IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
          IF(FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES_LOCKED) THEN
            LOCAL_ERROR="The field variable types has been locked for field number "// &
              & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//" and can not be changed."
            CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
          ELSE
            IF(SIZE(VARIABLE_TYPES,1)==FIELD%NUMBER_OF_VARIABLES) THEN
              DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
                variable_type=VARIABLE_TYPES(variable_idx)
                !Check that the variable type is in range
                IF(variable_type<1.OR.VARIABLE_TYPE>FIELD_NUMBER_OF_VARIABLE_TYPES) THEN
                  LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variable_type,"*",ERR,ERROR))// &
                    & " at position number "//TRIM(NUMBER_TO_VSTRING(variable_idx,"*",ERR,ERROR))// &
                    & " is invalid. The variable type must be between 1 and "// &
                    & TRIM(NUMBER_TO_VSTRING(FIELD_NUMBER_OF_VARIABLE_TYPES,"*",ERR,ERROR))//"."
                  CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)                  
                ENDIF
                !Check that the variable type is not repeated
                DO variable_idx2=variable_idx+1,FIELD%NUMBER_OF_VARIABLES
                  IF(VARIABLE_TYPES(variable_idx2)==variable_type) THEN
                    LOCAL_ERROR="The specified variable type of "//TRIM(NUMBER_TO_VSTRING(variable_type,"*",ERR,ERROR))// &
                      & " occurs at position number "//TRIM(NUMBER_TO_VSTRING(variable_idx,"*",ERR,ERROR))// &
                      & " and position number "//TRIM(NUMBER_TO_VSTRING(variable_idx2,"*",ERR,ERROR))// &
                      & ". The variable types must be unique."
                    CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)                    
                  ENDIF
                ENDDO !variable_idx2
              ENDDO !variable_idx
              NUMBER_OF_COMPONENTS=SIZE(FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE,1)
              ALLOCATE(OLD_VARIABLE_TYPES(FIELD%NUMBER_OF_VARIABLES),STAT=ERR)
              IF(ERR/=0) CALL FLAG_ERROR("Could not allocate old variable types.",ERR,ERROR,*999)
              ALLOCATE(OLD_INTERPOLATION_TYPE(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
              IF(ERR/=0) CALL FLAG_ERROR("Could not allocate old interpolation type.",ERR,ERROR,*999)
              ALLOCATE(OLD_INTERPOLATION_TYPE_LOCKED(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
              IF(ERR/=0) CALL FLAG_ERROR("Could not allocate old interpolation type locked.",ERR,ERROR,*999)
              ALLOCATE(OLD_MESH_COMPONENT_NUMBER(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
              IF(ERR/=0) CALL FLAG_ERROR("Could not allocate old mesh component number.",ERR,ERROR,*999)
              ALLOCATE(OLD_MESH_COMPONENT_NUMBER_LOCKED(NUMBER_OF_COMPONENTS,FIELD_NUMBER_OF_VARIABLE_TYPES),STAT=ERR)
              IF(ERR/=0) CALL FLAG_ERROR("Could not allocate old mesh component number locked.",ERR,ERROR,*999)
              OLD_VARIABLE_TYPES(1:FIELD%NUMBER_OF_VARIABLES)=FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(1:FIELD%NUMBER_OF_VARIABLES)
              OLD_LABELS=FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS
              OLD_LABELS_LOCKED=FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED
              OLD_DIMENSION=FIELD%CREATE_VALUES_CACHE%DIMENSION
              OLD_DIMENSION_LOCKED=FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED
              OLD_DATA_TYPES=FIELD%CREATE_VALUES_CACHE%DATA_TYPES
              OLD_DATA_TYPES_LOCKED=FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED
              OLD_DOF_ORDER_TYPES=FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES
              OLD_DOF_ORDER_TYPES_LOCKED=FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED
              OLD_NUMBER_OF_COMPONENTS=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS
              OLD_NUMBER_OF_COMPONENTS_LOCKED=FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED
              OLD_INTERPOLATION_TYPE(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)= &
                & FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)
              OLD_INTERPOLATION_TYPE_LOCKED(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)= &
                & FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)
              OLD_MESH_COMPONENT_NUMBER(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)= &
                & FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)
              OLD_MESH_COMPONENT_NUMBER_LOCKED(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)= &
                & FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(1:NUMBER_OF_COMPONENTS,1:FIELD_NUMBER_OF_VARIABLE_TYPES)
              FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES=0
              FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS=""
              FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED=.FALSE.
              FIELD%CREATE_VALUES_CACHE%DIMENSION=0
              FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED=.FALSE.
              FIELD%CREATE_VALUES_CACHE%DATA_TYPES=0
              FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED=.FALSE.
              FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES=0
              FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED=.FALSE.
              FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS=0
              FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED=.FALSE.
              FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE=0
              FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED=.FALSE.
              FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER=0
              FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED=.FALSE.
              DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES                
                variable_type=VARIABLE_TYPES(variable_idx)
                old_variable_type=OLD_VARIABLE_TYPES(variable_idx)
                FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS(variable_type)=OLD_LABELS(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%VARIABLE_LABELS_LOCKED(variable_type)=OLD_LABELS_LOCKED(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%DIMENSION(variable_type)=OLD_DIMENSION(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%DIMENSION_LOCKED(variable_type)=OLD_DIMENSION_LOCKED(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%DATA_TYPES(variable_type)=OLD_DATA_TYPES(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%DATA_TYPES_LOCKED(variable_type)=OLD_DATA_TYPES_LOCKED(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES(variable_type)=OLD_DOF_ORDER_TYPES(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%DOF_ORDER_TYPES_LOCKED(variable_type)=OLD_DOF_ORDER_TYPES_LOCKED(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS(variable_type)=OLD_NUMBER_OF_COMPONENTS(old_variable_type)
                FIELD%CREATE_VALUES_CACHE%NUMBER_OF_COMPONENTS_LOCKED(variable_type)=OLD_NUMBER_OF_COMPONENTS_LOCKED( &
                  & old_variable_type)
                FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE(:,variable_type)=OLD_INTERPOLATION_TYPE(:,old_variable_type)
                FIELD%CREATE_VALUES_CACHE%INTERPOLATION_TYPE_LOCKED(:,variable_type)=OLD_INTERPOLATION_TYPE_LOCKED(:, &
                  & old_variable_type)
                FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER(:,variable_type)=OLD_MESH_COMPONENT_NUMBER(:,old_variable_type)
                FIELD%CREATE_VALUES_CACHE%MESH_COMPONENT_NUMBER_LOCKED(:,variable_type)=OLD_MESH_COMPONENT_NUMBER_LOCKED(:, &
                  & old_variable_type)
              ENDDO !variable_idx
              FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES(1:SIZE(VARIABLE_TYPES,1))=VARIABLE_TYPES(1:SIZE(VARIABLE_TYPES,1))
              DEALLOCATE(OLD_VARIABLE_TYPES)
              DEALLOCATE(OLD_INTERPOLATION_TYPE)
              DEALLOCATE(OLD_INTERPOLATION_TYPE_LOCKED)
              DEALLOCATE(OLD_MESH_COMPONENT_NUMBER)
              DEALLOCATE(OLD_MESH_COMPONENT_NUMBER_LOCKED)              
            ELSE
              LOCAL_ERROR="Invalid variable types. The size of the specified variable types array is "// &
                & TRIM(NUMBER_TO_VSTRING(SIZE(VARIABLE_TYPES,1),"*",ERR,ERROR))// &
                & " and the number of variables for field number "//TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))// &
                & " is "//TRIM(NUMBER_TO_VSTRING(FIELD%NUMBER_OF_VARIABLES,"*",ERR,ERROR))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
            ENDIF
          ENDIF
        ELSE
          LOCAL_ERROR="Field create values cache is not associated for field number "// &
            & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
        ENDIF
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_VARIABLE_TYPES_SET")
    RETURN
999 IF(ALLOCATED(OLD_VARIABLE_TYPES)) DEALLOCATE(OLD_VARIABLE_TYPES)
    IF(ALLOCATED(OLD_INTERPOLATION_TYPE)) DEALLOCATE(OLD_INTERPOLATION_TYPE)
    IF(ALLOCATED(OLD_INTERPOLATION_TYPE_LOCKED)) DEALLOCATE(OLD_INTERPOLATION_TYPE_LOCKED)
    IF(ALLOCATED(OLD_MESH_COMPONENT_NUMBER)) DEALLOCATE(OLD_MESH_COMPONENT_NUMBER)
    IF(ALLOCATED(OLD_MESH_COMPONENT_NUMBER_LOCKED)) DEALLOCATE(OLD_MESH_COMPONENT_NUMBER_LOCKED)
    CALL ERRORS("FIELD_VARIABLE_TYPES_SET",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_TYPES_SET")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_TYPES_SET

  !
  !================================================================================================================================
  !

  !>Sets/changes the field variable types for a field and locks it so that no further changes can be made.
  SUBROUTINE FIELD_VARIABLE_TYPES_SET_AND_LOCK(FIELD,VARIABLE_TYPES,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to set the type for
    INTEGER(INTG), INTENT(IN) :: VARIABLE_TYPES(:) !<VARIABLE_TYPES(variable_idx). The field variable type for the variable_idx'th field variable to set 
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_VARIABLE_TYPES_SET_AND_LOCK",ERR,ERROR,*999)
    
    CALL FIELD_VARIABLE_TYPES_SET(FIELD,VARIABLE_TYPES,ERR,ERROR,*999)
    IF(ASSOCIATED(FIELD)) THEN
      IF(ASSOCIATED(FIELD%CREATE_VALUES_CACHE)) THEN
        FIELD%CREATE_VALUES_CACHE%VARIABLE_TYPES_LOCKED=.TRUE.
      ELSE
        LOCAL_ERROR="Field create values cache is not associated for field number "// &
          & TRIM(NUMBER_TO_VSTRING(FIELD%USER_NUMBER,"*",ERR,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,ERR,ERROR,*999)
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_VARIABLE_TYPES_SET_AND_LOCK")
    RETURN
999 CALL ERRORS("FIELD_VARIABLE_TYPES_SET_AND_LOCK",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLE_TYPES_SET_AND_LOCK")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLE_TYPES_SET_AND_LOCK

  !
  !================================================================================================================================
  !

  !>Checks for a valid setup of the field variables
  SUBROUTINE FieldVariablesCheck(field,err,error,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: field !<A pointer to the field to check the variables for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: error !<The error string
    !Local Variables
    INTEGER(INTG) :: variableIdx,variableIdx2,variableType,variableType2
    LOGICAL :: duplicates
    TYPE(VARYING_STRING) :: localError

    CALL Enters("FieldVariablesCheck",err,error,*999)

    IF(ASSOCIATED(field)) THEN
      IF(ASSOCIATED(field%CREATE_VALUES_CACHE)) THEN
        !Check the number of field variables
        IF(field%NUMBER_OF_VARIABLES>0) THEN
          !Check that the variable types are unique. Just do an exhaustive check. It is expensive but the list should be short.
          duplicates=.FALSE.
          firstVariable: DO variableIdx=1,field%NUMBER_OF_VARIABLES
            variableType=field%CREATE_VALUES_CACHE%VARIABLE_TYPES(variableIdx)
            secondVariable: DO variableIdx2=variableIdx+1,field%NUMBER_OF_VARIABLES
              variableType2=field%CREATE_VALUES_CACHE%VARIABLE_TYPES(variableIdx2)
              IF(variableType==variableType2) THEN
                duplicates=.TRUE.
                EXIT firstVariable
              ENDIF
            ENDDO secondVariable !variableIdx2
          ENDDO firstVariable !variableIdx
          IF(duplicates) THEN
            localError="Invalid variable types. Two or more variables have variable type "// &
              & TRIM(NumberToVString(variableType,"*",err,error))//"."
            CALL FlagError(localError,err,error,*999)
          ENDIF
        ELSE
          localError="Invalid field setup. The field has "//TRIM(NumberToVString(field%NUMBER_OF_VARIABLES,"*",err,error))// &
            & " variables and should have > 0 variables."
          CALL FlagError(localError,err,error,*999)
        ENDIF
      ELSE
        CALL FlagError("Field create values cache is not associated.",err,error,*999)
      ENDIF
    ELSE
      CALL FlagError("Field is not associated.",err,error,*999)
    ENDIF

    CALL Exits("FieldVariablesCheck")
    RETURN
999 CALL Errors("FieldVariablesCheck",err,error)
    CALL Exits("FieldVariablesCheck")
    RETURN 1
    
  END SUBROUTINE FieldVariablesCheck

  !
  !================================================================================================================================
  !

  !>Finalises the field variables for a field and deallocates all memory.
  SUBROUTINE FIELD_VARIABLES_FINALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to finalise the variables for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx

    CALL ENTERS("FIELD_VARIABLES_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ALLOCATED(FIELD%VARIABLES)) THEN
        DO variable_idx=1,SIZE(FIELD%VARIABLES,1)
          CALL FIELD_VARIABLE_FINALISE(FIELD%VARIABLES(variable_idx),ERR,ERROR,*999)
        ENDDO !variable_idx
        DEALLOCATE(FIELD%VARIABLES)
      ENDIF
      FIELD%NUMBER_OF_VARIABLES=0
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_VARIABLES_FINALISE")
    RETURN
999 CALL ERRORS("FIELD_VARIABLES_FINALISE",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLES_FINALISE")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLES_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the field variables.
  SUBROUTINE FIELD_VARIABLES_INITIALISE(FIELD,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELD_TYPE), POINTER :: FIELD !<A pointer to the field to initialise the variables for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    INTEGER(INTG) :: variable_idx

    CALL ENTERS("FIELD_VARIABLES_INITIALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELD)) THEN
      IF(ALLOCATED(FIELD%VARIABLES)) THEN
        CALL FLAG_ERROR("Field already has associated variables.",ERR,ERROR,*999)
      ELSE
        ALLOCATE(FIELD%VARIABLES(FIELD%NUMBER_OF_VARIABLES),STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Could not allocate new field variables.",ERR,ERROR,*999)
        DO variable_idx=1,FIELD%NUMBER_OF_VARIABLES
          CALL FIELD_VARIABLE_INITIALISE(FIELD,variable_idx,ERR,ERROR,*999)
        ENDDO !variable_idx
      ENDIF
    ELSE
      CALL FLAG_ERROR("Field is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELD_VARIABLES_INITIALISE")
    RETURN
999 CALL ERRORS("FIELD_VARIABLES_INITIALISE",ERR,ERROR)
    CALL EXITS("FIELD_VARIABLES_INITIALISE")
    RETURN 1
  END SUBROUTINE FIELD_VARIABLES_INITIALISE

  !
  !================================================================================================================================
  !

  !>Finalises the fields and deallocates all memory.
  SUBROUTINE FIELDS_FINALISE(FIELDS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELDS_TYPE), POINTER :: FIELDS !<A pointer to the fields to finalise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables
    TYPE(FIELD_TYPE), POINTER :: FIELD

    CALL ENTERS("FIELDS_FINALISE",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELDS)) THEN
      DO WHILE(FIELDS%NUMBER_OF_FIELDS>0)
        FIELD=>FIELDS%FIELDS(1)%PTR
        CALL FIELD_DESTROY(FIELD,ERR,ERROR,*999)
      ENDDO !field_idx
      DEALLOCATE(FIELDS)
    ENDIF
    
    CALL EXITS("FIELDS_FINALISE")
    RETURN
999 CALL ERRORS("FIELDS_FINALISE",ERR,ERROR)
    CALL EXITS("FIELDS_FINALISE")
    RETURN 1
  END SUBROUTINE FIELDS_FINALISE

  !
  !================================================================================================================================
  !

  !>Initialises the fields.
  SUBROUTINE FIELDS_INITIALISE_GENERIC(FIELDS,ERR,ERROR,*)

    !Argument variables
    TYPE(FIELDS_TYPE), POINTER :: FIELDS !<A pointer to the fields to initialise
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELDS_INITIALISE_GENERIC",ERR,ERROR,*999)

    IF(ASSOCIATED(FIELDS)) THEN
      NULLIFY(FIELDS%REGION)
      NULLIFY(FIELDS%INTERFACE)
      FIELDS%NUMBER_OF_FIELDS=0
      NULLIFY(FIELDS%FIELDS)
    ELSE
      CALL FLAG_ERROR("Fields is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELDS_INITIALISE_GENERIC")
    RETURN
999 CALL ERRORS("FIELDS_INITIALISE_GENERIC",ERR,ERROR)
    CALL EXITS("FIELDS_INITIALISE_GENERIC")
    RETURN 1
  END SUBROUTINE FIELDS_INITIALISE_GENERIC

  !
  !================================================================================================================================
  !

  !>Initialises the fields for the given interface.
  SUBROUTINE FIELDS_INITIALISE_INTERFACE(INTERFACE,ERR,ERROR,*)

    !Argument variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE !<A pointer to the interface to initialise the fields for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELDS_INITIALISE_INTERFACE",ERR,ERROR,*999)

    IF(ASSOCIATED(INTERFACE)) THEN
      IF(ASSOCIATED(INTERFACE%FIELDS)) THEN
        CALL FLAG_ERROR("Interface already has fields associated.",ERR,ERROR,*999)
      ELSE
        ALLOCATE(INTERFACE%FIELDS,STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Interface fields could not be allocated.",ERR,ERROR,*999)
        CALL FIELDS_INITIALISE_GENERIC(INTERFACE%FIELDS,ERR,ERROR,*999)
        INTERFACE%FIELDS%INTERFACE=>INTERFACE
      ENDIF
    ELSE
      CALL FLAG_ERROR("Interface is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELDS_INITIALISE_INTERFACE")
    RETURN
999 CALL ERRORS("FIELDS_INITIALISE_INTERFACE",ERR,ERROR)
    CALL EXITS("FIELDS_INITIALISE_INTERFACE")
    RETURN 1
  END SUBROUTINE FIELDS_INITIALISE_INTERFACE

  !
  !================================================================================================================================
  !

  !>Initialises the fields for the given region.
  SUBROUTINE FIELDS_INITIALISE_REGION(REGION,ERR,ERROR,*)

    !Argument variables
    TYPE(REGION_TYPE), POINTER :: REGION !<A pointer to the region to initialise the fields for
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string
    !Local Variables

    CALL ENTERS("FIELDS_INITIALISE_REGION",ERR,ERROR,*999)

    IF(ASSOCIATED(REGION)) THEN
      IF(ASSOCIATED(REGION%FIELDS)) THEN
        CALL FLAG_ERROR("Region already has fields associated.",ERR,ERROR,*999)
      ELSE
        ALLOCATE(REGION%FIELDS,STAT=ERR)
        IF(ERR/=0) CALL FLAG_ERROR("Region fields could not be allocated.",ERR,ERROR,*999)
        CALL FIELDS_INITIALISE_GENERIC(REGION%FIELDS,ERR,ERROR,*999)
        REGION%FIELDS%REGION=>REGION
      ENDIF
    ELSE
      CALL FLAG_ERROR("Region is not associated.",ERR,ERROR,*999)
    ENDIF

    CALL EXITS("FIELDS_INITIALISE_REGION")
    RETURN
999 CALL ERRORS("FIELDS_INITIALISE_REGION",ERR,ERROR)
    CALL EXITS("FIELDS_INITIALISE_REGION")
    RETURN 1
  END SUBROUTINE FIELDS_INITIALISE_REGION

  !
  !================================================================================================================================
  !

  !> Interpolates data from one field/mesh to another
  SUBROUTINE MESH_EMBEDDING_PUSH_DATA(MESH_EMBEDDING,PARENT_FIELD,PARENT_COMPONENT,CHILD_FIELD,CHILD_COMPONENT,ERR,ERROR,*)
    TYPE(MESH_EMBEDDING_TYPE), INTENT(INOUT) :: MESH_EMBEDDING !<The mesh embedding object
    INTEGER(INTG), INTENT(OUT) :: ERR              !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR     !<The error string
    TYPE(FIELD_TYPE), POINTER :: PARENT_FIELD      !<Field for the parent nodes
    TYPE(FIELD_TYPE), POINTER :: CHILD_FIELD       !<Field for the child nodes
    INTEGER(INTG), INTENT(IN) :: PARENT_COMPONENT  !<Component of the parent field, must be nodally based
    INTEGER(INTG), INTENT(IN) ::  CHILD_COMPONENT  !<Component of the child  field, must be nodally based

    !Local variables
    TYPE(MESH_ELEMENT_TYPE), POINTER :: ELEMENT
    TYPE(BASIS_TYPE), POINTER :: BASIS
    INTEGER(INTG) :: E,I,B,version
    REAL(DP) :: INTERP_VAL, WT
    REAL(DP),ALLOCATABLE :: PARENT_VALUES(:)

    CALL ENTERS("MESH_EMBEDDING_PUSH_DATA",ERR,ERROR,*999)
    version=1
    DO E=1,MESH_EMBEDDING%PARENT_MESH%NUMBER_OF_ELEMENTS
      ELEMENT=>MESH_EMBEDDING%PARENT_MESH%TOPOLOGY(1)%PTR%ELEMENTS%ELEMENTS(E)
      BASIS=>ELEMENT%BASIS
      ALLOCATE(PARENT_VALUES(BASIS%NUMBER_OF_NODES))

      DO B=1,BASIS%NUMBER_OF_NODES
        ! Version variable added and initialized above
        CALL FIELD_PARAMETER_SET_GET_NODE(PARENT_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,version,1,& ! TODO: FROM INPUT
        &  ELEMENT%GLOBAL_ELEMENT_NODES(B),PARENT_COMPONENT,PARENT_VALUES(B),ERR,ERROR,*999)   ! global no?
      ENDDO


      DO I=1,MESH_EMBEDDING%CHILD_NODE_XI_POSITION(E)%NUMBER_OF_NODES
        INTERP_VAL = 0.0
        DO B=1,BASIS%NUMBER_OF_NODES
          WT = BASIS_EVALUATE_XI(BASIS,B,NO_PART_DERIV,MESH_EMBEDDING%CHILD_NODE_XI_POSITION(E)%XI_COORDS(:,I),ERR,ERROR)
          INTERP_VAL = INTERP_VAL + WT * PARENT_VALUES(B)
        ENDDO

        ! store in field
        ! Version variable added and initialized above
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(CHILD_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,version,1,& ! TODO: FROM INPUT
        &  MESH_EMBEDDING%CHILD_NODE_XI_POSITION(E)%NODE_NUMBERS(I),CHILD_COMPONENT,INTERP_VAL,ERR,ERROR,*999) 
      ENDDO
      DEALLOCATE(PARENT_VALUES)
    ENDDO

    RETURN
999 CALL ERRORS("MESH_EMBEDDING_PUSH_DATA",ERR,ERROR)
    CALL EXITS("MESH_EMBEDDING_PUSH_DATA")
    RETURN 1
  END SUBROUTINE MESH_EMBEDDING_PUSH_DATA

  !  
  !================================================================================================================================
  !  

  SUBROUTINE MESH_EMBEDDING_PULL_GAUSS_POINT_DATA(MESH_EMBEDDING,PARENT_FIELD,PARENT_COMPONENT,CHILD_FIELD,CHILD_COMPONENT,&
    & ERR,ERROR,*)
    
    TYPE(MESH_EMBEDDING_TYPE), INTENT(INOUT) :: MESH_EMBEDDING !<The mesh embedding object
    INTEGER(INTG), INTENT(OUT) :: ERR              !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR     !<The error string
    TYPE(FIELD_TYPE), POINTER :: PARENT_FIELD      !<Field for the parent nodes
    TYPE(FIELD_TYPE), POINTER :: CHILD_FIELD       !<Field for the child nodes
    INTEGER(INTG), INTENT(IN) :: PARENT_COMPONENT  !<Component of the parent field, must be nodally based
    INTEGER(INTG), INTENT(IN) ::  CHILD_COMPONENT  !<Component of the child  field, must be nodally based

    !Local variables
    TYPE(MeshElementsType), POINTER :: ELEMENTS
    TYPE(MESH_ELEMENT_TYPE), POINTER :: ELEMENT
    TYPE(BASIS_TYPE), POINTER :: BASIS
    INTEGER(INTG) :: E,GP,B, NGP,version
    REAL(DP) :: INTERP_VAL, WT, VAL

    CALL ENTERS("MESH_EMBEDDING_PULL_GAUSS_POINT_DATA",ERR,ERROR,*999)

    ELEMENTS=>MESH_EMBEDDING%CHILD_MESH%TOPOLOGY(1)%PTR%ELEMENTS

    BASIS=>MESH_EMBEDDING%CHILD_MESH%TOPOLOGY(1)%PTR%ELEMENTS%ELEMENTS(1)%BASIS
    version = 1
    DO E=1,MESH_EMBEDDING%PARENT_MESH%NUMBER_OF_ELEMENTS    
      NGP = BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%PTR%NUMBER_OF_GAUSS
      DO GP=1,NGP
        ELEMENT=>ELEMENTS%ELEMENTS(MESH_EMBEDDING%GAUSS_POINT_XI_POSITION(GP,E)%ELEMENT_NUMBER)
        BASIS=>ELEMENT%BASIS
        DO B=1,BASIS%NUMBER_OF_NODES
          ! Version variable added and initialized above
          CALL FIELD_PARAMETER_SET_GET_NODE(CHILD_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,version,1,& ! TODO: FROM INPUT
          &  ELEMENT%GLOBAL_ELEMENT_NODES(B),CHILD_COMPONENT,VAL ,ERR,ERROR,*999)   ! global no?
          WT = BASIS_EVALUATE_XI(BASIS,B,NO_PART_DERIV,MESH_EMBEDDING%GAUSS_POINT_XI_POSITION(GP,E)%CHILD_XI_COORD,ERR,ERROR) 
          INTERP_VAL = INTERP_VAL + WT * VAL
        ENDDO       
         ! store in gauss point parent field 
        CALL FIELD_PARAMETER_SET_UPDATE_GAUSS_POINT(PARENT_FIELD,FIELD_U_VARIABLE_TYPE,FIELD_VALUES_SET_TYPE,E,GP,& ! TODO: var type/par set from input
          &  PARENT_COMPONENT, INTERP_VAL,ERR,ERROR,*999) 
      ENDDO
    ENDDO

    RETURN
999 CALL ERRORS("MESH_EMBEDDING_PULL_GAUSS_POINT_DATA",ERR,ERROR)
    CALL EXITS("MESH_EMBEDDING_PULL_GAUSS_POINT_DATA")
    RETURN 1
  END SUBROUTINE MESH_EMBEDDING_PULL_GAUSS_POINT_DATA

  !
  !================================================================================================================================
  !

 !>Returns from the given parameter set a double precision value for the specified gauss point of a field variable component. \see OPENCMISS::CMISSFieldParameterSetGetGaussPoint
  SUBROUTINE FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD(MESH_EMBEDDING,COMPONENT_NUMBER,NGP,COORD_VALUE, &
    & ERR,ERROR,*)
    
    TYPE(MESH_EMBEDDING_TYPE), INTENT(INOUT) :: MESH_EMBEDDING !<The mesh embedding object
    INTEGER(INTG), INTENT(IN) :: COMPONENT_NUMBER  !<Component
    INTEGER(INTG), INTENT(OUT) :: NGP
    REAL(DP), INTENT(OUT) :: COORD_VALUE(:)
    INTEGER(INTG), INTENT(OUT) :: ERR              !<The error code
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR     !<The error string
  
    !Local variables
    TYPE(MeshElementsType), POINTER :: ELEMENTS
    TYPE(BASIS_TYPE), POINTER :: BASIS
    INTEGER(INTG) :: GP

    CALL ENTERS("FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD",ERR,ERROR,*999)

    ELEMENTS=>MESH_EMBEDDING%PARENT_MESH%TOPOLOGY(1)%PTR%ELEMENTS

    BASIS=>MESH_EMBEDDING%PARENT_MESH%TOPOLOGY(1)%PTR%ELEMENTS%ELEMENTS(1)%BASIS
    NGP = BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%PTR%NUMBER_OF_GAUSS

    DO GP = 1,NGP
    COORD_VALUE(GP) = BASIS%QUADRATURE%QUADRATURE_SCHEME_MAP(BASIS_DEFAULT_QUADRATURE_SCHEME)%PTR%&
       &GAUSS_POSITIONS(COMPONENT_NUMBER,GP)
    ENDDO

999 CALL ERRORS("FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD",ERR,ERROR)
    CALL EXITS("FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD")
    RETURN 1
  END SUBROUTINE FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD

  !
  !================================================================================================================================
  !

  !> Find the field with the given user number, or throw an error if it does not exist.
  SUBROUTINE FIELD_USER_NUMBER_TO_FIELD_REGION( USER_NUMBER, REGION, FIELD, ERR, ERROR, * )
    !Arguments
    INTEGER(INTG), INTENT(IN) :: USER_NUMBER !<The user number of the field to find
    TYPE(REGION_TYPE), POINTER :: REGION !<The region containing the field
    TYPE(FIELD_TYPE), POINTER :: FIELD !<On exit, a pointer to the field with the specified user number.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string

    !Locals
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_USER_NUMBER_TO_FIELD_REGION", ERR, ERROR, *999 )

    NULLIFY( FIELD )
    CALL FIELD_USER_NUMBER_FIND( USER_NUMBER, REGION, FIELD, ERR, ERROR, *999 )
      CALL FIELD_USER_NUMBER_FIND( USER_NUMBER, REGION, FIELD, ERR, ERROR, *999 )
    IF( .NOT.ASSOCIATED( FIELD ) ) THEN
      LOCAL_ERROR = "A field with an user number of "//TRIM(NUMBER_TO_VSTRING( USER_NUMBER, "*", ERR, ERROR ))// &
        & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING( REGION%USER_NUMBER, "*", ERR, ERROR ))//"."
      CALL FLAG_ERROR( LOCAL_ERROR, ERR, ERROR, *999 )
    ENDIF

    CALL EXITS( "FIELD_USER_NUMBER_TO_FIELD_REGION" )
    RETURN
999 CALL ERRORS( "FIELD_USER_NUMBER_TO_FIELD_REGION", ERR, ERROR )
    CALL EXITS( "FIELD_USER_NUMBER_TO_FIELD_REGION" )
    RETURN 1

  END SUBROUTINE FIELD_USER_NUMBER_TO_FIELD_REGION

  !
  !================================================================================================================================
  !

  !> Find the field with the given user number, or throw an error if it does not exist.
  SUBROUTINE FIELD_USER_NUMBER_TO_FIELD_INTERFACE( USER_NUMBER, INTERFACE, FIELD, ERR, ERROR, * )
    !Arguments
    INTEGER(INTG), INTENT(IN) :: USER_NUMBER !<The user number of the field to find
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE !<A pointer to the interface containing the field
    TYPE(FIELD_TYPE), POINTER :: FIELD !<On exit, a pointer to the field with the specified user number.
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code.
    TYPE(VARYING_STRING), INTENT(OUT) :: ERROR !<The error string

    !Locals
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("FIELD_USER_NUMBER_TO_FIELD_INTERFACE", ERR, ERROR, *999 )

    NULLIFY( FIELD )
    CALL FIELD_USER_NUMBER_FIND( USER_NUMBER, INTERFACE, FIELD, ERR, ERROR, *999 )
      CALL FIELD_USER_NUMBER_FIND( USER_NUMBER, INTERFACE, FIELD, ERR, ERROR, *999 )
    IF( .NOT.ASSOCIATED( FIELD ) ) THEN
      LOCAL_ERROR = "A field with an user number of "//TRIM(NUMBER_TO_VSTRING( USER_NUMBER, "*", ERR, ERROR ))// &
        & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING( INTERFACE%USER_NUMBER, "*", ERR, ERROR ))//"."
      CALL FLAG_ERROR( LOCAL_ERROR, ERR, ERROR, *999 )
    ENDIF

    CALL EXITS( "FIELD_USER_NUMBER_TO_FIELD_INTERFACE" )
    RETURN
999 CALL ERRORS( "FIELD_USER_NUMBER_TO_FIELD_INTERFACE", ERR, ERROR )
    CALL EXITS( "FIELD_USER_NUMBER_TO_FIELD_INTERFACE" )
    RETURN 1

  END SUBROUTINE FIELD_USER_NUMBER_TO_FIELD_INTERFACE

  !
  !================================================================================================================================
  !

END MODULE FIELD_ROUTINES
