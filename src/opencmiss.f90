!> \file
!> \author Chris Bradley
!> \brief The top level OpenCMISS module.
!>
!> \mainpage OpenCMISS Documentation
!>
!> An open source interactive computer program for Continuum Mechanics, Image analysis, Signal processing and System
!> Identification. Target usage: Bioengineering application of finite element analysis, boundary element and collocation
!> techniques.
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand, the University of Oxford, Oxford, United
!> Kingdom and King's College, London, United Kingdom. Portions created
!> by the University of Auckland, the University of Oxford and King's
!> College, London are Copyright (C) 2007-2010 by the University of
!> Auckland, the University of Oxford and King's College, London.
!> All Rights Reserved.
!>
!> Contributor(s):
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>
!>
!> The top level OpenCMISS module. This module is the buffer module between the OpenCMISS library and user code.
MODULE OPENCMISS

  USE ANALYTIC_ANALYSIS_ROUTINES
  USE BASE_ROUTINES
  USE BASIS_ROUTINES
  USE BIOELECTRIC_FINITE_ELASTICITY_ROUTINES
  USE BOUNDARY_CONDITIONS_ROUTINES
  USE CMISS
  USE CMISS_CELLML
  USE COMP_ENVIRONMENT
  USE CONSTANTS
  USE CONTROL_LOOP_ROUTINES
  USE COORDINATE_ROUTINES
  USE DATA_POINT_ROUTINES
  USE DATA_PROJECTION_ROUTINES
  USE DISTRIBUTED_MATRIX_VECTOR
  USE EQUATIONS_ROUTINES
  USE EQUATIONS_SET_CONSTANTS
  USE EQUATIONS_SET_ROUTINES
  USE FIELD_ROUTINES
#ifdef USEFIELDML
  USE FIELDML_TYPES
  USE FIELDML_INPUT_ROUTINES
  USE FIELDML_OUTPUT_ROUTINES
  USE FIELDML_UTIL_ROUTINES
#endif
  USE FIELD_IO_ROUTINES
  USE FINITE_ELASTICITY_ROUTINES
  USE GENERATED_MESH_ROUTINES
  USE HAMILTON_JACOBI_EQUATIONS_ROUTINES
  USE HISTORY_ROUTINES
  USE INPUT_OUTPUT
  USE INTERFACE_ROUTINES
  USE INTERFACE_CONDITIONS_CONSTANTS
  USE INTERFACE_CONDITIONS_ROUTINES
  USE INTERFACE_EQUATIONS_ROUTINES
  USE INTERFACE_MATRICES_CONSTANTS
  USE INTERFACE_MATRICES_ROUTINES
  USE ISO_C_BINDING
  USE ISO_VARYING_STRING
  USE KINDS
  USE MESH_ROUTINES
  USE NODE_ROUTINES
  USE PROBLEM_CONSTANTS
  USE PROBLEM_ROUTINES
  USE REGION_ROUTINES
  USE SOLVER_ROUTINES
  USE STRINGS
  USE TYPES

  IMPLICIT NONE

  PRIVATE

#include "include/petscversion.h"
  
  !Module parameters

  !Module types

  !>Contains information about a basis function.
  TYPE CMISSBasisType
    PRIVATE
    TYPE(BASIS_TYPE), POINTER :: BASIS
  END TYPE CMISSBasisType

  !>Contains information on the boundary conditions for the equations set.
  TYPE CMISSBoundaryConditionsType
    PRIVATE
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
  END TYPE CMISSBoundaryConditionsType

  !>Contains information on a CellML environment.
  TYPE CMISSCellMLType
    PRIVATE
    TYPE(CELLML_TYPE), POINTER :: CELLML
  END TYPE CMISSCellMLType

  !>Contains information about the CellML equations for a solver.
  TYPE CMISSCellMLEquationsType
    PRIVATE
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS
  END TYPE CMISSCellMLEquationsType

  !>Contains information on a control loop.
  TYPE CMISSControlLoopType
    PRIVATE
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
  END TYPE CMISSControlLoopType

  !>Contains information on a coordinate system.
  TYPE CMISSCoordinateSystemType
    PRIVATE
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
  END TYPE CMISSCoordinateSystemType

  !>Contains information on the data points defined on a region.
  TYPE CMISSDataPointsType
    PRIVATE
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
  END TYPE CMISSDataPointsType

  !>Contains information about a data projection.
  TYPE CMISSDataProjectionType
    PRIVATE
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
  END TYPE CMISSDataProjectionType

  !>Contains information on the mesh decomposition.
  TYPE CMISSDecompositionType
    PRIVATE
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
  END TYPE CMISSDecompositionType

  !>Contains information about the equations in an equations set.
  TYPE CMISSEquationsType
    PRIVATE
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
  END TYPE CMISSEquationsType

  !>Contains information on an equations set defined on a region.
  TYPE CMISSEquationsSetType
    PRIVATE
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
  END TYPE CMISSEquationsSetType

  !>Contains information for a field defined on a region.
  TYPE CMISSFieldType
    PRIVATE
    TYPE(FIELD_TYPE), POINTER :: FIELD
  END TYPE CMISSFieldType

  !>Contains information for a fields defined on a region.
  TYPE CMISSFieldsType
    !PRIVATE
    TYPE(FIELDS_TYPE), POINTER :: FIELDS
  END TYPE CMISSFieldsType

  !>Contains information on a generated mesh.
  TYPE CMISSGeneratedMeshType
    PRIVATE
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
  END TYPE CMISSGeneratedMeshType

  !>Contains information about a history file for a control loop.
  TYPE CMISSHistoryType
    PRIVATE
    TYPE(HISTORY_TYPE), POINTER :: HISTORY
  END TYPE CMISSHistoryType

  !>Contains information about an interface.
  TYPE CMISSInterfaceType
    PRIVATE
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
  END TYPE CMISSInterfaceType

  !>Contains information about an interface condition.
  TYPE CMISSInterfaceConditionType
    PRIVATE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
  END TYPE CMISSInterfaceConditionType

  !>Contains information about an interface condition.
  TYPE CMISSInterfaceEquationsType
    PRIVATE
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
  END TYPE CMISSInterfaceEquationsType

   !>Contains information on an interfaces meshes connectivity.
  TYPE CMISSInterfaceMeshConnectivityType
    PRIVATE
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: MESH_CONNECTIVITY
  END TYPE CMISSInterfaceMeshConnectivityType
  
  !>Contains information on an interfaces points connectivity.
  TYPE CMISSInterfacePointsConnectivityType
    PRIVATE
    TYPE(InterfacePointsConnectivityType), POINTER :: pointsConnectivity
  END TYPE CMISSInterfacePointsConnectivityType

  !>A matrix that may be distributed across multiple computational nodes
  !>and may use sparse or full storage.
  TYPE CMISSDistributedMatrixType
    PRIVATE
    TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: distributedMatrix
  END TYPE CMISSDistributedMatrixType

  !>A vector that may be distributed across multiple computational nodes
  TYPE CMISSDistributedVectorType
    PRIVATE
    TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: distributedVector
  END TYPE CMISSDistributedVectorType

  !>Contains information on a mesh defined on a region.
  TYPE CMISSMeshType
    PRIVATE
    TYPE(MESH_TYPE), POINTER :: MESH
  END TYPE CMISSMeshType

  !>Contains information on a mesh elements defined in a mesh
  TYPE CMISSMeshElementsType
    PRIVATE
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
  END TYPE CMISSMeshElementsType

  !>Contains information on an embedded mesh
  TYPE CMISSMeshEmbeddingType
    PRIVATE
    TYPE(MESH_EMBEDDING_TYPE), POINTER :: MESH_EMBEDDING
  END TYPE CMISSMeshEmbeddingType

  !>Contains information on a mesh nodes defined in a mesh
  TYPE CMISSMeshNodesType
    PRIVATE
    TYPE(MeshNodesType), POINTER :: meshNodes
  END TYPE CMISSMeshNodesType

  !>Contains information on the nodes defined on a region.
  TYPE CMISSNodesType
    PRIVATE
    TYPE(NODES_TYPE), POINTER :: NODES
  END TYPE CMISSNodesType

  !>Contains information for a problem.
  TYPE CMISSProblemType
    PRIVATE
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
  END TYPE CMISSProblemType

  !>Contains information for a particular quadrature scheme for a basis.
  TYPE CMISSQuadratureType
    PRIVATE
    TYPE(QUADRATURE_TYPE), POINTER :: QUADRATURE
  END TYPE CMISSQuadratureType

 !>Contains information for a region.
  TYPE CMISSRegionType
    PRIVATE
    TYPE(REGION_TYPE), POINTER :: REGION
  END TYPE CMISSRegionType

  !>Contains information about a solver.
  TYPE CMISSSolverType
    PRIVATE
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
  END TYPE CMISSSolverType

  !>Contains information about the solver equations for a solver.
  TYPE CMISSSolverEquationsType
    PRIVATE
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
  END TYPE CMISSSolverEquationsType

  !>Contains information on a computational work group
  TYPE CMISSComputationalWorkGroupType
    PRIVATE
    TYPE(COMPUTATIONAL_WORK_GROUP_TYPE), POINTER :: COMPUTATIONAL_WORK_GROUP
  END TYPE CMISSComputationalWorkGroupType

  !Module variables

  TYPE(VARYING_STRING) :: error

  !Interface CMISS_Finalise_
  !  MODULE PROCEDURE CMISSFinalise
  !END INTERFACE !CMISS_Finalise_

  INTERFACE CMISSInitialise
    MODULE PROCEDURE CMISSInitialiseNumber
    MODULE PROCEDURE CMISSInitialiseObj
  END INTERFACE !CMISSInitialise

  INTERFACE CMISSFields_Create
    MODULE PROCEDURE CMISSFields_CreateInterface
    MODULE PROCEDURE CMISSFields_CreateRegion
  END INTERFACE !CMISSFields_Create

  !PUBLIC CMISS_Finalise,CMISS_Initialise
  PUBLIC CMISSFinalise,CMISSInitialise

  PUBLIC CMISSBasisType,CMISSBasisTypesCopy,CMISSBasis_Finalise,CMISSBasis_Initialise

  PUBLIC CMISSBoundaryConditionsType,CMISSBoundaryConditions_Finalise,CMISSBoundaryConditions_Initialise

  PUBLIC CMISSCellMLType,CMISSCellML_Finalise,CMISSCellML_Initialise

  PUBLIC CMISSCellMLEquationsType,CMISSCellMLEquations_Finalise,CMISSCellMLEquations_Initialise

  PUBLIC CMISSComputationalWorkGroupType,CMISSComputationalWorkGroup_Initialise

  PUBLIC CMISSControlLoopType,CMISSControlLoop_Finalise,CMISSControlLoop_Initialise,CMISSControlLoop_LoadOutputSet

  PUBLIC CMISSCoordinateSystemType,CMISSCoordinateSystem_Finalise,CMISSCoordinateSystem_Initialise

  PUBLIC CMISSDataPointsType,CMISSDataPoints_Finalise,CMISSDataPoints_Initialise

  PUBLIC CMISSDataProjectionType,CMISSDataProjection_Finalise,CMISSDataProjection_Initialise

  PUBLIC CMISSDecompositionType,CMISSDecomposition_Finalise,CMISSDecomposition_Initialise

  PUBLIC CMISSDecomposition_CalculateFacesSet,CMISSDecomposition_CalculateLinesSet

  PUBLIC CMISSEquationsType,CMISSEquations_Finalise,CMISSEquations_Initialise

  PUBLIC CMISSEquationsSetType,CMISSEquationsSet_Finalise,CMISSEquationsSet_Initialise

  PUBLIC CMISSFieldType,CMISSField_Finalise,CMISSField_Initialise

  PUBLIC CMISSFieldsType,CMISSFields_Create,CMISSFields_Finalise,CMISSFields_Initialise

  PUBLIC CMISSGeneratedMeshType,CMISSGeneratedMesh_Finalise,CMISSGeneratedMesh_Initialise

  PUBLIC CMISSHistoryType,CMISSHistory_Finalise,CMISSHistory_Initialise

  PUBLIC CMISSInterfaceType,CMISSInterface_Finalise,CMISSInterface_Initialise

  PUBLIC CMISSInterfaceConditionType,CMISSInterfaceCondition_Finalise,CMISSInterfaceCondition_Initialise

  PUBLIC CMISSInterfaceEquationsType,CMISSInterfaceEquations_Finalise,CMISSInterfaceEquations_Initialise

  PUBLIC CMISSInterfaceMeshConnectivityType,CMISSInterfaceMeshConnectivity_Finalise, &
    & CMISSInterfaceMeshConnectivity_Initialise
  
  PUBLIC CMISSInterfacePointsConnectivityType,CMISSInterfacePointsConnectivity_Initialise, &
    & CMISSInterfacePointsConnectivity_Finalise

  PUBLIC CMISSDistributedMatrixType,CMISSDistributedVectorType

  PUBLIC CMISSDistributedMatrix_Initialise,CMISSDistributedVector_Initialise

  PUBLIC CMISSMeshType,CMISSMesh_Finalise,CMISSMesh_Initialise

  PUBLIC CMISSMeshElementsType,CMISSMeshElements_Finalise,CMISSMeshElements_Initialise

  PUBLIC CMISSMeshNodesType,CMISSMeshNodes_Finalise,CMISSMeshNodes_Initialise

  PUBLIC CMISSNodesType,CMISSNodes_Finalise,CMISSNodes_Initialise

  PUBLIC CMISSProblemType,CMISSProblem_Finalise,CMISSProblem_Initialise

  PUBLIC CMISSQuadratureType,CMISSQuadrature_Finalise,CMISSQuadrature_Initialise

  PUBLIC CMISSRegionType,CMISSRegion_Finalise,CMISSRegion_Initialise

  PUBLIC CMISSSolverType,CMISSSolver_Finalise,CMISSSolver_Initialise

  PUBLIC CMISSSolverEquationsType,CMISSSolverEquations_Finalise,CMISSSolverEquations_Initialise

!!==================================================================================================================================
!!
!! ANALYTIC_ANALYSIS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Output the analytic error analysis for a field compared to the analytic values parameter set.
  INTERFACE CMISSAnalyticAnalysisOutput
    MODULE PROCEDURE CMISSAnalyticAnalysisOutputNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisOutputObj
  END INTERFACE !CMISSAnalyticAnalysisOutput

  !>Get the absolute error of the node.
  INTERFACE CMISSAnalyticAnalysisAbsoluteErrorGetNode
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj
  END INTERFACE !CMISSAnalyticAnalysisAbsoluteErrorGetNode

  !>Get the percentage error of the node.
  INTERFACE CMISSAnalyticAnalysisPercentageErrorGetNode
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetNodeNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetNodeObj
  END INTERFACE !CMISSAnalyticAnalysisPercentageErrorGetNode

  !>Get the relative error of the node.
  INTERFACE CMISSAnalyticAnalysisRelativeErrorGetNode
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetNodeNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetNodeObj
  END INTERFACE !CMISSAnalyticAnalysisRelativeErrorGetNode

  !>Get the absolute error of the element.
  INTERFACE CMISSAnalyticAnalysisAbsoluteErrorGetElement
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetElementObj
  END INTERFACE !CMISSAnalyticAnalysisAbsoluteErrorGetElement

  !>Get the percentage error of the element.
  INTERFACE CMISSAnalyticAnalysisPercentageErrorGetElement
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetElementNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetElementObj
  END INTERFACE !CMISSAnalyticAnalysisPercentageErrorGetElement

  !>Get the relative error of the element.
  INTERFACE CMISSAnalyticAnalysisRelativeErrorGetElement
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetElementNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetElementObj
  END INTERFACE !CMISSAnalyticAnalysisRelativeErrorGetElement

  !>Get the absolute error of the constant.
  INTERFACE CMISSAnalyticAnalysisAbsoluteErrorGetConstant
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj
  END INTERFACE !CMISSAnalyticAnalysisAbsoluteErrorGetConstant

  !>Get the percentage error of the constant.
  INTERFACE CMISSAnalyticAnalysisPercentageErrorGetConstant
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetConstantNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisPercentageErrorGetConstantObj
  END INTERFACE !CMISSAnalyticAnalysisPercentageErrorGetConstant

  !>Get the relative error of the constant.
  INTERFACE CMISSAnalyticAnalysisRelativeErrorGetConstant
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetConstantNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisRelativeErrorGetConstantObj
  END INTERFACE !CMISSAnalyticAnalysisRelativeErrorGetConstant

  !>Get the rms error of nodes.
  INTERFACE CMISSAnalyticAnalysisRmsErrorGetNode
    MODULE PROCEDURE CMISSAnalyticAnalysisRmsErrorGetNodeNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisRmsErrorGetNodeObj
  END INTERFACE !CMISSAnalyticAnalysisRmsErrorGetNode

  !>Get the rms error of elements.
  INTERFACE CMISSAnalyticAnalysisRmsErrorGetElement
    MODULE PROCEDURE CMISSAnalyticAnalysisRmsErrorGetElementNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisRmsErrorGetElementObj
  END INTERFACE !CMISSAnalyticAnalysisRmsErrorGetElement

  !>Get integral of numerical values.
  INTERFACE CMISSAnalyticAnalysisIntegralNumericalValueGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNumericalValueGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNumericalValueGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralNumericalValueGet

  !>Get integral of analytical values.
  INTERFACE CMISSAnalyticAnalysisIntegralAnalyticValueGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralAnalyticValueGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralAnalyticValueGet

  !>Get integral of percentage errors.
  INTERFACE CMISSAnalyticAnalysisIntegralPercentageErrorGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralPercentageErrorGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralPercentageErrorGet

  !>Get integral of absolute errors.
  INTERFACE CMISSAnalyticAnalysisIntegralAbsoluteErrorGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralAbsoluteErrorGet

  !>Get integral of relative errors.
  INTERFACE CMISSAnalyticAnalysisIntegralRelativeErrorGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralRelativeErrorGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralRelativeErrorGet

  !>Get integral of nid numerical errors.
  INTERFACE CMISSAnalyticAnalysisIntegralNidNumericalValueGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralNidNumericalValueGet

  !>Get integral of nid errors.
  INTERFACE CMISSAnalyticAnalysisIntegralNidErrorGet
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNidErrorGetNumber
    MODULE PROCEDURE CMISSAnalyticAnalysisIntegralNidErrorGetObj
  END INTERFACE !CMISSAnalyticAnalysisIntegralNidErrorGet

  PUBLIC CMISSAnalyticAnalysisOutput

  PUBLIC CMISSAnalyticAnalysisAbsoluteErrorGetNode,CMISSAnalyticAnalysisPercentageErrorGetNode, &
    & CMISSAnalyticAnalysisRelativeErrorGetNode

  PUBLIC CMISSAnalyticAnalysisAbsoluteErrorGetElement,CMISSAnalyticAnalysisPercentageErrorGetElement, &
    & CMISSAnalyticAnalysisRelativeErrorGetElement

  PUBLIC CMISSAnalyticAnalysisAbsoluteErrorGetConstant,CMISSAnalyticAnalysisPercentageErrorGetConstant, &
    & CMISSAnalyticAnalysisRelativeErrorGetConstant

  PUBLIC CMISSAnalyticAnalysisRmsErrorGetNode,CMISSAnalyticAnalysisRmsErrorGetElement

  PUBLIC CMISSAnalyticAnalysisIntegralNumericalValueGet,CMISSAnalyticAnalysisIntegralAnalyticValueGet, &
    & CMISSAnalyticAnalysisIntegralPercentageErrorGet,CMISSAnalyticAnalysisIntegralAbsoluteErrorGet, &
    & CMISSAnalyticAnalysisIntegralRelativeErrorGet,CMISSAnalyticAnalysisIntegralNidNumericalValueGet, &
    & CMISSAnalyticAnalysisIntegralNidErrorGet

!!==================================================================================================================================
!!
!! BASE_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_DiagnosticAndTimingConstants OPENCMISS::DiagnosticAndTiming::Constants
  !> \brief Diagnostic and Timing constants.
  !>@{
  !> \addtogroup OPENCMISS_DiagnosticTypes OPENCMISS::DiagnosticAndTiming::DiagnosticTypes
  !> \brief Diganostic constants.
  !> \see OPENCMISS::DiagnosticTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_ALL_DIAG_TYPE = ALL_DIAG_TYPE !<Type for setting diagnostic output in all routines \see OPENCMISS_DiagnosticTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_IN_DIAG_TYPE = IN_DIAG_TYPE !<Type for setting diagnostic output in one routine \see OPENCMISS_DiagnosticTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FROM_DIAG_TYPE = FROM_DIAG_TYPE !<Type for setting diagnostic output in one routine downwards \see OPENCMISS_DiagnosticTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_TimingTypes OPENCMISS::DiagnosticAndTiming::TimingTypes
  !> \brief Timing constants.
  !> \see OPENCMISS::TimingTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_ALL_TIMING_TYPE = ALL_TIMING_TYPE !<Type for setting timing output in all routines \see OPENCMISS_TimingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_IN_TIMING_TYPE = IN_TIMING_TYPE !<Type for setting timing output in one routine \see OPENCMISS_TimingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FROM_TIMING_TYPE = FROM_TIMING_TYPE !<Type for setting timing output from one routine downwards \see OPENCMISS_TimingTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISS_ALL_DIAG_TYPE,CMISS_IN_DIAG_TYPE,CMISS_FROM_DIAG_TYPE

  PUBLIC CMISS_ALL_TIMING_TYPE,CMISS_IN_TIMING_TYPE,CMISS_FROM_TIMING_TYPE

  PUBLIC CMISSDiagnosticsSetOff,CMISSDiagnosticsSetOn

  PUBLIC CMISSOutputSetOff,CMISSOutputSetOn

  PUBLIC CMISSTimingSetOff,CMISSTimingSetOn,CMISSTimingSummaryOutput

!!==================================================================================================================================
!!
!! BASIS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_BasisConstants OPENCMISS::Basis::Constants
  !> \brief Basis function constants.
  !>@{
  !> \addtogroup OPENCMISS_BasisTypes OPENCMISS::Basis::BasisTypes
  !> \brief Basis definition type parameters.
  !> \see OPENCMISS::BasisConstants,OPENCMISS
  !>@{ symbol 'nodenumber' at (1) has no IMPLICIT type.
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_LAGRANGE_HERMITE_TP_TYPE = BASIS_LAGRANGE_HERMITE_TP_TYPE !<Lagrange-Hermite tensor product basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_SIMPLEX_TYPE = BASIS_SIMPLEX_TYPE !<Simplex basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_SERENDIPITY_TYPE = BASIS_SERENDIPITY_TYPE !<Serendipity basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_AUXILLIARY_TYPE = BASIS_AUXILLIARY_TYPE !<Auxillary basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_B_SPLINE_TP_TYPE = BASIS_B_SPLINE_TP_TYPE !<B-spline basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE = BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE !<Fourier-Lagrange tensor product basis type \see OPENCMISS_BasisTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_EXTENDED_LAGRANGE_TP_TYPE = BASIS_EXTENDED_LAGRANGE_TP_TYPE !< Extendend Lagrange tensor product basis type \see OPENCMISS_BasisTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_BasisInterpolationSpecifications OPENCMISS::Basis::InterpolationSpecifications
  !> \brief Interpolation specification parameters
  !> \see OPENCMISS::BasisConstants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_LINEAR_LAGRANGE_INTERPOLATION = BASIS_LINEAR_LAGRANGE_INTERPOLATION !<Linear Lagrange interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_QUADRATIC_LAGRANGE_INTERPOLATION = BASIS_QUADRATIC_LAGRANGE_INTERPOLATION !<Quadratic Lagrange interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_CUBIC_LAGRANGE_INTERPOLATION = BASIS_CUBIC_LAGRANGE_INTERPOLATION !<Cubic Lagrange interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_CUBIC_HERMITE_INTERPOLATION = BASIS_CUBIC_HERMITE_INTERPOLATION !<Cubic Hermite interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_QUADRATIC1_HERMITE_INTERPOLATION = BASIS_QUADRATIC1_HERMITE_INTERPOLATION !<Quadratic Hermite (no derivative at xi=0) interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_QUADRATIC2_HERMITE_INTERPOLATION = BASIS_QUADRATIC2_HERMITE_INTERPOLATION !<Quadratic Hermite (no derivative at xi=1) interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_LINEAR_SIMPLEX_INTERPOLATION = BASIS_LINEAR_SIMPLEX_INTERPOLATION !<Linear Simplex interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_QUADRATIC_SIMPLEX_INTERPOLATION = BASIS_QUADRATIC_SIMPLEX_INTERPOLATION !<Quadratic Simplex interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_CUBIC_SIMPLEX_INTERPOLATION = BASIS_CUBIC_SIMPLEX_INTERPOLATION !<Cubic Simplex interpolation specification \see OPENCMISS_BasisInterpolationSpecifications,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_BasisQuadratureSchemes OPENCMISS::Basis::QuadratureSchemes
  !> \brief Quadrature scheme parameters
  !> \see OPENCMISS::BasisConstants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_DEFAULT_QUADRATURE_SCHEME = BASIS_DEFAULT_QUADRATURE_SCHEME !<Identifier for the default quadrature scheme \see OPENCMISS_BasisQuadratureSchemes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_LOW_QUADRATURE_SCHEME = BASIS_LOW_QUADRATURE_SCHEME !<Identifier for a low order quadrature scheme \see OPENCMISS_BasisQuadratureSchemes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_MID_QUADRATURE_SCHEME = BASIS_MID_QUADRATURE_SCHEME !<Identifier for a mid order quadrature scheme \see OPENCMISS_BasisQuadratureSchemes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_HIGH_QUADRATURE_SCHEME = BASIS_HIGH_QUADRATURE_SCHEME !<Identifier for a high order quadrature scheme \see OPENCMISS_BasisQuadratureSchemes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_BasisQuadratureTypes OPENCMISS::Basis::QuadratureTypes
  !> \brief Basis quadrature type parameters.
  !> \see OPENCMISS::BasisConstants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_GAUSS_LEGENDRE_QUADRATURE = BASIS_GAUSS_LEGENDRE_QUADRATURE !<Gauss-Legendre quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_GAUSS_LAGUERRE_QUADRATURE = BASIS_GAUSS_LAGUERRE_QUADRATURE !<Gauss-Laguerre quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_GUASS_HERMITE_QUADRATURE = BASIS_GUASS_HERMITE_QUADRATURE !<Gauss-Hermite quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_ADAPTIVE_GAUSS_LEGENDRE_QUADRATURE = BASIS_ADAPTIVE_GAUSS_LEGENDRE_QUADRATURE !<Adaptive Gauss-Legendre quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_GAUSS_SIMPLEX_QUADRATURE = BASIS_GAUSS_SIMPLEX_QUADRATURE !<Gauss-Legendre for Simplex elements quadrature \see OPENCMISS_BasisQuadratureTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_BasisXiCollapse OPENCMISS::Basis::XiCollapse
  !> \brief Basis Xi collapse parameters.
  !> \see OPENCMISS::Basis,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_XI_COLLAPSED = BASIS_XI_COLLAPSED !<The Xi direction is collapsed \see OPENCMISS_BasisXiCollapse,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_COLLAPSED_AT_XI0 = BASIS_COLLAPSED_AT_XI0 !<The Xi direction at the xi=0 end of this Xi direction is collapsed \see OPENCMISS_BasisXiCollapse,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_COLLAPSED_AT_XI1 = BASIS_COLLAPSED_AT_XI1 !<The Xi direction at the xi=1 end of this Xi direction is collapsed \see OPENCMISS_BasisXiCollapse,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_BASIS_NOT_COLLAPSED = BASIS_NOT_COLLAPSED !<The Xi direction is not collapsed \see OPENCMISS_BasisXiCollapse,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the collapsed Xi flags for a basis.
  INTERFACE CMISSBasis_CollapsedXiGet
    MODULE PROCEDURE CMISSBasis_CollapsedXiGetNumber
    MODULE PROCEDURE CMISSBasis_CollapsedXiGetObj
  END INTERFACE !CMISSBasis_CollapsedXiGet

  !>Sets/changes the collapsed Xi flags for a basis.
  INTERFACE CMISSBasis_CollapsedXiSet
    MODULE PROCEDURE CMISSBasis_CollapsedXiSetNumber
    MODULE PROCEDURE CMISSBasis_CollapsedXiSetObj
  END INTERFACE !CMISSBasis_CollapsedXiSet

  !>Finishes the creation of a new basis. \see OPENCMISS::CMISSBasis_CreateStart
  INTERFACE CMISSBasis_CreateFinish
    MODULE PROCEDURE CMISSBasis_CreateFinishNumber
    MODULE PROCEDURE CMISSBasis_CreateFinishObj
  END INTERFACE !CMISSBasis_CreateFinish

  !>Starts the creation of a new basis. \see OPENCMISS::CMISSBasis_CreateFinish
  INTERFACE CMISSBasis_CreateStart
    MODULE PROCEDURE CMISSBasis_CreateStartNumber
    MODULE PROCEDURE CMISSBasis_CreateStartObj
  END INTERFACE !CMISSBasis_CreateStart

  !>Destroys a basis.
  INTERFACE CMISSBasis_Destroy
    MODULE PROCEDURE CMISSBasis_DestroyNumber
    MODULE PROCEDURE CMISSBasis_DestroyObj
  END INTERFACE !CMISSBasis_Destroy

  !>Get the interpolation type in each Xi directions for a basis.
  INTERFACE CMISSBasis_InterpolationXiGet
    MODULE PROCEDURE CMISSBasis_InterpolationXiGetNumber
    MODULE PROCEDURE CMISSBasis_InterpolationXiGetObj
  END INTERFACE !CMISSBasis_InterpolationXiGet

  !>Sets/changes the interpolation type in each Xi directions for a basis.
  INTERFACE CMISSBasis_InterpolationXiSet
    MODULE PROCEDURE CMISSBasis_InterpolationXiSetNumber
    MODULE PROCEDURE CMISSBasis_InterpolationXiSetObj
  END INTERFACE !CMISSBasis_InterpolationXiSet

  !>Returns the number of local nodes in a basis.
  INTERFACE CMISSBasis_NumberOfLocalNodesGet
    MODULE PROCEDURE CMISSBasis_NumberOfLocalNodesGetNumber
    MODULE PROCEDURE CMISSBasis_NumberOfLocalNodesGetObj
  END INTERFACE !CMISSBasis_NumberOfLocalNodesGet

  !>Returns the number of Xi directions in a basis.
  INTERFACE CMISSBasis_NumberOfXiGet
    MODULE PROCEDURE CMISSBasis_NumberOfXiGetNumber
    MODULE PROCEDURE CMISSBasis_NumberOfXiGetObj
  END INTERFACE !CMISSBasis_NumberOfXiGet

  !>Sets/changes the number of Xi directions in a basis.
  INTERFACE CMISSBasis_NumberOfXiSet
    MODULE PROCEDURE CMISSBasis_NumberOfXiSetNumber
    MODULE PROCEDURE CMISSBasis_NumberOfXiSetObj
  END INTERFACE !CMISSBasis_NumberOfXiSet

  !>Returns the number of Gauss points in each Xi direction on a basis quadrature.
  INTERFACE CMISSBasis_QuadratureNumberOfGaussXiGet
    MODULE PROCEDURE CMISSBasis_QuadratureNumberOfGaussXiGetNumber
    MODULE PROCEDURE CMISSBasis_QuadratureNumberOfGaussXiGetObj
  END INTERFACE !CMISSBasis_QuadratureNumberOfGaussXiGet

  !>Sets/changes the number of Gauss points in each Xi direction on a basis quadrature.
  INTERFACE CMISSBasis_QuadratureNumberOfGaussXiSet
    MODULE PROCEDURE CMISSBasis_QuadratureNumberOfGaussXiSetNumber
    MODULE PROCEDURE CMISSBasis_QuadratureNumberOfGaussXiSetObj
  END INTERFACE !CMISSBasis_QuadratureNumberOfGaussXiSet

  !>Returns the xi positions of Gauss points on a basis quadrature.
  INTERFACE CMISSBasis_QuadratureGaussXiGet
    MODULE PROCEDURE CMISSBasis_QuadratureSingleGaussXiGetNumber
    MODULE PROCEDURE CMISSBasis_QuadratureSingleGaussXiGetObj
    MODULE PROCEDURE CMISSBasis_QuadratureMultipleGaussXiGetNumber
    MODULE PROCEDURE CMISSBasis_QuadratureMultipleGaussXiGetObj
  END INTERFACE !CMISSBasis_QuadratureGaussXiGet

  !>Returns the order of quadrature for a basis quadrature.
  INTERFACE CMISSBasis_QuadratureOrderGet
    MODULE PROCEDURE CMISSBasis_QuadratureOrderGetNumber
    MODULE PROCEDURE CMISSBasis_QuadratureOrderGetObj
  END INTERFACE !CMISSBasis_QuadratureOrderGet

  !>Sets/changes the order of quadrature for a basis quadrature.
  INTERFACE CMISSBasis_QuadratureOrderSet
    MODULE PROCEDURE CMISSBasis_QuadratureOrderSetNumber
    MODULE PROCEDURE CMISSBasis_QuadratureOrderSetObj
  END INTERFACE !CMISSBasis_QuadratureOrderSet

  !>Returns the quadrature type for a basis quadrature.
  INTERFACE CMISSBasis_QuadratureTypeGet
    MODULE PROCEDURE CMISSBasis_QuadratureTypeGetNumber
    MODULE PROCEDURE CMISSBasis_QuadratureTypeGetObj
  END INTERFACE !CMISSBasis_QuadratureTypeGet

  !>Sets/changes the quadrature type for a basis quadrature.
  INTERFACE CMISSBasis_QuadratureTypeSet
    MODULE PROCEDURE CMISSBasis_QuadratureTypeSetNumber
    MODULE PROCEDURE CMISSBasis_QuadratureTypeSetObj
  END INTERFACE !CMISSBasis_QuadratureTypeSet

  !>Sets/changes the local face gauss evaluatoin flag for a basis quadrature.
  INTERFACE CMISSBasis_QuadratureLocalFaceGaussEvaluateSet
    MODULE PROCEDURE CMISSBasis_QuadratureLocalFaceGaussEvaluateSetNumber
    MODULE PROCEDURE CMISSBasis_QuadratureLocalFaceGaussEvaluateSetObj
  END INTERFACE !CMISSBasis_QuadratureLocalFaceGaussEvaluateSet

  !>Returns the type of a basis.
  INTERFACE CMISSBasis_TypeGet
    MODULE PROCEDURE CMISSBasis_TypeGetNumber
    MODULE PROCEDURE CMISSBasis_TypeGetObj
  END INTERFACE !CMISSBasis_TypeGet

  !>Sets/changes the type of a basis.
  INTERFACE CMISSBasis_TypeSet
    MODULE PROCEDURE CMISSBasis_TypeSetNumber
    MODULE PROCEDURE CMISSBasis_TypeSetObj
  END INTERFACE !CMISSBasis_TypeSet

  PUBLIC CMISS_BASIS_LAGRANGE_HERMITE_TP_TYPE,CMISS_BASIS_SIMPLEX_TYPE,CMISS_BASIS_SERENDIPITY_TYPE,CMISS_BASIS_AUXILLIARY_TYPE, &
    & CMISS_BASIS_B_SPLINE_TP_TYPE,CMISS_BASIS_FOURIER_LAGRANGE_HERMITE_TP_TYPE,CMISS_BASIS_EXTENDED_LAGRANGE_TP_TYPE

  PUBLIC CMISS_BASIS_LINEAR_LAGRANGE_INTERPOLATION,CMISS_BASIS_QUADRATIC_LAGRANGE_INTERPOLATION, &
    & CMISS_BASIS_CUBIC_LAGRANGE_INTERPOLATION, &
    & CMISS_BASIS_CUBIC_HERMITE_INTERPOLATION,CMISS_BASIS_QUADRATIC1_HERMITE_INTERPOLATION, &
    & CMISS_BASIS_QUADRATIC2_HERMITE_INTERPOLATION, &
    & CMISS_BASIS_LINEAR_SIMPLEX_INTERPOLATION,CMISS_BASIS_QUADRATIC_SIMPLEX_INTERPOLATION,CMISS_BASIS_CUBIC_SIMPLEX_INTERPOLATION

  PUBLIC CMISS_BASIS_DEFAULT_QUADRATURE_SCHEME,CMISS_BASIS_LOW_QUADRATURE_SCHEME,CMISS_BASIS_MID_QUADRATURE_SCHEME, &
    & CMISS_BASIS_HIGH_QUADRATURE_SCHEME

  PUBLIC CMISS_BASIS_GAUSS_LEGENDRE_QUADRATURE,CMISS_BASIS_GAUSS_LAGUERRE_QUADRATURE,CMISS_BASIS_GUASS_HERMITE_QUADRATURE, &
    & CMISS_BASIS_ADAPTIVE_GAUSS_LEGENDRE_QUADRATURE,CMISS_BASIS_GAUSS_SIMPLEX_QUADRATURE

  PUBLIC CMISS_BASIS_XI_COLLAPSED,CMISS_BASIS_COLLAPSED_AT_XI0,CMISS_BASIS_COLLAPSED_AT_XI1,CMISS_BASIS_NOT_COLLAPSED

  PUBLIC CMISSBasis_CollapsedXiGet,CMISSBasis_CollapsedXiSet

  PUBLIC CMISSBasis_CreateFinish,CMISSBasis_CreateStart,CMISSBasis_Destroy

  PUBLIC CMISSBasis_InterpolationXiGet,CMISSBasis_InterpolationXiSet

  PUBLIC CMISSBasis_NumberOfLocalNodesGet

  PUBLIC CMISSBasis_NumberOfXiGet,CMISSBasis_NumberOfXiSet

  PUBLIC CMISSBasis_QuadratureNumberOfGaussXiGet,CMISSBasis_QuadratureNumberOfGaussXiSet

  PUBLIC CMISSBasis_QuadratureGaussXiGet

  PUBLIC CMISSBasis_QuadratureOrderGet,CMISSBasis_QuadratureOrderSet

  PUBLIC CMISSBasis_QuadratureTypeGet,CMISSBasis_QuadratureTypeSet, CMISSBasis_QuadratureLocalFaceGaussEvaluateSet

  PUBLIC CMISSBasis_TypeGet,CMISSBasis_TypeSet

!!==================================================================================================================================
!!
!! BOUNDARY_CONDITIONS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters


  !> \addtogroup OPENCMISS_BoundaryConditionsConstants OPENCMISS::BoundaryConditions::Constants
  !> \brief Boundary conditions constants.
  !>@{
  !> \addtogroup OPENCMISS_BoundaryConditionsTypes OPENCMISS::BoundaryConditions::Types
  !> \brief Specific boundary condition types, which might only be applicable to certain equation sets.
  !> \see OPENCMISS::BoundaryConditions,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_FREE = BOUNDARY_CONDITION_FREE !<The dof is free.
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_FIXED = BOUNDARY_CONDITION_FIXED !<The dof is fixed as a boundary condition.
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_FIXED_WALL = BOUNDARY_CONDITION_FIXED_WALL
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_FIXED_INLET = BOUNDARY_CONDITION_FIXED_INLET
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_FIXED_OUTLET = BOUNDARY_CONDITION_FIXED_OUTLET
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_MOVED_WALL = BOUNDARY_CONDITION_MOVED_WALL
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED = BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_FREE_WALL = BOUNDARY_CONDITION_FREE_WALL

  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_NEUMANN_POINT = BOUNDARY_CONDITION_NEUMANN_POINT !<Specify the normal derivative at a node, which is then integrated to find the nodal load term
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_NEUMANN_POINT_INCREMENTED = BOUNDARY_CONDITION_NEUMANN_POINT_INCREMENTED !<Specify the normal derivative at a node, which is then integrated to find the nodal load term. The value is incremented inside a load incremented control loop.
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_NEUMANN_INTEGRATED = BOUNDARY_CONDITION_NEUMANN_INTEGRATED !<Set the integrated right hand side load value directly
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_DIRICHLET = BOUNDARY_CONDITION_DIRICHLET
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_CAUCHY = BOUNDARY_CONDITION_CAUCHY
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_ROBIN = BOUNDARY_CONDITION_ROBIN

  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_FIXED_INCREMENTED = BOUNDARY_CONDITION_FIXED_INCREMENTED
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_PRESSURE = BOUNDARY_CONDITION_PRESSURE
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_PRESSURE_INCREMENTED = BOUNDARY_CONDITION_PRESSURE_INCREMENTED

  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_CORRECTION_MASS_INCREASE = BOUNDARY_CONDITION_CORRECTION_MASS_INCREASE
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_IMPERMEABLE_WALL = BOUNDARY_CONDITION_IMPERMEABLE_WALL
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_NEUMANN_INTEGRATED_ONLY = BOUNDARY_CONDITION_NEUMANN_INTEGRATED_ONLY !<A Neumann integrated boundary condition, and no point values will be integrated over a face or line that includes this dof

  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_FixedFitted = BOUNDARY_CONDITION_FixedFitted
  !>@}
  !> \addtogroup OPENCMISS_BoundaryConditionSparsityTypes OPENCMISS::BoundaryConditions::SparsityTypes
  !> \brief Storage type for matrices used by boundary conditions.
  !> \see OPENCMISS::BoundaryConditions,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_SPARSE_MATRICES = BOUNDARY_CONDITION_SPARSE_MATRICES
  INTEGER(INTG), PARAMETER :: CMISS_BOUNDARY_CONDITION_FULL_MATRICES = BOUNDARY_CONDITION_FULL_MATRICES
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Destroys boundary conditions.
  INTERFACE CMISSBoundaryConditions_Destroy
    MODULE PROCEDURE CMISSBoundaryConditions_DestroyNumber0
    MODULE PROCEDURE CMISSBoundaryConditions_DestroyNumber1
    MODULE PROCEDURE CMISSBoundaryConditions_DestroyObj
  END INTERFACE !CMISSBoundaryConditions_Destroy

  !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant.
  INTERFACE CMISSBoundaryConditions_AddConstant
    MODULE PROCEDURE CMISSBoundaryConditions_AddConstantNumber
    MODULE PROCEDURE CMISSBoundaryConditions_AddConstantObj
  END INTERFACE !CMISSBoundaryConditions_AddConstant

  !>Sets the value of the specified constant as a boundary condition on the specified constant.
  INTERFACE CMISSBoundaryConditions_SetConstant
    MODULE PROCEDURE CMISSBoundaryConditions_SetConstantNumber
    MODULE PROCEDURE CMISSBoundaryConditions_SetConstantObj
  END INTERFACE !CMISSBoundaryConditions_SetConstant

  !>Adds to the value of the element constant and sets this as a boundary condition on the specified element.
  INTERFACE CMISSBoundaryConditions_AddElement
    MODULE PROCEDURE CMISSBoundaryConditions_AddElementNumber
    MODULE PROCEDURE CMISSBoundaryConditions_AddElementObj
  END INTERFACE !CMISSBoundaryConditions_AddElement

  !>Sets the value of the specified element as a boundary condition on the specified element.
  INTERFACE CMISSBoundaryConditions_SetElement
    MODULE PROCEDURE CMISSBoundaryConditions_SetElementNumber
    MODULE PROCEDURE CMISSBoundaryConditions_SetElementObj
  END INTERFACE !CMISSBoundaryConditions_SetElement

  !>Adds to the value of the node constant and sets this as a boundary condition on the specified node.
  INTERFACE CMISSBoundaryConditions_AddNode
    MODULE PROCEDURE CMISSBoundaryConditions_AddNodeNumber
    MODULE PROCEDURE CMISSBoundaryConditions_AddNodeObj
  END INTERFACE !CMISSBoundaryConditions_AddNode

  !>Sets the value of the specified node as a boundary condition on the specified node.
  INTERFACE CMISSBoundaryConditions_SetNode
    MODULE PROCEDURE CMISSBoundaryConditions_SetNodeNumber0
    MODULE PROCEDURE CMISSBoundaryConditions_SetNodeNumber1
    MODULE PROCEDURE CMISSBoundaryConditions_SetNodeObj
  END INTERFACE !CMISSBoundaryConditions_SetNode

  !>Sets the matrix sparsity type for Neumann integration matrices, used when integrating Neumann point values.
  INTERFACE CMISSBoundaryConditions_NeumannSparsityTypeSet
    MODULE PROCEDURE CMISSBoundaryConditions_NeumannSparsityTypeSetNumber0
    MODULE PROCEDURE CMISSBoundaryConditions_NeumannSparsityTypeSetNumber1
    MODULE PROCEDURE CMISSBoundaryConditions_NeumannSparsityTypeSetObj
  END INTERFACE !CMISSBoundaryConditions_NeumannSparsityTypeSet

  !>Constrain multiple nodal equations dependent field DOFs to be a single solver DOF in the solver equations
  INTERFACE CMISSBoundaryConditions_ConstrainNodeDofsEqual
    MODULE PROCEDURE CMISSBoundaryConditions_ConstrainNodeDofsEqualNumber
    MODULE PROCEDURE CMISSBoundaryConditions_ConstrainNodeDofsEqualObj
  END INTERFACE CMISSBoundaryConditions_ConstrainNodeDofsEqual

  PUBLIC CMISS_BOUNDARY_CONDITION_FREE,CMISS_BOUNDARY_CONDITION_FIXED, &
    & CMISS_BOUNDARY_CONDITION_FIXED_WALL,CMISS_BOUNDARY_CONDITION_FIXED_INLET,CMISS_BOUNDARY_CONDITION_MOVED_WALL, &
    & CMISS_BOUNDARY_CONDITION_FREE_WALL,CMISS_BOUNDARY_CONDITION_FIXED_OUTLET,CMISS_BOUNDARY_CONDITION_MOVED_WALL_INCREMENTED, &
    & CMISS_BOUNDARY_CONDITION_CORRECTION_MASS_INCREASE,CMISS_BOUNDARY_CONDITION_IMPERMEABLE_WALL, &
    & CMISS_BOUNDARY_CONDITION_NEUMANN_INTEGRATED_ONLY,CMISS_BOUNDARY_CONDITION_FixedFitted

  PUBLIC CMISS_BOUNDARY_CONDITION_NEUMANN_POINT,CMISS_BOUNDARY_CONDITION_NEUMANN_INTEGRATED,CMISS_BOUNDARY_CONDITION_DIRICHLET
  PUBLIC CMISS_BOUNDARY_CONDITION_CAUCHY,CMISS_BOUNDARY_CONDITION_ROBIN,CMISS_BOUNDARY_CONDITION_FIXED_INCREMENTED
  PUBLIC CMISS_BOUNDARY_CONDITION_PRESSURE,CMISS_BOUNDARY_CONDITION_PRESSURE_INCREMENTED
  PUBLIC CMISS_BOUNDARY_CONDITION_NEUMANN_POINT_INCREMENTED

  PUBLIC CMISS_BOUNDARY_CONDITION_SPARSE_MATRICES,CMISS_BOUNDARY_CONDITION_FULL_MATRICES

  PUBLIC CMISSBoundaryConditions_Destroy

  PUBLIC CMISSBoundaryConditions_AddConstant,CMISSBoundaryConditions_SetConstant

  PUBLIC CMISSBoundaryConditions_AddElement,CMISSBoundaryConditions_SetElement

  PUBLIC CMISSBoundaryConditions_AddNode,CMISSBoundaryConditions_SetNode

  PUBLIC CMISSBoundaryConditions_NeumannSparsityTypeSet

  PUBLIC CMISSBoundaryConditions_ConstrainNodeDofsEqual

!!==================================================================================================================================
!!
!! CMISS
!!
!!==================================================================================================================================

  !Module parameters
  !> \addtogroup OPENCMISS_CMISSConstants OPENCMISS::CMISS::Constants
  !> \brief CMISS constants.
  !>@{
  !> \addtogroup OPENCMISS_CMISSErrorHandlingModes OPENCMISS::CMISS::ErrorHandlingModes
  !> \brief CMISS error handling mode parameters
  !> \see OPENCMISS::CMISS,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_ERRORS_RETURN_ERROR_CODE = CMISS_RETURN_ERROR_CODE !<Just return the error code \see OPENCMISS_CMISSErrorHandlingModes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_ERRORS_OUTPUT_ERROR = CMISS_OUTPUT_ERROR !<Output the error traceback and return the error code \see OPENCMISS_CMISSErrorHandlingModes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_ERRORS_TRAP_ERROR = CMISS_TRAP_ERROR!<Trap the error by outputing the error traceback and stopping the program \see OPENCMISS_CMISSErrorHandlingModes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Extracts the OpenCMISS error message.
  INTERFACE CMISSExtractErrorMessage
    MODULE PROCEDURE CMISSExtractErrorMessageC
    MODULE PROCEDURE CMISSExtractErrorMessageVS
  END INTERFACE !CMISSExtractErrorMessage

  !>Gets the random seeds for OpenCMISS.
  INTERFACE CMISSRandomSeedsGet
    MODULE PROCEDURE CMISSRandomSeedsGet0
    MODULE PROCEDURE CMISSRandomSeedsGet1
  END INTERFACE !CMISSRandomSeedsGet

  !>Sets the random seeds for OpenCMISS.
  INTERFACE CMISSRandomSeedsSet
    MODULE PROCEDURE CMISSRandomSeedsSet0
    MODULE PROCEDURE CMISSRandomSeedsSet1
  END INTERFACE !CMISSRandomSeedsSet

  PUBLIC CMISS_ERRORS_RETURN_ERROR_CODE,CMISS_ERRORS_OUTPUT_ERROR,CMISS_ERRORS_TRAP_ERROR

  PUBLIC CMISSErrorHandlingModeGet,CMISSErrorHandlingModeSet

  PUBLIC CMISSExtractErrorMessage

  PUBLIC CMISSRandomSeedsGet,CMISSRandomSeedsSizeGet,CMISSRandomSeedsSet

!!==================================================================================================================================
!!
!! CMISS_CELLML
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_CellMLConstants OPENCMISS::CellML::Constants
  !> \brief CellML constants.
  !>@{
  !> \addtogroup OPENCMISS_CellMLFieldTypes OPENCMISS::CellML::FieldTypes
  !> \brief CellML field type parameters.
  !> \see OPENCMISS::CellML,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_CELLML_MODELS_FIELD = CELLML_MODELS_FIELD !<CellML models field type \see OPENCMISS_CellMLFieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_CELLML_STATE_FIELD = CELLML_STATE_FIELD !<CellML state field type \see OPENCMISS_CellMLFieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_CELLML_INTERMEDIATE_FIELD = CELLML_INTERMEDIATE_FIELD !<CellML intermediate field type \see OPENCMISS_CellMLFieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_CELLML_PARAMETERS_FIELD = CELLML_PARAMETERS_FIELD !<CellML parameters field type \see OPENCMISS_CellMLFieldTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Set a CellML model variable as being known (the value will be set from an OpenCMISS field)
  INTERFACE CMISSCellML_VariableSetAsKnown
    MODULE PROCEDURE CMISSCellML_VariableSetAsKnownNumberC
    MODULE PROCEDURE CMISSCellML_VariableSetAsKnownObjC
    MODULE PROCEDURE CMISSCellML_VariableSetAsKnownNumberVS
    MODULE PROCEDURE CMISSCellML_VariableSetAsKnownObjVS
  END INTERFACE !CMISSCellML_VariableSetAsKnown

  !>Set a CellML model variable as being wanted (the value will be extracted from the model to an OpenCMISS field)
  INTERFACE CMISSCellML_VariableSetAsWanted
    MODULE PROCEDURE CMISSCellML_VariableSetAsWantedNumberC
    MODULE PROCEDURE CMISSCellML_VariableSetAsWantedObjC
    MODULE PROCEDURE CMISSCellML_VariableSetAsWantedNumberVS
    MODULE PROCEDURE CMISSCellML_VariableSetAsWantedObjVS
  END INTERFACE !CMISSCellML_VariableSetAsWanted

  !>Map a CellML model variable to a field variable component in this CellML environment.
  INTERFACE CMISSCellML_CreateCellMLToFieldMap
    MODULE PROCEDURE CMISSCellML_CreateCellMLToFieldMapNumberC
    MODULE PROCEDURE CMISSCellML_CreateCellMLToFieldMapObjC
    MODULE PROCEDURE CMISSCellML_CreateCellMLToFieldMapNumberVS
    MODULE PROCEDURE CMISSCellML_CreateCellMLToFieldMapObjVS
  END INTERFACE !CMISSCellML_CreateCellMLToFieldMap

  !>Map a field variable component to a CellML model variable in this CellML environment.
  INTERFACE CMISSCellML_CreateFieldToCellMLMap
    MODULE PROCEDURE CMISSCellML_CreateFieldToCellMLMapNumberC
    MODULE PROCEDURE CMISSCellML_CreateFieldToCellMLMapObjC
    MODULE PROCEDURE CMISSCellML_CreateFieldToCellMLMapNumberVS
    MODULE PROCEDURE CMISSCellML_CreateFieldToCellMLMapObjVS
  END INTERFACE !CMISSCellML_CreateFieldToCellMLMap

  !>Finishes the creation of a CellML environment. \see OPENCMISS::CMISSCellML_CreateStart
  INTERFACE CMISSCellML_CreateFinish
    MODULE PROCEDURE CMISSCellML_CreateFinishNumber
    MODULE PROCEDURE CMISSCellML_CreateFinishObj
  END INTERFACE !CMISSCellML_CreateFinish

  !>Starts the creation of a CellML environment. \see OPENCMISS::CMISSCellML_CreateFinish
  INTERFACE CMISSCellML_CreateStart
    MODULE PROCEDURE CMISSCellML_CreateStartNumber
    MODULE PROCEDURE CMISSCellML_CreateStartObj
  END INTERFACE !CMISSCellML_CreateStart

  !>Destroys a CellML environment.
  INTERFACE CMISSCellML_Destroy
    MODULE PROCEDURE CMISSCellML_DestroyNumber
    MODULE PROCEDURE CMISSCellML_DestroyObj
  END INTERFACE !CMISSCellML_Destroy

  !>Finishes the creation of field maps for a CellML environment. \see OPENCMISS::CMISSCellML_FieldMapsCreateStart
  INTERFACE CMISSCellML_FieldMapsCreateFinish
    MODULE PROCEDURE CMISSCellML_FieldMapsCreateFinishNumber
    MODULE PROCEDURE CMISSCellML_FieldMapsCreateFinishObj
  END INTERFACE !CMISSCellML_FieldMapsCreateFinish

  !>Starts the creation of field maps for a CellML environment. \see OPENCMISS::CMISSCellML_FieldMapsCreateFinish
  INTERFACE CMISSCellML_FieldMapsCreateStart
    MODULE PROCEDURE CMISSCellML_FieldMapsCreateStartNumber
    MODULE PROCEDURE CMISSCellML_FieldMapsCreateStartObj
  END INTERFACE !CMISSCellML_FieldMapsCreateStart

  !>Imports the specified CellML model into a CellML models environment.
  INTERFACE CMISSCellML_ModelImport
    MODULE PROCEDURE CMISSCellML_ModelImportNumberC
    MODULE PROCEDURE CMISSCellML_ModelImportObjC
    MODULE PROCEDURE CMISSCellML_ModelImportNumberVS
    MODULE PROCEDURE CMISSCellML_ModelImportObjVS
  END INTERFACE !CMISSCellML_ModelImport

  !>Finishes the creation of CellML models field. \see OPENCMISS::CMISSCellML_ModelsFieldCreateStart
  INTERFACE CMISSCellML_ModelsFieldCreateFinish
    MODULE PROCEDURE CMISSCellML_ModelsFieldCreateFinishNumber
    MODULE PROCEDURE CMISSCellML_ModelsFieldCreateFinishObj
  END INTERFACE !CMISSCellML_ModelsFieldCreateFinish

  !>Starts the creation of CellML models field. \see OPENCMISS::CMISSCellML_ModelsFieldCreateFinish
  INTERFACE CMISSCellML_ModelsFieldCreateStart
    MODULE PROCEDURE CMISSCellML_ModelsFieldCreateStartNumber
    MODULE PROCEDURE CMISSCellML_ModelsFieldCreateStartObj
  END INTERFACE !CMISSCellML_ModelsFieldCreateStart

  !>Returns the CellML models field for a CellML environment.
  INTERFACE CMISSCellML_ModelsFieldGet
    MODULE PROCEDURE CMISSCellML_ModelsFieldGetNumber
    MODULE PROCEDURE CMISSCellML_ModelsFieldGetObj
  END INTERFACE !CMISSCellML_ModelsFieldGet

  !>Finishes the creation of CellML state field. \see OPENCMISS::CMISSCellML_StateFieldCreateStart
  INTERFACE CMISSCellML_StateFieldCreateFinish
    MODULE PROCEDURE CMISSCellML_StateFieldCreateFinishNumber
    MODULE PROCEDURE CMISSCellML_StateFieldCreateFinishObj
  END INTERFACE !CMISSCellML_StateFieldCreateFinish

  !>Starts the creation of CellML state field. \see OPENCMISS::CMISSCellML_StateFieldCreateFinish
  INTERFACE CMISSCellML_StateFieldCreateStart
    MODULE PROCEDURE CMISSCellML_StateFieldCreateStartNumber
    MODULE PROCEDURE CMISSCellML_StateFieldCreateStartObj
  END INTERFACE !CMISSCellML_StateFieldCreateStart

  !>Returns the CellML state field for a CellML environment.
  INTERFACE CMISSCellML_StateFieldGet
    MODULE PROCEDURE CMISSCellML_StateFieldGetNumber
    MODULE PROCEDURE CMISSCellML_StateFieldGetObj
  END INTERFACE !CMISSCellML_StateFieldGet

  !>Returns the component for a given CellML field that corresponds to the specified CellML variable ID.
  INTERFACE CMISSCellML_FieldComponentGet
    MODULE PROCEDURE CMISSCellML_FieldComponentGetNumberC
    MODULE PROCEDURE CMISSCellML_FieldComponentGetObjC
    MODULE PROCEDURE CMISSCellML_FieldComponentGetNumberVS
    MODULE PROCEDURE CMISSCellML_FieldComponentGetObjVS
  END INTERFACE !CMISSCellML_FieldComponentGet

  !>Finishes the creation of CellML intermediate field. \see OPENCMISS::CMISSCellML_IntermediateFieldCreateStart
  INTERFACE CMISSCellML_IntermediateFieldCreateFinish
    MODULE PROCEDURE CMISSCellML_IntermediateFieldCreateFinishNumber
    MODULE PROCEDURE CMISSCellML_IntermediateFieldCreateFinishObj
  END INTERFACE !CMISSCellML_IntermediateFieldCreateFinish

  !>Starts the creation of CellML intermediate field. \see OPENCMISS::CMISSCellML_IntermediateFieldCreateFinish
  INTERFACE CMISSCellML_IntermediateFieldCreateStart
    MODULE PROCEDURE CMISSCellML_IntermediateFieldCreateStartNumber
    MODULE PROCEDURE CMISSCellML_IntermediateFieldCreateStartObj
  END INTERFACE !CMISSCellML_IntermediateFieldCreateStart

  !>Returns the CellML intermediate field for a CellML environment.
  INTERFACE CMISSCellML_IntermediateFieldGet
    MODULE PROCEDURE CMISSCellML_IntermediateFieldGetNumber
    MODULE PROCEDURE CMISSCellML_IntermediateFieldGetObj
  END INTERFACE !CMISSCellML_IntermediateFieldGet

  !>Finishes the creation of CellML parameters field. \see OPENCMISS::CMISSCellML_ParametersFieldCreateStart
  INTERFACE CMISSCellML_ParametersFieldCreateFinish
    MODULE PROCEDURE CMISSCellML_ParametersFieldCreateFinishNumber
    MODULE PROCEDURE CMISSCellML_ParametersFieldCreateFinishObj
  END INTERFACE !CMISSCellML_ParametersFieldCreateFinish

  !>Starts the creation of CellML parameters field. \see OPENCMISS::CMISSCellML_ParametersFieldCreateFinish
  INTERFACE CMISSCellML_ParametersFieldCreateStart
    MODULE PROCEDURE CMISSCellML_ParametersFieldCreateStartNumber
    MODULE PROCEDURE CMISSCellML_ParametersFieldCreateStartObj
  END INTERFACE !CMISSCellML_ParametersFieldCreateStart

  !>Returns the CellML parameters field for a CellML environment.
  INTERFACE CMISSCellML_ParametersFieldGet
    MODULE PROCEDURE CMISSCellML_ParametersFieldGetNumber
    MODULE PROCEDURE CMISSCellML_ParametersFieldGetObj
  END INTERFACE !CMISSCellML_ParametersFieldGet

  !>Validate and instantiate the specified CellML environment.
  INTERFACE CMISSCellML_Generate
    MODULE PROCEDURE CMISSCellML_GenerateNumber
    MODULE PROCEDURE CMISSCellML_GenerateObj
  END INTERFACE !CMISSCellML_Generate

  PUBLIC CMISS_CELLML_MODELS_FIELD,CMISS_CELLML_STATE_FIELD,CMISS_CELLML_INTERMEDIATE_FIELD,CMISS_CELLML_PARAMETERS_FIELD

  PUBLIC CMISSCellML_VariableSetAsKnown,CMISSCellML_VariableSetAsWanted

  PUBLIC CMISSCellML_CreateCellMLToFieldMap,CMISSCellML_CreateFieldToCellMLMap

  PUBLIC CMISSCellML_CreateFinish,CMISSCellML_CreateStart

  PUBLIC CMISSCellML_Destroy

  PUBLIC CMISSCellML_FieldMapsCreateStart,CMISSCellML_FieldMapsCreateFinish

  PUBLIC CMISSCellML_ModelImport

  PUBLIC CMISSCellML_ModelsFieldCreateFinish,CMISSCellML_ModelsFieldCreateStart,CMISSCellML_ModelsFieldGet

  PUBLIC CMISSCellML_StateFieldCreateFinish,CMISSCellML_StateFieldCreateStart,CMISSCellML_StateFieldGet

  PUBLIC CMISSCellML_FieldComponentGet

  PUBLIC CMISSCellML_IntermediateFieldCreateFinish,CMISSCellML_IntermediateFieldCreateStart

  PUBLIC CMISSCellML_IntermediateFieldGet

  PUBLIC CMISSCellML_ParametersFieldCreateFinish,CMISSCellML_ParametersFieldCreateStart,CMISSCellML_ParametersFieldGet

  PUBLIC CMISSCellML_Generate

!!==================================================================================================================================
!!
!! COMP_ENVIRONMENT
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISSComputationalNodeNumberGet

  PUBLIC CMISSComputationalNumberOfNodesGet

  PUBLIC CMISSComputationalWorkGroup_CreateStart

  PUBLIC CMISSComputationalWorkGroup_CreateFinish

  PUBLIC CMISSComputationalWorkGroup_SubgroupAdd

  PUBLIC CMISSDecomposition_WorldWorkGroupSet
!!==================================================================================================================================
!!
!! CONSTANTS
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_Constants OPENCMISS::Constants
  !> \brief Control loops constants.
  !>@{
  !> \addtogroup OPENCMISS_GlobalDerivativeConstants OPENCMISS::Constants::GlobalDerivativeConstants
  !> \brief Global derivative constant identifiers
  !> \see OPENCMISS_CONSTANTS,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_NO_GLOBAL_DERIV = NO_GLOBAL_DERIV !<No global derivative i.e., u \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GLOBAL_DERIV_S1 = GLOBAL_DERIV_S1 !<First global derivative in the s1 direction i.e., du/ds1 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GLOBAL_DERIV_S2 = GLOBAL_DERIV_S2 !<First global derivative in the s2 direction i.e., du/ds2 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GLOBAL_DERIV_S1_S2 = GLOBAL_DERIV_S1_S2 !<Global Cross derivative in the s1 and s2 direction i.e., d^2u/ds1ds2 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GLOBAL_DERIV_S3 = GLOBAL_DERIV_S3 !<First global derivative in the s3 direction i.e., du/ds3 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GLOBAL_DERIV_S1_S3 = GLOBAL_DERIV_S1_S3 !<Global Cross derivative in the s1 and s3 direction i.e., d^2u/ds1ds3 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GLOBAL_DERIV_S2_S3 = GLOBAL_DERIV_S2_S3 !<Global Cross derivative in the s2 and s3 direction i.e., d^2u/ds2ds3 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GLOBAL_DERIV_S1_S2_S3 = GLOBAL_DERIV_S1_S2_S3 !<Cross derivative in the s1, s2 and s3 direction i.e., d^3u/ds1ds2ds3 \see OPENCMISS_GlobalDerivativeConstants,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISS_NO_GLOBAL_DERIV,CMISS_GLOBAL_DERIV_S1,CMISS_GLOBAL_DERIV_S2,CMISS_GLOBAL_DERIV_S1_S2, &
    & CMISS_GLOBAL_DERIV_S3,CMISS_GLOBAL_DERIV_S1_S3,CMISS_GLOBAL_DERIV_S2_S3,CMISS_GLOBAL_DERIV_S1_S2_S3

!!==================================================================================================================================
!!
!! CONTROL_LOOP_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_ControlLoopConstants OPENCMISS::ControlLoop::Constants
  !> \brief Control loops constants.
  !>@{
  !> \addtogroup OPENCMISS_ControlLoopIdentifiers OPENCMISS::ControlLoop::Identifiers
  !> \brief The control loop identification parameters.
  !> \see OPENCMISS::ControlLoop,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_CONTROL_LOOP_NODE = CONTROL_LOOP_NODE !<The identifier for a each "leaf" node in a control loop. \see OPENCMISS_ControlLoopIdentifiers,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_ControlLoopOutputTypes OPENCMISS::ControlLoop::OutputTypes
  !> \brief The control loop output types.
  !> \see OPENCMISS::ControlLoop,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_CONTROL_LOOP_NO_OUTPUT = CONTROL_LOOP_NO_OUTPUT !<No output from the control loop. \see OPENCMISS_ControlLoopOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_CONTROL_LOOP_PROGRESS_OUTPUT = CONTROL_LOOP_PROGRESS_OUTPUT !<Progress output from the control loop. \see OPENCMISS_ControlLoopOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_CONTROL_LOOP_TIMING_OUTPUT = CONTROL_LOOP_TIMING_OUTPUT !<Timing output from the control loop. \see OPENCMISS_ControlLoopOutputTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the current time parameters for a time control loop.
  INTERFACE CMISSControlLoop_CurrentTimesGet
    MODULE PROCEDURE CMISSControlLoop_CurrentTimesGetNumber0
    MODULE PROCEDURE CMISSControlLoop_CurrentTimesGetNumber1
    MODULE PROCEDURE CMISSControlLoop_CurrentTimesGetObj
  END INTERFACE !CMISSControlLoop_CurrentTimesGet

  !>Destroy a control loop.
  INTERFACE CMISSControlLoop_Destroy
    MODULE PROCEDURE CMISSControlLoop_DestroyNumber0
    MODULE PROCEDURE CMISSControlLoop_DestroyNumber1
    MODULE PROCEDURE CMISSControlLoop_DestroyObj
  END INTERFACE !CMISSControlLoop_Destroy

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root.
  INTERFACE CMISSControlLoop_ControlLoopGet
    MODULE PROCEDURE CMISSControlLoop_ControlLoopGetNumber00
    MODULE PROCEDURE CMISSControlLoop_ControlLoopGetNumber10
    MODULE PROCEDURE CMISSControlLoop_ControlLoopGetNumber01
    MODULE PROCEDURE CMISSControlLoop_ControlLoopGetNumber11
    MODULE PROCEDURE CMISSControlLoop_ControlLoopGetObj0
    MODULE PROCEDURE CMISSControlLoop_ControlLoopGetObj1
  END INTERFACE !CMISSControlLoop_ControlLoopGet

  !>Sets/changes the iteration parameters for a fixed control loop. \todo need a get metod
  INTERFACE CMISSControlLoop_IterationsSet
    MODULE PROCEDURE CMISSControlLoop_IterationsSetNumber0
    MODULE PROCEDURE CMISSControlLoop_IterationsSetNumber1
    MODULE PROCEDURE CMISSControlLoop_IterationsSetObj
  END INTERFACE !CMISSControlLoop_IterationsSet

  !>Returns the label of a control loop.
  INTERFACE CMISSControlLoop_LabelGet
    MODULE PROCEDURE CMISSControlLoop_LabelGetCNumber0
    MODULE PROCEDURE CMISSControlLoop_LabelGetCNumber1
    MODULE PROCEDURE CMISSControlLoop_LabelGetCObj
    MODULE PROCEDURE CMISSControlLoop_LabelGetVSNumber0
    MODULE PROCEDURE CMISSControlLoop_LabelGetVSNumber1
    MODULE PROCEDURE CMISSControlLoop_LabelGetVSObj
  END INTERFACE !CMISSControlLoop_LabelGet

  !>Sets/changes the label of a control loop.
  INTERFACE CMISSControlLoop_LabelSet
    MODULE PROCEDURE CMISSControlLoop_LabelSetCNumber0
    MODULE PROCEDURE CMISSControlLoop_LabelSetCNumber1
    MODULE PROCEDURE CMISSControlLoop_LabelSetCObj
    MODULE PROCEDURE CMISSControlLoop_LabelSetVSNumber0
    MODULE PROCEDURE CMISSControlLoop_LabelSetVSNumber1
    MODULE PROCEDURE CMISSControlLoop_LabelSetVSObj
  END INTERFACE !CMISSControlLoop_LabelSet

  !>Sets/changes the maximum iterations for a while control loop. \todo need a get method
  INTERFACE CMISSControlLoop_MaximumIterationsSet
    MODULE PROCEDURE CMISSControlLoop_MaximumIterationsSetNumber0
    MODULE PROCEDURE CMISSControlLoop_MaximumIterationsSetNumber1
    MODULE PROCEDURE CMISSControlLoop_MaximumIterationsSetObj
  END INTERFACE !CMISSControlLoop_MaximumIterationsSet

  !>Returns the number of sub loops for a control loop.
  INTERFACE CMISSControlLoop_NumberOfSubLoopsGet
    MODULE PROCEDURE CMISSControlLoop_NumberOfSubLoopsGetNumber0
    MODULE PROCEDURE CMISSControlLoop_NumberOfSubLoopsGetNumber1
    MODULE PROCEDURE CMISSControlLoop_NumberOfSubLoopsGetObj
  END INTERFACE !CMISSControlLoop_NumberOfSubLoopsGet

  !>Sets/changes the number of sub loops for a control loop. \todo is this really a public method???
  INTERFACE CMISSControlLoop_NumberOfSubLoopsSet
    MODULE PROCEDURE CMISSControlLoop_NumberOfSubLoopsSetNumber0
    MODULE PROCEDURE CMISSControlLoop_NumberOfSubLoopsSetNumber1
    MODULE PROCEDURE CMISSControlLoop_NumberOfSubLoopsSetObj
  END INTERFACE !CMISSControlLoop_NumberOfSubLoopsGet

  !>Sets/changes the output parameters for a time control loop.
  INTERFACE CMISSControlLoop_TimeOutputSet
    MODULE PROCEDURE CMISSControlLoop_TimeOutputSetNumber0
    MODULE PROCEDURE CMISSControlLoop_TimeOutputSetNumber1
    MODULE PROCEDURE CMISSControlLoop_TimeOutputSetObj
  END INTERFACE !CMISSControlLoop_TimeOutputSet

  !>Returns the output type for a control loop.
  INTERFACE CMISSControlLoop_OutputTypeGet
    MODULE PROCEDURE CMISSControlLoop_OutputTypeGetNumber0
    MODULE PROCEDURE CMISSControlLoop_OutputTypeGetNumber1
    MODULE PROCEDURE CMISSControlLoop_OutputTypeGetObj
  END INTERFACE !CMISSControlLoop_OutputTypeGet

  !>Sets/changes the output type for a control loop.
  INTERFACE CMISSControlLoop_OutputTypeSet
    MODULE PROCEDURE CMISSControlLoop_OutputTypeSetNumber0
    MODULE PROCEDURE CMISSControlLoop_OutputTypeSetNumber1
    MODULE PROCEDURE CMISSControlLoop_OutputTypeSetObj
  END INTERFACE !CMISSControlLoop_OutputTypeSet

  !>Sets/changes the input parameters for a time control loop.
  INTERFACE CMISSControlLoop_TimeInputSet
    MODULE PROCEDURE CMISSControlLoop_TimeInputSetNumber0
    MODULE PROCEDURE CMISSControlLoop_TimeInputSetNumber1
    MODULE PROCEDURE CMISSControlLoop_TimeInputSetObj
  END INTERFACE !CMISSControlLoop_TimeInputSet

  !>Returns the time parameters for a time control loop.
  INTERFACE CMISSControlLoop_TimesGet
    MODULE PROCEDURE CMISSControlLoop_TimesGetNumber0
    MODULE PROCEDURE CMISSControlLoop_TimesGetNumber1
    MODULE PROCEDURE CMISSControlLoop_TimesGetObj
  END INTERFACE !CMISSControlLoop_TimesGet

  !>Sets/Changes the time parameters for a time control loop.
  INTERFACE CMISSControlLoop_TimesSet
    MODULE PROCEDURE CMISSControlLoop_TimesSetNumber0
    MODULE PROCEDURE CMISSControlLoop_TimesSetNumber1
    MODULE PROCEDURE CMISSControlLoop_TimesSetObj
  END INTERFACE !CMISSControlLoop_TimesSet

  !>Sets/Changes the loop type for a control loop. \todo Is this really a public       method? \todo need a get method
  INTERFACE CMISSControlLoop_TypeSet
    MODULE PROCEDURE CMISSControlLoop_TypeSetNumber0
    MODULE PROCEDURE CMISSControlLoop_TypeSetNumber1
    MODULE PROCEDURE CMISSControlLoop_TypeSetObj
  END INTERFACE !CMISSControlLoop_TypeSet

  PUBLIC CMISS_CONTROL_LOOP_NODE

  PUBLIC CMISS_CONTROL_LOOP_NO_OUTPUT,CMISS_CONTROL_LOOP_PROGRESS_OUTPUT,CMISS_CONTROL_LOOP_TIMING_OUTPUT

  PUBLIC CMISSControlLoop_CurrentTimesGet

  PUBLIC CMISSControlLoop_Destroy

  PUBLIC CMISSControlLoop_ControlLoopGet

  PUBLIC CMISSControlLoop_IterationsSet

  PUBLIC CMISSControlLoop_LabelGet,CMISSControlLoop_LabelSet

  PUBLIC CMISSControlLoop_MaximumIterationsSet

  PUBLIC CMISSControlLoop_NumberOfSubLoopsGet,CMISSControlLoop_NumberOfSubLoopsSet

  PUBLIC CMISSControlLoop_OutputTypeGet,CMISSControlLoop_OutputTypeSet

  PUBLIC CMISSControlLoop_TimeOutputSet,CMISSControlLoop_TimeInputSet

  PUBLIC CMISSControlLoop_TimesGet,CMISSControlLoop_TimesSet

  PUBLIC CMISSControlLoop_TypeSet


!!==================================================================================================================================
!!
!! COORDINATE_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_CoordinateConstants OPENCMISS::Coordinate::Constants
  !> \brief Coordinate constants.
  !>@{
  !> \addtogroup OPENCMISS_CoordinateSystemTypes OPENCMISS::Coordinate::SystemTypes
  !> \brief Coordinate system type parameters.
  !> \see OPENCMISS::Coordinate,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_RECTANGULAR_CARTESIAN_TYPE = COORDINATE_RECTANGULAR_CARTESIAN_TYPE !<Rectangular Cartesian coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_CYLINDRICAL_POLAR_TYPE = COORDINATE_CYLINDRICAL_POLAR_TYPE !<Cylindrical polar coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_SPHERICAL_POLAR_TYPE = COORDINATE_SPHERICAL_POLAR_TYPE !<Spherical polar coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_PROLATE_SPHEROIDAL_TYPE = COORDINATE_PROLATE_SPHEROIDAL_TYPE !<Prolate spheroidal coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_OBLATE_SPHEROIDAL_TYPE = COORDINATE_OBLATE_SPHEROIDAL_TYPE !<Oblate spheroidal coordinate system type \see OPENCMISS_CoordinateSystemTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_CoordinateRadialInterpolations OPENCMISS::Coordinate::RadialInterpolations
  !> \brief The type of radial interpolation for polar coordinate systems
  !> \see OPENCMISS::Coordinate,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_NO_RADIAL_INTERPOLATION_TYPE = COORDINATE_NO_RADIAL_INTERPOLATION_TYPE !<No radial interpolation \see OPENCMISS_CoordinateRadialInterpolations,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_RADIAL_INTERPOLATION_TYPE = COORDINATE_RADIAL_INTERPOLATION_TYPE !<r radial interpolation \see OPENCMISS_CoordinateRadialInterpolations,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_RADIAL_SQUARED_INTERPOLATION_TYPE = COORDINATE_RADIAL_SQUARED_INTERPOLATION_TYPE !<r^2 radial interpolation \see OPENCMISS_CoordinateRadialInterpolations,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_COORDINATE_RADIAL_CUBED_INTERPOLATION_TYPE = COORDINATE_RADIAL_CUBED_INTERPOLATION_TYPE !<r^3 radial interpolation \see OPENCMISS_CoordinateRadialInterpolations,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the creation of a coordinate system. \see OPENCMISS::CMISSCoordinateSystem_CreateStart
  INTERFACE CMISSCoordinateSystem_CreateFinish
    MODULE PROCEDURE CMISSCoordinateSystem_CreateFinishNumber
    MODULE PROCEDURE CMISSCoordinateSystem_CreateFinishObj
  END INTERFACE !CMISSCoordinateSystem_CreateFinish

  !>Starts the creation of a coordinate system. \see OPENCMISS::CMISSCoordinateSystem_CreateFinish
  INTERFACE CMISSCoordinateSystem_CreateStart
    MODULE PROCEDURE CMISSCoordinateSystem_CreateStartNumber
    MODULE PROCEDURE CMISSCoordinateSystem_CreateStartObj
  END INTERFACE !CMISSCoordinateSystem_CreateStart

  !>Destorys a coordinate system.
  INTERFACE CMISSCoordinateSystem_Destroy
    MODULE PROCEDURE CMISSCoordinateSystem_DestroyNumber
    MODULE PROCEDURE CMISSCoordinateSystem_DestroyObj
  END INTERFACE !CMISSCoordinateSystem_Destroy

  !>Returns the coordinate system dimension. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystem_DimensionGet
    MODULE PROCEDURE CMISSCoordinateSystem_DimensionGetNumber
    MODULE PROCEDURE CMISSCoordinateSystem_DimensionGetObj
  END INTERFACE !CMISSCoordinateSystem_DimensionGet

  !>Sets/changes the coordinate system dimension. \todo fix pointers
  INTERFACE CMISSCoordinateSystem_DimensionSet
    MODULE PROCEDURE CMISSCoordinateSystem_DimensionSetNumber
    MODULE PROCEDURE CMISSCoordinateSystem_DimensionSetObj
  END INTERFACE !CMISSCoordinateSystem_DimensionSet

  !>Returns the coordinate system focus. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystem_FocusGet
    MODULE PROCEDURE CMISSCoordinateSystem_FocusGetNumber
    MODULE PROCEDURE CMISSCoordinateSystem_FocusGetObj
  END INTERFACE !CMISSCoordinateSystem_FocusGet

  !>Sets/changes the coordinate system focus. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystem_FocusSet
    MODULE PROCEDURE CMISSCoordinateSystem_FocusSetNumber
    MODULE PROCEDURE CMISSCoordinateSystem_FocusSetObj
  END INTERFACE !CMISSCoordinateSystem_FocusSet

  !>Returns the coordinate system radial interpolation type. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystem_RadialInterpolationGet
    MODULE PROCEDURE CMISSCoordinateSystem_RadialInterpolationGetNumber
    MODULE PROCEDURE CMISSCoordinateSystem_RadialInterpolationGetObj
  END INTERFACE !CMISSCoordinateSystem_RadialInterpolationGet

  !>Sets/changes the coordinate system radial interpolation type. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystem_RadialInterpolationSet
    MODULE PROCEDURE CMISSCoordinateSystem_RadialInterpolationSetNumber
    MODULE PROCEDURE CMISSCoordinateSystem_RadialInterpolationSetObj
  END INTERFACE !CMISSCoordinateSystem_RadialInterpolationSet

  !>Returns the coordinate system type. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystem_TypeGet
    MODULE PROCEDURE CMISSCoordinateSystem_TypeGetNumber
    MODULE PROCEDURE CMISSCoordinateSystem_TypeGetObj
  END INTERFACE !CMISSCoordinateSystem_TypeGet

  !>Sets/changes the coordinate system type. \todo user number method \todo fix pointers
  INTERFACE CMISSCoordinateSystem_TypeSet
    MODULE PROCEDURE CMISSCoordinateSystem_TypeSetNumber
    MODULE PROCEDURE CMISSCoordinateSystem_TypeSetObj
  END INTERFACE !CMISSCoordinateSystem_TypeSet

  !>Returns the coordinate system orign.
  INTERFACE CMISSCoordinateSystem_OriginGet
    MODULE PROCEDURE CMISSCoordinateSystem_OriginGetNumber
    MODULE PROCEDURE CMISSCoordinateSystem_OriginGetObj
  END INTERFACE !CMISSCoordinateSystem_OriginGet

  !>Sets/changes the coordinate system orign.
  INTERFACE CMISSCoordinateSystem_OriginSet
    MODULE PROCEDURE CMISSCoordinateSystem_OriginSetNumber
    MODULE PROCEDURE CMISSCoordinateSystem_OriginSetObj
  END INTERFACE !CMISSCoordinateSystem_OriginSet

  !>Returns the coordinate system orientation.
  INTERFACE CMISSCoordinateSystem_OrientationGet
    MODULE PROCEDURE CMISSCoordinateSystem_OrientationGetNumber
    MODULE PROCEDURE CMISSCoordinateSystem_OrientationGetObj
  END INTERFACE !CMISSCoordinateSystem_OrientationGet

  !>Sets/changes the coordinate system orientation.
  INTERFACE CMISSCoordinateSystem_OrientationSet
    MODULE PROCEDURE CMISSCoordinateSystem_OrientationSetNumber
    MODULE PROCEDURE CMISSCoordinateSystem_OrientationSetObj
  END INTERFACE !CMISSCoordinateSystem_OrientationSet

  PUBLIC CMISS_COORDINATE_RECTANGULAR_CARTESIAN_TYPE,CMISS_COORDINATE_CYLINDRICAL_POLAR_TYPE, &
    & CMISS_COORDINATE_SPHERICAL_POLAR_TYPE, &
    & CMISS_COORDINATE_PROLATE_SPHEROIDAL_TYPE,CMISS_COORDINATE_OBLATE_SPHEROIDAL_TYPE

  PUBLIC CMISS_COORDINATE_NO_RADIAL_INTERPOLATION_TYPE,CMISS_COORDINATE_RADIAL_INTERPOLATION_TYPE, &
    & CMISS_COORDINATE_RADIAL_SQUARED_INTERPOLATION_TYPE,CMISS_COORDINATE_RADIAL_CUBED_INTERPOLATION_TYPE

  PUBLIC CMISSCoordinateSystem_CreateFinish,CMISSCoordinateSystem_CreateStart

  PUBLIC CMISSCoordinateSystem_Destroy

  PUBLIC CMISSCoordinateSystem_DimensionGet,CMISSCoordinateSystem_DimensionSet

  PUBLIC CMISSCoordinateSystem_FocusGet,CMISSCoordinateSystem_FocusSet

  PUBLIC CMISSCoordinateSystem_RadialInterpolationGet,CMISSCoordinateSystem_RadialInterpolationSet

  PUBLIC CMISSCoordinateSystem_TypeGet,CMISSCoordinateSystem_TypeSet

  PUBLIC CMISSCoordinateSystem_OriginGet,CMISSCoordinateSystem_OriginSet

  PUBLIC CMISSCoordinateSystem_OrientationGet,CMISSCoordinateSystem_OrientationSet

!!==================================================================================================================================
!!
!! DATA_POINT_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the process of creating data points in a region. \see OPENCMISS::CMISSDataPoints_CreateStart
  INTERFACE CMISSDataPoints_CreateFinish
    MODULE PROCEDURE CMISSDataPoints_CreateFinishNumber
    MODULE PROCEDURE CMISSDataPoints_CreateFinishObj
  END INTERFACE !CMISSDataPoints_CreateFinish

  !>Starts the process of creating data points in a region. \see OPENCMISS::CMISSDataPoints_CreateFinish
  INTERFACE CMISSDataPoints_CreateStart
    MODULE PROCEDURE CMISSDataPoints_CreateStartNumber
    MODULE PROCEDURE CMISSDataPoints_CreateStartObj
    MODULE PROCEDURE CMISSDataPoints_CreateStartInterfaceObj
  END INTERFACE !CMISSDataPoints_CreateFinish

  !>Destroys data points.
  INTERFACE CMISSDataPoints_Destroy
    MODULE PROCEDURE CMISSDataPoints_DestroyNumber
    MODULE PROCEDURE CMISSDataPoints_DestroyObj
  END INTERFACE !CMISSDataPoints_Destroy

  !>Returns the number of data points
  INTERFACE CMISSDataPoints_NumberOfDataPointsGet
    MODULE PROCEDURE CMISSDataPoints_NumberOfDataPointsGetNumber
    MODULE PROCEDURE CMISSDataPoints_NumberOfDataPointsGetObj
  END INTERFACE !CMISSDataPoints_NumberOfDataPointsGet

  !>Returns the label for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSDataPoints_LabelGet
    MODULE PROCEDURE CMISSDataPoints_LabelGetCNumber
    MODULE PROCEDURE CMISSDataPoints_LabelGetCObj
    MODULE PROCEDURE CMISSDataPoints_LabelGetVSNumber
    MODULE PROCEDURE CMISSDataPoints_LabelGetVSObj
  END INTERFACE !CMISSDataPoints_LabelGet

  !>Sets/changes the label for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSDataPoints_LabelSet
    MODULE PROCEDURE CMISSDataPoints_LabelSetCNumber
    MODULE PROCEDURE CMISSDataPoints_LabelSetCObj
    MODULE PROCEDURE CMISSDataPoints_LabelSetVSNumber
    MODULE PROCEDURE CMISSDataPoints_LabelSetVSObj
  END INTERFACE !CMISSDataPoints_LabelSet

  !>Returns the user number for a data point identified by a given global number.
  INTERFACE CMISSDataPoints_UserNumberGet
    MODULE PROCEDURE CMISSDataPoints_UserNumberGetNumber
    MODULE PROCEDURE CMISSDataPoints_UserNumberGetObj
  END INTERFACE !CMISSDataPoints_UserNumberGet

  !>Sets/changes the user number for a data point identified by a given global number.
  INTERFACE CMISSDataPoints_UserNumberSet
    MODULE PROCEDURE CMISSDataPoints_UserNumberSetNumber
    MODULE PROCEDURE CMISSDataPoints_UserNumberSetObj
  END INTERFACE !CMISSDataPoints_UserNumberSet

  !>Returns the values for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSDataPoints_ValuesGet
    MODULE PROCEDURE CMISSDataPoints_ValuesGetNumber
    MODULE PROCEDURE CMISSDataPoints_ValuesGetObj
  END INTERFACE !CMISSDataPoints_ValuesGet

  !>Sets/changes the values for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSDataPoints_ValuesSet
    MODULE PROCEDURE CMISSDataPoints_ValuesSetNumber
    MODULE PROCEDURE CMISSDataPoints_ValuesSetObj
  END INTERFACE !CMISSDataPoints_ValuesSet

  !>Returns the weights for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSDataPoints_WeightsGet
    MODULE PROCEDURE CMISSDataPoints_WeightsGetNumber
    MODULE PROCEDURE CMISSDataPoints_WeightsGetObj
  END INTERFACE !CMISSDataPoints_WeightsGet

  !>Sets/changes the weights for a data point identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSDataPoints_WeightsSet
    MODULE PROCEDURE CMISSDataPoints_WeightsSetNumber
    MODULE PROCEDURE CMISSDataPoints_WeightsSetObj
  END INTERFACE !CMISSDataPoints_WeightsSet

  PUBLIC CMISSDataPoints_CreateFinish,CMISSDataPoints_CreateStart

  PUBLIC CMISSDataPoints_Destroy

  PUBLIC CMISSDataPoints_NumberOfDataPointsGet

  PUBLIC CMISSDataPoints_LabelGet,CMISSDataPoints_LabelSet

  PUBLIC CMISSDataPoints_UserNumberGet,CMISSDataPoints_UserNumberSet

  PUBLIC CMISSDataPoints_ValuesGet,CMISSDataPoints_ValuesSet

  PUBLIC CMISSDataPoints_WeightsGet,CMISSDataPoints_WeightsSet

!!==================================================================================================================================
!!
!! DATA_PROJECTION_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_DataProjectionConstants OPENCMISS::DataProjection::Constants
  !> \brief DataProjection  constants.
  !>@{
  !> \addtogroup OPENCMISS_DataProjectionProjectionTypes OPENCMISS::DataProjection::ProjectionTypes
  !> \brief Data Projection types
  !> \see OPENCMISS::DataProjection,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_DATA_PROJECTION_BOUNDARY_LINES_PROJECTION_TYPE = DATA_PROJECTION_BOUNDARY_LINES_PROJECTION_TYPE!<The boundary line projection type for data projection, only projects to boundary lines of the mesh. \see OPENCMISS_DataProjectionProjectionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_DATA_PROJECTION_BOUNDARY_FACES_PROJECTION_TYPE = DATA_PROJECTION_BOUNDARY_FACES_PROJECTION_TYPE!<The boundary face projection type for data projection, only projects to boundary faces of the mesh. \see OPENCMISS_DataProjectionProjectionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_DATA_PROJECTION_ALL_ELEMENTS_PROJECTION_TYPE = DATA_PROJECTION_ALL_ELEMENTS_PROJECTION_TYPE !<The element projection type for data projection, projects to all elements in mesh. \see OPENCMISS_DataProjectionProjectionTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the absolute tolerance for a data projection.
  INTERFACE CMISSDataProjection_AbsoluteToleranceGet
    MODULE PROCEDURE CMISSDataProjection_AbsoluteToleranceGetNumber
    MODULE PROCEDURE CMISSDataProjection_AbsoluteToleranceGetObj
  END INTERFACE !CMISSDataProjectionWeightsGet

  !>Sets/changes the absolute tolerance for a data projection.
  INTERFACE CMISSDataProjection_AbsoluteToleranceSet
    MODULE PROCEDURE CMISSDataProjection_AbsoluteToleranceSetNumber
    MODULE PROCEDURE CMISSDataProjection_AbsoluteToleranceSetObj
  END INTERFACE !CMISSDataProjectionWeightsSet

  !>Finishes the creation of a new data projection. \see OPENCMISS::CMISSDataProjection_CreateStart
  INTERFACE CMISSDataProjection_CreateFinish
    MODULE PROCEDURE CMISSDataProjection_CreateFinishNumber
    MODULE PROCEDURE CMISSDataProjection_CreateFinishObj
  END INTERFACE !CMISSDataProjection_CreateFinish

  !>Starts the creation of a new data projection. \see OPENCMISS::CMISSDataProjection_CreateFinish
  INTERFACE CMISSDataProjection_CreateStart
    MODULE PROCEDURE CMISSDataProjection_CreateStartNumber
    MODULE PROCEDURE CMISSDataProjection_CreateStartObj
  END INTERFACE !CMISSDataProjection_CreateStart

  !>Destroy a data projection.
  INTERFACE CMISSDataProjection_Destroy
    MODULE PROCEDURE CMISSDataProjection_DestroyNumber
    MODULE PROCEDURE CMISSDataProjection_DestroyObj
  END INTERFACE !CMISSDataProjection_Destroy
  
  !>Evaluate the data points position in a field based on data projection
  INTERFACE CMISSDataProjection_DataPointsPositionEvaluate
    MODULE PROCEDURE CMISSDataProjection_DataPointsPositionEvaluateRegionNumber
    MODULE PROCEDURE CMISSDataProjection_DataPointsPositionEvaluateInterfaceNumber
    MODULE PROCEDURE CMISSDataProjection_DataPointsPositionEvaluateObj
  END INTERFACE !CMISSDataProjection_DataPointsPositionEvaluate

  !>Starts the evluation of data projection on the geometric field.
  INTERFACE CMISSDataProjection_ProjectionEvaluate
    MODULE PROCEDURE CMISSDataProjection_ProjectionEvaluateNumber
    MODULE PROCEDURE CMISSDataProjection_ProjectionEvaluateObj
  END INTERFACE !CMISSDataProjection_ProjectionEvaluate

  !>Returns the maximum iteration update for a data projection.
  INTERFACE CMISSDataProjection_MaximumIterationUpdateGet
    MODULE PROCEDURE CMISSDataProjection_MaximumIterationUpdateGetNumber
    MODULE PROCEDURE CMISSDataProjection_MaximumIterationUpdateGetObj
  END INTERFACE !CMISSDataProjection_MaximumIterationUpdateGet

  !>Sets/changes the maximum iteration update for a data projection.
  INTERFACE CMISSDataProjection_MaximumIterationUpdateSet
    MODULE PROCEDURE CMISSDataProjection_MaximumIterationUpdateSetNumber
    MODULE PROCEDURE CMISSDataProjection_MaximumIterationUpdateSetObj
  END INTERFACE !CMISSDataProjection_MaximumIterationUpdateSet

  !>Returns the maximum number of iterations for a data projection.
  INTERFACE CMISSDataProjection_MaximumNumberOfIterationsGet
    MODULE PROCEDURE CMISSDataProjection_MaximumNumberOfIterationsGetNumber
    MODULE PROCEDURE CMISSDataProjection_MaximumNumberOfIterationsGetObj
  END INTERFACE !CMISSDataProjection_MaximumNumberOfIterationsGet

  !>Sets/changes the maximum number of iterations for a data projection.
  INTERFACE CMISSDataProjection_MaximumNumberOfIterationsSet
    MODULE PROCEDURE CMISSDataProjection_MaximumNumberOfIterationsSetNumber
    MODULE PROCEDURE CMISSDataProjection_MaximumNumberOfIterationsSetObj
  END INTERFACE !CMISSDataProjection_MaximumNumberOfIterationsSet

  !>Returns the number of closest elements for a data projection.
  INTERFACE CMISSDataProjection_NumberOfClosestElementsGet
    MODULE PROCEDURE CMISSDataProjection_NumberOfClosestElementsGetNumber
    MODULE PROCEDURE CMISSDataProjection_NumberOfClosestElementsGetObj
  END INTERFACE !CMISSDataProjection_NumberOfClosestElementsGet

  !>Sets/changes the number of closest elements for a data projection.
  INTERFACE CMISSDataProjection_NumberOfClosestElementsSet
    MODULE PROCEDURE CMISSDataProjection_NumberOfClosestElementsSetNumber
    MODULE PROCEDURE CMISSDataProjection_NumberOfClosestElementsSetObj
  END INTERFACE !CMISSDataProjection_NumberOfClosestElementsSet
  
  !>Set the candidate element numbers and their local face/line numbers
  INTERFACE CMISSDataProjection_ProjectionCandidatesSet
    MODULE PROCEDURE CMISSDataProjection_ProjectionCandidatesSetRegionNumber
    MODULE PROCEDURE CMISSDataProjection_ProjectionCandidatesSetInterfaceNumber
    MODULE PROCEDURE CMISSDataProjection_ProjectionCandidatesSetObj
  END INTERFACE !CMISSDataProjection_ProjectionCandidatesSet

  !>Returns the projection type for a data projection.
  INTERFACE CMISSDataProjection_ProjectionTypeGet
    MODULE PROCEDURE CMISSDataProjection_ProjectionTypeGetNumber
    MODULE PROCEDURE CMISSDataProjection_ProjectionTypeGetObj
  END INTERFACE !CMISSDataProjection_ProjectionTypeGet

  !>Sets/changes the projection type for a data projection.
  INTERFACE CMISSDataProjection_ProjectionTypeSet
    MODULE PROCEDURE CMISSDataProjection_ProjectionTypeSetNumber
    MODULE PROCEDURE CMISSDataProjection_ProjectionTypeSetObj
  END INTERFACE !CMISSDataProjection_ProjectionTypeSet

  !>Returns the relative tolerance for a data projection.
  INTERFACE CMISSDataProjection_RelativeToleranceGet
    MODULE PROCEDURE CMISSDataProjection_RelativeToleranceGetNumber
    MODULE PROCEDURE CMISSDataProjection_RelativeToleranceGetObj
  END INTERFACE !CMISSDataProjection_RelativeToleranceGet

  !>Sets/changes the relative tolerance for a data projection.
  INTERFACE CMISSDataProjection_RelativeToleranceSet
    MODULE PROCEDURE CMISSDataProjection_RelativeToleranceSetNumber
    MODULE PROCEDURE CMISSDataProjection_RelativeToleranceSetObj
  END INTERFACE !CMISSDataProjection_RelativeToleranceSet

  !>Returns the starting xi for a data projection.
  INTERFACE CMISSDataProjection_StartingXiGet
    MODULE PROCEDURE CMISSDataProjection_StartingXiGetNumber
    MODULE PROCEDURE CMISSDataProjection_StartingXiGetObj
  END INTERFACE !CMISSDataProjection_StartingXiGet

  !>Sets/changes the starting xi for a data projection.
  INTERFACE CMISSDataProjection_StartingXiSet
    MODULE PROCEDURE CMISSDataProjection_StartingXiSetNumber
    MODULE PROCEDURE CMISSDataProjection_StartingXiSetObj
  END INTERFACE !CMISSDataProjection_StartingXiSet

  !>Sets/changes the element number for a data point projection.
  INTERFACE CMISSDataProjection_ElementSet
    MODULE PROCEDURE CMISSDataProjection_ElementSetRegionNumber
    MODULE PROCEDURE CMISSDataProjection_ElementSetInterfaceNumber
    MODULE PROCEDURE CMISSDataProjection_ElementSetObj
  END INTERFACE !CMISSDataProjection_ElementSet

  !>Gets the label for a data point projection.
  INTERFACE CMISSDataProjection_LabelGet
    MODULE PROCEDURE CMISSDataProjection_LabelGetCRegionNumber
    MODULE PROCEDURE CMISSDataProjection_LabelGetCInterfaceNumber
    MODULE PROCEDURE CMISSDataProjection_LabelGetCObj
    MODULE PROCEDURE CMISSDataProjection_LabelGetVSRegionNumber
    MODULE PROCEDURE CMISSDataProjection_LabelGetVSInterfaceNumber
    MODULE PROCEDURE CMISSDataProjection_LabelGetVSObj
  END INTERFACE !CMISSDataProjection_LabelGet

  !>Sets/changes the label for a data point projection.
  INTERFACE CMISSDataProjection_LabelSet
    MODULE PROCEDURE CMISSDataProjection_LabelSetCRegionNumber
    MODULE PROCEDURE CMISSDataProjection_LabelSetCInterfaceNumber
    MODULE PROCEDURE CMISSDataProjection_LabelSetCObj
    MODULE PROCEDURE CMISSDataProjection_LabelSetVSRegionNumber
    MODULE PROCEDURE CMISSDataProjection_LabelSetVSInterfaceNumber
    MODULE PROCEDURE CMISSDataProjection_LabelSetVSObj
  END INTERFACE !CMISSDataProjection_LabelSet

  !>Returns the projection distance for a data point identified by a given user number.
  INTERFACE CMISSDataProjection_ResultDistanceGet
    MODULE PROCEDURE CMISSDataProjection_ResultDistanceGetNumber
    MODULE PROCEDURE CMISSDataProjection_ResultDistanceGetObj
  END INTERFACE !CMISSDataProjection_ResultDistanceGet

  !>Returns the projection element number for a data point identified by a given user number.
  INTERFACE CMISSDataProjection_ResultElementNumberGet
    MODULE PROCEDURE CMISSDataProjection_ResultElementNumberGetNumber
    MODULE PROCEDURE CMISSDataProjection_ResultElementNumberGetObj
  END INTERFACE !CMISSDataProjection_ResultElementNumberGet

  !>Returns the projection element face number for a data point identified by a given user number.
  INTERFACE CMISSDataProjection_ResultElementFaceNumberGet
    MODULE PROCEDURE CMISSDataProjection_ResultElementFaceNumberGetNumber
    MODULE PROCEDURE CMISSDataProjection_ResultElementFaceNumberGetObj
  END INTERFACE !CMISSDataProjection_ResultElementFaceNumberGet

  !>Returns the projection element line number for a data point identified by a given user number.
  INTERFACE CMISSDataProjection_ResultElementLineNumberGet
    MODULE PROCEDURE CMISSDataProjection_ResultElementLineNumberGetNumber
    MODULE PROCEDURE CMISSDataProjection_ResultElementLineNumberGetObj
  END INTERFACE !CMISSDataProjection_ResultElementLineNumberGet

  !>Returns the projection exit tag for a data point identified by a given user number.
  INTERFACE CMISSDataProjection_ResultExitTagGet
    MODULE PROCEDURE CMISSDataProjection_ResultExitTagGetNumber
    MODULE PROCEDURE CMISSDataProjection_ResultExitTagGetObj
  END INTERFACE !CMISSDataProjection_ResultExitTagGet

  !>Returns the projection xi for a data point identified by a given user number.
  INTERFACE CMISSDataProjection_ResultXiGet
    MODULE PROCEDURE CMISSDataProjection_ResultXiGetNumber
    MODULE PROCEDURE CMISSDataProjection_ResultXiGetObj
  END INTERFACE !CMISSDataProjection_ResultXiGet

  !>Sets the projection xi for a data point identified by a given user number.
  INTERFACE CMISSDataProjection_ResultXiSet
    MODULE PROCEDURE CMISSDataProjection_ResultXiSetNumber
    MODULE PROCEDURE CMISSDataProjection_ResultXiSetObj
  END INTERFACE !CMISSDataProjection_ResultXiSet

  PUBLIC CMISS_DATA_PROJECTION_BOUNDARY_LINES_PROJECTION_TYPE,CMISS_DATA_PROJECTION_BOUNDARY_FACES_PROJECTION_TYPE

  PUBLIC CMISS_DATA_PROJECTION_ALL_ELEMENTS_PROJECTION_TYPE

  PUBLIC CMISSDataProjection_AbsoluteToleranceGet,CMISSDataProjection_AbsoluteToleranceSet

  PUBLIC CMISSDataProjection_CreateFinish,CMISSDataProjection_CreateStart

  PUBLIC CMISSDataProjection_Destroy
  
  PUBLIC CMISSDataProjection_DataPointsPositionEvaluate
  
  PUBLIC CMISSDataProjection_ProjectionCandidatesSet

  PUBLIC CMISSDataProjection_ProjectionEvaluate

  PUBLIC CMISSDataProjection_MaximumIterationUpdateGet,CMISSDataProjection_MaximumIterationUpdateSet

  PUBLIC CMISSDataProjection_MaximumNumberOfIterationsGet,CMISSDataProjection_MaximumNumberOfIterationsSet

  PUBLIC CMISSDataProjection_NumberOfClosestElementsGet,CMISSDataProjection_NumberOfClosestElementsSet

  PUBLIC CMISSDataProjection_ProjectionTypeGet,CMISSDataProjection_ProjectionTypeSet

  PUBLIC CMISSDataProjection_RelativeToleranceGet,CMISSDataProjection_RelativeToleranceSet

  PUBLIC CMISSDataProjection_StartingXiGet,CMISSDataProjection_StartingXiSet

  PUBLIC CMISSDataProjection_ElementSet

  PUBLIC CMISSDataProjection_LabelGet,CMISSDataProjection_LabelSet

  PUBLIC CMISSDataProjection_ResultDistanceGet,CMISSDataProjection_ResultElementNumberGet

  PUBLIC CMISSDataProjection_ResultElementFaceNumberGet,CMISSDataProjection_ResultElementLineNumberGet

  PUBLIC CMISSDataProjection_ResultExitTagGet

  PUBLIC CMISSDataProjection_ResultXiGet, CMISSDataProjection_ResultXiSet

!!==================================================================================================================================
!!
!! EQUATIONS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_EquationsConstants OPENCMISS::Equations::Constants
  !> \brief Equations  constants.
  !>@{
  !> \addtogroup OPENCMISS_EquationsOutputTypes OPENCMISS::Equations::OutputTypes
  !> \brief Equations output types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_NO_OUTPUT = EQUATIONS_NO_OUTPUT!<No output from the equations \see OPENCMISS_EquationsOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_TIMING_OUTPUT = EQUATIONS_TIMING_OUTPUT !<Timing information output. \see OPENCMISS_EquationsOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_MATRIX_OUTPUT = EQUATIONS_MATRIX_OUTPUT !<All below and equation matrices output. \see OPENCMISS_EquationsOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_ELEMENT_MATRIX_OUTPUT = EQUATIONS_ELEMENT_MATRIX_OUTPUT !<All below and element matrices output. \see OPENCMISS_EquationsOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_NODAL_MATRIX_OUTPUT = EQUATIONS_NODAL_MATRIX_OUTPUT !<All below and nodal matrices output. \see OPENCMISS_EquationsOutputTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsSparsityTypes OPENCMISS::Equations::SparsityTypes
  !> \brief Equations sparsity types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SPARSE_MATRICES = EQUATIONS_SPARSE_MATRICES !<Use sparse matrices for the equations. \see OPENCMISS_EquationsSparsityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_FULL_MATRICES = EQUATIONS_FULL_MATRICES !<Use fully populated matrices for the equations. \see OPENCMISS_EquationsSparsityTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsLumpingTypes OPENCMISS::Equations::LumpingTypes
  !> \brief Equations lumping types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_UNLUMPED_MATRICES = EQUATIONS_UNLUMPED_MATRICES !<The equations matrices are not lumped. \see OPENCMISS_EquationsLumpingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_LUMPED_MATRICES = EQUATIONS_LUMPED_MATRICES !<The equations matrices are "mass" lumped. \see OPENCMISS_EquationsLumpingTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsLinearityTypes OPENCMISS::Equations::LinearityTypes
  !> \brief The equations linearity types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_LINEAR = EQUATIONS_LINEAR !<The equations are linear. \see OPENCMISS_EquationsLinearityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_NONLINEAR = EQUATIONS_NONLINEAR !<The equations are non-linear. \see \see OPENCMISS_EquationsLinearityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_NONLINEAR_BCS = EQUATIONS_NONLINEAR_BCS !<The equations have non-linear boundary conditions. \see \see OPENCMISS_EquationsLinearityTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsTimeDepedenceTypes OPENCMISS::Equations::TimeDepedenceTypes
  !> \brief The equations time dependence types
  !> \see OPENCMISS::Equations,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_STATIC = EQUATIONS_STATIC !<The equations are static and have no time dependence. \see OPENCMISS_EquationsTimeDepedenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_QUASISTATIC = EQUATIONS_QUASISTATIC !<The equations are quasi-static. \see OPENCMISS_EquationsTimeDepedenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_FIRST_ORDER_DYNAMIC = EQUATIONS_FIRST_ORDER_DYNAMIC !<The equations are first order dynamic. \see OPENCMISS_EquationsTimeDepedenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SECOND_ORDER_DYNAMIC = EQUATIONS_SECOND_ORDER_DYNAMIC !<The equations are a second order dynamic. \see OPENCMISS_EquationsTimeDepedenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_TIME_STEPPING = EQUATIONS_TIME_STEPPING !<The equations are for time stepping. \see OPENCMISS_EquationsTimeDepedenceTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Destroys equations for an equations set.
  INTERFACE CMISSEquations_Destroy
    MODULE PROCEDURE CMISSEquations_DestroyNumber
    MODULE PROCEDURE CMISSEquations_DestroyObj
  END INTERFACE !CMISSEquations_Destroy

  !>Gets the linearity type for equations.
  INTERFACE CMISSEquations_LinearityTypeGet
    MODULE PROCEDURE CMISSEquations_LinearityTypeGetNumber
    MODULE PROCEDURE CMISSEquations_LinearityTypeGetObj
  END INTERFACE !CMISSEquations_LinearityTypeGet

  !>Gets the lumping type for equations.
  INTERFACE CMISSEquations_LumpingTypeGet
    MODULE PROCEDURE CMISSEquations_LumpingTypeGetNumber
    MODULE PROCEDURE CMISSEquations_LumpingTypeGetObj
  END INTERFACE !CMISSEquations_LumpingTypeGet

  !>Sets/changes the lumping type for equations.
  INTERFACE CMISSEquations_LumpingTypeSet
    MODULE PROCEDURE CMISSEquations_LumpingTypeSetNumber
    MODULE PROCEDURE CMISSEquations_LumpingTypeSetObj
  END INTERFACE !CMISSEquations_LumpingTypeSet

  !>Gets the output type for equations.
  INTERFACE CMISSEquations_OutputTypeGet
    MODULE PROCEDURE CMISSEquations_OutputTypeGetNumber
    MODULE PROCEDURE CMISSEquations_OutputTypeGetObj
  END INTERFACE !CMISSEquations_OutputTypeGet

  !>Sets/changes the output type for equations.
  INTERFACE CMISSEquations_OutputTypeSet
    MODULE PROCEDURE CMISSEquations_OutputTypeSetNumber
    MODULE PROCEDURE CMISSEquations_OutputTypeSetObj
  END INTERFACE !CMISSEquations_OutputTypeSet

 !>Gets the sparsity type for equations.
  INTERFACE CMISSEquations_SparsityTypeGet
    MODULE PROCEDURE CMISSEquations_SparsityTypeGetNumber
    MODULE PROCEDURE CMISSEquations_SparsityTypeGetObj
  END INTERFACE !CMISSEquations_SparsityTypeGet

  !>Sets/changes the sparsity type for equations.
  INTERFACE CMISSEquations_SparsityTypeSet
    MODULE PROCEDURE CMISSEquations_SparsityTypeSetNumber
    MODULE PROCEDURE CMISSEquations_SparsityTypeSetObj
  END INTERFACE !CMISSEquations_SparsityTypeSet

  !>Gets the time dependence type for equations.
  INTERFACE CMISSEquations_TimeDependenceTypeGet
    MODULE PROCEDURE CMISSEquations_TimeDependenceTypeGetNumber
    MODULE PROCEDURE CMISSEquations_TimeDependenceTypeGetObj
  END INTERFACE !CMISSEquations_TimeDependenceTypeGet

  PUBLIC CMISS_EQUATIONS_NO_OUTPUT,CMISS_EQUATIONS_TIMING_OUTPUT,CMISS_EQUATIONS_MATRIX_OUTPUT

  PUBLIC CMISS_EQUATIONS_ELEMENT_MATRIX_OUTPUT,CMISS_EQUATIONS_NODAL_MATRIX_OUTPUT

  PUBLIC CMISS_EQUATIONS_SPARSE_MATRICES,CMISS_EQUATIONS_FULL_MATRICES

  PUBLIC CMISS_EQUATIONS_UNLUMPED_MATRICES,CMISS_EQUATIONS_LUMPED_MATRICES

  PUBLIC CMISS_EQUATIONS_LINEAR,CMISS_EQUATIONS_NONLINEAR,CMISS_EQUATIONS_NONLINEAR_BCS

  PUBLIC CMISS_EQUATIONS_STATIC,CMISS_EQUATIONS_QUASISTATIC,CMISS_EQUATIONS_FIRST_ORDER_DYNAMIC, &
    & CMISS_EQUATIONS_SECOND_ORDER_DYNAMIC, &
    & CMISS_EQUATIONS_TIME_STEPPING

  PUBLIC CMISSEquations_Destroy

  PUBLIC CMISSEquations_LinearityTypeGet

  PUBLIC CMISSEquations_LumpingTypeGet,CMISSEquations_LumpingTypeSet

  PUBLIC CMISSEquations_OutputTypeGet,CMISSEquations_OutputTypeSet

  PUBLIC CMISSEquations_SparsityTypeGet,CMISSEquations_SparsityTypeSet

  PUBLIC CMISSEquations_TimeDependenceTypeGet

  PUBLIC CMISSEquations_NumberOfLinearMatricesGet

  PUBLIC CMISSEquations_NumberOfJacobianMatricesGet

  PUBLIC CMISSEquations_NumberOfDynamicMatricesGet

  PUBLIC CMISSEquations_LinearMatrixGet
  
  PUBLIC CMISSEquations_JacobianMatrixGet

  PUBLIC CMISSEquations_DynamicMatrixGet

  PUBLIC CMISSEquations_DynamicMatrixGetByType

  PUBLIC CMISSEquations_DynamicMatrixTypeGet

  PUBLIC CMISSEquations_RhsVectorGet

  PUBLIC CMISSEquations_ResidualVectorGet

  PUBLIC CMISSEquations_ResidualNumberOfVariablesGet

  PUBLIC CMISSEquations_ResidualVariablesGet

  PUBLIC CMISSEquations_SourceVectorGet

!!==================================================================================================================================
!!
!! EQUATIONS_SET_CONSTANTS
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_EquationsSetConstants OPENCMISS::EquationsSet::Constants
  !> \brief Equations set constants.
  !>@{
  !> \addtogroup OPENCMISS_EquationsSetClasses OPENCMISS::EquationsSet::Classes
  !> \brief Equations set classes.
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_CLASS = EQUATIONS_SET_NO_CLASS !<No equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ELASTICITY_CLASS = EQUATIONS_SET_ELASTICITY_CLASS !<Elasticity equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FLUID_MECHANICS_CLASS = EQUATIONS_SET_FLUID_MECHANICS_CLASS !<Fluid Mechanics equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ELECTROMAGNETICS_CLASS = EQUATIONS_SET_ELECTROMAGNETICS_CLASS !<Electromagnetics equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CLASSICAL_FIELD_CLASS = EQUATIONS_SET_CLASSICAL_FIELD_CLASS !<Classical Field equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_BIOELECTRICS_CLASS = EQUATIONS_SET_BIOELECTRICS_CLASS !<Bioelectrics equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MODAL_CLASS = EQUATIONS_SET_MODAL_CLASS !<Modal equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FITTING_CLASS = EQUATIONS_SET_FITTING_CLASS !<Fitting equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_OPTIMISATION_CLASS = EQUATIONS_SET_OPTIMISATION_CLASS !<Optimisation equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULTI_PHYSICS_CLASS = EQUATIONS_SET_MULTI_PHYSICS_CLASS !<Multi Physics equations set class \see OPENCMISS_EquationsSetClasses,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsSetTypes OPENCMISS::EquationsSet::Types
  !> \brief Equations set Types.
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_TYPE = EQUATIONS_SET_NO_TYPE !<No equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_TYPE = EQUATIONS_SET_LINEAR_ELASTICITY_TYPE !<Linear elasticity equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FINITE_ELASTICITY_TYPE = EQUATIONS_SET_FINITE_ELASTICITY_TYPE !<Finite elasticity equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_TYPE = EQUATIONS_SET_STOKES_EQUATION_TYPE !<Stokes equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TYPE = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TYPE !<Navier-Stokes equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DARCY_EQUATION_TYPE = EQUATIONS_SET_DARCY_EQUATION_TYPE !<Darcy equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DARCY_PRESSURE_EQUATION_TYPE = EQUATIONS_SET_DARCY_PRESSURE_EQUATION_TYPE !<Darcy pressure equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISEUILLE_EQUATION_TYPE = EQUATIONS_SET_POISEUILLE_EQUATION_TYPE !<Poiseuille equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_BURGERS_EQUATION_TYPE = EQUATIONS_SET_BURGERS_EQUATION_TYPE !<Burgers equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CHARACTERISTIC_EQUATION_TYPE = EQUATIONS_SET_CHARACTERISTIC_EQUATION_TYPE !<Characteristic equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ELECTROSTATIC_TYPE = EQUATIONS_SET_ELECTROSTATIC_TYPE !<Electrostatic equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MAGNETOSTATIC_TYPE = EQUATIONS_SET_MAGNETOSTATIC_TYPE !<Magnetostatic equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MAXWELLS_EQUATIONS_TYPE = EQUATIONS_SET_MAXWELLS_EQUATIONS_TYPE !<Maxwells equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LAPLACE_EQUATION_TYPE = EQUATIONS_SET_LAPLACE_EQUATION_TYPE !<Laplace equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISSON_EQUATION_TYPE = EQUATIONS_SET_POISSON_EQUATION_TYPE !<Poisson equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_HELMHOLTZ_EQUATION_TYPE = EQUATIONS_SET_HELMHOLTZ_EQUATION_TYPE !<Helmholtz equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_WAVE_EQUATION_TYPE = EQUATIONS_SET_WAVE_EQUATION_TYPE !<Wave equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DIFFUSION_EQUATION_TYPE = EQUATIONS_SET_DIFFUSION_EQUATION_TYPE !<Diffusion equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TYPE = &
    & EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TYPE !<Advection-Diffusion equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_TYPE = EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_TYPE !<Reaction-Diffusion equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_BIHARMONIC_EQUATION_TYPE = EQUATIONS_SET_BIHARMONIC_EQUATION_TYPE !<Biharmonic equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MONODOMAIN_EQUATION_TYPE = EQUATIONS_SET_MONODOMAIN_EQUATION_TYPE !<Monodomain equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_BIDOMAIN_EQUATION_TYPE = EQUATIONS_SET_BIDOMAIN_EQUATION_TYPE !<Bidomain equation equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_ELASTIC_MODAL_TYPE = EQUATIONS_SET_LINEAR_ELASTIC_MODAL_TYPE !<Linear elasticity modal equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DATA_FITTING_EQUATION_TYPE = EQUATIONS_SET_DATA_FITTING_EQUATION_TYPE !<Galerkin projection equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FINITE_ELASTICITY_DARCY_TYPE = EQUATIONS_SET_FINITE_ELASTICITY_DARCY_TYPE !<Finite Elasticity Darcy equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FINITE_ELASTICITY_STOKES_TYPE = EQUATIONS_SET_FINITE_ELASTICITY_STOKES_TYPE !<Finite Elasticity Stokes equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_TYPE = &
    & EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_TYPE !<Finite Elasticity Navier Stokes equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DIFFUSION_DIFFUSION_TYPE = EQUATIONS_SET_DIFFUSION_DIFFUSION_TYPE !<Diffusion Diffusion equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DIFFUSION_ADVECTION_DIFFUSION_TYPE = &
    & EQUATIONS_SET_DIFFUSION_ADVECTION_DIFFUSION_TYPE !<Diffusion Advection Diffusion equations set type \see OPENCMISS_EquationsSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE = &
    & EQUATIONS_SET_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE !<Monodomain equation equations Strang Splitting set type \see OPENCMISS_EquationsSetTypes,OPENCMISS

  !>@}
  !> \addtogroup OPENCMISS_EquationsSetSubtypes OPENCMISS::EquationsSet::Subtypes
  !> \brief Equations set subtypes.
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SUBTYPE = EQUATIONS_SET_NO_SUBTYPE !<No equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE = EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE !<Three dimensional linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE = &
    & EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE !<Plane stress linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE = &
    & EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE !<Plane strain linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE = EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE !<One dimensional linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_PLATE_SUBTYPE = EQUATIONS_SET_PLATE_SUBTYPE !<Plate linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_SHELL_SUBTYPE = EQUATIONS_SET_SHELL_SUBTYPE !<Shell linear elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE = EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE !< Mooney-Rivlin constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE = &
  & EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE !< Incompressible Mooney-Rivlin constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE = &
  & EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE !< Nearly Incompressible Mooney-Rivlin constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE = & 
    & EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE !< Mooney-Rivlin constitutive law with steady-state active contraction for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE = & 
    & EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE !< St Venant Kirchoff constitutive law with steady-state active contraction for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE =&
    & EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE !< Active contraction/costa-based law with quasistatic time loop for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE = EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE !< Isotropic exponential constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE = &
    & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE !< Transverse isotropic exponential constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE = &
    & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE !< Transverse isotropic, active-contraction constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE = &
    & EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE !< Transverse isotropic, active-contraction material-transition constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE = &
    & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE !< Orthotropic Costa constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE= &
    & EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE !<Compressible version for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE= &
    & EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE !<Compressible version for finite elasticity equations set with active contraction subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE = &
    & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE !< Transverse isotropic Guccione constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE = &
    & EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE !< Transverse isotropic Guccione constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_INCOMPRESS_FINITE_ELASTICITY_DARCY_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_FINITE_ELASTICITY_DARCY_SUBTYPE !<Incompressible version for finite elasticity coupled with Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE= &
    & EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE !<INRIA Model for finite elasticity coupled with Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ELASTICITY_MULTI_COMP_DARCY_INRIA_SUBTYPE= &
    & EQUATIONS_SET_ELASTICITY_MULTI_COMPARTMENT_DARCY_INRIA_SUBTYPE !<Multi Compartment Darcy INRIA Model coupled with finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_INCOMPRESS_ELASTICITY_DRIVEN_DARCY_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_DARCY_SUBTYPE !< Incompressible finite elasticity with Darcy flow driven by solid hydrostatic pressure \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_MR_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_MR_SUBTYPE !< Incompressible finite elasticity with Darcy flow driven by solid hydrostatic pressure, formulated in terms of modified invariants. \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_INCOMPRESS_ELAST_MULTI_COMP_DARCY_SUBTYPE= &
    & EQUATIONS_SET_INCOMPRESSIBLE_ELAST_MULTI_COMP_DARCY_SUBTYPE
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MEMBRANE_SUBTYPE = EQUATIONS_SET_MEMBRANE_SUBTYPE !<Compressible version for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ORTHOTROPIC_HOLZAPFEL_OGDEN_SUBTYPE = &
    & EQUATIONS_SET_ORTHOTROPIC_MATERIAL_HOLZAPFEL_OGDEN_SUBTYPE !< Orthotropic Holzapfel-Ogden constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE = &
    & EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE &
    & !< Orthotropic Holzapfel-Ogden constitutive law with active contraction for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ELASTICITY_FLUID_PRES_STATIC_INRIA_SUBTYPE = &
    & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_STATIC_INRIA_SUBTYPE !< Static finite elasticity coupled with fluid pressure set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_SUBTYPE= &
    & EQUATIONS_SET_ELASTICITY_FLUID_PRESSURE_HOLMES_MOW_SUBTYPE !<Holmes and Mow's poroelastic constitutive relation subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE = &
    & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE !<Transverse isotropic constitutive law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE= &
    & EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE !<Humphrey and Yin transversely isotropic constitutive relation subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STATIC_STOKES_SUBTYPE = EQUATIONS_SET_STATIC_STOKES_SUBTYPE !<Static Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LAPLACE_STOKES_SUBTYPE = EQUATIONS_SET_LAPLACE_STOKES_SUBTYPE !<Laplace type Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANSIENT_STOKES_SUBTYPE = EQUATIONS_SET_TRANSIENT_STOKES_SUBTYPE !<Transient Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ALE_STOKES_SUBTYPE = EQUATIONS_SET_ALE_STOKES_SUBTYPE !<ALE Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_PGM_STOKES_SUBTYPE = EQUATIONS_SET_PGM_STOKES_SUBTYPE !<PGM Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_OPTIMISED_STOKES_SUBTYPE = EQUATIONS_SET_OPTIMISED_STOKES_SUBTYPE !<Optimised Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STATIC_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_STATIC_NAVIER_STOKES_SUBTYPE !<Static Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LAPLACE_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_LAPLACE_NAVIER_STOKES_SUBTYPE !<Laplace type Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANSIENT_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_TRANSIENT_NAVIER_STOKES_SUBTYPE !<Transient Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANSIENT_SUPG_NAVIER_STOKES_SUBTYPE = & 
    & EQUATIONS_SET_TRANSIENT_SUPG_NAVIER_STOKES_SUBTYPE !<Transient SUPG Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STATIC_SUPG_NAVIER_STOKES_SUBTYPE =  &
    & EQUATIONS_SET_STATIC_SUPG_NAVIER_STOKES_SUBTYPE !<Transient SUPG Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANSIENT_SUPG_NAVIER_STOKES_CMM_SUBTYPE = & 
    & EQUATIONS_SET_TRANSIENT_SUPG_NAVIER_STOKES_MULTIDOMAIN_SUBTYPE !<Transient SUPG Navier-Stokes equations set with coupled multidomain method subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_1DTRANSIENT_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_1DTRANSIENT_NAVIER_STOKES_SUBTYPE !<1DTransient Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STATIC_CHARACTERISTIC_SUBTYPE = EQUATIONS_SET_STATIC_CHARACTERISTIC_SUBTYPE !<Static Characteristics equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_Coupled1D0D_CHARACTERISTIC_SUBTYPE = &
    & EQUATIONS_SET_Coupled1D0D_CHARACTERISTIC_SUBTYPE !<Static Characteristics equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_Coupled1D0D_NAVIER_STOKES_SUBTYPE = &
    & EQUATIONS_SET_Coupled1D0D_NAVIER_STOKES_SUBTYPE !<Coupled 1D-0D Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ALE_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_ALE_NAVIER_STOKES_SUBTYPE !<ALE Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_PGM_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_PGM_NAVIER_STOKES_SUBTYPE !<PGM Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_OPTIMISED_NAVIER_STOKES_SUBTYPE = EQUATIONS_SET_OPTIMISED_NAVIER_STOKES_SUBTYPE !<Optimised Navier-Stokes equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STANDARD_DARCY_SUBTYPE = EQUATIONS_SET_STANDARD_DARCY_SUBTYPE !<Standard Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUASISTATIC_DARCY_SUBTYPE = EQUATIONS_SET_QUASISTATIC_DARCY_SUBTYPE !<Quasistatic Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ALE_DARCY_SUBTYPE = EQUATIONS_SET_ALE_DARCY_SUBTYPE !<ALE Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANSIENT_DARCY_SUBTYPE = EQUATIONS_SET_TRANSIENT_DARCY_SUBTYPE !<Transient Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_TRANSIENT_ALE_DARCY_SUBTYPE = EQUATIONS_SET_TRANSIENT_ALE_DARCY_SUBTYPE !<Transient ALE Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULTI_COMPARTMENT_DARCY_SUBTYPE = EQUATIONS_SET_MULTI_COMPARTMENT_DARCY_SUBTYPE !<Multi Compartment Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_BURGERS_SUBTYPE = EQUATIONS_SET_BURGERS_SUBTYPE !<Burgers equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GENERALISED_BURGERS_SUBTYPE = EQUATIONS_SET_GENERALISED_BURGERS_SUBTYPE !<Generalised Burgers equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STATIC_BURGERS_SUBTYPE = EQUATIONS_SET_STATIC_BURGERS_SUBTYPE !<Static Burgers equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_INVISCID_BURGERS_SUBTYPE = EQUATIONS_SET_INVISCID_BURGERS_SUBTYPE !<Inviscid Burgers equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STANDARD_LAPLACE_SUBTYPE = EQUATIONS_SET_STANDARD_LAPLACE_SUBTYPE !<Standard Laplace equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GENERALISED_LAPLACE_SUBTYPE = EQUATIONS_SET_GENERALISED_LAPLACE_SUBTYPE !<Generalised Laplace equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MOVING_MESH_LAPLACE_SUBTYPE = EQUATIONS_SET_MOVING_MESH_LAPLACE_SUBTYPE !<Moving mesh Laplace equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STATIC_POISEUILLE_SUBTYPE = EQUATIONS_SET_STATIC_POISEUILLE_SUBTYPE !<Static Poiseuille equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DYNAMIC_POISEUILLE_SUBTYPE = EQUATIONS_SET_DYNAMIC_POISEUILLE_SUBTYPE !<Dynamic Poiseuille equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_PRESSURE_POISSON_SUBTYPE = EQUATIONS_SET_LINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NONLINEAR_PRESSURE_POISSON_SUBTYPE = &
    & EQUATIONS_SET_NONLINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ALE_PRESSURE_POISSON_SUBTYPE = EQUATIONS_SET_ALE_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FITTED_PRESSURE_POISSON_SUBTYPE = EQUATIONS_SET_FITTED_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_SOURCE_POISSON_SUBTYPE = EQUATIONS_SET_CONSTANT_SOURCE_POISSON_SUBTYPE !<Constant source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE = &
    & EQUATIONS_SET_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE !<Poisson equations set subtype, that is the extracellular bidomain equation \see OPENCMISS_EquationsSetSubtypes,OPENCMISS  
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_POISSON_SUBTYPE = EQUATIONS_SET_LINEAR_SOURCE_POISSON_SUBTYPE !<Linear source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_POISSON_SUBTYPE = EQUATIONS_SET_QUADRATIC_SOURCE_POISSON_SUBTYPE !<Quadratic source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_POISSON_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_POISSON_SUBTYPE !<Exponential source Poisson equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STANDARD_HELMHOLTZ_SUBTYPE = EQUATIONS_SET_STANDARD_HELMHOLTZ_SUBTYPE !<No source Helmholtz equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GENERALISED_HELMHOLTZ_SUBTYPE = EQUATIONS_SET_GENERALISED_HELMHOLTZ_SUBTYPE !<No source Helmholtz equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SOURCE_DIFFUSION_SUBTYPE = EQUATIONS_SET_NO_SOURCE_DIFFUSION_SUBTYPE !<No source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_SOURCE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_DIFFUSION_SUBTYPE !<Constant source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_SUBTYPE = EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_SUBTYPE !<Linear source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_SUBTYPE !<Quadratic source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_SUBTYPE !<Exponential source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SOURCE_ALE_DIFFUSION_SUBTYPE = EQUATIONS_SET_NO_SOURCE_ALE_DIFFUSION_SUBTYPE !<No source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_ALE_DIFFUSION_SUBTYPE !<Constant source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE !<Linear source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ALE_DIFFUSION_SUBTYPE !<Quadratic source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_ALE_DIFFUSION_SUBTYPE !<Exponential source diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULTI_COMP_TRANSPORT_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_MULTI_COMP_TRANSPORT_DIFFUSION_SUBTYPE !<Multi-compartment transport diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Quadratic source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Exponential source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE = &
    & EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE !<In CellML evaluated incompressible material law for finite elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Quadratic source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Exponential source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUAD_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_QUAD_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE !<Quadratic source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_EXP_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_EXP_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE !<Exponential source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUAD_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_QUAD_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE !<Quadratic source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE !<Exponential source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE !<No source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONST_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE !<Constant source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LIN_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE !<Linear source advection diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE !<Coupled source diffusion & advection-diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUBTYPE !<Multi-component transport advection-diffusion equations set \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULT_COMP_TRANSPORT_ADVEC_DIFF_SUPG_SUBTYPE = &
    & EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUPG_SUBTYPE !<Multi-component transport advection-diffusion equations set using SUPG scheme \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CELLML_REAC_SPLIT_REAC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CELLML_REAC_SPLIT_REAC_DIFF_SUBTYPE !CellML Reaction Diffusion with order splitting \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CELLML_REAC_NO_SPLIT_REAC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CELLML_REAC_NO_SPLIT_REAC_DIFF_SUBTYPE !CellML Reaction Diffusion without order splitting \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_CONSTANT_REAC_DIFF_SUBTYPE = &
    & EQUATIONS_SET_CONSTANT_REAC_DIFF_SUBTYPE !Standard Reaction Diffusion without order splitting, and constant source \see OPENCMISS_EquationsSetSubtypes,OPENCMISS


  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MONODOMAIN_BUENOOROVIO_SUBTYPE= EQUATIONS_SET_MONODOMAIN_BUENOOROVIO_SUBTYPE !<First monodomain equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MONODOMAIN_TENTUSSCHER06_SUBTYPE= EQUATIONS_SET_MONODOMAIN_TENTUSSCHER06_SUBTYPE !<First monodomain equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FIRST_BIDOMAIN_SUBTYPE = EQUATIONS_SET_FIRST_BIDOMAIN_SUBTYPE !<First bidomain equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_SECOND_BIDOMAIN_SUBTYPE = EQUATIONS_SET_SECOND_BIDOMAIN_SUBTYPE !<Second bidomain equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STANDARD_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_STANDARD_DATA_FITTING_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GENERALISED_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_GENERALISED_DATA_FITTING_SUBTYPE !<Generalised Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MAT_PROPERTIES_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_MAT_PROPERTIES_DATA_FITTING_SUBTYPE !<Material Properties Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MAT_PROP_INRIA_MODEL_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_MAT_PROPERTIES_INRIA_MODEL_DATA_FITTING_SUBTYPE !<Material Properties INRIA Model Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_VECTOR_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_VECTOR_DATA_FITTING_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DIVFREE_VECTOR_DATA_FITTING_SUBTYPE = &
    & EQUATIONS_SET_DIVFREE_VECTOR_DATA_FITTING_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DATA_POINT_VECTOR_STATIC_FITTING_SUBTYPE = &
    & EquationsSet_DataPointVectorStaticFittingSubtype !<Standard static Galerkin Projection using data points subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DATA_PT_VECTOR_QUASISTATIC_FITTING_SUBTYPE = &
    & EquationsSet_DataPointVectorQuasistaticFittingSubtype !<Standard quasistatic Galerkin Projection using data points subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_VECTOR_DATA_PRE_FITTING_SUBTYPE = &
    & EQUATIONS_SET_VECTOR_DATA_PRE_FITTING_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DIVFREE_VECTOR_DATA_PRE_FITTING_SUBTYPE = &
    & EQUATIONS_SET_DIVFREE_VECTOR_DATA_PRE_FITTING_SUBTYPE !<Standard Galerkin Projection equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS



  INTEGER(INTG), PARAMETER :: CMISSEquationsSetStandardElasticityDarcySubtype = EQUATIONS_SET_STANDARD_ELASTICITY_DARCY_SUBTYPE !<Standard Elasticity Darcy equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE = &
    & EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE !<Coupled source diffusion-diffusion equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE =  &
    & EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE !<Standard Monodomain Elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE =  &
    & EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE !<Coupled 1D Monodomain 3D Elasticity equations set subtype \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE =  &
    & EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE !<Coupled 1D Monodomain 3D Elasticity equations set subtype with titin \see OPENCMISS_EquationsSetSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE = &
    & EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE !<Finite Elasticity Navier Stokes ALE equations set subtype \see OPENCMISS_EquationsSetSubtype,OPENCMISS

  !>@}
  !> \addtogroup OPENCMISS_EquationsSetSolutionMethods OPENCMISS::EquationsSet::SolutionMethods
  !> \brief The solution method parameters
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FEM_SOLUTION_METHOD = EQUATIONS_SET_FEM_SOLUTION_METHOD !<Finite Element Method solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_BEM_SOLUTION_METHOD = EQUATIONS_SET_BEM_SOLUTION_METHOD !<Boundary Element Method solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FD_SOLUTION_METHOD = EQUATIONS_SET_FD_SOLUTION_METHOD !<Finite Difference solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FV_SOLUTION_METHOD = EQUATIONS_SET_FV_SOLUTION_METHOD !<Finite Volume solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GFEM_SOLUTION_METHOD = EQUATIONS_SET_GFEM_SOLUTION_METHOD !<Grid-based Finite Element Method solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GFD_SOLUTION_METHOD = EQUATIONS_SET_GFD_SOLUTION_METHOD !<Grid-based Finite Difference solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GFV_SOLUTION_METHOD = EQUATIONS_SET_GFV_SOLUTION_METHOD !<Grid-based Finite Volume solution method. \see OPENCMISS_EquationsSetSolutionMethods,OPENCMISS
  !>@}

  !> \addtogroup OPENCMISS_EquationsSetDynamicMatrixTypes OPENCMISS::EquationsSet::DynamicMatrixTypes
  !> \brief Type of matrix in a dynamic equations set
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_MATRIX_STIFFNESS=EQUATIONS_MATRIX_STIFFNESS !<A stiffness matrix (multiplies displacement values)
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_MATRIX_DAMPING=EQUATIONS_MATRIX_DAMPING !<A damping matrix (multiplies velocity values)
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_MATRIX_MASS=EQUATIONS_MATRIX_MASS !<A mass matrix (multiplies acceleration values)
  !>@}

  !> \addtogroup OPENCMISS_EquationsSetAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes
  !> \brief The analytic function types.
  !> \see OPENCMISS::EquationsSet,OPENCMISS
  !>@{
  !> \addtogroup OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Laplace
  !> \brief The analytic function types for a Laplace equation
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_1 = EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_1 !<u=x**2+2*x*y-y**2 \see OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_2 = EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_2 !<u=cos(x)cosh(y) \see OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_1 = EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_1 !<u=x**2-2*y**2+z**2 \see OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_2 = EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_2 !<u=cos(x)*cosh(y)*z \see OPENCMISS_EquationsSetLaplaceAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsSetHelmholtzAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Helmholtz
  !> \brief The analytic function types for a Helmholtz equation
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_HELMHOLTZ_EQUATION_TWO_DIM_1 = EQUATIONS_SET_HELMHOLTZ_EQUATION_TWO_DIM_1 !<u=cos(sqrt(2)*k*x)*sin(sqrt(2)*k*y) \see OPENCMISS_EquationsSetHelmholtzAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_PoiseuilleAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Poiseuille
  !> \brief The analytic function types for a Poiseuille equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISEUILLE_EQUATION_TWO_DIM_1 = EQUATIONS_SET_POISEUILLE_EQUATION_TWO_DIM_1 !<u=ln(4/(x+y+1^2)) \see OPENCMISS_EquationsSetPoiseuilleAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_PoissonAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Poisson
  !> \brief The analytic function types for a Poisson equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_1 = EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_1 !<u=ln(4/(x+y+1^2)) \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_2 = EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_3 = EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_1 = EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_1 !<u=ln(6/(x+y+z+1^2)) \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_2 = EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_3 = EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_1 = EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_2 = EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetPoissonAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DiffusionAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Diffusion
  !> \brief The analytic function types for a diffusion equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DIFFUSION_EQUATION_ONE_DIM_1 = EQUATIONS_SET_DIFFUSION_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DIFFUSION_EQUATION_TWO_DIM_1 = EQUATIONS_SET_DIFFUSION_EQUATION_TWO_DIM_1 !<u=exp(-kt)*sin(sqrt(k)*(x*cos(phi)+y*sin(phi))) \see OPENCMISS_EquationsSetDiffusionAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DIFFUSION_EQUATION_THREE_DIM_1 = EQUATIONS_SET_DIFFUSION_EQUATION_THREE_DIM_1 !<
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_THREE_DIM_1 = &
    & EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_EQUATION_THREE_DIM_1
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_ONE_DIM_1 = &
    & EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_ONE_DIM_1 = &
    & EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_EQUATION_ONE_DIM_1

  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_TWO_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_TWO_DIM !<Prescribed solution, using a source term to correct for error - 2D with 2 compartments
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_THREE_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_THREE_DIM !<Prescribed solution, using a source term to correct for error - 3D with 2 compartments
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULTI_COMP_DIFFUSION_THREE_COMP_THREE_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_THREE_COMP_THREE_DIM !<Prescribed solution, using a source term to correct for error - 3D with 3 compartments
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_MULTI_COMP_DIFFUSION_FOUR_COMP_THREE_DIM = &
    & EQUATIONS_SET_MULTI_COMP_DIFFUSION_FOUR_COMP_THREE_DIM !<Prescribed solution, using a source term to correct for error - 3D with 3 compartments
  !>@}
  !> \addtogroup OPENCMISS_AdvectionDiffusionAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::AdvectionDiffusion
  !> \brief The analytic function types for an advection-diffusion equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TWO_DIM_1 = &
    & EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TWO_DIM_1 !<u=exp(-kt)*sin(sqrt(k)*(x*cos(phi)+y*sin(phi))) \see OPENCMISS_EquationsSetDiffusionAnalyticFunctionTypes,OPENCMISS
  !> \addtogroup OPENCMISS_StokesAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Stokes
  !> \brief The analytic function types for a Stokes equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_1 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_2 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_3 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_4 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_4 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_5 = EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_5 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_1 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_2 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_3 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_4 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_4 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_5 = EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_5 !<u=tbd \see OPENCMISS_EquationsSetStokesAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_NavierStokesAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::NavierStokes
  !> \brief The analytic function types for a Navier-Stokes equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_POISEUILLE= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_POISEUILLE !< fully developed 2D channel flow (parabolic) \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_TAYLOR_GREEN= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_TAYLOR_GREEN !< 2D dynamic nonlinear Taylor-Green vortex decay \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_FlowrateSheffield= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_FlowrateSheffield !< A fourier decomposed flow waveform for boundary conditions
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_FlowrateReymonds= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_FlowrateReymonds !< A fourier decomposed flow waveform for boundary conditions
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_FlowrateOlufsen= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_FlowrateOlufsen !< A fourier decomposed flow waveform for boundary conditions
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_FlowrateAorta= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_FlowrateAorta !< A fourier decomposed flow waveform for boundary conditions
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_FlowrateSinusoid= &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_FlowrateSinusoid !< A sinusoidal flow waveform
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_1 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_2 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_3 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_4 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_4 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_5 = EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_5 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_1 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_2 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_3 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_4 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_4 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_5 = &
    & EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_5 !<u=tbd \see OPENCMISS_EquationsSetNavierStokesAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DarcyAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Darcy
  !> \brief The analytic function types for a Darcy equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_1 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_2 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_3 = EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_1 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_2 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_3 = EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_3 !<u=tbd \see OPENCMISS_EquationsSetDarcyAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_INCOMP_ELAST_DARCY_ANALYTIC_DARCY = &
    & EQUATIONS_SET_INCOMP_ELAST_DARCY_ANALYTIC_DARCY !<this is a solution where the finite elasticity solve is skipped to allow easy analytic testing of the mass increase & velocity solve step of incompressible poromechanical model
  !>@}
  !> \addtogroup OPENCMISS_BurgersAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::Burgers
  !> \brief The analytic function types for a Burgers equation.
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_BURGERS_EQUATION_ONE_DIM_1 = EQUATIONS_SET_BURGERS_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_1 = &
    & EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_1
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_2 = &
    & EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_2
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_STATIC_BURGERS_EQUATION_ONE_DIM_1 = &
    & EQUATIONS_SET_STATIC_BURGERS_EQUATION_ONE_DIM_1
  !>@}

  !> \addtogroup OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::LinearElasticity
  !> \brief The analytic function types for a LinearElasticity equation
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1 = EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1 = EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_2 = EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1 = EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2 = EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2 !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_EquationsSetFiniteElasticityAnalyticFunctionTypes OPENCMISS::EquationsSet::AnalyticFunctionTypes::FiniteElasticity
  !> \brief The analytic function types for a FiniteElasticity equation
  !> \see OPENCMISS::EquationsSet::AnalyticFunctionTypes,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER = EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER !<u=tbd \see OPENCMISS_EquationsSetLinearElasticityAnalyticFunctionTypes,OPENCMISS
  !>@}
  !>@}
  !>@}

  !> \addtogroup OPENCMISS_AnalyticParamIndices OPENCMISS::FiniteElasticity::AnalyticParamIndices
  !> \brief Indices for EQUATIONS_SET_ANALYTIC_TYPE%ANALYTIC_USER_PARAMS
  !> \see OPENCMISS::FiniteElasticity::AnalyticParamIndices,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX !<Inner pressure parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX !<Outer pressure parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX !<Lambda parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX !<Tsi parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX !<Inner radius parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX !<Outer radius parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX !<c1 parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX = &
    & FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX !<c2 parameter index \see OPENCMISS_AnalyticParamIndices,OPENCMISS
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISS_EQUATIONS_SET_NO_CLASS,CMISS_EQUATIONS_SET_ELASTICITY_CLASS,CMISS_EQUATIONS_SET_FLUID_MECHANICS_CLASS, &
    & CMISS_EQUATIONS_SET_ELECTROMAGNETICS_CLASS,CMISS_EQUATIONS_SET_CLASSICAL_FIELD_CLASS,CMISS_EQUATIONS_SET_BIOELECTRICS_CLASS, &
    & CMISS_EQUATIONS_SET_MODAL_CLASS,CMISS_EQUATIONS_SET_FITTING_CLASS,CMISS_EQUATIONS_SET_OPTIMISATION_CLASS, &
    & CMISS_EQUATIONS_SET_MULTI_PHYSICS_CLASS

  PUBLIC CMISS_EQUATIONS_SET_NO_TYPE,CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_TYPE,CMISS_EQUATIONS_SET_FINITE_ELASTICITY_TYPE, &
    & CMISS_EQUATIONS_SET_STOKES_EQUATION_TYPE,CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_DARCY_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_DARCY_PRESSURE_EQUATION_TYPE,CMISS_EQUATIONS_SET_BURGERS_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_STATIC_POISEUILLE_SUBTYPE, &
    & CMISS_EQUATIONS_SET_DYNAMIC_POISEUILLE_SUBTYPE, &
    & CMISS_EQUATIONS_SET_CHARACTERISTIC_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_ELECTROSTATIC_TYPE,CMISS_EQUATIONS_SET_MAGNETOSTATIC_TYPE,CMISS_EQUATIONS_SET_MAXWELLS_EQUATIONS_TYPE, &
    & CMISS_EQUATIONS_SET_LAPLACE_EQUATION_TYPE,CMISS_EQUATIONS_SET_POISEUILLE_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_POISSON_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_HELMHOLTZ_EQUATION_TYPE,CMISS_EQUATIONS_SET_WAVE_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_DIFFUSION_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TYPE,CMISS_EQUATIONS_SET_REACTION_DIFFUSION_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_BIHARMONIC_EQUATION_TYPE,CMISS_EQUATIONS_SET_MONODOMAIN_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_BIDOMAIN_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_LINEAR_ELASTIC_MODAL_TYPE,CMISS_EQUATIONS_SET_DATA_FITTING_EQUATION_TYPE, &
    & CMISS_EQUATIONS_SET_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE

  PUBLIC CMISS_EQUATIONS_SET_FINITE_ELASTICITY_DARCY_TYPE, &
    & CMISS_EQUATIONS_SET_FINITE_ELASTICITY_STOKES_TYPE, CMISS_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_TYPE, &
    & CMISS_EQUATIONS_SET_DIFFUSION_DIFFUSION_TYPE, CMISS_EQUATIONS_SET_DIFFUSION_ADVECTION_DIFFUSION_TYPE

  PUBLIC CMISS_EQUATIONS_SET_NO_SUBTYPE,CMISS_EQUATIONS_SET_THREE_DIMENSIONAL_SUBTYPE, &
    & CMISS_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRESS_SUBTYPE, &
    & CMISS_EQUATIONS_SET_TWO_DIMENSIONAL_PLANE_STRAIN_SUBTYPE,CMISS_EQUATIONS_SET_ONE_DIMENSIONAL_SUBTYPE, &
    & CMISS_EQUATIONS_SET_PLATE_SUBTYPE, &
    & CMISS_EQUATIONS_SET_SHELL_SUBTYPE, &
    & CMISS_EQUATIONS_SET_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE,CMISS_EQUATIONS_SET_NEARLY_INCOMPRESSIBLE_MOONEY_RIVLIN_SUBTYPE, &
    & CMISS_EQUATIONS_SET_MOONEY_RIVLIN_SUBTYPE,CMISS_EQUATIONS_SET_ISOTROPIC_EXPONENTIAL_SUBTYPE, &
    & CMISS_EQUATIONS_SET_ACTIVECONTRACTION_SUBTYPE,CMISS_EQUATIONS_SET_MOONEY_RIVLIN_ACTIVECONTRACTION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_COMPRESSIBLE_ACTIVECONTRACTION_SUBTYPE,CMISS_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_ACTIVE_SUBTYPE, &
    & CMISS_EQUATIONS_SET_TRANS_ISOTROPIC_ACTIVE_TRANSITION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_POLYNOMIAL_SUBTYPE,CMISS_EQUATIONS_SET_STVENANT_KIRCHOFF_ACTIVECONTRACTION_SUBTYPE,&
    & CMISS_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_EXPONENTIAL_SUBTYPE,CMISS_EQUATIONS_SET_ORTHOTROPIC_MATERIAL_COSTA_SUBTYPE, &
    & CMISS_EQUATIONS_SET_COMPRESSIBLE_FINITE_ELASTICITY_SUBTYPE,CMISS_EQUATIONS_SET_INCOMPRESS_FINITE_ELASTICITY_DARCY_SUBTYPE, &
    & CMISS_EQUATIONS_SET_ELASTICITY_DARCY_INRIA_MODEL_SUBTYPE,CMISS_EQUATIONS_SET_ELASTICITY_MULTI_COMP_DARCY_INRIA_SUBTYPE, &
    & CMISS_EQUATIONS_SET_INCOMPRESS_ELASTICITY_DRIVEN_DARCY_SUBTYPE, &
    & CMISS_EQUATIONS_SET_INCOMPRESSIBLE_ELASTICITY_DRIVEN_MR_SUBTYPE, &
    & CMISS_EQUATIONS_SET_INCOMPRESS_ELAST_MULTI_COMP_DARCY_SUBTYPE,CMISS_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_GUCCIONE_SUBTYPE, &
    & CMISS_EQUATIONS_SET_GUCCIONE_ACTIVECONTRACTION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_MEMBRANE_SUBTYPE, CMISS_EQUATIONS_SET_ORTHOTROPIC_HOLZAPFEL_OGDEN_SUBTYPE, &
    & CMISS_EQUATIONS_SET_HOLZAPFEL_OGDEN_ACTIVECONTRACTION_SUBTYPE,  &
    & CMISS_EQUATIONS_SET_ELASTICITY_FLUID_PRES_STATIC_INRIA_SUBTYPE, &
    & CMISS_EQUATIONS_SET_ELASTICITY_FLUID_PRES_HOLMES_MOW_SUBTYPE,&
    & CMISS_EQUATIONS_SET_TRANSVERSE_ISOTROPIC_HUMPHREY_YIN_SUBTYPE,&
    & CMISS_EQUATIONS_SET_STATIC_STOKES_SUBTYPE, CMISS_EQUATIONS_SET_LAPLACE_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_TRANSIENT_STOKES_SUBTYPE,CMISS_EQUATIONS_SET_ALE_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_ALE_NAVIER_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_OPTIMISED_STOKES_SUBTYPE,CMISS_EQUATIONS_SET_STATIC_NAVIER_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LAPLACE_NAVIER_STOKES_SUBTYPE,CMISS_EQUATIONS_SET_TRANSIENT_NAVIER_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_1DTRANSIENT_NAVIER_STOKES_SUBTYPE, CMISS_EQUATIONS_SET_TRANSIENT_SUPG_NAVIER_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_STATIC_SUPG_NAVIER_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_STATIC_CHARACTERISTIC_SUBTYPE, &
    & CMISS_EQUATIONS_SET_Coupled1D0D_CHARACTERISTIC_SUBTYPE, &
    & CMISS_EQUATIONS_SET_TRANSIENT_SUPG_NAVIER_STOKES_CMM_SUBTYPE, &
    & CMISS_EQUATIONS_SET_Coupled1D0D_NAVIER_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_OPTIMISED_NAVIER_STOKES_SUBTYPE,CMISS_EQUATIONS_SET_STANDARD_DARCY_SUBTYPE, &
    & CMISS_EQUATIONS_SET_QUASISTATIC_DARCY_SUBTYPE,CMISS_EQUATIONS_SET_ALE_DARCY_SUBTYPE, &
    & CMISS_EQUATIONS_SET_TRANSIENT_DARCY_SUBTYPE, &
    & CMISS_EQUATIONS_SET_TRANSIENT_ALE_DARCY_SUBTYPE,CMISS_EQUATIONS_SET_MULTI_COMPARTMENT_DARCY_SUBTYPE, &
    & CMISS_EQUATIONS_SET_STANDARD_LAPLACE_SUBTYPE,CMISS_EQUATIONS_SET_MOVING_MESH_LAPLACE_SUBTYPE, &
    & CMISS_EQUATIONS_SET_GENERALISED_LAPLACE_SUBTYPE,CMISS_EQUATIONS_SET_CONSTANT_SOURCE_POISSON_SUBTYPE, &
    & CMISS_EQUATIONS_SET_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LINEAR_PRESSURE_POISSON_SUBTYPE, CMISS_EQUATIONS_SET_NONLINEAR_PRESSURE_POISSON_SUBTYPE, &
    & CMISS_EQUATIONS_SET_ALE_PRESSURE_POISSON_SUBTYPE, CMISS_EQUATIONS_SET_FITTED_PRESSURE_POISSON_SUBTYPE,&
    & CMISS_EQUATIONS_SET_LINEAR_SOURCE_POISSON_SUBTYPE,CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_POISSON_SUBTYPE, &
    & CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_POISSON_SUBTYPE,CMISS_EQUATIONS_SET_STANDARD_HELMHOLTZ_SUBTYPE, &
    & CMISS_EQUATIONS_SET_GENERALISED_HELMHOLTZ_SUBTYPE, &
    & CMISS_EQUATIONS_SET_NO_SOURCE_DIFFUSION_SUBTYPE,CMISS_EQUATIONS_SET_CONSTANT_SOURCE_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_SUBTYPE,CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_SUBTYPE,CMISS_EQUATIONS_SET_MULTI_COMP_TRANSPORT_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_NO_SOURCE_ALE_DIFFUSION_SUBTYPE,CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ALE_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE,CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_ALE_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_ADVEC_DIFF_SUBTYPE,CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_ADVEC_DIFF_SUBTYPE, &
    & CMISS_EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVEC_DIFF_SUBTYPE,CMISS_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUBTYPE, &
    & CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_ALE_ADVEC_DIFF_SUBTYPE,CMISS_EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE, CMISS_EQUATIONS_SET_CONSTANT_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE, &
    & CMISS_EQUATIONS_SET_NO_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE, CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LINEAR_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE, CMISS_EQUATIONS_SET_QUAD_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_EXP_SOURCE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_NO_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_CONSTANT_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LINEAR_SOURCE_ALE_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_QUAD_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_EXP_SOURCE_ALE_ADVECTION_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_NO_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_CONST_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_LIN_SOURCE_STATIC_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_MULTI_COMP_TRANSPORT_ADVEC_DIFF_SUBTYPE,CMISS_EQUATIONS_SET_MULT_COMP_TRANSPORT_ADVEC_DIFF_SUPG_SUBTYPE, &
    & CMISS_EQUATIONS_SET_PGM_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_FIRST_BIDOMAIN_SUBTYPE,CMISS_EQUATIONS_SET_SECOND_BIDOMAIN_SUBTYPE, &
    & CMISS_EQUATIONS_SET_MONODOMAIN_BUENOOROVIO_SUBTYPE,&
    & CMISS_EQUATIONS_SET_MONODOMAIN_TENTUSSCHER06_SUBTYPE  ,&
    & CMISS_EQUATIONS_SET_STANDARD_DATA_FITTING_SUBTYPE,CMISS_EQUATIONS_SET_GENERALISED_DATA_FITTING_SUBTYPE, &
    & CMISS_EQUATIONS_SET_VECTOR_DATA_FITTING_SUBTYPE,CMISS_EQUATIONS_SET_DIVFREE_VECTOR_DATA_FITTING_SUBTYPE, &
    & CMISS_EQUATIONS_SET_VECTOR_DATA_PRE_FITTING_SUBTYPE,CMISS_EQUATIONS_SET_DIVFREE_VECTOR_DATA_PRE_FITTING_SUBTYPE, &
    & CMISS_EQUATIONS_SET_MAT_PROPERTIES_DATA_FITTING_SUBTYPE,CMISS_EQUATIONS_SET_MAT_PROP_INRIA_MODEL_DATA_FITTING_SUBTYPE, &
    & CMISS_EQUATIONS_SET_DATA_POINT_VECTOR_STATIC_FITTING_SUBTYPE, &
    & CMISS_EQUATIONS_SET_DATA_PT_VECTOR_QUASISTATIC_FITTING_SUBTYPE, &
    & CMISS_EQUATIONS_SET_PGM_NAVIER_STOKES_SUBTYPE, &
    & CMISS_EQUATIONS_SET_CONSTITUTIVE_LAW_IN_CELLML_EVALUATE_SUBTYPE, &
    & CMISS_EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE, &
    & CMISS_EQUATIONS_SET_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFF_SUBTYPE, &
    & CMISS_EQUATIONS_SET_BURGERS_SUBTYPE,CMISS_EQUATIONS_SET_GENERALISED_BURGERS_SUBTYPE, &
    & CMISS_EQUATIONS_SET_STATIC_BURGERS_SUBTYPE, &
    & CMISS_EQUATIONS_SET_INVISCID_BURGERS_SUBTYPE,CMISS_EQUATIONS_SET_STANDARD_MONODOMAIN_ELASTICITY_SUBTYPE, &
    & CMISS_EQUATIONS_SET_1D3D_MONODOMAIN_ELASTICITY_SUBTYPE,CMISS_EQUATIONS_SET_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE, &
    & CMISS_EQUATIONS_SET_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE


  PUBLIC CMISS_EQUATIONS_SET_CELLML_REAC_SPLIT_REAC_DIFF_SUBTYPE, CMISS_EQUATIONS_SET_CELLML_REAC_NO_SPLIT_REAC_DIFF_SUBTYPE, &
    & CMISS_EQUATIONS_SET_CONSTANT_REAC_DIFF_SUBTYPE

  PUBLIC CMISS_EQUATIONS_SET_FEM_SOLUTION_METHOD,CMISS_EQUATIONS_SET_BEM_SOLUTION_METHOD,CMISS_EQUATIONS_SET_FD_SOLUTION_METHOD, &
    & CMISS_EQUATIONS_SET_FV_SOLUTION_METHOD,CMISS_EQUATIONS_SET_GFEM_SOLUTION_METHOD,CMISS_EQUATIONS_SET_GFD_SOLUTION_METHOD, &
    & CMISS_EQUATIONS_SET_GFV_SOLUTION_METHOD

  PUBLIC CMISS_EQUATIONS_MATRIX_STIFFNESS,CMISS_EQUATIONS_MATRIX_DAMPING,CMISS_EQUATIONS_MATRIX_MASS

  PUBLIC CMISS_EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_1,CMISS_EQUATIONS_SET_LAPLACE_EQUATION_TWO_DIM_2, &
    & CMISS_EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_1,CMISS_EQUATIONS_SET_LAPLACE_EQUATION_THREE_DIM_2

  PUBLIC CMISS_EQUATIONS_SET_HELMHOLTZ_EQUATION_TWO_DIM_1

  PUBLIC CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_ONE_DIM_1,CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_1, &
    & CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_TWO_DIM_2,CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_1, &
    & CMISS_EQUATIONS_SET_LINEAR_ELASTICITY_THREE_DIM_2

  PUBLIC CMISS_EQUATIONS_SET_DIFFUSION_EQUATION_ONE_DIM_1,CMISS_EQUATIONS_SET_DIFFUSION_EQUATION_TWO_DIM_1, &
    & CMISS_EQUATIONS_SET_DIFFUSION_EQUATION_THREE_DIM_1, &
    & CMISS_EQUATIONS_SET_LINEAR_SOURCE_DIFFUSION_THREE_DIM_1,CMISS_EQUATIONS_SET_QUADRATIC_SOURCE_DIFFUSION_ONE_DIM_1, &
    & CMISS_EQUATIONS_SET_EXPONENTIAL_SOURCE_DIFFUSION_ONE_DIM_1,CMISS_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_TWO_DIM, &
    & CMISS_EQUATIONS_SET_MULTI_COMP_DIFFUSION_TWO_COMP_THREE_DIM,CMISS_EQUATIONS_SET_MULTI_COMP_DIFFUSION_THREE_COMP_THREE_DIM, &
    & CMISS_EQUATIONS_SET_MULTI_COMP_DIFFUSION_FOUR_COMP_THREE_DIM


  PUBLIC CMISS_EQUATIONS_SET_ADVECTION_DIFFUSION_EQUATION_TWO_DIM_1

  PUBLIC CMISS_EQUATIONS_SET_POISEUILLE_EQUATION_TWO_DIM_1

  PUBLIC CMISS_EQUATIONS_SET_BURGERS_EQUATION_ONE_DIM_1,CMISS_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_1, &
    & CMISS_EQUATIONS_SET_GENERALISED_BURGERS_EQUATION_ONE_DIM_2, &
    & CMISS_EQUATIONS_SET_STATIC_BURGERS_EQUATION_ONE_DIM_1

  PUBLIC CMISS_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_1,CMISS_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_2, &
    & CMISS_EQUATIONS_SET_POISSON_EQUATION_TWO_DIM_3
  PUBLIC CMISS_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_1,CMISS_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_2, &
    & CMISS_EQUATIONS_SET_POISSON_EQUATION_THREE_DIM_3
  PUBLIC CMISS_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_1, &
    & CMISS_EQUATIONS_SET_PRESSURE_POISSON_THREE_DIM_2

  PUBLIC CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_1,CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_2, &
    & CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_3
  PUBLIC CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_4,CMISS_EQUATIONS_SET_STOKES_EQUATION_TWO_DIM_5
  PUBLIC CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_1,CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_2, &
    & CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_3
  PUBLIC CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_4,CMISS_EQUATIONS_SET_STOKES_EQUATION_THREE_DIM_5

  PUBLIC CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_POISEUILLE, &
    & CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_TAYLOR_GREEN
  PUBLIC CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_FlowrateSheffield, &
    &    CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_FlowrateReymonds, &
    &    CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_FlowrateOlufsen, &
    &    CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_FlowrateAorta, &
    &    CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_FlowrateSinusoid
  PUBLIC CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_1,CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_2, &
    & CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_3
  PUBLIC CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_4,CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_TWO_DIM_5
  PUBLIC CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_1,CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_2, &
    & CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_3
  PUBLIC CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_4,CMISS_EQUATIONS_SET_NAVIER_STOKES_EQUATION_THREE_DIM_5

  PUBLIC CMISS_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_1,CMISS_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_2, &
    & CMISS_EQUATIONS_SET_DARCY_EQUATION_TWO_DIM_3
  PUBLIC CMISS_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_1,CMISS_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_2, &
    & CMISS_EQUATIONS_SET_DARCY_EQUATION_THREE_DIM_3
  PUBLIC CMISS_EQUATIONS_SET_INCOMP_ELAST_DARCY_ANALYTIC_DARCY

  PUBLIC CMISS_EQUATIONS_SET_FINITE_ELASTICITY_CYLINDER
  PUBLIC CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_PIN_IDX,CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_POUT_IDX
  PUBLIC CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_LAMBDA_IDX,CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_TSI_IDX
  PUBLIC CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_RIN_IDX,CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_ROUT_IDX
  PUBLIC CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C1_IDX,CMISS_FINITE_ELASTICITY_ANALYTIC_CYLINDER_PARAM_C2_IDX

!!==================================================================================================================================
!!
!! EQUATIONS_SET_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finish the creation of a analytic solution for an equations set. \see OPENCMISS::CMISSEquationsSet_AnalyticCreateStart
  INTERFACE CMISSEquationsSet_AnalyticCreateFinish
    MODULE PROCEDURE CMISSEquationsSet_AnalyticCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSet_AnalyticCreateFinishObj
  END INTERFACE !CMISSEquationsSet_AnalyticCreateFinish

  !>Start the creation of a analytic solution for an equations set. \see OPENCMISS::CMISSEquationsSet_AnalyticCreateFinish
  INTERFACE CMISSEquationsSet_AnalyticCreateStart
    MODULE PROCEDURE CMISSEquationsSet_AnalyticCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSet_AnalyticCreateStartObj
  END INTERFACE !CMISSEquationsSet_AnalyticCreateStart

  !>Destroy the analytic solution for an equations set.
  INTERFACE CMISSEquationsSet_AnalyticDestroy
    MODULE PROCEDURE CMISSEquationsSet_AnalyticDestroyNumber
    MODULE PROCEDURE CMISSEquationsSet_AnalyticDestroyObj
  END INTERFACE !CMISSEquationsSet_AnalyticDestroy

  !>Evaluates the current analytic solution for an equations set.
  INTERFACE CMISSEquationsSet_AnalyticEvaluate
    MODULE PROCEDURE CMISSEquationsSet_AnalyticEvaluateNumber
    MODULE PROCEDURE CMISSEquationsSet_AnalyticEvaluateObj
  END INTERFACE !CMISSEquationsSet_AnalyticEvaluate

  !>Returns the analytic time for an equations set.
  INTERFACE CMISSEquationsSet_AnalyticTimeGet
    MODULE PROCEDURE CMISSEquationsSet_AnalyticTimeGetNumber
    MODULE PROCEDURE CMISSEquationsSet_AnalyticTimeGetObj
  END INTERFACE !CMISSEquationsSet_AnalyticTimeGet

  !>Sets/changes the analytic time for an equations set.
  INTERFACE CMISSEquationsSet_AnalyticTimeSet
    MODULE PROCEDURE CMISSEquationsSet_AnalyticTimeSetNumber
    MODULE PROCEDURE CMISSEquationsSet_AnalyticTimeSetObj
  END INTERFACE !CMISSEquationsSet_AnalyticTimeSet

  !>Finish the creation of an equations set. \see OPENCMISS::CMISSEquationsSet_CreateStart
  INTERFACE CMISSEquationsSet_CreateFinish
    MODULE PROCEDURE CMISSEquationsSet_CreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSet_CreateFinishObj
  END INTERFACE !CMISSEquationsSet_CreateFinish

  !>Start the creation of an equations set on a region. \see OPENCMISS::CMISSEquationsSet_CreateFinish
  INTERFACE CMISSEquationsSet_CreateStart
    MODULE PROCEDURE CMISSEquationsSet_CreateStartNumber
    MODULE PROCEDURE CMISSEquationsSet_CreateStartObj
  END INTERFACE !CMISSEquationsSet_CreateStart

  !>Calculate the deformation for a specified user element number and xi coordinates.
  INTERFACE CMISSEquationsSet_DeformationCalculate
    MODULE PROCEDURE CMISSEquationsSet_DeformationCalculateNumber
    MODULE PROCEDURE CMISSEquationsSet_DeformationCalculateObj
  END INTERFACE
 
  !>Destroy an equations set.
  INTERFACE CMISSEquationsSet_Destroy
    MODULE PROCEDURE CMISSEquationsSet_DestroyNumber
    MODULE PROCEDURE CMISSEquationsSet_DestroyObj
  END INTERFACE !CMISSEquationsSet_Destroy

  !>Finish the creation of dependent variables for an equations set. \see OPENCMISS::CMISSEquationsSet_DependentCreateStart
  INTERFACE CMISSEquationsSet_DependentCreateFinish
    MODULE PROCEDURE CMISSEquationsSet_DependentCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSet_DependentCreateFinishObj
  END INTERFACE !CMISSEquationsSet_DependentCreateFinish

  !>Start the creation of dependent variables for an equations set. \see OPENCMISS::CMISSEquationsSet_DependentCreateFinish
  INTERFACE CMISSEquationsSet_DependentCreateStart
    MODULE PROCEDURE CMISSEquationsSet_DependentCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSet_DependentCreateStartObj
  END INTERFACE !CMISSEquationsSet_DependentCreateStart

  !>Destroy the dependent variables for an equations set.
  INTERFACE CMISSEquationsSet_DependentDestroy
    MODULE PROCEDURE CMISSEquationsSet_DependentDestroyNumber
    MODULE PROCEDURE CMISSEquationsSet_DependentDestroyObj
  END INTERFACE !CMISSEquationsSet_DependentDestroy

  !>Finish the creation of equations for an equations set. \see OPENCMISS::CMISSEquationsSet_EquationsCreateStart
  INTERFACE CMISSEquationsSet_EquationsCreateFinish
    MODULE PROCEDURE CMISSEquationsSet_EquationsCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSet_EquationsCreateFinishObj
  END INTERFACE !CMISSEquationsSet_EquationsCreateFinish

  !>Start the creation of equations for an equations set. \see OPENCMISS::CMISSEquationsSet_EquationsCreateFinish
  INTERFACE CMISSEquationsSet_EquationsCreateStart
    MODULE PROCEDURE CMISSEquationsSet_EquationsCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSet_EquationsCreateStartObj
  END INTERFACE !CMISSEquationsSet_EquationsCreateStart

  !>Destroy the equations for an equations set.
  INTERFACE CMISSEquationsSet_EquationsDestroy
    MODULE PROCEDURE CMISSEquationsSet_EquationsDestroyNumber
    MODULE PROCEDURE CMISSEquationsSet_EquationsDestroyObj
  END INTERFACE !CMISSEquationsSet_EquationsDestroy

  !>Finish the creation of independent fields for an equations set. \see OPENCMISS::CMISSEquationsSet_IndependentCreateStart
  INTERFACE CMISSEquationsSet_IndependentCreateFinish
    MODULE PROCEDURE CMISSEquationsSet_IndependentCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSet_IndependentCreateFinishObj
  END INTERFACE !CMISSEquationsSet_IndependentCreateFinish

  !>Start the creation of independent fields for an equations set. \see OPENCMISS::CMISSEquationsSet_MaterialsCreateFinish
  INTERFACE CMISSEquationsSet_IndependentCreateStart
    MODULE PROCEDURE CMISSEquationsSet_IndependentCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSet_IndependentCreateStartObj
  END INTERFACE !CMISSEquationsSet_IndependentCreateStart

  !>Destroy the independent fields for an equations set.
  INTERFACE CMISSEquationsSet_IndependentDestroy
    MODULE PROCEDURE CMISSEquationsSet_IndependentDestroyNumber
    MODULE PROCEDURE CMISSEquationsSet_IndependentDestroyObj
  END INTERFACE !CMISSEquationsSet_IndependentDestroy

  !>Finish the creation of materials for an equations set. \see OPENCMISS::CMISSEquationsSet_MaterialsCreateStart
  INTERFACE CMISSEquationsSet_MaterialsCreateFinish
    MODULE PROCEDURE CMISSEquationsSet_MaterialsCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSet_MaterialsCreateFinishObj
  END INTERFACE !CMISSEquationsSet_MaterialsCreateFinish

  !>Start the creation of materials for an equations set. \see OPENCMISS::CMISSEquationsSet_MaterialsCreateFinish
  INTERFACE CMISSEquationsSet_MaterialsCreateStart
    MODULE PROCEDURE CMISSEquationsSet_MaterialsCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSet_MaterialsCreateStartObj
  END INTERFACE !CMISSEquationsSet_MaterialsCreateStart

  !>Destroy the materials for an equations set.
  INTERFACE CMISSEquationsSet_MaterialsDestroy
    MODULE PROCEDURE CMISSEquationsSet_MaterialsDestroyNumber
    MODULE PROCEDURE CMISSEquationsSet_MaterialsDestroyObj
  END INTERFACE !CMISSEquationsSet_MaterialsDestroy

  !>Returns the solution method for an equations set.
  INTERFACE CMISSEquationsSet_SolutionMethodGet
    MODULE PROCEDURE CMISSEquationsSet_SolutionMethodGetNumber
    MODULE PROCEDURE CMISSEquationsSet_SolutionMethodGetObj
  END INTERFACE !CMISSEquationsSet_SolutionMethodGet

  !>Sets/changes the solution method for an equations set.
  INTERFACE CMISSEquationsSet_SolutionMethodSet
    MODULE PROCEDURE CMISSEquationsSet_SolutionMethodSetNumber
    MODULE PROCEDURE CMISSEquationsSet_SolutionMethodSetObj
  END INTERFACE !CMISSEquationsSet_SolutionMethodSet

  !>Finish the creation of a source for an equations set. \see OPENCMISS::CMISSEquationsSet_SourceCreateStart
  INTERFACE CMISSEquationsSet_SourceCreateFinish
    MODULE PROCEDURE CMISSEquationsSet_SourceCreateFinishNumber
    MODULE PROCEDURE CMISSEquationsSet_SourceCreateFinishObj
  END INTERFACE !CMISSEquationsSet_SourceCreateFinish

  !>Start the creation of a source for an equations set. \see OPENCMISS::CMISSEquationsSet_SourceCreateFinish
  INTERFACE CMISSEquationsSet_SourceCreateStart
    MODULE PROCEDURE CMISSEquationsSet_SourceCreateStartNumber
    MODULE PROCEDURE CMISSEquationsSet_SourceCreateStartObj
  END INTERFACE !CMISSEquationsSet_SourceCreateStart

  !>Destroy the source for an equations set.
  INTERFACE CMISSEquationsSet_SourceDestroy
    MODULE PROCEDURE CMISSEquationsSet_SourceDestroyNumber
    MODULE PROCEDURE CMISSEquationsSet_SourceDestroyObj
  END INTERFACE !CMISSEquationsSet_SourceDestroy

  !>Returns the equations set specification i.e., equations set class, type and subtype for an equations set.
  INTERFACE CMISSEquationsSet_SpecificationGet
    MODULE PROCEDURE CMISSEquationsSet_SpecificationGetNumber
    MODULE PROCEDURE CMISSEquationsSet_SpecificationGetObj
  END INTERFACE !CMISSEquationsSet_SpecificationGet

   !>Sets/changes the equations set specification i.e., equations set class, type and subtype for an equations set.
  INTERFACE CMISSEquationsSet_SpecificationSet
    MODULE PROCEDURE CMISSEquationsSet_SpecificationSetNumber
    MODULE PROCEDURE CMISSEquationsSet_SpecificationSetObj
  END INTERFACE !CMISSEquationsSet_SpecificationSet

  !>Gets the equations set analytic user parameter
  INTERFACE CMISSEquationsSet_AnalyticUserParamGet
    MODULE PROCEDURE CMISSEquationsSet_AnalyticUserParamGetNumber
    MODULE PROCEDURE CMISSEquationsSet_AnalyticUserParamGetObj
  END INTERFACE

  !>Sets/changes the equations set analytic user parameter
  INTERFACE CMISSEquationsSet_AnalyticUserParamSet
    MODULE PROCEDURE CMISSEquationsSet_AnalyticUserParamSetNumber
    MODULE PROCEDURE CMISSEquationsSet_AnalyticUserParamSetObj
  END INTERFACE


  PUBLIC CMISSEquationsSet_AnalyticCreateFinish,CMISSEquationsSet_AnalyticCreateStart

  PUBLIC CMISSEquationsSet_AnalyticDestroy

  PUBLIC CMISSEquationsSet_AnalyticEvaluate

  PUBLIC CMISSEquationsSet_AnalyticTimeGet,CMISSEquationsSet_AnalyticTimeSet

  PUBLIC CMISSEquationsSet_CreateFinish,CMISSEquationsSet_CreateStart

  PUBLIC CMISSEquationsSet_DeformationCalculate
  
  PUBLIC CMISSEquationsSet_Destroy

  PUBLIC CMISSEquationsSet_DependentCreateFinish,CMISSEquationsSet_DependentCreateStart

  PUBLIC CMISSEquationsSet_DependentDestroy

  PUBLIC CMISSEquationsSet_EquationsCreateFinish,CMISSEquationsSet_EquationsCreateStart

  PUBLIC CMISSEquationsSet_EquationsDestroy

  PUBLIC CMISSEquationsSet_IndependentCreateFinish,CMISSEquationsSet_IndependentCreateStart

  PUBLIC CMISSEquationsSet_IndependentDestroy

  PUBLIC CMISSEquationsSet_MaterialsCreateFinish,CMISSEquationsSet_MaterialsCreateStart

  PUBLIC CMISSEquationsSet_MaterialsDestroy

  PUBLIC CMISSEquationsSet_SolutionMethodGet,CMISSEquationsSet_SolutionMethodSet

  PUBLIC CMISSEquationsSet_SourceCreateFinish,CMISSEquationsSet_SourceCreateStart

  PUBLIC CMISSEquationsSet_SourceDestroy

  PUBLIC CMISSEquationsSet_SpecificationGet,CMISSEquationsSet_SpecificationSet

  PUBLIC CMISSEquationsSet_AnalyticUserParamSet,CMISSEquationsSet_AnalyticUserParamGet
  

!!==================================================================================================================================
!!
!! FIELD_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_FieldConstants OPENCMISS::Field::Constants
  !> \brief Field constants.
  !>@{
  !> \addtogroup OPENCMISS_FieldDependentTypes OPENCMISS::Field::DependentTypes
  !> \brief Depedent field parameter types.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_INDEPENDENT_TYPE = FIELD_INDEPENDENT_TYPE !<Independent field type \see OPENCMISS_FieldDependentTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEPENDENT_TYPE = FIELD_DEPENDENT_TYPE !<Dependent field type \see OPENCMISS_FieldDependentTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldDimensionTypes OPENCMISS::Field::DimensionTypes
  !> \brief Field dimension parameter types.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_SCALAR_DIMENSION_TYPE = FIELD_SCALAR_DIMENSION_TYPE !<Scalar field \see OPENCMISS_FieldDimensionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_VECTOR_DIMENSION_TYPE = FIELD_VECTOR_DIMENSION_TYPE !<Vector field \see OPENCMISS_FieldDimensionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_TENSOR_DIMENSION_TYPE = FIELD_TENSOR_DIMENSION_TYPE !<Tensor field \see OPENCMISS_FieldDimensionTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldTypes OPENCMISS::Field::Types
  !> \brief Field type parameters.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_GEOMETRIC_TYPE = FIELD_GEOMETRIC_TYPE !<Geometric field \see OPENCMISS_FieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_FIBRE_TYPE = FIELD_FIBRE_TYPE !<Fibre field \see OPENCMISS_FieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_GENERAL_TYPE = FIELD_GENERAL_TYPE !<General field \see OPENCMISS_FieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_MATERIAL_TYPE = FIELD_MATERIAL_TYPE !<Material field \see OPENCMISS_FieldTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_GEOMETRIC_GENERAL_TYPE = FIELD_GEOMETRIC_GENERAL_TYPE !<Geometric general field \see OPENCMISS_FieldTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldInterpolationTypes OPENCMISS::Field::InterpolationTypes
  !> \brief Field interpolation parameters.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_CONSTANT_INTERPOLATION = FIELD_CONSTANT_INTERPOLATION !<Constant interpolation. One parameter for the field \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_ELEMENT_BASED_INTERPOLATION = FIELD_ELEMENT_BASED_INTERPOLATION !<Element based interpolation. Parameters are different in each element \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_NODE_BASED_INTERPOLATION = FIELD_NODE_BASED_INTERPOLATION !<Node based interpolation. Parameters are nodal based and a basis function is used \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_GRID_POINT_BASED_INTERPOLATION = FIELD_GRID_POINT_BASED_INTERPOLATION !<Grid point based interpolation. Parameters are different at each grid point \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_GAUSS_POINT_BASED_INTERPOLATION = FIELD_GAUSS_POINT_BASED_INTERPOLATION !<Gauss point based interpolation. Parameters are different at each Gauss point \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DATA_POINT_BASED_INTERPOLATION = FIELD_DATA_POINT_BASED_INTERPOLATION !<Data point based interpolation. Parameters are different at each data point \see OPENCMISS_FieldInterpolationTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldVariableTypes OPENCMISS::Field::VariableTypes
  !> \brief Field variable type parameters.
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_NUMBER_OF_VARIABLE_SUBTYPES = FIELD_NUMBER_OF_VARIABLE_SUBTYPES !<The number of subtypes of a variable - i.e., u, du/dn, du/dt, d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U_VARIABLE_TYPE = FIELD_U_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELUDELN_VARIABLE_TYPE = FIELD_DELUDELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELUDELT_VARIABLE_TYPE = FIELD_DELUDELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2UDELT2_VARIABLE_TYPE = FIELD_DEL2UDELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_V_VARIABLE_TYPE = FIELD_V_VARIABLE_TYPE !<Second standard variable type i.e., v \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELVDELN_VARIABLE_TYPE = FIELD_DELVDELN_VARIABLE_TYPE !<Second normal derivative variable type i.e., dv/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELVDELT_VARIABLE_TYPE = FIELD_DELVDELT_VARIABLE_TYPE !<Second first time derivative variable type i.e., dv/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2VDELT2_VARIABLE_TYPE = FIELD_DEL2VDELT2_VARIABLE_TYPE !<Second second time derivative variable type i.e., d^2v/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U1_VARIABLE_TYPE = FIELD_U1_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU1DELN_VARIABLE_TYPE = FIELD_DELU1DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU1DELT_VARIABLE_TYPE = FIELD_DELU1DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U1DELT2_VARIABLE_TYPE = FIELD_DEL2U1DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U2_VARIABLE_TYPE = FIELD_U2_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU2DELN_VARIABLE_TYPE = FIELD_DELU2DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU2DELT_VARIABLE_TYPE = FIELD_DELU2DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U2DELT2_VARIABLE_TYPE = FIELD_DEL2U2DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U3_VARIABLE_TYPE = FIELD_U3_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU3DELN_VARIABLE_TYPE = FIELD_DELU3DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU3DELT_VARIABLE_TYPE = FIELD_DELU3DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U3DELT2_VARIABLE_TYPE = FIELD_DEL2U3DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U4_VARIABLE_TYPE = FIELD_U4_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU4DELN_VARIABLE_TYPE = FIELD_DELU4DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU4DELT_VARIABLE_TYPE = FIELD_DELU4DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U4DELT2_VARIABLE_TYPE = FIELD_DEL2U4DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U5_VARIABLE_TYPE = FIELD_U5_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU5DELN_VARIABLE_TYPE = FIELD_DELU5DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU5DELT_VARIABLE_TYPE = FIELD_DELU5DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U5DELT2_VARIABLE_TYPE = FIELD_DEL2U5DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U6_VARIABLE_TYPE = FIELD_U6_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU6DELN_VARIABLE_TYPE = FIELD_DELU6DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU6DELT_VARIABLE_TYPE = FIELD_DELU6DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U6DELT2_VARIABLE_TYPE = FIELD_DEL2U6DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U7_VARIABLE_TYPE = FIELD_U7_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU7DELN_VARIABLE_TYPE = FIELD_DELU7DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU7DELT_VARIABLE_TYPE = FIELD_DELU7DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U7DELT2_VARIABLE_TYPE = FIELD_DEL2U7DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U8_VARIABLE_TYPE = FIELD_U8_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU8DELN_VARIABLE_TYPE = FIELD_DELU8DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU8DELT_VARIABLE_TYPE = FIELD_DELU8DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U8DELT2_VARIABLE_TYPE = FIELD_DEL2U8DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U9_VARIABLE_TYPE = FIELD_U9_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU9DELN_VARIABLE_TYPE = FIELD_DELU9DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU9DELT_VARIABLE_TYPE = FIELD_DELU9DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U9DELT2_VARIABLE_TYPE = FIELD_DEL2U9DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_U10_VARIABLE_TYPE = FIELD_U10_VARIABLE_TYPE !<Standard variable type i.e., u \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU10DELN_VARIABLE_TYPE = FIELD_DELU10DELN_VARIABLE_TYPE !<Normal derivative variable type i.e., du/dn \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DELU10DELT_VARIABLE_TYPE = FIELD_DELU10DELT_VARIABLE_TYPE !<First time derivative variable type i.e., du/dt \see OPENCMISS_FieldVariableTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DEL2U10DELT2_VARIABLE_TYPE = FIELD_DEL2U10DELT2_VARIABLE_TYPE !<Second time derivative variable type i.e., d^2u/dt^2 \see OPENCMISS_FieldVariableTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldDataTypes OPENCMISS::Field::DataTypes
  !> \brief Field data types
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_INTG_TYPE = FIELD_INTG_TYPE !<Integer field data type \see OPENCMISS_FieldDataTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_SP_TYPE = FIELD_SP_TYPE !<Single precision real field data type \see OPENCMISS_FieldDataTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_DP_TYPE = FIELD_DP_TYPE !<Double precision real field data type \see OPENCMISS_FieldDataTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_L_TYPE = FIELD_L_TYPE !<Logical field data type \see OPENCMISS_FieldDataTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldDOFOrderTypes OPENCMISS::Field::DOFOrderTypes
  !> \brief Field DOF order types
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_SEPARATED_COMPONENT_DOF_ORDER = FIELD_SEPARATED_COMPONENT_DOF_ORDER !<Field variable component dofs are not contiguous \see OPENCMISS_FieldDOFOrderTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER = FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER !<Field variable component dofs are contiguous \see OPENCMISS_FieldDOFOrderTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldParameterSetTypes OPENCMISS::Field::ParameterSetTypes
  !> \brief Field parameter set type parameters
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_VALUES_SET_TYPE = FIELD_VALUES_SET_TYPE !<The parameter set corresponding to the field values (at time T+DT for dynamic problems) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_BOUNDARY_CONDITIONS_SET_TYPE = FIELD_BOUNDARY_CONDITIONS_SET_TYPE !<The parameter set corresponding to the field boundary condition values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_INITIAL_VALUES_SET_TYPE = FIELD_INITIAL_VALUES_SET_TYPE !<The parameter set corresponding to the field initial values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_INCREMENTAL_VALUES_SET_TYPE = FIELD_INCREMENTAL_VALUES_SET_TYPE !<The parameter set corresponding to the field incremental values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_ANALYTIC_VALUES_SET_TYPE = FIELD_ANALYTIC_VALUES_SET_TYPE !<The parameter set corresponding to the analytic field values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_PREVIOUS_VALUES_SET_TYPE = FIELD_PREVIOUS_VALUES_SET_TYPE !<The parameter set corresponding to the previous field values (at time T) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE = FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE !<The parameter set corresponding to the mean predicited avalues (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_VELOCITY_VALUES_SET_TYPE = FIELD_VELOCITY_VALUES_SET_TYPE !<The parameter set corresponding to the velocity values (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_INITIAL_VELOCITY_SET_TYPE = FIELD_INITIAL_VELOCITY_SET_TYPE !<The parameter set corresponding to the initial velocity values for dynamic problems. This is also the previous velocity values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_PREVIOUS_VELOCITY_SET_TYPE = FIELD_PREVIOUS_VELOCITY_SET_TYPE !<The parameter set corresponding to the previous velocity values (at time T). This is also the initial velocity values for dynamic problems. \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE = FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE !<The parameter set corresponding to the mean predicited velocity values (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_ACCELERATION_VALUES_SET_TYPE = FIELD_ACCELERATION_VALUES_SET_TYPE !<The parameter set corresponding to the acceleration values (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_INITIAL_ACCELERATION_SET_TYPE = FIELD_INITIAL_ACCELERATION_SET_TYPE !<The parameter set corresponding to the initial acceleration values for dynamic problems. This is also the previous accelearation values \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_PREVIOUS_ACCELERATION_SET_TYPE = FIELD_PREVIOUS_ACCELERATION_SET_TYPE !<The parameter set corresponding to the previous acceleration values (at time T).This is also the initial acceleration values for dynamic problems. \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE = FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE !<The parameter set corresponding to the mean predicited acceleration values (at time T+DT) \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_PRESSURE_VALUES_SET_TYPE = FIELD_PRESSURE_VALUES_SET_TYPE !<The parameter set corresponding to the surface pressure values. \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_PREVIOUS_PRESSURE_SET_TYPE = FIELD_PREVIOUS_PRESSURE_SET_TYPE !<The parameter set corresponding to the previous surface pressure values (at time T). \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE = FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE !<The parameter set corresponding to the impermeable flag values. \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_INTEGRATED_NEUMANN_SET_TYPE = FIELD_INTEGRATED_NEUMANN_SET_TYPE !<Stores integrated Neumann values calculated from Neumann point values. \see OPENCMISS_FieldParameterSetTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_FieldScalingTypes OPENCMISS::Field::ScalingTypes
  !> \brief Field scaling type parameters
  !> \see OPENCMISS::Field,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_NO_SCALING = FIELD_NO_SCALING !<The field is not scaled \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_UNIT_SCALING = FIELD_UNIT_SCALING !<The field has unit scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_ARC_LENGTH_SCALING = FIELD_ARC_LENGTH_SCALING !<The field has arc length scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_ARITHMETIC_MEAN_SCALING = FIELD_ARITHMETIC_MEAN_SCALING !<The field has arithmetic mean of the arc length scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_GEOMETRIC_MEAN_SCALING = FIELD_GEOMETRIC_MEAN_SCALING !<The field has geometric mean of the arc length scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_FIELD_HARMONIC_MEAN_SCALING = FIELD_HARMONIC_MEAN_SCALING !<The field has geometric mean of the arc length scaling \see OPENCMISS_FieldScalingTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the interpolation type for a field variable component.
  INTERFACE CMISSField_ComponentInterpolationGet
    MODULE PROCEDURE CMISSField_ComponentInterpolationGetNumber
    MODULE PROCEDURE CMISSField_ComponentInterpolationGetObj
  END INTERFACE !CMISSField_ComponentInterpolationGet

  !>Sets/changes the interpolation type for a field variable component.
  INTERFACE CMISSField_ComponentInterpolationSet
    MODULE PROCEDURE CMISSField_ComponentInterpolationSetNumber
    MODULE PROCEDURE CMISSField_ComponentInterpolationSetObj
  END INTERFACE !CMISSField_ComponentInterpolationSet

  !>Returns the label for a field variable component.
  INTERFACE CMISSField_ComponentLabelGet
    MODULE PROCEDURE CMISSField_ComponentLabelGetCNumber
    MODULE PROCEDURE CMISSField_ComponentLabelGetCObj
    MODULE PROCEDURE CMISSField_ComponentLabelGetVSNumber
    MODULE PROCEDURE CMISSField_ComponentLabelGetVSObj
  END INTERFACE !CMISSField_ComponentLabelGet

  !>Sets/changes the label for a field variable component.
  INTERFACE CMISSField_ComponentLabelSet
    MODULE PROCEDURE CMISSField_ComponentLabelSetCNumber
    MODULE PROCEDURE CMISSField_ComponentLabelSetCObj
    MODULE PROCEDURE CMISSField_ComponentLabelSetVSNumber
    MODULE PROCEDURE CMISSField_ComponentLabelSetVSObj
  END INTERFACE !CMISSField_ComponentLabelSet

  !>Returns the mesh component number for a field variable component.
  INTERFACE CMISSField_ComponentMeshComponentGet
    MODULE PROCEDURE CMISSField_ComponentMeshComponentGetNumber
    MODULE PROCEDURE CMISSField_ComponentMeshComponentGetObj
  END INTERFACE !CMISSField_ComponentMeshComponentGet

  !>Sets/changes the mesh component number for a field variable component.
  INTERFACE CMISSField_ComponentMeshComponentSet
    MODULE PROCEDURE CMISSField_ComponentMeshComponentSetNumber
    MODULE PROCEDURE CMISSField_ComponentMeshComponentSetObj
  END INTERFACE !CMISSField_ComponentMeshComponentSet

  !>Initialises the values of a parameter set of a field variable component to a constant value.
  INTERFACE CMISSField_ComponentValuesInitialise
    MODULE PROCEDURE CMISSField_ComponentValuesInitialiseIntgNumber
    MODULE PROCEDURE CMISSField_ComponentValuesInitialiseIntgObj
    MODULE PROCEDURE CMISSField_ComponentValuesInitialiseSPNumber
    MODULE PROCEDURE CMISSField_ComponentValuesInitialiseSPObj
    MODULE PROCEDURE CMISSField_ComponentValuesInitialiseDPNumber
    MODULE PROCEDURE CMISSField_ComponentValuesInitialiseDPObj
    MODULE PROCEDURE CMISSField_ComponentValuesInitialiseLNumber
    MODULE PROCEDURE CMISSField_ComponentValuesInitialiseLObj
  END INTERFACE !CMISSField_ComponentValuesInitialise

  !>Returns the data type for a field variable.
  INTERFACE CMISSField_DataTypeGet
    MODULE PROCEDURE CMISSField_DataTypeGetNumber
    MODULE PROCEDURE CMISSField_DataTypeGetObj
  END INTERFACE !CMISSField_DataTypeGet

  !>Sets/changes the data type for a field variable.
  INTERFACE CMISSField_DataTypeSet
    MODULE PROCEDURE CMISSField_DataTypeSetNumber
    MODULE PROCEDURE CMISSField_DataTypeSetObj
  END INTERFACE !CMISSField_DataTypeSet

  !>Returns the DOF order type for a field variable.
  INTERFACE CMISSField_DOFOrderTypeGet
    MODULE PROCEDURE CMISSField_DOFOrderTypeGetNumber
    MODULE PROCEDURE CMISSField_DOFOrderTypeGetObj
  END INTERFACE !CMISSField_DOFOrderTypeGet

  !>Sets/changes the DOF order type for a field variable. Note: for contiguous coponent DOF ordering all the components of the field variable must have the same interpolation type.
  INTERFACE CMISSField_DOFOrderTypeSet
    MODULE PROCEDURE CMISSField_DOFOrderTypeSetNumber
    MODULE PROCEDURE CMISSField_DOFOrderTypeSetObj
  END INTERFACE !CMISSField_DOFOrderTypeSet

  !>Finishes the creation of a field. \see OPENCMISS::CMISSField_CreateStart
  INTERFACE CMISSField_CreateFinish
    MODULE PROCEDURE CMISSField_CreateFinishNumber
    MODULE PROCEDURE CMISSField_CreateFinishObj
  END INTERFACE !CMISSField_CreateFinish

  !>Starts the creation of a field. \see OPENCMISS::CMISSField_CreateFinish
  INTERFACE CMISSField_CreateStart
    MODULE PROCEDURE CMISSField_CreateStartNumber
    MODULE PROCEDURE CMISSField_CreateStartInterfaceObj
    MODULE PROCEDURE CMISSField_CreateStartRegionObj
  END INTERFACE !CMISSField_CreateStart

  !>Returns the dependent type for a field.
  INTERFACE CMISSField_DependentTypeGet
    MODULE PROCEDURE CMISSField_DependentTypeGetNumber
    MODULE PROCEDURE CMISSField_DependentTypeGetObj
  END INTERFACE !CMISSField_DependentTypeGet

  !>Sets/changes the dependent type for a field.
  INTERFACE CMISSField_DependentTypeSet
    MODULE PROCEDURE CMISSField_DependentTypeSetNumber
    MODULE PROCEDURE CMISSField_DependentTypeSetObj
  END INTERFACE !CMISSField_DependentTypeSet

  !>Destroys a field.
  INTERFACE CMISSField_Destroy
    MODULE PROCEDURE CMISSField_DestroyNumber
    MODULE PROCEDURE CMISSField_DestroyObj
  END INTERFACE !CMISSField_Destroy

  !>Returns the field dimension for a field variable.
  INTERFACE CMISSField_DimensionGet
    MODULE PROCEDURE CMISSField_DimensionGetNumber
    MODULE PROCEDURE CMISSField_DimensionGetObj
  END INTERFACE !CMISSField_DimensionGet

  !>Sets/changes the field dimension for a field variable.
  INTERFACE CMISSField_DimensionSet
    MODULE PROCEDURE CMISSField_DimensionSetNumber
    MODULE PROCEDURE CMISSField_DimensionSetObj
  END INTERFACE !CMISSField_DimensionSet

  !>Returns the geometric field for a field.
  INTERFACE CMISSField_GeometricFieldGet
    MODULE PROCEDURE CMISSField_GeometricFieldGetNumber
    MODULE PROCEDURE CMISSField_GeometricFieldGetObj
  END INTERFACE !CMISSField_GeometricFieldGet

  !>Sets/changes the geometric field for a field.
  INTERFACE CMISSField_GeometricFieldSet
    MODULE PROCEDURE CMISSField_GeometricFieldSetNumber
    MODULE PROCEDURE CMISSField_GeometricFieldSetObj
  END INTERFACE !CMISSField_GeometricFieldSet

  !>Gets line lengths from a geometric field given an element number and element basis line number.
  INTERFACE CMISSField_GeometricParametersElementLineLengthGet
    MODULE PROCEDURE CMISSField_GeometricParametersElementLineLengthGetNumber
    MODULE PROCEDURE CMISSField_GeometricParametersElementLineLengthGetObj
  END INTERFACE !CMISSField_GeometricParametersElementLineLengthGet

 !>Returns the label for a field.
  INTERFACE CMISSField_LabelGet
    MODULE PROCEDURE CMISSField_LabelGetCNumber
    MODULE PROCEDURE CMISSField_LabelGetCObj
    MODULE PROCEDURE CMISSField_LabelGetVSNumber
    MODULE PROCEDURE CMISSField_LabelGetVSObj
  END INTERFACE !CMISSField_LabelGet

  !>Sets/changes the label for a field.
  INTERFACE CMISSField_LabelSet
    MODULE PROCEDURE CMISSField_LabelSetCNumber
    MODULE PROCEDURE CMISSField_LabelSetCObj
    MODULE PROCEDURE CMISSField_LabelSetVSNumber
    MODULE PROCEDURE CMISSField_LabelSetVSObj
  END INTERFACE !CMISSField_LabelSet

  INTERFACE CMISSField_PositionNormalTangentCalculateNode
    MODULE PROCEDURE CMISSField_PositionNormalTangentCalculateNodeNumber
    MODULE PROCEDURE CMISSField_PositionNormalTangentCalculateNodeObj
  END INTERFACE

  !>Returns the mesh decomposition for a field.
  INTERFACE CMISSField_MeshDecompositionGet
    MODULE PROCEDURE CMISSField_MeshDecompositionGetNumber
    MODULE PROCEDURE CMISSField_MeshDecompositionGetObj
  END INTERFACE !CMISSField_MeshDecompositionGet

  !>Sets/changes the mesh decomposition for a field. \todo remove when fields take decomposition argument on creation???
  INTERFACE CMISSField_MeshDecompositionSet
    MODULE PROCEDURE CMISSField_MeshDecompositionSetNumber
    MODULE PROCEDURE CMISSField_MeshDecompositionSetObj
  END INTERFACE !CMISSField_MeshDecompositionSet

  !>Sets/changes the data projection for a field.
  INTERFACE CMISSField_DataProjectionSet
    MODULE PROCEDURE CMISSField_DataProjectionSetNumber
    MODULE PROCEDURE CMISSField_DataProjectionSetObj
  END INTERFACE !CMISSField_DataProjectionSet

  !>Returns the number of field components for a field variable.
  INTERFACE CMISSField_NumberOfComponentsGet
    MODULE PROCEDURE CMISSField_NumberOfComponentsGetNumber
    MODULE PROCEDURE CMISSField_NumberOfComponentsGetObj
  END INTERFACE !CMISSField_NumberOfComponentsGet

  !>Sets/changes the number of field components for a field variable.
  INTERFACE CMISSField_NumberOfComponentsSet
    MODULE PROCEDURE CMISSField_NumberOfComponentsSetNumber
    MODULE PROCEDURE CMISSField_NumberOfComponentsSetObj
  END INTERFACE !CMISSField_NumberOfComponentsSet

  !>Returns the number of field variables for a field.
  INTERFACE CMISSField_NumberOfVariablesGet
    MODULE PROCEDURE CMISSField_NumberOfVariablesGetNumber
    MODULE PROCEDURE CMISSField_NumberOfVariablesGetObj
  END INTERFACE !CMISSField_NumberOfVariablesGet

  !>Sets/changes the number of field variables for a field.
  INTERFACE CMISSField_NumberOfVariablesSet
    MODULE PROCEDURE CMISSField_NumberOfVariablesSetNumber
    MODULE PROCEDURE CMISSField_NumberOfVariablesSetObj
  END INTERFACE !CMISSField_NumberOfVariablesSet

  !>Adds the given value to the given parameter set for the constant of the field variable component.
  INTERFACE CMISSField_ParameterSetAddConstant
    MODULE PROCEDURE CMISSField_ParameterSetAddConstantIntgNumber
    MODULE PROCEDURE CMISSField_ParameterSetAddConstantIntgObj
    MODULE PROCEDURE CMISSField_ParameterSetAddConstantSPNumber
    MODULE PROCEDURE CMISSField_ParameterSetAddConstantSPObj
    MODULE PROCEDURE CMISSField_ParameterSetAddConstantDPNumber
    MODULE PROCEDURE CMISSField_ParameterSetAddConstantDPObj
    MODULE PROCEDURE CMISSField_ParameterSetAddConstantLNumber
    MODULE PROCEDURE CMISSField_ParameterSetAddConstantLObj
  END INTERFACE !CMISSField_ParameterSetAddConstant

  !>Adds the given value to the given parameter set for a particular user element of the field variable component.
  INTERFACE CMISSField_ParameterSetAddElement
    MODULE PROCEDURE CMISSField_ParameterSetAddElementIntgNumber
    MODULE PROCEDURE CMISSField_ParameterSetAddElementIntgObj
    MODULE PROCEDURE CMISSField_ParameterSetAddElementSPNumber
    MODULE PROCEDURE CMISSField_ParameterSetAddElementSPObj
    MODULE PROCEDURE CMISSField_ParameterSetAddElementDPNumber
    MODULE PROCEDURE CMISSField_ParameterSetAddElementDPObj
    MODULE PROCEDURE CMISSField_ParameterSetAddElementLNumber
    MODULE PROCEDURE CMISSField_ParameterSetAddElementLObj
  END INTERFACE !CMISSField_ParameterSetAddElement

  !>Adds the given value to the given parameter set for a particular user node of the field variable component.
  INTERFACE CMISSField_ParameterSetAddNode
    MODULE PROCEDURE CMISSField_ParameterSetAddNodeIntgNumber
    MODULE PROCEDURE CMISSField_ParameterSetAddNodeIntgObj
    MODULE PROCEDURE CMISSField_ParameterSetAddNodeSPNumber
    MODULE PROCEDURE CMISSField_ParameterSetAddNodeSPObj
    MODULE PROCEDURE CMISSField_ParameterSetAddNodeDPNumber
    MODULE PROCEDURE CMISSField_ParameterSetAddNodeDPObj
    MODULE PROCEDURE CMISSField_ParameterSetAddNodeLNumber
    MODULE PROCEDURE CMISSField_ParameterSetAddNodeLObj
  END INTERFACE !CMISSField_ParameterSetAddNode

  !>Creates a new parameter set of type set type for a field variable.
  INTERFACE CMISSField_ParameterSetCreate
    MODULE PROCEDURE CMISSField_ParameterSetCreateNumber
    MODULE PROCEDURE CMISSField_ParameterSetCreateObj
  END INTERFACE !CMISSField_ParameterSetCreate

  !>Destroy a parameter set of type set type for a field variable.
  INTERFACE CMISSField_ParameterSetDestroy
    MODULE PROCEDURE CMISSField_ParameterSetDestroyNumber
    MODULE PROCEDURE CMISSField_ParameterSetDestroyObj
  END INTERFACE !CMISSField_ParameterSetCreate

  !>Returns a pointer to the specified field parameter set local data array. The pointer must be restored with a call to OPENCMISS::CMISSField_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  INTERFACE CMISSField_ParameterSetDataGet
    MODULE PROCEDURE CMISSField_ParameterSetDataGetIntgNumber
    MODULE PROCEDURE CMISSField_ParameterSetDataGetIntgObj
    MODULE PROCEDURE CMISSField_ParameterSetDataGetSPNumber
    MODULE PROCEDURE CMISSField_ParameterSetDataGetSPObj
    MODULE PROCEDURE CMISSField_ParameterSetDataGetDPNumber
    MODULE PROCEDURE CMISSField_ParameterSetDataGetDPObj
    MODULE PROCEDURE CMISSField_ParameterSetDataGetLNumber
    MODULE PROCEDURE CMISSField_ParameterSetDataGetLObj
  END INTERFACE !CMISSField_ParameterSetDataGet

  !>Restores the specified field variable parameter set local array that was obtained with an OPENCMISS::CMISSField_ParameterSetDataGet call.
  INTERFACE CMISSField_ParameterSetDataRestore
    MODULE PROCEDURE CMISSField_ParameterSetDataRestoreIntgNumber
    MODULE PROCEDURE CMISSField_ParameterSetDataRestoreIntgObj
    MODULE PROCEDURE CMISSField_ParameterSetDataRestoreSPNumber
    MODULE PROCEDURE CMISSField_ParameterSetDataRestoreSPObj
    MODULE PROCEDURE CMISSField_ParameterSetDataRestoreDPNumber
    MODULE PROCEDURE CMISSField_ParameterSetDataRestoreDPObj
    MODULE PROCEDURE CMISSField_ParameterSetDataRestoreLNumber
    MODULE PROCEDURE CMISSField_ParameterSetDataRestoreLObj
  END INTERFACE !CMISSField_ParameterSetDataRestore

  !>Returns from the given parameter set a value for the specified constant of a field variable component.
  INTERFACE CMISSField_ParameterSetGetConstant
    MODULE PROCEDURE CMISSField_ParameterSetGetConstantIntgNumber
    MODULE PROCEDURE CMISSField_ParameterSetGetConstantIntgObj
    MODULE PROCEDURE CMISSField_ParameterSetGetConstantSPNumber
    MODULE PROCEDURE CMISSField_ParameterSetGetConstantSPObj
    MODULE PROCEDURE CMISSField_ParameterSetGetConstantDPNumber
    MODULE PROCEDURE CMISSField_ParameterSetGetConstantDPObj
    MODULE PROCEDURE CMISSField_ParameterSetGetConstantLNumber
    MODULE PROCEDURE CMISSField_ParameterSetGetConstantLObj
  END INTERFACE !CMISSField_ParameterSetGetConstant
  
  !>Returns from the given parameter set a value for the specified data pont of a field variable component.
  INTERFACE CMISSField_ParameterSetGetDataPoint
    MODULE PROCEDURE CMISSField_ParameterSetGetDataPointIntgNumberI !Interface
    MODULE PROCEDURE CMISSField_ParameterSetGetDataPointIntgNumberR !Region
    MODULE PROCEDURE CMISSField_ParameterSetGetDataPointIntgObj
    MODULE PROCEDURE CMISSField_ParameterSetGetDataPointSPNumberI !Interface
    MODULE PROCEDURE CMISSField_ParameterSetGetDataPointSPNumberR !Region
    MODULE PROCEDURE CMISSField_ParameterSetGetDataPointSPObj
    MODULE PROCEDURE CMISSField_ParameterSetGetDataPointDPNumberI !Interface
    MODULE PROCEDURE CMISSField_ParameterSetGetDataPointDPNumberR !Region
    MODULE PROCEDURE CMISSField_ParameterSetGetDataPointDPObj
    MODULE PROCEDURE CMISSField_ParameterSetGetDataPointLNumberI !Interface
    MODULE PROCEDURE CMISSField_ParameterSetGetDataPointLNumberR !Region
    MODULE PROCEDURE CMISSField_ParameterSetGetDataPointLObj
  END INTERFACE !CMISSField_ParameterSetGetDataPoint

  !>Returns from the given parameter set a value for the specified element of a field variable component.
  INTERFACE CMISSField_ParameterSetGetElement
    MODULE PROCEDURE CMISSField_ParameterSetGetElementIntgNumber
    MODULE PROCEDURE CMISSField_ParameterSetGetElementIntgObj
    MODULE PROCEDURE CMISSField_ParameterSetGetElementSPNumber
    MODULE PROCEDURE CMISSField_ParameterSetGetElementSPObj
    MODULE PROCEDURE CMISSField_ParameterSetGetElementDPNumber
    MODULE PROCEDURE CMISSField_ParameterSetGetElementDPObj
    MODULE PROCEDURE CMISSField_ParameterSetGetElementLNumber
    MODULE PROCEDURE CMISSField_ParameterSetGetElementLObj
  END INTERFACE !CMISSField_ParameterSetGetElement

  !>Returns from the given parameter set a value for the specified node and derivative of a field variable component.
  INTERFACE CMISSField_ParameterSetGetNode
    MODULE PROCEDURE CMISSField_ParameterSetGetNodeIntgNumber
    MODULE PROCEDURE CMISSField_ParameterSetGetNodeIntgObj
    MODULE PROCEDURE CMISSField_ParameterSetGetNodeSPNumber
    MODULE PROCEDURE CMISSField_ParameterSetGetNodeSPObj
    MODULE PROCEDURE CMISSField_ParameterSetGetNodeDPNumber
    MODULE PROCEDURE CMISSField_ParameterSetGetNodeDPObj
    MODULE PROCEDURE CMISSField_ParameterSetGetNodeLNumber
    MODULE PROCEDURE CMISSField_ParameterSetGetNodeLObj
  END INTERFACE !CMISSField_ParameterSetGetNode

  !>Returns from the given parameter set a value for the specified element and Gauss point of a field variable component.
  INTERFACE CMISSField_ParameterSetGetGaussPoint ! TODO: other versions
    MODULE PROCEDURE CMISSField_ParameterSetGetGaussPointDPObj
  END INTERFACE !CMISSField_ParameterSetGetGaussPoint

  !>Updates the given parameter set with the given value for the constant of a field variable component.
  INTERFACE CMISSField_ParameterSetUpdateConstant
    MODULE PROCEDURE CMISSField_ParameterSetUpdateConstantIntgNumber
    MODULE PROCEDURE CMISSField_ParameterSetUpdateConstantIntgObj
    MODULE PROCEDURE CMISSField_ParameterSetUpdateConstantSPNumber
    MODULE PROCEDURE CMISSField_ParameterSetUpdateConstantSPObj
    MODULE PROCEDURE CMISSField_ParameterSetUpdateConstantDPNumber
    MODULE PROCEDURE CMISSField_ParameterSetUpdateConstantDPObj
    MODULE PROCEDURE CMISSField_ParameterSetUpdateConstantLNumber
    MODULE PROCEDURE CMISSField_ParameterSetUpdateConstantLObj
  END INTERFACE !CMISSField_ParameterSetUpdateConstant
  
  !>Update the given parameter set a value for the specified data pont of a field variable component.
  INTERFACE CMISSField_ParameterSetUpdateDataPoint
    MODULE PROCEDURE CMISSField_ParameterSetUpdateDataPointIntgNumberI !Interface
    MODULE PROCEDURE CMISSField_ParameterSetUpdateDataPointIntgNumberR !Region
    MODULE PROCEDURE CMISSField_ParameterSetUpdateDataPointIntgObj
    MODULE PROCEDURE CMISSField_ParameterSetUpdateDataPointSPNumberI !Interface
    MODULE PROCEDURE CMISSField_ParameterSetUpdateDataPointSPNumberR !Region
    MODULE PROCEDURE CMISSField_ParameterSetUpdateDataPointSPObj
    MODULE PROCEDURE CMISSField_ParameterSetUpdateDataPointDPNumberI !Interface
    MODULE PROCEDURE CMISSField_ParameterSetUpdateDataPointDPNumberR !Region
    MODULE PROCEDURE CMISSField_ParameterSetUpdateDataPointDPObj
    MODULE PROCEDURE CMISSField_ParameterSetUpdateDataPointLNumberI !Interface
    MODULE PROCEDURE CMISSField_ParameterSetUpdateDataPointLNumberR !Region
    MODULE PROCEDURE CMISSField_ParameterSetUpdateDataPointLObj
  END INTERFACE !CMISSField_ParameterSetUpdateDataPoint

  !>Updates the given parameter set with the given value for a particular user element of a field variable component.
  INTERFACE CMISSField_ParameterSetUpdateElement
    MODULE PROCEDURE CMISSField_ParameterSetUpdateElementIntgNumber
    MODULE PROCEDURE CMISSField_ParameterSetUpdateElementIntgObj
    MODULE PROCEDURE CMISSField_ParameterSetUpdateElementSPNumber
    MODULE PROCEDURE CMISSField_ParameterSetUpdateElementSPObj
    MODULE PROCEDURE CMISSField_ParameterSetUpdateElementDPNumber
    MODULE PROCEDURE CMISSField_ParameterSetUpdateElementDPObj
    MODULE PROCEDURE CMISSField_ParameterSetUpdateElementLNumber
    MODULE PROCEDURE CMISSField_ParameterSetUpdateElementLObj
  END INTERFACE !CMISSField_ParameterSetUpdateElement

  !>Finishes the parameter set update for a field variable. \see OPENCMISS::CMISSField_ParameterSetUpdateStart
  INTERFACE CMISSField_ParameterSetUpdateFinish
    MODULE PROCEDURE CMISSField_ParameterSetUpdateFinishNumber
    MODULE PROCEDURE CMISSField_ParameterSetUpdateFinishObj
  END INTERFACE !CMISSField_ParameterSetUpdateFinish

  !>Updates the given parameter set with the given value for a particular user node of a field variable component.
  INTERFACE CMISSField_ParameterSetUpdateNode
    MODULE PROCEDURE CMISSField_ParameterSetUpdateNodeIntgNumber
    MODULE PROCEDURE CMISSField_ParameterSetUpdateNodeIntgObj
    MODULE PROCEDURE CMISSField_ParameterSetUpdateNodeSPNumber
    MODULE PROCEDURE CMISSField_ParameterSetUpdateNodeSPObj
    MODULE PROCEDURE CMISSField_ParameterSetUpdateNodeDPNumber
    MODULE PROCEDURE CMISSField_ParameterSetUpdateNodeDPObj
    MODULE PROCEDURE CMISSField_ParameterSetUpdateNodeLNumber
    MODULE PROCEDURE CMISSField_ParameterSetUpdateNodeLObj
  END INTERFACE !CMISSField_ParameterSetUpdateNode

  !\todo: merge the two types of routines for getting scalefactors under the same interface declaration?
  !>Gets a scale factor for a particular node.
  INTERFACE CMISSField_ParameterSetNodeScaleFactorGet
    MODULE PROCEDURE CMISSField_ParameterSetNodeScaleFactorGetNumber
    MODULE PROCEDURE CMISSField_ParameterSetNodeScaleFactorGetObj
  END INTERFACE !CMISSField_ParameterSetNodeScaleFactorGet

  !>Gets the scale factors for all nodes
  INTERFACE CMISSField_ParameterSetNodeScaleFactorsGet
    MODULE PROCEDURE CMISSField_ParameterSetNodeScaleFactorsGetNumber
    MODULE PROCEDURE CMISSField_ParameterSetNodeScaleFactorsGetObj
  END INTERFACE !CMISSField_ParameterSetNodeScaleFactorsGet

  !>Sets a scale factor for a particular node.
  INTERFACE CMISSField_ParameterSetNodeScaleFactorSet
    MODULE PROCEDURE CMISSField_ParameterSetNodeScaleFactorSetNumber
    MODULE PROCEDURE CMISSField_ParameterSetNodeScaleFactorSetObj
  END INTERFACE !CMISSField_ParameterSetNodeScaleFactorSet

  !>Sets the scale factors for all nodes
  INTERFACE CMISSField_ParameterSetNodeScaleFactorsSet
    MODULE PROCEDURE CMISSField_ParameterSetNodeScaleFactorsSetNumber
    MODULE PROCEDURE CMISSField_ParameterSetNodeScaleFactorsSetObj
  END INTERFACE !CMISSField_ParameterSetNodeScaleFactorsSet

  !>Gets the number of scalefactor dofs
  INTERFACE CMISSField_ParameterSetNodeNumberOfScaleFactorDofsGet
    MODULE PROCEDURE CMISSField_ParameterSetNodeNumberOfScaleFactorDofsGetNumber
    MODULE PROCEDURE CMISSField_ParameterSetNodeNumberOfScaleFactorDofsGetObj
  END INTERFACE !CMISSField_ParameterSetNodeNumberOfScaleFactorDofsGet

  !>Updates the given parameter set with the given values for all local dofs of the field variable.  
  INTERFACE CMISSField_ParameterSetUpdateLocalDofs
    MODULE PROCEDURE CMISSField_ParameterSetUpdateLocalDofsDPObj
    !\todo: add Intg/SP/L routines, both indexed by Number and Obj
  END INTERFACE !CMISSField_ParameterSetUpdateLocalDofs

  !>Updates the given parameter set with the given value for a particular gauss point of a field variable component.
  INTERFACE CMISSField_ParameterSetUpdateGaussPoint
    MODULE PROCEDURE CMISSField_ParameterSetUpdateGaussPointDPNumber
    MODULE PROCEDURE CMISSField_ParameterSetUpdateGaussPointDPObj
  END INTERFACE !CMISSField_ParameterSetUpdateGaussPoint

  !>Interpolates the given parameter set at a specified xi/set of xi locations for specified element and derviative.
  INTERFACE CMISSField_ParameterSetInterpolateXi
    MODULE PROCEDURE CMISSField_ParameterSetInterpolateSingleXiDPNumber
    MODULE PROCEDURE CMISSField_ParameterSetInterpolateSingleXiDPObj
    MODULE PROCEDURE CMISSField_ParameterSetInterpolateMultipleXiDPNumber
    MODULE PROCEDURE CMISSField_ParameterSetInterpolateMultipleXiDPObj
  END INTERFACE !CMISSField_ParameterSetInterpolateXi

  !>Interpolates the given parameter set at a specified set of Gauss points for specified element and derviative. When interpolating at multiple Gauss points, if no Gauss points are specified then all Gauss points are interpolated.
  INTERFACE CMISSField_ParameterSetInterpolateGauss
    MODULE PROCEDURE CMISSField_ParameterSetInterpolateSingleGaussDPNumber
    MODULE PROCEDURE CMISSField_ParameterSetInterpolateSingleGaussDPObj
    MODULE PROCEDURE CMISSField_ParameterSetInterpolateMultipleGaussDPNumber
    MODULE PROCEDURE CMISSField_ParameterSetInterpolateMultipleGaussDPObj
  END INTERFACE !CMISSField_ParameterSetInterpolateGauss

  !>Updates the given parameter set with the given value for a particular data point of a field variable component.
  INTERFACE CMISSField_ParameterSetUpdateElementDataPoint
    MODULE PROCEDURE CMISSField_ParameterSetUpdateElementDataPointDPObj
  END INTERFACE !CMISSField_ParameterSetUpdateElementDataPoint

  !>Starts the parameter set update for a field variable. \see OPENCMISS::CMISSField_ParameterSetUpdateFinish
  INTERFACE CMISSField_ParameterSetUpdateStart
    MODULE PROCEDURE CMISSField_ParameterSetUpdateStartNumber
    MODULE PROCEDURE CMISSField_ParameterSetUpdateStartObj
  END INTERFACE !CMISSField_ParameterSetUpdateStart

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable.
  INTERFACE CMISSField_ParametersToFieldParametersComponentCopy
    MODULE PROCEDURE CMISSField_ParametersToFieldParametersComponentCopyNumber
    MODULE PROCEDURE CMISSField_ParametersToFieldParametersComponentCopyObj
  END INTERFACE !CMISSField_ParametersToFieldParametersComponentCopy

  !>Returns the scaling type for a field.
  INTERFACE CMISSField_ScalingTypeGet
    MODULE PROCEDURE CMISSField_ScalingTypeGetNumber
    MODULE PROCEDURE CMISSField_ScalingTypeGetObj
  END INTERFACE !CMISSField_ScalingTypeGet

  !>Sets/changes the scaling type for a field.
  INTERFACE CMISSField_ScalingTypeSet
    MODULE PROCEDURE CMISSField_ScalingTypeSetNumber
    MODULE PROCEDURE CMISSField_ScalingTypeSetObj
  END INTERFACE !CMISSField_ScalingTypeSet

  !>Returns the type for a field.
  INTERFACE CMISSField_TypeGet
    MODULE PROCEDURE CMISSField_TypeGetNumber
    MODULE PROCEDURE CMISSField_TypeGetObj
  END INTERFACE !CMISSField_TypeGet

  !>Sets/changes the type for a field.
  INTERFACE CMISSField_TypeSet
    MODULE PROCEDURE CMISSField_TypeSetNumber
    MODULE PROCEDURE CMISSField_TypeSetObj
  END INTERFACE !CMISSField_TypeSet

  !>Returns the label for a field variable.
  INTERFACE CMISSField_VariableLabelGet
    MODULE PROCEDURE CMISSField_VariableLabelGetCNumber
    MODULE PROCEDURE CMISSField_VariableLabelGetCObj
    MODULE PROCEDURE CMISSField_VariableLabelGetVSNumber
    MODULE PROCEDURE CMISSField_VariableLabelGetVSObj
  END INTERFACE !CMISSField_VariableLabelGet

  !>Sets/changes the label for a field variable.
  INTERFACE CMISSField_VariableLabelSet
    MODULE PROCEDURE CMISSField_VariableLabelSetCNumber
    MODULE PROCEDURE CMISSField_VariableLabelSetCObj
    MODULE PROCEDURE CMISSField_VariableLabelSetVSNumber
    MODULE PROCEDURE CMISSField_VariableLabelSetVSObj
  END INTERFACE !CMISSField_VariableLabelSet

  !>Returns the field variable types for a field.
  INTERFACE CMISSField_VariableTypesGet
    MODULE PROCEDURE CMISSField_VariableTypesGetNumber
    MODULE PROCEDURE CMISSField_VariableTypesGetObj
  END INTERFACE !CMISSField_VariableTypesGet

  !>Sets/changes the field variable types for a field.
  INTERFACE CMISSField_VariableTypesSet
    MODULE PROCEDURE CMISSField_VariableTypesSetNumber
    MODULE PROCEDURE CMISSField_VariableTypesSetObj
  END INTERFACE !CMISSField_VariableTypesSet


  PUBLIC CMISS_FIELD_DEPENDENT_TYPE,CMISS_FIELD_INDEPENDENT_TYPE

  PUBLIC CMISS_FIELD_SCALAR_DIMENSION_TYPE,CMISS_FIELD_VECTOR_DIMENSION_TYPE,CMISS_FIELD_TENSOR_DIMENSION_TYPE

  PUBLIC CMISS_FIELD_GEOMETRIC_TYPE,CMISS_FIELD_FIBRE_TYPE,CMISS_FIELD_GENERAL_TYPE,CMISS_FIELD_MATERIAL_TYPE, &
    & CMISS_FIELD_GEOMETRIC_GENERAL_TYPE

  PUBLIC CMISS_FIELD_CONSTANT_INTERPOLATION,CMISS_FIELD_ELEMENT_BASED_INTERPOLATION,CMISS_FIELD_NODE_BASED_INTERPOLATION, &
    & CMISS_FIELD_GRID_POINT_BASED_INTERPOLATION,CMISS_FIELD_GAUSS_POINT_BASED_INTERPOLATION, &
    & CMISS_FIELD_DATA_POINT_BASED_INTERPOLATION

  PUBLIC CMISS_FIELD_NUMBER_OF_VARIABLE_SUBTYPES

  PUBLIC CMISS_FIELD_U_VARIABLE_TYPE,CMISS_FIELD_DELUDELN_VARIABLE_TYPE,CMISS_FIELD_DELUDELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2UDELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_V_VARIABLE_TYPE,CMISS_FIELD_DELVDELN_VARIABLE_TYPE,CMISS_FIELD_DELVDELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2VDELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U1_VARIABLE_TYPE,CMISS_FIELD_DELU1DELN_VARIABLE_TYPE,CMISS_FIELD_DELU1DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U1DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U2_VARIABLE_TYPE,CMISS_FIELD_DELU2DELN_VARIABLE_TYPE,CMISS_FIELD_DELU2DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U2DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U3_VARIABLE_TYPE,CMISS_FIELD_DELU3DELN_VARIABLE_TYPE,CMISS_FIELD_DELU3DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U3DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U4_VARIABLE_TYPE,CMISS_FIELD_DELU4DELN_VARIABLE_TYPE,CMISS_FIELD_DELU4DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U4DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U5_VARIABLE_TYPE,CMISS_FIELD_DELU5DELN_VARIABLE_TYPE,CMISS_FIELD_DELU5DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U5DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U6_VARIABLE_TYPE,CMISS_FIELD_DELU6DELN_VARIABLE_TYPE,CMISS_FIELD_DELU6DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U6DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U7_VARIABLE_TYPE,CMISS_FIELD_DELU7DELN_VARIABLE_TYPE,CMISS_FIELD_DELU7DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U7DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U8_VARIABLE_TYPE,CMISS_FIELD_DELU8DELN_VARIABLE_TYPE,CMISS_FIELD_DELU8DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U8DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U9_VARIABLE_TYPE,CMISS_FIELD_DELU9DELN_VARIABLE_TYPE,CMISS_FIELD_DELU9DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U9DELT2_VARIABLE_TYPE, &
    & CMISS_FIELD_U10_VARIABLE_TYPE,CMISS_FIELD_DELU10DELN_VARIABLE_TYPE,CMISS_FIELD_DELU10DELT_VARIABLE_TYPE, &
    & CMISS_FIELD_DEL2U10DELT2_VARIABLE_TYPE

  PUBLIC CMISS_FIELD_INTG_TYPE,CMISS_FIELD_SP_TYPE,CMISS_FIELD_DP_TYPE,CMISS_FIELD_L_TYPE

  PUBLIC CMISS_FIELD_SEPARATED_COMPONENT_DOF_ORDER,CMISS_FIELD_CONTIGUOUS_COMPONENT_DOF_ORDER

  PUBLIC CMISS_FIELD_VALUES_SET_TYPE,CMISS_FIELD_INITIAL_VALUES_SET_TYPE,CMISS_FIELD_INCREMENTAL_VALUES_SET_TYPE, &
    & CMISS_FIELD_BOUNDARY_CONDITIONS_SET_TYPE, &
    & CMISS_FIELD_ANALYTIC_VALUES_SET_TYPE, &
    & CMISS_FIELD_PREVIOUS_VALUES_SET_TYPE,CMISS_FIELD_MEAN_PREDICTED_DISPLACEMENT_SET_TYPE,CMISS_FIELD_VELOCITY_VALUES_SET_TYPE, &
    & CMISS_FIELD_INITIAL_VELOCITY_SET_TYPE,CMISS_FIELD_PREVIOUS_VELOCITY_SET_TYPE,CMISS_FIELD_MEAN_PREDICTED_VELOCITY_SET_TYPE, &
    & CMISS_FIELD_ACCELERATION_VALUES_SET_TYPE,CMISS_FIELD_INITIAL_ACCELERATION_SET_TYPE, &
    & CMISS_FIELD_PREVIOUS_ACCELERATION_SET_TYPE, &
    & CMISS_FIELD_MEAN_PREDICTED_ACCELERATION_SET_TYPE, CMISS_FIELD_PRESSURE_VALUES_SET_TYPE, &
    & CMISS_FIELD_PREVIOUS_PRESSURE_SET_TYPE, &
    & CMISS_FIELD_IMPERMEABLE_FLAG_VALUES_SET_TYPE,CMISS_FIELD_INTEGRATED_NEUMANN_SET_TYPE

  PUBLIC CMISS_FIELD_NO_SCALING,CMISS_FIELD_UNIT_SCALING,CMISS_FIELD_ARC_LENGTH_SCALING,CMISS_FIELD_ARITHMETIC_MEAN_SCALING, &
    & CMISS_FIELD_GEOMETRIC_MEAN_SCALING,CMISS_FIELD_HARMONIC_MEAN_SCALING

  PUBLIC CMISSField_ComponentInterpolationGet,CMISSField_ComponentInterpolationSet

  PUBLIC CMISSField_ComponentLabelGet,CMISSField_ComponentLabelSet

  PUBLIC CMISSField_ComponentMeshComponentGet,CMISSField_ComponentMeshComponentSet

  PUBLIC CMISSField_ComponentValuesInitialise

  PUBLIC CMISSField_DataTypeGet,CMISSField_DataTypeSet

  PUBLIC CMISSField_DOFOrderTypeGet,CMISSField_DOFOrderTypeSet

  PUBLIC CMISSField_CreateFinish,CMISSField_CreateStart

  PUBLIC CMISSField_DependentTypeGet,CMISSField_DependentTypeSet

  PUBLIC CMISSField_Destroy

  PUBLIC CMISSField_DimensionGet,CMISSField_DimensionSet

  PUBLIC CMISSField_GeometricFieldGet,CMISSField_GeometricFieldSet

  PUBLIC CMISSField_GeometricParametersElementLineLengthGet

  PUBLIC CMISSField_LabelGet,CMISSField_LabelSet

  PUBLIC CMISSField_MeshDecompositionGet,CMISSField_MeshDecompositionSet

  PUBLIC CMISSField_DataProjectionSet

  PUBLIC CMISSField_PositionNormalTangentCalculateNode

  PUBLIC CMISSField_NumberOfComponentsGet,CMISSField_NumberOfComponentsSet

  PUBLIC CMISSField_NumberOfVariablesGet,CMISSField_NumberOfVariablesSet

  PUBLIC CMISSField_ParameterSetAddConstant,CMISSField_ParameterSetAddElement,CMISSField_ParameterSetAddNode

  PUBLIC CMISSField_ParameterSetCreate

  PUBLIC CMISSField_ParameterSetDestroy

  PUBLIC CMISSField_ParameterSetDataGet,CMISSField_ParameterSetDataRestore

  PUBLIC CMISSField_ParameterSetGetConstant,CMISSField_ParameterSetGetElement,CMISSField_ParameterSetGetNode
  
  PUBLIC CMISSField_ParameterSetGetDataPoint,CMISSField_ParameterSetUpdateDataPoint

  PUBLIC CMISSField_ParameterSetUpdateConstant,CMISSField_ParameterSetUpdateElement,CMISSField_ParameterSetUpdateNode

  PUBLIC CMISSField_ParameterSetNodeScaleFactorGet,CMISSField_ParameterSetNodeScaleFactorSet

  PUBLIC CMISSField_ParameterSetNodeScaleFactorsGet,CMISSField_ParameterSetNodeScaleFactorsSet

  PUBLIC CMISSField_ParameterSetNodeNumberOfScaleFactorDofsGet

  PUBLIC CMISSField_ParameterSetUpdateLocalDofs

  PUBLIC CMISSField_ParameterSetUpdateGaussPoint, CMISSField_ParameterSetGetGaussPoint

  PUBLIC CMISSField_ParameterSetInterpolateXi

  PUBLIC CMISSField_ParameterSetInterpolateGauss

  PUBLIC CMISSField_ParameterSetUpdateElementDataPoint

  PUBLIC CMISSField_ParameterSetUpdateFinish,CMISSField_ParameterSetUpdateStart

  PUBLIC CMISSField_ParametersToFieldParametersComponentCopy

  PUBLIC CMISSField_ScalingTypeGet,CMISSField_ScalingTypeSet

  PUBLIC CMISSField_TypeGet,CMISSField_TypeSet

  PUBLIC CMISSField_VariableLabelGet,CMISSField_VariableLabelSet

  PUBLIC CMISSField_VariableTypesGet,CMISSField_VariableTypesSet

!!==================================================================================================================================
!!
!! FIELD_IO_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  INTERFACE CMISSFields_ElementsExport
    MODULE PROCEDURE CMISSFields_ElementsExportCCObj
    MODULE PROCEDURE CMISSFields_ElementsExportVSCObj
    MODULE PROCEDURE CMISSFields_ElementsExportCVSObj
    MODULE PROCEDURE CMISSFields_ElementsExportVSVSObj
  END INTERFACE !CMISSFields_ElementsExport

  INTERFACE CMISSFields_NodesExport
    MODULE PROCEDURE CMISSFields_NodesExportCCObj
    MODULE PROCEDURE CMISSFields_NodesExportVSCObj
    MODULE PROCEDURE CMISSFields_NodesExportCVSObj
    MODULE PROCEDURE CMISSFields_NodesExportVSVSObj
  END INTERFACE !CMISSFields_NodesExport

  PUBLIC CMISSFields_ElementsExport,CMISSFields_NodesExport

!!==================================================================================================================================
!!
!! GENERATED_MESH_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_GeneratedMeshConstants OPENCMISS::GeneratedMesh::Constants
  !> \brief Generated mesh constants.
  !>@{
  !> \addtogroup OPENCMISS_GeneratedMeshTypes OPENCMISS::GeneratedMesh::Types
  !> \brief Generated mesh types.
  !> \see OPENCMISS::GeneratedMesh,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_REGULAR_MESH_TYPE = GENERATED_MESH_REGULAR_MESH_TYPE !<A regular generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_POLAR_MESH_TYPE = GENERATED_MESH_POLAR_MESH_TYPE !<A polar generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_FRACTAL_TREE_MESH_TYPE = GENERATED_MESH_FRACTAL_TREE_MESH_TYPE !<A fractal tree generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_CYLINDER_MESH_TYPE = GENERATED_MESH_CYLINDER_MESH_TYPE !<A cylinder generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_ELLIPSOID_MESH_TYPE = GENERATED_MESH_ELLIPSOID_MESH_TYPE !<An ellipsoid generated mesh. \see OPENCMISS_GeneratedMeshTypes,OPENCMISS
  !>@}
  !>@}

  !> \addtogroup OPENCMISS_GeneratedMeshConstants OPENCMISS::GeneratedMesh::Constants
  !> \brief Generated mesh constants.
  !>@{
  !> \addtogroup OPENCMISS_GeneratedMeshSurfaceTypes OPENCMISS::GeneratedMesh::SurfaceTypes
  !> \brief Generated mesh surface types.
  !> \see OPENCMISS::GeneratedMesh,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_CYLINDER_INNER_SURFACE = GENERATED_MESH_CYLINDER_INNER_SURFACE !<Cylinder inner surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_CYLINDER_OUTER_SURFACE = GENERATED_MESH_CYLINDER_OUTER_SURFACE !<Cylinder outer surface. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_CYLINDER_TOP_SURFACE = GENERATED_MESH_CYLINDER_TOP_SURFACE !<Cylinder top surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_CYLINDER_BOTTOM_SURFACE = GENERATED_MESH_CYLINDER_BOTTOM_SURFACE !<Cylinder bottom surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_ELLIPSOID_INNER_SURFACE = GENERATED_MESH_ELLIPSOID_INNER_SURFACE !<Ellipsoid inner surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_ELLIPSOID_OUTER_SURFACE = GENERATED_MESH_ELLIPSOID_OUTER_SURFACE !<Ellipsoid outer surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_ELLIPSOID_TOP_SURFACE = GENERATED_MESH_ELLIPSOID_TOP_SURFACE !<Ellipsoid top surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_REGULAR_LEFT_SURFACE = GENERATED_MESH_REGULAR_LEFT_SURFACE !<Regular left surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_REGULAR_RIGHT_SURFACE = GENERATED_MESH_REGULAR_RIGHT_SURFACE !<Regular right surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_REGULAR_TOP_SURFACE = GENERATED_MESH_REGULAR_TOP_SURFACE !<Regular top surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_REGULAR_BOTTOM_SURFACE = GENERATED_MESH_REGULAR_BOTTOM_SURFACE !<Regular bottom surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_REGULAR_FRONT_SURFACE = GENERATED_MESH_REGULAR_FRONT_SURFACE !<Regular front surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_GENERATED_MESH_REGULAR_BACK_SURFACE = GENERATED_MESH_REGULAR_BACK_SURFACE !<Regular back surface constant. \see OPENCMISS_GeneratedMeshSurfaceTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the basis for a generated mesh.
  INTERFACE CMISSGeneratedMesh_BasisGet
    MODULE PROCEDURE CMISSGeneratedMesh_BasisGetNumber
    MODULE PROCEDURE CMISSGeneratedMesh_BasisGetObj
  END INTERFACE !CMISSGeneratedMesh_BasisGet

  !>Sets/changes the basis for a generated mesh.
  INTERFACE CMISSGeneratedMesh_BasisSet
    MODULE PROCEDURE CMISSGeneratedMesh_BasisSetNumber0
    MODULE PROCEDURE CMISSGeneratedMesh_BasisSetNumber1
    MODULE PROCEDURE CMISSGeneratedMesh_BasisSetObj0
    MODULE PROCEDURE CMISSGeneratedMesh_BasisSetObj1
  END INTERFACE !CMISSGeneratedMesh_BasisSet

  !>Sets/changes the base vectors for a generated mesh.
  INTERFACE CMISSGeneratedMesh_BaseVectorsSet
    MODULE PROCEDURE CMISSGeneratedMesh_BaseVectorsSetNumber
    MODULE PROCEDURE CMISSGeneratedMesh_BaseVectorsSetObj
  END INTERFACE !CMISSGeneratedMesh_BaseVectorsSet

  !>Finishes the creation of a generated mesh. \see OPENCMISS::CMISSGeneratedMesh_CreateStart
  INTERFACE CMISSGeneratedMesh_CreateFinish
    MODULE PROCEDURE CMISSGeneratedMesh_CreateFinishNumber
    MODULE PROCEDURE CMISSGeneratedMesh_CreateFinishObj
  END INTERFACE !CMISSGeneratedMesh_CreateFinish

  !>Starts the creation of a generated mesh. \see OPENCMISS::CMISSGeneratedMesh_CreateFinish
  INTERFACE CMISSGeneratedMesh_CreateStart
    MODULE PROCEDURE CMISSGeneratedMesh_CreateStartNumber
    MODULE PROCEDURE CMISSGeneratedMesh_CreateStartInterfaceObj
    MODULE PROCEDURE CMISSGeneratedMesh_CreateStartRegionObj
  END INTERFACE !CMISSGeneratedMesh_CreateStart

  !>Destroys a generated mesh.
  INTERFACE CMISSGeneratedMesh_Destroy
    MODULE PROCEDURE CMISSGeneratedMesh_DestroyNumber
    MODULE PROCEDURE CMISSGeneratedMesh_DestroyObj
  END INTERFACE !CMISSGeneratedMesh_Destroy

  !>Returns the extent of a generated mesh.
  INTERFACE CMISSGeneratedMesh_ExtentGet
    MODULE PROCEDURE CMISSGeneratedMesh_ExtentGetNumber
    MODULE PROCEDURE CMISSGeneratedMesh_ExtentGetObj
  END INTERFACE !CMISSGeneratedMesh_ExtentGet

  !>Sets/changes the extent of a generated mesh.
  INTERFACE CMISSGeneratedMesh_ExtentSet
    MODULE PROCEDURE CMISSGeneratedMesh_ExtentSetNumber
    MODULE PROCEDURE CMISSGeneratedMesh_ExtentSetObj
  END INTERFACE !CMISSGeneratedMesh_ExtentSet

  !>Returns the number of elements in a generated mesh.
  INTERFACE CMISSGeneratedMesh_NumberOfElementsGet
    MODULE PROCEDURE CMISSGeneratedMesh_NumberOfElementsGetNumber
    MODULE PROCEDURE CMISSGeneratedMesh_NumberOfElementsGetObj
  END INTERFACE !CMISSGeneratedMesh_NumberOfElementsGet

  !>Sets/changes the number of elements in a generated mesh.
  INTERFACE CMISSGeneratedMesh_NumberOfElementsSet
    MODULE PROCEDURE CMISSGeneratedMesh_NumberOfElementsSetNumber
    MODULE PROCEDURE CMISSGeneratedMesh_NumberOfElementsSetObj
  END INTERFACE !CMISSGeneratedMesh_NumberOfElementsSet

  !>Returns the origin of a generated mesh.
  INTERFACE CMISSGeneratedMesh_OriginGet
    MODULE PROCEDURE CMISSGeneratedMesh_OriginGetNumber
    MODULE PROCEDURE CMISSGeneratedMesh_OriginGetObj
  END INTERFACE !CMISSGeneratedMesh_OriginGet

  !>Sets/changes the origin of a generated mesh.
  INTERFACE CMISSGeneratedMesh_OriginSet
    MODULE PROCEDURE CMISSGeneratedMesh_OriginSetNumber
    MODULE PROCEDURE CMISSGeneratedMesh_OriginSetObj
  END INTERFACE !CMISSGeneratedMesh_OriginSet

  !>Returns the type of a generated mesh.
  INTERFACE CMISSGeneratedMesh_TypeGet
    MODULE PROCEDURE CMISSGeneratedMesh_TypeGetNumber
    MODULE PROCEDURE CMISSGeneratedMesh_TypeGetObj
  END INTERFACE !CMISSGeneratedMesh_TypeGet

  !>Sets/changes the type of a generated mesh.
  INTERFACE CMISSGeneratedMesh_TypeSet
    MODULE PROCEDURE CMISSGeneratedMesh_TypeSetNumber
    MODULE PROCEDURE CMISSGeneratedMesh_TypeSetObj
  END INTERFACE !CMISSGeneratedMesh_TypeSet

  !>Calculates and sets the geometric field parameters for a generated mesh
  INTERFACE CMISSGeneratedMesh_GeometricParametersCalculate
    MODULE PROCEDURE CMISSGeneratedMesh_GeometricParametersCalculateNumber
    MODULE PROCEDURE CMISSGeneratedMesh_GeometricParametersCalculateObj
  END INTERFACE !CMISSGeneratedMesh_GeometricParametersCalculate

  !>Returns a list of nodes belonging to a surface of given type
  INTERFACE CMISSGeneratedMesh_SurfaceGet
    MODULE PROCEDURE CMISSGeneratedMesh_SurfaceGetNumber0
    MODULE PROCEDURE CMISSGeneratedMesh_SurfaceGetNumber1
    MODULE PROCEDURE CMISSGeneratedMesh_SurfaceGetObj0
    MODULE PROCEDURE CMISSGeneratedMesh_SurfaceGetObj1
  END INTERFACE


  !>Creates an embedding of one mesh in another
  INTERFACE CMISSMeshEmbedding_Create
    MODULE PROCEDURE CMISSMeshEmbedding_CreateNumber
    MODULE PROCEDURE CMISSMeshEmbedding_CreateObj
  END INTERFACE

  !>Sets the embedded nodes for one parent element
  INTERFACE CMISSMeshEmbedding_SetChildNodePosition
    MODULE PROCEDURE CMISSMeshEmbedding_SetChildNodePositionObj
  END INTERFACE


  !>Pushes data from the parent field to the child field
  INTERFACE CMISSMeshEmbedding_PushData
    MODULE PROCEDURE CMISSMeshEmbedding_PushDataObj
  END INTERFACE

  INTERFACE CMISSMeshEmbedding_SetGaussPointData
   MODULE PROCEDURE CMISSMeshEmbedding_SetGaussPointDataObj
  END INTERFACE

  INTERFACE CMISSMeshEmbedding_PullGaussPointData
   MODULE PROCEDURE CMISSMeshEmbedding_PullGaussPointDataObj
  END INTERFACE

   INTERFACE CMISSMeshEmbedding_GetGaussPointCoord
    MODULE PROCEDURE CMISSField_ParameterSetGetGaussPointCoordObj
   END INTERFACE

  PUBLIC CMISSMeshEmbedding_Create, CMISSMeshEmbedding_SetChildNodePosition, CMISSMeshEmbeddingType

  PUBLIC CMISSMeshEmbedding_Initialise, CMISSMeshEmbedding_SetGaussPointData

  PUBLIC CMISSMeshEmbedding_PushData, CMISSMeshEmbedding_PullGaussPointData

  PUBLIC CMISSMeshEmbedding_GetGaussPointCoord

  PUBLIC CMISS_GENERATED_MESH_REGULAR_MESH_TYPE,CMISS_GENERATED_MESH_POLAR_MESH_TYPE,CMISS_GENERATED_MESH_FRACTAL_TREE_MESH_TYPE

  PUBLIC CMISS_GENERATED_MESH_CYLINDER_MESH_TYPE, CMISS_GENERATED_MESH_ELLIPSOID_MESH_TYPE

  PUBLIC CMISS_GENERATED_MESH_CYLINDER_INNER_SURFACE,CMISS_GENERATED_MESH_CYLINDER_OUTER_SURFACE

  PUBLIC CMISS_GENERATED_MESH_CYLINDER_TOP_SURFACE, CMISS_GENERATED_MESH_CYLINDER_BOTTOM_SURFACE

  PUBLIC CMISS_GENERATED_MESH_ELLIPSOID_INNER_SURFACE, CMISS_GENERATED_MESH_ELLIPSOID_OUTER_SURFACE

  PUBLIC CMISS_GENERATED_MESH_ELLIPSOID_TOP_SURFACE

  PUBLIC CMISS_GENERATED_MESH_REGULAR_LEFT_SURFACE, CMISS_GENERATED_MESH_REGULAR_RIGHT_SURFACE, &
    & CMISS_GENERATED_MESH_REGULAR_TOP_SURFACE

  PUBLIC CMISS_GENERATED_MESH_REGULAR_BOTTOM_SURFACE, CMISS_GENERATED_MESH_REGULAR_FRONT_SURFACE, &
    & CMISS_GENERATED_MESH_REGULAR_BACK_SURFACE

  PUBLIC CMISSGeneratedMesh_BasisGet,CMISSGeneratedMesh_BasisSet

  PUBLIC CMISSGeneratedMesh_BaseVectorsSet

  PUBLIC CMISSGeneratedMesh_CreateFinish,CMISSGeneratedMesh_CreateStart

  PUBLIC CMISSGeneratedMesh_Destroy

  PUBLIC CMISSGeneratedMesh_ExtentGet,CMISSGeneratedMesh_ExtentSet

  PUBLIC CMISSGeneratedMesh_NumberOfElementsGet,CMISSGeneratedMesh_NumberOfElementsSet

  PUBLIC CMISSGeneratedMesh_OriginGet,CMISSGeneratedMesh_OriginSet

  PUBLIC CMISSGeneratedMesh_TypeGet,CMISSGeneratedMesh_TypeSet

  PUBLIC CMISSGeneratedMesh_GeometricParametersCalculate

  PUBLIC CMISSGeneratedMesh_SurfaceGet


!!==================================================================================================================================
!!
!! INTERFACE_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Adds a mesh to an interface.
  INTERFACE CMISSInterface_MeshAdd
    MODULE PROCEDURE CMISSInterface_MeshAddNumber
    MODULE PROCEDURE CMISSInterface_MeshAddObj
  END INTERFACE !CMISSInterface_MeshAdd

  !>Finishes the creation of an interface. \see OPENCMISS::CMISSInterface_CreateStart
  INTERFACE CMISSInterface_CreateFinish
    MODULE PROCEDURE CMISSInterface_CreateFinishNumber
    MODULE PROCEDURE CMISSInterface_CreateFinishObj
  END INTERFACE !CMISSInterface_CreateStart

  !>Starts the creation of an interface. \see OPENCMISS::CMISSInterface_CreateFinish
  INTERFACE CMISSInterface_CreateStart
    MODULE PROCEDURE CMISSInterface_CreateStartNumber
    MODULE PROCEDURE CMISSInterface_CreateStartObj
  END INTERFACE !CMISSInterface_CreateStart
  
  !>Set the coordinate system of an inteface
  INTERFACE CMISSInterface_CoordinateSystemSet
    MODULE PROCEDURE CMISSInterface_CoordinateSystemSetNumber
    MODULE PROCEDURE CMISSInterface_CoordinateSystemSetObj
  END INTERFACE !CMISSInterfaceCoordinateSystemSet
  
  !>Get the coordinate system of an inteface
  INTERFACE CMISSInterface_CoordinateSystemGet
    MODULE PROCEDURE CMISSInterface_CoordinateSystemGetNumber
    MODULE PROCEDURE CMISSInterface_CoordinateSystemGetObj
  END INTERFACE !CMISSInterface_CoordinateSystemGet

  !>Destroys an interface.
  INTERFACE CMISSInterface_Destroy
    MODULE PROCEDURE CMISSInterface_DestroyNumber
    MODULE PROCEDURE CMISSInterface_DestroyObj
  END INTERFACE !CMISSInterface_Destroy

  !>Returns the label of an interface.
  INTERFACE CMISSInterface_LabelGet
    MODULE PROCEDURE CMISSInterface_LabelGetCNumber
    MODULE PROCEDURE CMISSInterface_LabelGetCObj
    MODULE PROCEDURE CMISSInterface_LabelGetVSNumber
    MODULE PROCEDURE CMISSInterface_LabelGetVSObj
  END INTERFACE !CMISSInterface_LabelGet

  !>Sets/changes the label of an interface.
  INTERFACE CMISSInterface_LabelSet
    MODULE PROCEDURE CMISSInterface_LabelSetCNumber
    MODULE PROCEDURE CMISSInterface_LabelSetCObj
    MODULE PROCEDURE CMISSInterface_LabelSetVSNumber
    MODULE PROCEDURE CMISSInterface_LabelSetVSObj
  END INTERFACE !CMISSInterface_LabelSet

  !>Returns the nodes for a interface.
  INTERFACE CMISSInterface_NodesGet
    MODULE PROCEDURE CMISSInterface_NodesGetObj
  END INTERFACE !CMISSInterface_NodesGet

  !>Finishes the creation of an interface meshes connectivity. \see OPENCMISS::CMISSInterfaceMeshConnectivity_CreateStart
  INTERFACE CMISSInterfaceMeshConnectivity_CreateFinish
    MODULE PROCEDURE CMISSInterfaceMeshConnectivity_CreateFinishNumber
    MODULE PROCEDURE CMISSInterfaceMeshConnectivity_CreateFinishObj
  END INTERFACE !CMISSInterfaceMeshConnectivity_CreateFinish

  !>Starts the creation of an interface meshes connectivity.
  INTERFACE CMISSInterfaceMeshConnectivity_CreateStart
    MODULE PROCEDURE CMISSInterfaceMeshConnectivity_CreateStartNumber
    MODULE PROCEDURE CMISSInterfaceMeshConnectivity_CreateStartObj
  END INTERFACE !CMISSInterfaceMeshConnectivity_CreateStart

  !>Sets the element xi values for the mesh connectivity between an element in the interface mesh and an element in a region mesh
  INTERFACE CMISSInterfaceMeshConnectivity_ElementXiSet
    MODULE PROCEDURE CMISSInterfaceMeshConnectivity_ElementXiSetNumber
    MODULE PROCEDURE CMISSInterfaceMeshConnectivity_ElementXiSetObj
  END INTERFACE !CMISSInterfaceMeshConnectivity_ElementXiSet

  !>Sets the number of elements coupled through a given interface mesh element
  INTERFACE CMISSInterfaceMeshConnectivity_ElementNumberSet
    MODULE PROCEDURE CMISSInterfaceMeshConnectivity_ElementNumberSetNumber
    MODULE PROCEDURE CMISSInterfaceMeshConnectivity_ElementNumberSetObj
  END INTERFACE !CMISSInterfaceMeshConnectivity_ElementNumberSet
  
  !>Sets the coupled node numbers
  INTERFACE CMISSInterfaceMeshConnectivity_NodeNumberSet
    MODULE PROCEDURE CMISSInterfaceMeshConnectivity_NodeNumberSetNumber
    MODULE PROCEDURE CMISSInterfaceMeshConnectivity_NodeNumberSetObj
  END INTERFACE

  !>Sets the number of elements coupled through a given interface mesh element
  INTERFACE CMISSInterfaceMeshConnectivity_BasisSet
    MODULE PROCEDURE CMISSInterfaceMeshConnectivity_BasisSetNumber
    MODULE PROCEDURE CMISSInterfaceMeshConnectivity_BasisSetObj
  END INTERFACE !CMISSInterfaceMeshConnectivity_BasisSet

  !>Destroys an interface meshes connectivity.
  INTERFACE CMISSInterfaceMeshConnectivity_Destroy
    MODULE PROCEDURE CMISSInterfaceMeshConnectivity_DestroyNumber
    MODULE PROCEDURE CMISSInterfaceMeshConnectivity_DestroyObj
  END INTERFACE !CMISSInterfaceMeshConnectivity_Destroy
  
  !>Finishes the creation of an interface points connectivity.
  INTERFACE CMISSInterfacePointsConnectivity_CreateFinish
    MODULE PROCEDURE CMISSInterfacePointsConnectivity_CreateFinishNumber
    MODULE PROCEDURE CMISSInterfacePointsConnectivity_CreateFinishObj
  END INTERFACE !CMISSInterfacePointsConnectivity_CreateFinish
  
  !>Starts the creation of an interface points connectivity.
  INTERFACE CMISSInterfacePointsConnectivity_CreateStart
    MODULE PROCEDURE CMISSInterfacePointsConnectivity_CreateStartNumber
    MODULE PROCEDURE CMISSInterfacePointsConnectivity_CreateStartObj
  END INTERFACE !CMISSInterfacePointsConnectivity_CreateStart
  
  !>Destroys an interface points connectivity.
  INTERFACE CMISSInterfacePointsConnectivity_Destroy
    MODULE PROCEDURE CMISSInterfacePointsConnectivity_DestroyNumber
    MODULE PROCEDURE CMISSInterfacePointsConnectivity_DestroyObj
  END INTERFACE !CMISSInterfacePointsConnectivity_Destroy
  
  !>Get the coupled mesh element number that defines points connectivity
  INTERFACE CMISSInterfacePointsConnectivity_ElementNumberGet
    MODULE PROCEDURE CMISSInterfacePointsConnectivity_ElementNumberGetNumber
    MODULE PROCEDURE CMISSInterfacePointsConnectivity_ElementNumberGetObj
  END INTERFACE !CMISSInterfacePointsConnectivity_ElementNumberGet
  
  !>Gets the element xi values for the points connectivity between a data point in the interface mesh and an element in a region mesh
  INTERFACE CMISSInterfacePointsConnectivity_PointXiGet
    MODULE PROCEDURE CMISSInterfacePointsConnectivity_PointXiGetNumber
    MODULE PROCEDURE CMISSInterfacePointsConnectivity_PointXiGetObj
  END INTERFACE !CMISSInterfacePointsConnectivity_PointXiGet
  
  !>Sets the coupled mesh element number that defines points connectivity
  INTERFACE CMISSInterfacePointsConnectivity_ElementNumberSet
    MODULE PROCEDURE CMISSInterfacePointsConnectivity_ElementNumberSetNumber
    MODULE PROCEDURE CMISSInterfacePointsConnectivity_ElementNumberSetObj
  END INTERFACE !CMISSInterfacePointsConnectivity_ElementNumberSet 
  
  !>Sets the element xi values for the points connectivity between a data point in the interface mesh and an element in a region mesh
  INTERFACE CMISSInterfacePointsConnectivity_PointXiSet
    MODULE PROCEDURE CMISSInterfacePointsConnectivity_PointXiSetNumber
    MODULE PROCEDURE CMISSInterfacePointsConnectivity_PointXiSetObj
  END INTERFACE !CMISSInterfacePointsConnectivity_PointXiSet 
  
  !>Update points connectivity information with projection results
  INTERFACE CMISSInterfacePointsConnectivity_UpdateFromProjection
    MODULE PROCEDURE CMISSInterfacePointsConnectivity_UpdateFromProjectionRNumber
    MODULE PROCEDURE CMISSInterfacePointsConnectivity_UpdateFromProjectionINumber
    MODULE PROCEDURE CMISSInterfacePointsConnectivity_UpdateFromProjectionObj
  END INTERFACE !CMISSInterfacePointsConnectivity_UpdateFromProjection

  PUBLIC CMISSInterface_MeshAdd

  PUBLIC CMISSInterface_CreateFinish,CMISSInterface_CreateStart
  
  PUBLIC CMISSInterface_CoordinateSystemSet,CMISSInterface_CoordinateSystemGet

  PUBLIC CMISSInterface_Destroy

  PUBLIC CMISSInterface_LabelGet,CMISSInterface_LabelSet

  PUBLIC CMISSInterface_NodesGet

  PUBLIC CMISSInterfaceMeshConnectivity_CreateFinish,CMISSInterfaceMeshConnectivity_CreateStart

  PUBLIC CMISSInterfaceMeshConnectivity_Destroy, CMISSInterfaceMeshConnectivity_BasisSet

  PUBLIC CMISSInterfaceMeshConnectivity_ElementNumberSet, CMISSInterfaceMeshConnectivity_ElementXiSet
  
  PUBLIC CMISSInterfaceMeshConnectivity_NodeNumberSet
  
  PUBLIC CMISSInterfacePointsConnectivity_CreateFinish,CMISSInterfacePointsConnectivity_CreateStart
  
  PUBLIC CMISSInterfacePointsConnectivity_Destroy
  
  PUBLIC CMISSInterfacePointsConnectivity_ElementNumberGet,CMISSInterfacePointsConnectivity_PointXiGet
  
  PUBLIC CMISSInterfacePointsConnectivity_ElementNumberSet,CMISSInterfacePointsConnectivity_PointXiSet
  
  PUBLIC CMISSInterfacePointsConnectivity_UpdateFromProjection

!!==================================================================================================================================
!!
!! INTERFACE_CONDITION_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_InterfaceConditionConstants OPENCMISS::InterfaceConditions::Constants
  !> \brief Interface conditions constants.
  !>@{
  !> \addtogroup OPENCMISS_InterfaceConditionMethods OPENCMISS::InterfaceConditions::Methods
  !> \brief Interface condition methods.
  !> \see OPENCMISS::InterfaceConditions,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD = &
    & INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD !<Lagrange multipliers interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD = INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD !<Augmented Lagrange multiplers interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_PENALTY_METHOD = INTERFACE_CONDITION_PENALTY_METHOD !<Penalty interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_POINT_TO_POINT_METHOD = INTERFACE_CONDITION_POINT_TO_POINT_METHOD !<Point to point interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_InterfaceConditionOperators OPENCMISS::InterfaceConditions::Operators
  !> \brief Interface condition operator types.
  !> \see OPENCMISS::InterfaceConditions,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR = &
    & INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR !<Continuous field operator, i.e., lambda.(u1_gauss-u2_gauss). \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR = &
    & INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR !<Continuous field normal operator, i.e., lambda(u_1.n_1-u_2.n_2). \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_FLS_CONTACT_OPERATOR= &
    & INTERFACE_CONDITION_FLS_CONTACT_OPERATOR !<Frictionless contact operator, i.e., lambda.(x_1.n-x_2.n). \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_FLS_CONTACT_REPROJECT_OPERATOR= &
    & INTERFACE_CONDITION_FLS_CONTACT_REPROJECT_OPERATOR !<Frictionless contact operator, reproject at each newton iteration and has geometric linearisation terms i.e., lambda.(x_1.n-x_2.n). \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_SOLID_FLUID_OPERATOR = INTERFACE_CONDITION_SOLID_FLUID_OPERATOR !<Solid fluid operator, i.e., lambda.(v_f-du_s/dt). \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR = &
    & INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR !<Solid fluid normal operator, i.e., lambda(v_f.n_f-du_s/dt.n_s). \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_InterfaceConditionIntegrationTypes OPENCMISS::InterfaceConditions::IntegrationTypes
  !> \brief Interface condition integration types.
  !> \see OPENCMISS::InterfaceConditions,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_GAUSS_INTEGRATION=INTERFACE_CONDITION_GAUSS_INTEGRATION !<Gauss points integration type, i.e. Loop over element Gauss points and sum up their contribution. \see OPENCMISS_InterfaceConditionIntegrationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_INTERFACE_CONDITION_DATA_POINTS_INTEGRATION=INTERFACE_CONDITION_DATA_POINTS_INTEGRATION !< Data points integration type i.e. Loop over data points and  sum up their contribution. \see OPENCMISS_InterfaceConditionIntegrationTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the creation of an interface condition. \see OPENCMISS::CMISSInterfaceCondition_CreateStart
  INTERFACE CMISSInterfaceCondition_CreateFinish
    MODULE PROCEDURE CMISSInterfaceCondition_CreateFinishNumber
    MODULE PROCEDURE CMISSInterfaceCondition_CreateFinishObj
  END INTERFACE !CMISSInterfaceCondition_CreateFinish

  !>Starts the creation of an interface condition. \see OPENCMISS::CMISSInterfaceCondition_CreateFinish
  INTERFACE CMISSInterfaceCondition_CreateStart
    MODULE PROCEDURE CMISSInterfaceCondition_CreateStartNumber
    MODULE PROCEDURE CMISSInterfaceCondition_CreateStartObj
  END INTERFACE !CMISSInterfaceCondition_CreateStart

  !>Adds in a dependent variable to an interface condition.
  INTERFACE CMISSInterfaceCondition_DependentVariableAdd
    MODULE PROCEDURE CMISSInterfaceCondition_DependentVariableAddNumber
    MODULE PROCEDURE CMISSInterfaceCondition_DependentVariableAddObj
  END INTERFACE !CMISSInterfaceCondition_DependentVariableAdd

  !>Destroys an interface condition.
  INTERFACE CMISSInterfaceCondition_Destroy
    MODULE PROCEDURE CMISSInterfaceCondition_DestroyNumber
    MODULE PROCEDURE CMISSInterfaceCondition_DestroyObj
  END INTERFACE !CMISSInterfaceCondition_Destroy

  !>Finishes the creation of equations for an interface condition. \see OPENCMISS::CMISSInterfaceCondition_EquationsCreateStart
  INTERFACE CMISSInterfaceCondition_EquationsCreateFinish
    MODULE PROCEDURE CMISSInterfaceCondition_EquationsCreateFinishNumber
    MODULE PROCEDURE CMISSInterfaceCondition_EquationsCreateFinishObj
  END INTERFACE !CMISSInterfaceCondition_EquationsCreateStart

  !>Starts the creation of equations for an interface condition. \see OPENCMISS::CMISSInterfaceCondition_EquationsCreateFinish
  INTERFACE CMISSInterfaceCondition_EquationsCreateStart
    MODULE PROCEDURE CMISSInterfaceCondition_EquationsCreateStartNumber
    MODULE PROCEDURE CMISSInterfaceCondition_EquationsCreateStartObj
  END INTERFACE !CMISSInterfaceCondition_EquationsCreateStart

  !>Destroys the interface equations for an interface condition.
  INTERFACE CMISSInterfaceCondition_EquationsDestroy
    MODULE PROCEDURE CMISSInterfaceCondition_EquationsDestroyNumber
    MODULE PROCEDURE CMISSInterfaceCondition_EquationsDestroyObj
  END INTERFACE !CMISSInterfaceCondition_EquationsDestroy
  
  !>Returns the integration type for an interface condition.
  INTERFACE CMISSInterfaceCondition_IntegrationTypeGet
    MODULE PROCEDURE CMISSInterfaceCondition_IntegrationTypeGetNumber
    MODULE PROCEDURE CMISSInterfaceCondition_IntegrationTypeGetObj
  END INTERFACE !CMISSInterfaceCondition_IntegrationTypeGet
  
  !>Sets/changes the integration type for an interface condition.
  INTERFACE CMISSInterfaceCondition_IntegrationTypeSet
    MODULE PROCEDURE CMISSInterfaceCondition_IntegrationTypeSetNumber
    MODULE PROCEDURE CMISSInterfaceCondition_IntegrationTypeSetObj
  END INTERFACE !CMISSInterfaceCondition_IntegrationTypeSet

  !>Finishes the creation of a Lagrange multipliers field for an interface condition. \see OPENCMISS::CMISSInterfaceCondition_LagrangeFieldCreateStart
  INTERFACE CMISSInterfaceCondition_LagrangeFieldCreateFinish
    MODULE PROCEDURE CMISSInterfaceCondition_LagrangeFieldCreateFinishNumber
    MODULE PROCEDURE CMISSInterfaceCondition_LagrangeFieldCreateFinishObj
  END INTERFACE !CMISSInterfaceCondition_LagrangeFieldCreateFinish

  !>Starts the creation of a Lagrange multipliers field for an interface condition. \see OPENCMISS::CMISSInterfaceCondition_LagrangeFieldCreateFinish
  INTERFACE CMISSInterfaceCondition_LagrangeFieldCreateStart
    MODULE PROCEDURE CMISSInterfaceCondition_LagrangeFieldCreateStartNumber
    MODULE PROCEDURE CMISSInterfaceCondition_LagrangeFieldCreateStartObj
  END INTERFACE !CMISSInterfaceCondition_LagrangeFieldCreateStart

  !>Finishes the creation of a Penalty field for an interface condition. \see OPENCMISS::CMISSInterfaceCondition_PenaltyFieldCreateStart
  INTERFACE CMISSInterfaceCondition_PenaltyFieldCreateFinish
    MODULE PROCEDURE CMISSInterfaceCondition_PenaltyFieldCreateFinishNumber
    MODULE PROCEDURE CMISSInterfaceCondition_PenaltyFieldCreateFinishObj
  END INTERFACE !CMISSInterfaceCondition_PenaltyFieldCreateFinish

  !>Starts the creation of a Penalty field for an interface condition. \see OPENCMISS::CMISSInterfaceCondition_PenaltyFieldCreateFinish
  INTERFACE CMISSInterfaceCondition_PenaltyFieldCreateStart
    MODULE PROCEDURE CMISSInterfaceCondition_PenaltyFieldCreateStartNumber
    MODULE PROCEDURE CMISSInterfaceCondition_PenaltyFieldCreateStartObj
  END INTERFACE !CMISSInterfaceCondition_PenaltyFieldCreateStart

  !>Returns the method for an interface condition.
  INTERFACE CMISSInterfaceCondition_MethodGet
    MODULE PROCEDURE CMISSInterfaceCondition_MethodGetNumber
    MODULE PROCEDURE CMISSInterfaceCondition_MethodGetObj
  END INTERFACE !CMISSInterfaceCondition_MethodGet

  !>Sets/changes the method for an interface condition.
  INTERFACE CMISSInterfaceCondition_MethodSet
    MODULE PROCEDURE CMISSInterfaceCondition_MethodSetNumber
    MODULE PROCEDURE CMISSInterfaceCondition_MethodSetObj
  END INTERFACE !CMISSInterfaceCondition_MethodSet

  !>Returns the operator for an interface condition.
  INTERFACE CMISSInterfaceCondition_OperatorGet
    MODULE PROCEDURE CMISSInterfaceCondition_OperatorGetNumber
    MODULE PROCEDURE CMISSInterfaceCondition_OperatorGetObj
  END INTERFACE !CMISSInterfaceCondition_OperatorGet

  !>Sets/changes the operator for an interface condition.
  INTERFACE CMISSInterfaceCondition_OperatorSet
    MODULE PROCEDURE CMISSInterfaceCondition_OperatorSetNumber
    MODULE PROCEDURE CMISSInterfaceCondition_OperatorSetObj
  END INTERFACE !CMISSInterfaceCondition_OperatorSet

  !>Returns the sparsity for interface equations.
  INTERFACE CMISSInterfaceEquations_SparsityGet
    MODULE PROCEDURE CMISSInterfaceEquations_SparsityGetNumber
    MODULE PROCEDURE CMISSInterfaceEquations_SparsityGetObj
  END INTERFACE !CMISSInterfaceEquations_SparsityGet

  !>Sets/changes the sparsity for interface equations.
  INTERFACE CMISSInterfaceEquations_SparsitySet
    MODULE PROCEDURE CMISSInterfaceEquations_SparsitySetNumber
    MODULE PROCEDURE CMISSInterfaceEquations_SparsitySetObj
  END INTERFACE !CMISSInterfaceEquations_SparsitySet

  !>Returns the output type for interface equations.
  INTERFACE CMISSInterfaceEquations_OutputTypeGet
    MODULE PROCEDURE CMISSInterfaceEquations_OutputTypeGetNumber
    MODULE PROCEDURE CMISSInterfaceEquations_OutputTypeGetObj
  END INTERFACE !CMISSInterfaceEquations_OutputTypeGet

  !>Sets/changes the output type for interface equations.
  INTERFACE CMISSInterfaceEquations_OutputTypeSet
    MODULE PROCEDURE CMISSInterfaceEquations_OutputTypeSetNumber
    MODULE PROCEDURE CMISSInterfaceEquations_OutputTypeSetObj
  END INTERFACE !CMISSInterfaceEquations_OutputTypeSet

  PUBLIC CMISS_INTERFACE_CONDITION_LAGRANGE_MULTIPLIERS_METHOD,CMISS_INTERFACE_CONDITION_AUGMENTED_LAGRANGE_METHOD, &
    & CMISS_INTERFACE_CONDITION_PENALTY_METHOD,CMISS_INTERFACE_CONDITION_POINT_TO_POINT_METHOD

  PUBLIC CMISS_INTERFACE_CONDITION_FIELD_CONTINUITY_OPERATOR,CMISS_INTERFACE_CONDITION_FIELD_NORMAL_CONTINUITY_OPERATOR, &
    & CMISS_INTERFACE_CONDITION_FLS_CONTACT_OPERATOR,CMISS_INTERFACE_CONDITION_FLS_CONTACT_REPROJECT_OPERATOR, &
    & CMISS_INTERFACE_CONDITION_SOLID_FLUID_OPERATOR,CMISS_INTERFACE_CONDITION_SOLID_FLUID_NORMAL_OPERATOR
    
  PUBLIC CMISS_INTERFACE_CONDITION_GAUSS_INTEGRATION,CMISS_INTERFACE_CONDITION_DATA_POINTS_INTEGRATION

  PUBLIC CMISSInterfaceCondition_CreateFinish,CMISSInterfaceCondition_CreateStart

  PUBLIC CMISSInterfaceCondition_DependentVariableAdd

  PUBLIC CMISSInterfaceCondition_Destroy

  PUBLIC CMISSInterfaceCondition_EquationsCreateFinish,CMISSInterfaceCondition_EquationsCreateStart

  PUBLIC CMISSInterfaceCondition_EquationsDestroy
  
  PUBLIC CMISSInterfaceCondition_IntegrationTypeGet,CMISSInterfaceCondition_IntegrationTypeSet

  PUBLIC CMISSInterfaceCondition_LagrangeFieldCreateFinish,CMISSInterfaceCondition_LagrangeFieldCreateStart

  PUBLIC CMISSInterfaceCondition_PenaltyFieldCreateFinish,CMISSInterfaceCondition_PenaltyFieldCreateStart

  PUBLIC CMISSInterfaceCondition_MethodGet,CMISSInterfaceCondition_MethodSet

  PUBLIC CMISSInterfaceCondition_OperatorGet,CMISSInterfaceCondition_OperatorSet

  PUBLIC CMISSInterfaceEquations_SparsityGet,CMISSInterfaceEquations_SparsitySet

  PUBLIC CMISSInterfaceEquations_OutputTypeGet,CMISSInterfaceEquations_OutputTypeSet
  
!!==================================================================================================================================
!!
!! INTERFACE MATRICES ROUTINES
!!
!!==================================================================================================================================
  
  !Module parameters

  !> \addtogroup INTERFACE_MATRICES_ROUTINES_InterfaceMatricesTimeDependenceTypes INTERFACE_MATRICES_ROUTINES::InterfaceMatricesTimeDependenceTypes
  !> \brief Interface matrices time dependency types
  !> \see INTERFACE_MATRICES_ROUTINES
  !>@{
  INTEGER, PARAMETER :: CMISS_NUMBER_OF_INTERFACE_MATRIX_TYPES=NUMBER_OF_INTERFACE_MATRIX_TYPES
  INTEGER, PARAMETER :: CMISS_INTERFACE_MATRIX_STATIC=INTERFACE_MATRIX_STATIC !<Interface matrix is of static type \see INTERFACE_MATRICES_ROUTINES_InterfaceMatricesTimeDependenceTypes,INTERFACE_MATRICES_ROUTINES
  INTEGER, PARAMETER :: CMISS_INTERFACE_MATRIX_QUASI_STATIC=INTERFACE_MATRIX_QUASI_STATIC !<Interface matrix is of quasi-static type \see INTERFACE_MATRICES_ROUTINES_InterfaceMatricesTimeDependenceTypes,INTERFACE_MATRICES_ROUTINES
  INTEGER, PARAMETER :: CMISS_INTERFACE_MATRIX_FIRST_ORDER_DYNAMIC=INTERFACE_MATRIX_FIRST_ORDER_DYNAMIC !<Interface matrix is of first order dynamic type \see INTERFACE_MATRICES_ROUTINES_InterfaceMatricesTimeDependenceTypes,INTERFACE_MATRICES_ROUTINES
  INTEGER, PARAMETER :: CMISS_INTERFACE_MATRIX_SECOND_ORDER_DYNAMIC=INTERFACE_MATRIX_SECOND_ORDER_DYNAMIC !<Interface matrix is of second order dynamic type \see INTERFACE_MATRICES_ROUTINES_InterfaceMatricesTimeDependenceTypes,INTERFACE_MATRICES_ROUTINES
  !>@}

  !Module types

  !Module variables

  !Interfaces
  PUBLIC CMISS_NUMBER_OF_INTERFACE_MATRIX_TYPES,CMISS_INTERFACE_MATRIX_STATIC,CMISS_INTERFACE_MATRIX_QUASI_STATIC, &
    & CMISS_INTERFACE_MATRIX_FIRST_ORDER_DYNAMIC,CMISS_INTERFACE_MATRIX_SECOND_ORDER_DYNAMIC
  
  PUBLIC CMISSInterfaceMatrices_TimeDependenceTypeSet,CMISSInterfaceMatrices_TimeDependenceTypeGet

!!==================================================================================================================================
!!
!! KINDS
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_KindConstants OPENCMISS::Kinds::Constants
  !> \brief Kind constants.
  !>@{
  !> \addtogroup OPENCMISS_IntegerKinds OPENCMISS::Kinds::Integers
  !> \brief Kind parameters for integer data types.
  !> \see OPENCMISS::Kinds,OPENCMISS
  !>@{
  INTEGER, PARAMETER :: CMISSIntg = INTG !<Standard integer kind. \see OPENCMISS_IntegerKinds,OPENCMISS
  INTEGER, PARAMETER :: CMISSSIntg = SINTG !<Short integer kind. \see OPENCMISS_IntegerKinds,OPENCMISS
  INTEGER, PARAMETER :: CMISSLIntg = LINTG !<Long integer kind. \see OPENCMISS_IntegerKinds,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_RealKinds OPENCMISS::Kinds::Reals
  !> \brief Kind parameters for real data types.
  !> \see OPENCMISS::Kinds,OPENCMISS
  !>@{
  INTEGER, PARAMETER :: CMISSSP = SP !<Single precision real kind. \see OPENCMISS_RealKinds,OPENCMISS
  INTEGER, PARAMETER :: CMISSDP = DP !<Double precision real kind. \see OPENCMISS_RealKinds,OPENCMISS
  INTEGER, PARAMETER :: CMISSQP = QP !<Quadruple precision real kind. \see OPENCMISS_RealKinds,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_ComplexKinds OPENCMISS::Kinds::Complex
  !> \brief Kind parameters for complex data types
  !> \see OPENCMISS::Kinds,OPENCMISS
  !>@{
  INTEGER, PARAMETER :: CMISSSPC = SPC !<Single precision complex kind. \see OPENCMISS_ComplexKinds,OPENCMISS
  INTEGER, PARAMETER :: CMISSDPC = DPC !<Double precision complex kind. \see OPENCMISS_ComplexKinds,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISSIntg,CMISSSIntg,CMISSLIntg

  PUBLIC CMISSSP,CMISSDP,CMISSQP

  PUBLIC CMISSSPC,CMISSDPC

!!==================================================================================================================================
!!
!! MESH_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_MeshConstants OPENCMISS::Mesh::Constants
  !> \brief Mesh constants.
  !>@{
  !> \addtogroup OPENCMISS_DecompositionTypes OPENCMISS::Mesh::DecompositionTypes
  !> \brief The Decomposition types parameters
  !> \see OPENCMISS::Mesh,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_DECOMPOSITION_ALL_TYPE = DECOMPOSITION_ALL_TYPE !<The decomposition contains all elements. \see OPENCMISS_DecompositionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_DECOMPOSITION_CALCULATED_TYPE = DECOMPOSITION_CALCULATED_TYPE !<The element decomposition is calculated by graph partitioning. \see OPENCMISS_DecompositionTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_DECOMPOSITION_USER_DEFINED_TYPE = DECOMPOSITION_USER_DEFINED_TYPE !<The user will set the element decomposition. \see OPENCMISS_DecompositionTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the creation of a domain decomposition. \see OPENCMISS::CMISSDecomposition_CreateStart
  INTERFACE CMISSDecomposition_CreateFinish
    MODULE PROCEDURE CMISSDecomposition_CreateFinishNumber
    MODULE PROCEDURE CMISSDecomposition_CreateFinishObj
  END INTERFACE !CMISSDecomposition_CreateFinish

  !>Start the creation of a domain decomposition for a given mesh. \see OPENCMISS::CMISSDecomposition_CreateStart
  INTERFACE CMISSDecomposition_CreateStart
    MODULE PROCEDURE CMISSDecomposition_CreateStartNumber
    MODULE PROCEDURE CMISSDecomposition_CreateStartObj
  END INTERFACE !CMISSDecomposition_CreateStart

  !>Destroys a domain decomposition.
  INTERFACE CMISSDecomposition_Destroy
    MODULE PROCEDURE CMISSDecomposition_DestroyNumber
    MODULE PROCEDURE CMISSDecomposition_DestroyObj
  END INTERFACE !CMISSDecomposition_Destroy

  !>Calculates the element domains for the decomposition of a mesh.
  INTERFACE CMISSDecomposition_ElementDomainCalculate
    MODULE PROCEDURE CMISSDecomposition_ElementDomainCalculateNumber
    MODULE PROCEDURE CMISSDecomposition_ElementDomainCalculateObj
  END INTERFACE !CMISSDecomposition_ElementDomainCalculate

  !>Returns the domain for a given element in a decomposition of a mesh.
  INTERFACE CMISSDecomposition_ElementDomainGet
    MODULE PROCEDURE CMISSDecomposition_ElementDomainGetNumber
    MODULE PROCEDURE CMISSDecomposition_ElementDomainGetObj
  END INTERFACE !CMISSDecomposition_ElementDomainGet

  !>Sets/changes the domain for a given element in a decomposition of a mesh.
  INTERFACE CMISSDecomposition_ElementDomainSet
    MODULE PROCEDURE CMISSDecomposition_ElementDomainSetNumber
    MODULE PROCEDURE CMISSDecomposition_ElementDomainSetObj
  END INTERFACE !CMISSDecomposition_ElementDomainSet

  !>Returns the mesh component number used for the decomposition of a mesh.
  INTERFACE CMISSDecomposition_MeshComponentGet
    MODULE PROCEDURE CMISSDecomposition_MeshComponentGetNumber
    MODULE PROCEDURE CMISSDecomposition_MeshComponentGetObj
  END INTERFACE !CMISSDecomposition_MeshComponentGet

  !>Sets/changes the mesh component number used for the decomposition of a mesh.
  INTERFACE CMISSDecomposition_MeshComponentSet
    MODULE PROCEDURE CMISSDecomposition_MeshComponentSetNumber
    MODULE PROCEDURE CMISSDecomposition_MeshComponentSetObj
  END INTERFACE !CMISSDecomposition_MeshComponentSet

  !>Returns the number of domains used for the decomposition of a mesh.
  INTERFACE CMISSDecomposition_NumberOfDomainsGet
    MODULE PROCEDURE CMISSDecomposition_NumberOfDomainsGetNumber
    MODULE PROCEDURE CMISSDecomposition_NumberOfDomainsGetObj
  END INTERFACE !CMISSDecomposition_NumberOfDomainsGet

  !>Sets/changes the number of domains used for the decomposition of a mesh.
  INTERFACE CMISSDecomposition_NumberOfDomainsSet
    MODULE PROCEDURE CMISSDecomposition_NumberOfDomainsSetNumber
    MODULE PROCEDURE CMISSDecomposition_NumberOfDomainsSetObj
  END INTERFACE !CMISSDecomposition_NumberOfDomainsSet

  !>Returns the type of decomposition.
  INTERFACE CMISSDecomposition_TypeGet
    MODULE PROCEDURE CMISSDecomposition_TypeGetNumber
    MODULE PROCEDURE CMISSDecomposition_TypeGetObj
  END INTERFACE !CMISSDecomposition_TypeGet

  !>Sets/changes the type of decomposition.
  INTERFACE CMISSDecomposition_TypeSet
    MODULE PROCEDURE CMISSDecomposition_TypeSetNumber
    MODULE PROCEDURE CMISSDecomposition_TypeSetObj
  END INTERFACE !CMISSDecomposition_TypeSet

  !>Sets/changes whether lines should be calculated for the decomposition.
  INTERFACE CMISSDecomposition_CalculateLinesSet
    MODULE PROCEDURE CMISSDecomposition_CalculateLinesSetNumber
    MODULE PROCEDURE CMISSDecomposition_CalculateLinesSetObj
  END INTERFACE !CMISSDecomposition_CalculateLinesSet

  !>Sets/changes whether faces should be calculated for the decomposition.
  INTERFACE CMISSDecomposition_CalculateFacesSet
    MODULE PROCEDURE CMISSDecomposition_CalculateFacesSetNumber
    MODULE PROCEDURE CMISSDecomposition_CalculateFacesSetObj
  END INTERFACE !CMISSDecomposition_CalculateFacesSet

  !>Finishes the creation of a mesh. \see OPENCMISS::CMISSMesh_CreateStart
  INTERFACE CMISSMesh_CreateFinish
    MODULE PROCEDURE CMISSMesh_CreateFinishNumber
    MODULE PROCEDURE CMISSMesh_CreateFinishObj
  END INTERFACE !CMISSMesh_CreateFinish

  !>Starts the creation of a mesh. \see OPENCMISS::CMISSMesh_CreateFinish
  INTERFACE CMISSMesh_CreateStart
    MODULE PROCEDURE CMISSMesh_CreateStartNumber
    MODULE PROCEDURE CMISSMesh_CreateStartObj
    MODULE PROCEDURE CMISSMesh_CreateStartInterfaceObj
  END INTERFACE !CMISSMesh_CreateStart

  !>Destroys a mesh.
  INTERFACE CMISSMesh_Destroy
    MODULE PROCEDURE CMISSMesh_DestroyNumber
    MODULE PROCEDURE CMISSMesh_DestroyObj
  END INTERFACE !CMISSMesh_Destroy

  !>Returns the number of mesh components in a mesh.
  INTERFACE CMISSMesh_NumberOfComponentsGet
    MODULE PROCEDURE CMISSMesh_NumberOfComponentsGetNumber
    MODULE PROCEDURE CMISSMesh_NumberOfComponentsGetObj
  END INTERFACE !CMISSMesh_NumberOfComponentsGet

  !>Sets/changes the number of mesh components in a mesh.
  INTERFACE CMISSMesh_NumberOfComponentsSet
    MODULE PROCEDURE CMISSMesh_NumberOfComponentsSetNumber
    MODULE PROCEDURE CMISSMesh_NumberOfComponentsSetObj
  END INTERFACE !CMISSMesh_NumberOfComponentsSet

  !>Returns the number of elements in a mesh.
  INTERFACE CMISSMesh_NumberOfElementsGet
    MODULE PROCEDURE CMISSMesh_NumberOfElementsGetNumber
    MODULE PROCEDURE CMISSMesh_NumberOfElementsGetObj
  END INTERFACE !CMISSMesh_NumberOfElementsGet

  !>Sets/changes the number of elements in a mesh.
  INTERFACE CMISSMesh_NumberOfElementsSet
    MODULE PROCEDURE CMISSMesh_NumberOfElementsSetNumber
    MODULE PROCEDURE CMISSMesh_NumberOfElementsSetObj
  END INTERFACE !CMISSMesh_NumberOfElementsSet

  !>Sets/changes the surrounding elements calculate flag for the mesh.
  INTERFACE CMISSMesh_SurroundingElementsCalculateSet
    MODULE PROCEDURE CMISSMesh_SurroundingElementsCalculateSetNumber
    MODULE PROCEDURE CMISSMesh_SurroundingElementsCalculateSetObj
  END INTERFACE !CMISSMesh_SurroundingElementsCalculateSet
  
  !>Sets/changes whether data points topology should be calculated for the decomposition.
  INTERFACE CMISSMesh_TopologyDataPointsCalculateProjection
    MODULE PROCEDURE CMISSMesh_TopologyDataPointsCalculateProjectionInterfaceNumber
    MODULE PROCEDURE CMISSMesh_TopologyDataPointsCalculateProjectionRegionNumber
    MODULE PROCEDURE CMISSMesh_TopologyDataPointsCalculateProjectionObj
  END INTERFACE !CMISSMesh_TopologyDataPointsCalculateProjection

  !>Returns the basis for an element in a mesh.
  INTERFACE CMISSMeshElements_BasisGet
    MODULE PROCEDURE CMISSMeshElements_BasisGetNumber
    MODULE PROCEDURE CMISSMeshElements_BasisGetObj
  END INTERFACE !CMISSMeshElements_BasisGet

  !>Sets/changes the basis for an element in a mesh.
  INTERFACE CMISSMeshElements_BasisSet
    MODULE PROCEDURE CMISSMeshElements_BasisSetNumber
    MODULE PROCEDURE CMISSMeshElements_BasisSetObj
  END INTERFACE !CMISSMeshElements_BasisSet

  !>Returns the adjacent elements for a given element and adjacent xi direction for an element in a mesh.
  INTERFACE CMISSMeshElements_AdjacentElementGet
    MODULE PROCEDURE CMISSMeshElements_AdjacentElementGetNumber
    MODULE PROCEDURE CMISSMeshElements_AdjacentElementGetObj
  END INTERFACE !CMISSMeshElements_AdjacentElementGet

  !>Finishes the creation of a mesh elements for a mesh component. \see OPENCMISS::CMISSMeshElements_CreateStart
  INTERFACE CMISSMeshElements_CreateFinish
    MODULE PROCEDURE CMISSMeshElements_CreateFinishNumber
    MODULE PROCEDURE CMISSMeshElements_CreateFinishObj
  END INTERFACE !CMISSMeshElements_CreateFinish

  !>Starts the creation of a mesh elements for a mesh component. \see OPENCMISS::CMISSMeshElements_CreateFinish
  INTERFACE CMISSMeshElements_CreateStart
    MODULE PROCEDURE CMISSMeshElements_CreateStartNumber
    MODULE PROCEDURE CMISSMeshElements_CreateStartObj
  END INTERFACE !CMISSMeshElements_CreateStart

  !>Get the mesh elements belonging to a mesh component.
  INTERFACE CMISSMesh_ElementsGet
    MODULE PROCEDURE CMISSMesh_ElementsGetNumber
    MODULE PROCEDURE CMISSMesh_ElementsGetObj
  END INTERFACE !CMISSMesh_ElementsGet

  !>Returns the element nodes for an element in a mesh.
  INTERFACE CMISSMeshElements_NodesGet
    MODULE PROCEDURE CMISSMeshElements_NodesGetNumber
    MODULE PROCEDURE CMISSMeshElements_NodesGetObj
  END INTERFACE !CMISSMeshElements_NodesGet

  !>Sets/changes the element nodes for an element in a mesh.
  INTERFACE CMISSMeshElements_NodesSet
    MODULE PROCEDURE CMISSMeshElements_NodesSetNumber
    MODULE PROCEDURE CMISSMeshElements_NodesSetObj
  END INTERFACE !CMISSMeshElements_NodesSet

  !>Sets/changes a user node's derivative version for an element in a mesh.
  INTERFACE CMISSMeshElements_UserNodeVersionSet
    MODULE PROCEDURE CMISSMeshElements_UserNodeVersionSetNumber
    MODULE PROCEDURE CMISSMeshElements_UserNodeVersionSetObj
  END INTERFACE !CMISSMeshElements_UserNodeVersionSet

  !>Sets/changes a local element's node derivative version for an element in a mesh.
  INTERFACE CMISSMeshElements_LocalElementNodeVersionSet
    MODULE PROCEDURE CMISSMeshElements_LocalElementNodeVersionSetNumber
    MODULE PROCEDURE CMISSMeshElements_LocalElementNodeVersionSetObj
  END INTERFACE !CMISSMeshElements_LocalElementNodeVersionSet

  !>Returns the element user number for an element in a mesh.
  INTERFACE CMISSMeshElements_UserNumberGet
    MODULE PROCEDURE CMISSMeshElements_UserNumberGetNumber
    MODULE PROCEDURE CMISSMeshElements_UserNumberGetObj
  END INTERFACE !CMISSMeshElements_UserNumberGet

  !>Sets/changes the element user number for an element in a mesh.
  INTERFACE CMISSMeshElements_UserNumberSet
    MODULE PROCEDURE CMISSMeshElements_UserNumberSetNumber
    MODULE PROCEDURE CMISSMeshElements_UserNumberSetObj
  END INTERFACE !CMISSMeshElements_UserNumberSet
  
  !>Sets/changes the element user numbers for all element in a mesh.
  INTERFACE CMISSMeshElements_UserNumbersAllSet
    MODULE PROCEDURE CMISSMeshElements_UserNumbersAllSetNumber
    MODULE PROCEDURE CMISSMeshElements_UserNumbersAllSetObj
  END INTERFACE CMISSMeshElements_UserNumbersAllSet

  !>Returns true if the given node is in the given mesh component.
  INTERFACE CMISSMesh_NodeExists
    MODULE PROCEDURE CMISSMesh_NodeExistsNumber
    MODULE PROCEDURE CMISSMesh_NodeExistsObj
  END INTERFACE !CMISSMesh_NodeExists

  !>Returns true if the given element is in the given mesh component.
  INTERFACE CMISSMesh_ElementExists
    MODULE PROCEDURE CMISSMesh_ElementExistsNumber
    MODULE PROCEDURE CMISSMesh_ElementExistsObj
  END INTERFACE !CMISSMesh_ElementExists

  !>Get the mesh nodes belonging to a mesh component.
  INTERFACE CMISSMesh_NodesGet
    MODULE PROCEDURE CMISSMesh_NodesGetNumber
    MODULE PROCEDURE CMISSMesh_NodesGetObj
  END INTERFACE CMISSMesh_NodesGet

  !>Returns the number of derivatives for a node in a mesh.
  INTERFACE CMISSMeshNodes_NumberOfDerivativesGet
    MODULE PROCEDURE CMISSMeshNodes_NumberOfDerivativesGetNumber
    MODULE PROCEDURE CMISSMeshNodes_NumberOfDerivativesGetObj
  END INTERFACE CMISSMeshNodes_NumberOfDerivativesGet

  !>Returns the derivatives for a node in a mesh.
  INTERFACE CMISSMeshNodes_DerivativesGet
    MODULE PROCEDURE CMISSMeshNodes_DerivativesGetNumber
    MODULE PROCEDURE CMISSMeshNodes_DerivativesGetObj
  END INTERFACE CMISSMeshNodes_DerivativesGet

  !>Returns the number of versions for a derivative at a node in a mesh.
  INTERFACE CMISSMeshNodes_NumberOfVersionsGet
    MODULE PROCEDURE CMISSMeshNodes_NumberOfVersionsGetNumber
    MODULE PROCEDURE CMISSMeshNodes_NumberOfVersionsGetObj
  END INTERFACE CMISSMeshNodes_NumberOfVersionsGet

  !>Returns the domain for a given element in a decomposition of a mesh.
  INTERFACE CMISSDecomposition_NodeDomainGet
    MODULE PROCEDURE CMISSDecomposition_NodeDomainGetNumber
    MODULE PROCEDURE CMISSDecomposition_NodeDomainGetObj
  END INTERFACE !CMISSDecomposition_ElementDomainGet

  !>Calculates the decomposition topology for data points .
  INTERFACE CMISSDecomposition_TopologyDataProjectionCalculate
    MODULE PROCEDURE CMISSDecomposition_TopologyDataProjectionCalculateObj
  END INTERFACE !CMISSDecomposition_TopologyDataProjectionCalculate

  !>Gets the local data point number for data points projected on an element
  INTERFACE CMISSDecomposition_TopologyElementDataPointLocalNumberGet
    MODULE PROCEDURE CMISSDecomposition_TopologyElementDataPointLocalNumberGetObj
  END INTERFACE !CMISSDecomposition_TopologyElementDataPointLocalNumberGet

  !>Gets the user data point number for data points projected on an element
  INTERFACE CMISSDecomposition_TopologyElementDataPointUserNumberGet
    MODULE PROCEDURE CMISSDecomposition_TopologyElementDataPointUserNumberGetObj
  END INTERFACE !CMISSDecomposition_TopologyElementDataPointUserNumberGet

  !>Gets the number of data points projected on an element
  INTERFACE CMISSDecomposition_TopologyNumberOfElementDataPointsGet
    MODULE PROCEDURE CMISSDecomposition_TopologyNumberOfElementDataPointsGetObj
  END INTERFACE !CMISSDecomposition_TopologyNumberOfElementDataPointsGet

  PUBLIC CMISS_DECOMPOSITION_ALL_TYPE,CMISS_DECOMPOSITION_CALCULATED_TYPE,CMISS_DECOMPOSITION_USER_DEFINED_TYPE

  PUBLIC CMISSDecomposition_CreateFinish,CMISSDecomposition_CreateStart

  PUBLIC CMISSDecomposition_TopologyDataProjectionCalculate

  PUBLIC CMISSDecomposition_TopologyElementDataPointLocalNumberGet

  PUBLIC CMISSDecomposition_TopologyElementDataPointUserNumberGet

  PUBLIC CMISSDecomposition_TopologyNumberOfElementDataPointsGet

  PUBLIC CMISSDecomposition_Destroy

  PUBLIC CMISSDecomposition_ElementDomainCalculate

  PUBLIC CMISSDecomposition_ElementDomainGet,CMISSDecomposition_ElementDomainSet

  PUBLIC CMISSDecomposition_MeshComponentGet,CMISSDecomposition_MeshComponentSet

  PUBLIC CMISSDecomposition_NumberOfDomainsGet,CMISSDecomposition_NumberOfDomainsSet

  PUBLIC CMISSDecomposition_TypeGet,CMISSDecomposition_TypeSet

  PUBLIC CMISSDecomposition_NodeDomainGet

  PUBLIC CMISSMesh_CreateFinish,CMISSMesh_CreateStart

  PUBLIC CMISSMesh_Destroy

  PUBLIC CMISSMesh_NumberOfComponentsGet,CMISSMesh_NumberOfComponentsSet

  PUBLIC CMISSMesh_NumberOfElementsGet,CMISSMesh_NumberOfElementsSet

  PUBLIC CMISSMeshElements_BasisGet,CMISSMeshElements_BasisSet

  PUBLIC CMISSMeshElements_AdjacentElementGet

  PUBLIC CMISSMeshElements_UserNodeVersionSet, CMISSMeshElements_LocalElementNodeVersionSet

  PUBLIC CMISSMeshElements_CreateFinish,CMISSMeshElements_CreateStart

  PUBLIC CMISSMeshElements_NodesGet,CMISSMeshElements_NodesSet

  PUBLIC CMISSMeshElements_UserNumberGet,CMISSMeshElements_UserNumberSet
  
  PUBLIC CMISSMeshElements_UserNumbersAllSet

  PUBLIC CMISSMeshNodes_NumberOfDerivativesGet,CMISSMeshNodes_DerivativesGet

  PUBLIC CMISSMeshNodes_NumberOfVersionsGet

  PUBLIC CMISSMesh_ElementsGet

  PUBLIC CMISSMesh_NodesGet

  PUBLIC CMISSMesh_NodeExists,CMISSMesh_ElementExists

  PUBLIC CMISSMesh_SurroundingElementsCalculateSet
  
  PUBLIC CMISSMesh_TopologyDataPointsCalculateProjection

!!==================================================================================================================================
!!
!! DISTRIBUTED_MATRIX_VECTOR
!!
!!==================================================================================================================================

  !> \addtogroup OPENCMISS_MatrixVectorConstants OPENCMISS::MatrixVector::Constants
  !> \brief Distributed matrix and vector function constants.
  !>@{
  !> \addtogroup OPENCMISS_MatrixStorageTypes OPENCMISS::MatrixVector::MatrixStorageTypes
  !> \brief Type of matrix storage.
  !> \see OPENCMISS::MatrixVectorConstants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_MATRIX_BLOCK_STORAGE_TYPE=DISTRIBUTED_MATRIX_BLOCK_STORAGE_TYPE !<Distributed matrix block storage type \see OPENCMISS_MatrixStorageTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_MATRIX_DIAGONAL_STORAGE_TYPE=DISTRIBUTED_MATRIX_DIAGONAL_STORAGE_TYPE !<Distributed matrix diagonal storage type \see OPENCMISS_MatrixStorageTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_MATRIX_COLUMN_MAJOR_STORAGE_TYPE=DISTRIBUTED_MATRIX_COLUMN_MAJOR_STORAGE_TYPE !<Distributed matrix column major storage type \see OPENCMISS_MatrixStorageTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_MATRIX_ROW_MAJOR_STORAGE_TYPE=DISTRIBUTED_MATRIX_ROW_MAJOR_STORAGE_TYPE !<Distributed matrix row major storage type \see OPENCMISS_MatrixStorageTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_MATRIX_COMPRESSED_ROW_STORAGE_TYPE=DISTRIBUTED_MATRIX_COMPRESSED_ROW_STORAGE_TYPE !<Distributed matrix compressed row storage type \see OPENCMISS_MatrixStorageTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE=DISTRIBUTED_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE !<Distributed matrix compressed column storage type \see OPENCMISS_MatrixStorageTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_MATRIX_ROW_COLUMN_STORAGE_TYPE=DISTRIBUTED_MATRIX_ROW_COLUMN_STORAGE_TYPE !<Distributed matrix row-column storage type \see OPENCMISS_MatrixStorageTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_MatrixVectorDataTypes OPENCMISS::MatrixVector::DataTypes
  !> \brief Type of data stored in matrices and vectors.
  !> \see OPENCMISS::MatrixVectorConstants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_MATRIX_VECTOR_INTG_TYPE=DISTRIBUTED_MATRIX_VECTOR_INTG_TYPE
  INTEGER(INTG), PARAMETER :: CMISS_MATRIX_VECTOR_SP_TYPE=DISTRIBUTED_MATRIX_VECTOR_SP_TYPE !<Single precision real distributed matrix-vector data type \see OPENCMISS_MatrixVectorDataTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_MATRIX_VECTOR_DP_TYPE=DISTRIBUTED_MATRIX_VECTOR_DP_TYPE !<Double precision real distributed matrix-vector data type \see OPENCMISS_MatrixVectorDataTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_MATRIX_VECTOR_L_TYPE=DISTRIBUTED_MATRIX_VECTOR_L_TYPE !<Logical distributed matrix-vector data type \see OPENCMISS_MatrixVectorDataTypes,OPENCMISS
  !>@}
  !>@}

  PUBLIC CMISS_MATRIX_BLOCK_STORAGE_TYPE,CMISS_MATRIX_DIAGONAL_STORAGE_TYPE,CMISS_MATRIX_COLUMN_MAJOR_STORAGE_TYPE, &
    & CMISS_MATRIX_ROW_MAJOR_STORAGE_TYPE,CMISS_MATRIX_COMPRESSED_ROW_STORAGE_TYPE,CMISS_MATRIX_COMPRESSED_COLUMN_STORAGE_TYPE, &
    & CMISS_MATRIX_ROW_COLUMN_STORAGE_TYPE

  PUBLIC CMISS_MATRIX_VECTOR_INTG_TYPE,CMISS_MATRIX_VECTOR_SP_TYPE,CMISS_MATRIX_VECTOR_DP_TYPE,CMISS_MATRIX_VECTOR_L_TYPE

  !Note that currently we don't have any user number based routines for distributed matrices
  !as if we can't use a pointer to a CMISS object, a pointer to matrix data isn't going to
  !be much use either. It's also more awkward when matrices and vectors themselves don't have
  !user numbers and there are multiple ways to access them through user numbers, eg. solver equations
  !matrices or equations set matrices

  !>Get the storage type for a distributed matrix
  INTERFACE CMISSDistributedMatrix_StorageTypeGet
    MODULE PROCEDURE CMISSDistributedMatrix_StorageTypeGetObj
  END INTERFACE CMISSDistributedMatrix_StorageTypeGet

  !>Get the data type for a distributed matrix
  INTERFACE CMISSDistributedMatrix_DataTypeGet
    MODULE PROCEDURE CMISSDistributedMatrix_DataTypeGetObj
  END INTERFACE CMISSDistributedMatrix_DataTypeGet

  !>Get the dimensions for a distributed matrix on this computational node
  INTERFACE CMISSDistributedMatrix_DimensionsGet
    MODULE PROCEDURE CMISSDistributedMatrix_DimensionsGetObj
  END INTERFACE CMISSDistributedMatrix_DimensionsGet

  !>Get the row indices and column indices for a sparse matrix
  INTERFACE CMISSDistributedMatrix_StorageLocationsGet
    MODULE PROCEDURE CMISSDistributedMatrix_StorageLocationsGetObj
  END INTERFACE CMISSDistributedMatrix_StorageLocationsGet

  !>Get the data array for this matrix on this computational node
  INTERFACE CMISSDistributedMatrix_DataGet
    MODULE PROCEDURE CMISSDistributedMatrix_DataGetIntgObj
    MODULE PROCEDURE CMISSDistributedMatrix_DataGetDPObj
    MODULE PROCEDURE CMISSDistributedMatrix_DataGetSPObj
    MODULE PROCEDURE CMISSDistributedMatrix_DataGetLObj
  END INTERFACE CMISSDistributedMatrix_DataGet

  !>Restore the data array for this matrix once it has finished being used
  INTERFACE CMISSDistributedMatrix_DataRestore
    MODULE PROCEDURE CMISSDistributedMatrix_DataRestoreIntgObj
    MODULE PROCEDURE CMISSDistributedMatrix_DataRestoreDPObj
    MODULE PROCEDURE CMISSDistributedMatrix_DataRestoreSPObj
    MODULE PROCEDURE CMISSDistributedMatrix_DataRestoreLObj
  END INTERFACE CMISSDistributedMatrix_DataRestore

  !>Get the data type for a distributed vector
  INTERFACE CMISSDistributedVector_DataTypeGet
    MODULE PROCEDURE CMISSDistributedVector_DataTypeGetObj
  END INTERFACE CMISSDistributedVector_DataTypeGet

  !>Get the data array for this vector on this computational node
  INTERFACE CMISSDistributedVector_DataGet
    MODULE PROCEDURE CMISSDistributedVector_DataGetIntgObj
    MODULE PROCEDURE CMISSDistributedVector_DataGetDPObj
    MODULE PROCEDURE CMISSDistributedVector_DataGetSPObj
    MODULE PROCEDURE CMISSDistributedVector_DataGetLObj
  END INTERFACE CMISSDistributedVector_DataGet

  !>Restore the data array for this vector once it has finished being used
  INTERFACE CMISSDistributedVector_DataRestore
    MODULE PROCEDURE CMISSDistributedVector_DataRestoreIntgObj
    MODULE PROCEDURE CMISSDistributedVector_DataRestoreDPObj
    MODULE PROCEDURE CMISSDistributedVector_DataRestoreSPObj
    MODULE PROCEDURE CMISSDistributedVector_DataRestoreLObj
  END INTERFACE CMISSDistributedVector_DataRestore

  PUBLIC CMISSDistributedMatrix_StorageTypeGet,CMISSDistributedMatrix_StorageLocationsGet
  PUBLIC CMISSDistributedMatrix_DataTypeGet,CMISSDistributedMatrix_DimensionsGet
  PUBLIC CMISSDistributedMatrix_DataGet,CMISSDistributedMatrix_DataRestore
  PUBLIC CMISSDistributedVector_DataTypeGet
  PUBLIC CMISSDistributedVector_DataGet,CMISSDistributedVector_DataRestore

!!==================================================================================================================================
!!
!! NODE_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finishes the process of creating nodes in a region. \see OPENCMISS::CMISSNodes_CreateStart
  INTERFACE CMISSNodes_CreateFinish
    MODULE PROCEDURE CMISSNodes_CreateFinishNumber
    MODULE PROCEDURE CMISSNodes_CreateFinishObj
  END INTERFACE !CMISSNodes_CreateFinish

  !>Starts the process of creating nodes in a region. \see OPENCMISS::CMISSNodes_CreateFinish
  INTERFACE CMISSNodes_CreateStart
    MODULE PROCEDURE CMISSNodes_CreateStartNumber
    MODULE PROCEDURE CMISSNodes_CreateStartObj
    MODULE PROCEDURE CMISSNodes_CreateStartInterfaceObj
  END INTERFACE !CMISSNodes_CreateStart

  !>Destroys nodes.
  INTERFACE CMISSNodes_Destroy
    MODULE PROCEDURE CMISSNodes_DestroyNumber
    MODULE PROCEDURE CMISSNodes_DestroyObj
  END INTERFACE !CMISSNodes_Destroy

  !>Returns the number of nodes
  INTERFACE CMISSNodes_NumberOfNodesGet
    MODULE PROCEDURE CMISSNodes_NumberOfNodesGetNumber
    MODULE PROCEDURE CMISSNodes_NumberOfNodesGetObj
  END INTERFACE !CMISSNodes_NumberOfNodesGet

  !>Returns the label for a node identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSNodes_LabelGet
    MODULE PROCEDURE CMISSNodes_LabelGetCNumber
    MODULE PROCEDURE CMISSNodes_LabelGetCObj
    MODULE PROCEDURE CMISSNodes_LabelGetVSNumber
    MODULE PROCEDURE CMISSNodes_LabelGetVSObj
  END INTERFACE !CMISSNodes_LabelGet

  !>Sets/changes the label for a node identified by a given global number. \todo should this be a user number?
  INTERFACE CMISSNodes_LabelSet
    MODULE PROCEDURE CMISSNodes_LabelSetCNumber
    MODULE PROCEDURE CMISSNodes_LabelSetCObj
    MODULE PROCEDURE CMISSNodes_LabelSetVSNumber
    MODULE PROCEDURE CMISSNodes_LabelSetVSObj
  END INTERFACE !CMISSNodes_LabelSet

  !>Returns the user number for a node identified by a given global number.
  INTERFACE CMISSNodes_UserNumberGet
    MODULE PROCEDURE CMISSNodes_UserNumberGetNumber
    MODULE PROCEDURE CMISSNodes_UserNumberGetObj
  END INTERFACE !CMISSNodes_UserNumberGet

  !>Sets/changes the user number for a node identified by a given global number.
  INTERFACE CMISSNodes_UserNumberSet
    MODULE PROCEDURE CMISSNodes_UserNumberSetNumber
    MODULE PROCEDURE CMISSNodes_UserNumberSetObj
  END INTERFACE !CMISSNodes_UserNumberSet
  
  !>Sets/changes the all user number for nodes.
  INTERFACE CMISSNodes_UserNumbersAllSet
    MODULE PROCEDURE CMISSNodes_UserNumbersAllSetNumber
    MODULE PROCEDURE CMISSNodes_UserNumbersAllSetObj
  END INTERFACE CMISSNodes_UserNumbersAllSet

  PUBLIC CMISSNodes_CreateFinish,CMISSNodes_CreateStart

  PUBLIC CMISSNodes_Destroy

  PUBLIC CMISSNodes_NumberOfNodesGet

  PUBLIC CMISSNodes_LabelGet,CMISSNodes_LabelSet

  PUBLIC CMISSNodes_UserNumberGet,CMISSNodes_UserNumberSet,CMISSNodes_UserNumbersAllSet

!!==================================================================================================================================
!!
!! PROBLEM_CONSTANTS_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_ProblemConstants OPENCMISS::Problem::Constants
  !> \brief Problem constants.
  !>@{
  !> \addtogroup OPENCMISS_ProblemClasses OPENCMISS::Problem::Classes
  !> \brief Problem classes.
  !> \see OPENCMISS::Problem,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NO_CLASS = PROBLEM_NO_CLASS !<No problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_ELASTICITY_CLASS = PROBLEM_ELASTICITY_CLASS !<Elasticity problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FLUID_MECHANICS_CLASS = PROBLEM_FLUID_MECHANICS_CLASS !<Fluid mechanics problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_ELECTROMAGNETICS_CLASS = PROBLEM_ELECTROMAGNETICS_CLASS !<Electromagnetics problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CLASSICAL_FIELD_CLASS = PROBLEM_CLASSICAL_FIELD_CLASS !<Classical field problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_BIOELECTRICS_CLASS = PROBLEM_BIOELECTRICS_CLASS !<Bioelectrics problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MODAL_CLASS = PROBLEM_MODAL_CLASS !<Modal problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FITTING_CLASS = PROBLEM_FITTING_CLASS !<Fitting problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_OPTIMISATION_CLASS = PROBLEM_OPTIMISATION_CLASS !<Optimisation problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MULTI_PHYSICS_CLASS = PROBLEM_MULTI_PHYSICS_CLASS !<Multi physics problem class \see OPENCMISS_ProblemClasses,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_ProblemTypes OPENCMISS::Problem::Types
  !> \brief Problem Types.
  !> \see OPENCMISS::Problem,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NO_TYPE = PROBLEM_NO_TYPE !<No problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_ELASTICITY_TYPE = PROBLEM_LINEAR_ELASTICITY_TYPE !<Linear elasticity problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FINITE_ELASTICITY_TYPE = PROBLEM_FINITE_ELASTICITY_TYPE !<Finite elasticity problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_ELASTICITY_CONTACT_TYPE = PROBLEM_LINEAR_ELASTICITY_CONTACT_TYPE !<Linear elasticity problem subject to contact contstraint type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FINITE_ELASTICITY_CONTACT_TYPE = PROBLEM_FINITE_ELASTICITY_CONTACT_TYPE !<Finite elasticity problem subject to contact constraint type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STOKES_EQUATION_TYPE = PROBLEM_STOKES_EQUATION_TYPE !<Stokes equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NAVIER_STOKES_EQUATION_TYPE = PROBLEM_NAVIER_STOKES_EQUATION_TYPE !<Navier-Stokes problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DARCY_EQUATION_TYPE = PROBLEM_DARCY_EQUATION_TYPE !<Darcy equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_POISEUILLE_EQUATION_TYPE = PROBLEM_POISEUILLE_EQUATION_TYPE !<Poiseuille equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_BURGERS_EQUATION_TYPE = PROBLEM_BURGERS_EQUATION_TYPE !<Burgers equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_ELECTROSTATIC_TYPE = PROBLEM_ELECTROSTATIC_TYPE !<Electrostatic problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MAGNETOSTATIC_TYPE = PROBLEM_MAGNETOSTATIC_TYPE !<Magnetostatic problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MAXWELLS_EQUATIONS_TYPE = PROBLEM_MAXWELLS_EQUATIONS_TYPE !<Maxwell's equations problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LAPLACE_EQUATION_TYPE = PROBLEM_LAPLACE_EQUATION_TYPE !<Laplace problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_POISSON_EQUATION_TYPE = PROBLEM_POISSON_EQUATION_TYPE !<Poisson problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_HELMHOLTZ_EQUATION_TYPE = PROBLEM_HELMHOLTZ_EQUATION_TYPE !<Helmholtz problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_WAVE_EQUATION_TYPE = PROBLEM_WAVE_EQUATION_TYPE !<Wave equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DIFFUSION_EQUATION_TYPE = PROBLEM_DIFFUSION_EQUATION_TYPE !<Diffusion equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_ADVECTION_DIFFUSION_EQUATION_TYPE = PROBLEM_ADVECTION_DIFFUSION_EQUATION_TYPE !<Advection-Diffusion equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_REACTION_DIFFUSION_EQUATION_TYPE = PROBLEM_REACTION_DIFFUSION_EQUATION_TYPE !<Reaction-Diffusion equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_BIHARMONIC_EQUATION_TYPE = PROBLEM_BIHARMONIC_EQUATION_TYPE !<Bi-harmonic equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MONODOMAIN_EQUATION_TYPE = PROBLEM_MONODOMAIN_EQUATION_TYPE !<Monodomain equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_BIDOMAIN_EQUATION_TYPE = PROBLEM_BIDOMAIN_EQUATION_TYPE !<Bidomain equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_ELASTIC_MODAL_TYPE = PROBLEM_LINEAR_ELASTIC_MODAL_TYPE !<Linear elastic modal problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DATA_FITTING_TYPE = PROBLEM_DATA_FITTING_TYPE !<Galerkin projection problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FINITE_ELASTICITY_DARCY_TYPE = PROBLEM_FINITE_ELASTICITY_DARCY_TYPE !<Finite Elasticity Darcy problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FINITE_ELASTICITY_STOKES_TYPE = PROBLEM_FINITE_ELASTICITY_STOKES_TYPE !<Finite Elasticity Stokes problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_TYPE = PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_TYPE !<Finite Elasticity NavierStokes problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DIFFUSION_DIFFUSION_TYPE = PROBLEM_DIFFUSION_DIFFUSION_TYPE !<Diffusion Diffusion problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DIFFUSION_ADVECTION_DIFFUSION_TYPE = PROBLEM_DIFFUSION_ADVECTION_DIFFUSION_TYPE !<Diffusion Advection Diffusion problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MULTI_COMPARTMENT_TRANSPORT_TYPE = PROBLEM_MULTI_COMPARTMENT_TRANSPORT_TYPE !<Multi-compartment transport problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FINITE_ELASTICITY_FLUID_PRESSURE_TYPE = PROBLEM_FINITE_ELASTICITY_FLUID_PRESSURE_TYPE !<Finite elasticity fluid pressure problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_BIOELECTRIC_FINITE_ELASTICITY_TYPE = PROBLEM_BIOELECTRIC_FINITE_ELASTICITY_TYPE !<Monodomain finite elasticity problem type \see OPENCMISS_ProblemTypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE = &
    & PROBLEM_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE !<Monodomain equation problem type \see OPENCMISS_ProblemTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_ProblemSubTypes OPENCMISS::Problem::Subtypes
  !> \brief Problem Subtypes.
  !> \see OPENCMISS::Problem,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NO_SUBTYPE = PROBLEM_NO_SUBTYPE !<No problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STATIC_STOKES_SUBTYPE = PROBLEM_STATIC_STOKES_SUBTYPE !<Static Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LAPLACE_STOKES_SUBTYPE = PROBLEM_LAPLACE_STOKES_SUBTYPE !<Laplace type Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_TRANSIENT_STOKES_SUBTYPE = PROBLEM_TRANSIENT_STOKES_SUBTYPE !<Transient Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_ALE_STOKES_SUBTYPE = PROBLEM_ALE_STOKES_SUBTYPE !<ALE Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_PGM_STOKES_SUBTYPE = PROBLEM_PGM_STOKES_SUBTYPE !<PGM Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_OPTIMISED_STOKES_SUBTYPE = PROBLEM_OPTIMISED_STOKES_SUBTYPE !<Optimised Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STATIC_NAVIER_STOKES_SUBTYPE = PROBLEM_STATIC_NAVIER_STOKES_SUBTYPE !<Static Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LAPLACE_NAVIER_STOKES_SUBTYPE = PROBLEM_LAPLACE_NAVIER_STOKES_SUBTYPE !<Laplace type Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_TRANSIENT_NAVIER_STOKES_SUBTYPE = PROBLEM_TRANSIENT_NAVIER_STOKES_SUBTYPE !<Transient Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_TRANSIENT_SUPG_NAVIER_STOKES_SUBTYPE = PROBLEM_TRANSIENT_SUPG_NAVIER_STOKES_SUBTYPE !<Transient SUPG Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_TRANSIENT_SUPG_NAVIER_STOKES_CMM_SUBTYPE = &
    & PROBLEM_TRANSIENT_SUPG_NAVIER_STOKES_MULTIDOMAIN_SUBTYPE !<Transient SUPG Navier-Stokes problem with coupled multidomain method subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_1DTRANSIENT_NAVIER_STOKES_SUBTYPE = PROBLEM_1DTRANSIENT_NAVIER_STOKES_SUBTYPE !<1DTransient Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_Coupled1D0D_NAVIER_STOKES_SUBTYPE = PROBLEM_Coupled1D0D_NAVIER_STOKES_SUBTYPE !<Coupled 1D-0D Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_Coupled1dDae_NAVIER_STOKES_SUBTYPE = Problem_Coupled1dDaeNavierStokesSubtype !<Coupled 1D-DAE Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_ALE_NAVIER_STOKES_SUBTYPE = PROBLEM_ALE_NAVIER_STOKES_SUBTYPE !<ALE Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_PGM_NAVIER_STOKES_SUBTYPE = PROBLEM_PGM_NAVIER_STOKES_SUBTYPE !<PGM Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_OPTIMISED_NAVIER_STOKES_SUBTYPE = PROBLEM_OPTIMISED_NAVIER_STOKES_SUBTYPE !<Optimised Navier-Stokes problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STANDARD_DARCY_SUBTYPE = PROBLEM_STANDARD_DARCY_SUBTYPE !<Standard Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_QUASISTATIC_DARCY_SUBTYPE = PROBLEM_QUASISTATIC_DARCY_SUBTYPE !<Quasistatic Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_ALE_DARCY_SUBTYPE = PROBLEM_ALE_DARCY_SUBTYPE !<ALE Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_TRANSIENT_DARCY_SUBTYPE = PROBLEM_TRANSIENT_DARCY_SUBTYPE !<Transient Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_PGM_DARCY_SUBTYPE = PROBLEM_PGM_DARCY_SUBTYPE !<PGM Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_PGM_TRANSIENT_DARCY_SUBTYPE = PROBLEM_PGM_TRANSIENT_DARCY_SUBTYPE !<PGM Transient Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STANDARD_LAPLACE_SUBTYPE = PROBLEM_STANDARD_LAPLACE_SUBTYPE !<Standard Laplace problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_GENERALISED_LAPLACE_SUBTYPE = PROBLEM_GENERALISED_LAPLACE_SUBTYPE !<Generalised Laplace problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STATIC_POISEUILLE_SUBTYPE = PROBLEM_STATIC_POISEUILLE_SUBTYPE !<Static Poiseuille problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
 INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DYNAMIC_POISEUILLE_SUBTYPE = PROBLEM_DYNAMIC_POISEUILLE_SUBTYPE !<Static Poiseuille problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE = PROBLEM_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE !<Linear source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_SOURCE_POISSON_SUBTYPE = PROBLEM_LINEAR_SOURCE_POISSON_SUBTYPE !<Linear source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_PRESSURE_POISSON_SUBTYPE = PROBLEM_LINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NONLINEAR_PRESSURE_POISSON_SUBTYPE = PROBLEM_NONLINEAR_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_ALE_PRESSURE_POISSON_SUBTYPE = PROBLEM_ALE_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FITTED_PRESSURE_POISSON_SUBTYPE = PROBLEM_FITTED_PRESSURE_POISSON_SUBTYPE !<Vector source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NONLINEAR_SOURCE_POISSON_SUBTYPE = PROBLEM_NONLINEAR_SOURCE_POISSON_SUBTYPE !<Nonlinear source Poisson problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STANDARD_HELMHOLTZ_SUBTYPE = PROBLEM_STANDARD_HELMHOLTZ_SUBTYPE !<No source Helmholtz problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_GENERALISED_HELMHOLTZ_SUBTYPE = PROBLEM_GENERALISED_HELMHOLTZ_SUBTYPE !<No source Helmholtz problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NO_SOURCE_DIFFUSION_SUBTYPE = PROBLEM_NO_SOURCE_DIFFUSION_SUBTYPE !<No source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_SOURCE_DIFFUSION_SUBTYPE = PROBLEM_LINEAR_SOURCE_DIFFUSION_SUBTYPE !<Linear source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NONLINEAR_SOURCE_DIFFUSION_SUBTYPE = PROBLEM_NONLINEAR_SOURCE_DIFFUSION_SUBTYPE !<Nonlinear source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NO_SOURCE_ALE_DIFFUSION_SUBTYPE = PROBLEM_NO_SOURCE_ALE_DIFFUSION_SUBTYPE !<No source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE = PROBLEM_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE !<Linear source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NONLINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE = &
    & PROBLEM_NONLINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE !<Nonlinear source Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<No source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Linear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NONLINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_NONLINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE !<Nonlinear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<No source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_LINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Linear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NONLINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE = &
    & PROBLEM_NONLINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE !<Nonlinear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = PROBLEM_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<No source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & PROBLEM_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Linear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_NONLINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE = &
    & PROBLEM_NONLINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE !<Nonlinear source advection-Diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STATIC_BURGERS_SUBTYPE = PROBLEM_STATIC_BURGERS_SUBTYPE !<static Burgers problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DYNAMIC_BURGERS_SUBTYPE = PROBLEM_DYNAMIC_BURGERS_SUBTYPE !<dynamic Burgers problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CELLML_REAC_INTEG_REAC_DIFF_STRANG_SPLIT_SUBTYPE = &
    & PROBLEM_CELLML_REAC_INTEG_REAC_DIFF_STRANG_SPLIT_SUBTYPE !CellML reaction integrated strang-split subtype of reaction diffusion \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CELLML_REAC_EVAL_REAC_DIFF_NO_SPLIT_SUBTYPE = &
    & PROBLEM_CELLML_REAC_EVAL_REAC_DIFF_NO_SPLIT_SUBTYPE !CellML reaction evaluated no-split subtype of reaction diffusion \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CONSTANT_REAC_DIFF_NO_SPLIT_SUBTYPE = &
    & PROBLEM_CONSTANT_REAC_DIFF_NO_SPLIT_SUBTYPE !Standard constant reaction reaction diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STANDARD_DATA_FITTING_SUBTYPE = &
    & PROBLEM_STANDARD_DATA_FITTING_SUBTYPE !<Standard Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_VECTOR_DATA_FITTING_SUBTYPE = &
    & PROBLEM_VECTOR_DATA_FITTING_SUBTYPE !<Standard Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DIV_FREE_VECTOR_DATA_FITTING_SUBTYPE = &
    & PROBLEM_DIV_FREE_VECTOR_DATA_FITTING_SUBTYPE !<Standard Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DATA_POINT_VECTOR_STATIC_FITTING_SUBTYPE = &
    & Problem_DataPointVectorStaticFittingSubtype !<Standard static Galerkin projection problem using data points subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DATA_PT_VECTOR_QUASISTATIC_FITTING_SUBTYPE = &
    & Problem_DataPointVectorQuasistaticFittingSubtype !<Standard quasistatic Galerkin projection problem using data points subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_VECTOR_DATA_PRE_FITTING_SUBTYPE = &
    & PROBLEM_VECTOR_DATA_PRE_FITTING_SUBTYPE !<Standard Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_DIV_FREE_VECTOR_DATA_PRE_FITTING_SUBTYPE = &
    & PROBLEM_DIV_FREE_VECTOR_DATA_PRE_FITTING_SUBTYPE !<Standard Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_GENERALISED_DATA_FITTING_SUBTYPE = &
    & PROBLEM_GENERALISED_DATA_FITTING_SUBTYPE !<Generalised Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MAT_PROPERTIES_DATA_FITTING_SUBTYPE = &
    & PROBLEM_MAT_PROPERTIES_DATA_FITTING_SUBTYPE !<Material Properties Galerkin projection problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE = PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE !<Standard Elasticity Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_PGM_ELASTICITY_DARCY_SUBTYPE = PROBLEM_PGM_ELASTICITY_DARCY_SUBTYPE !<PGM Elasticity Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE = &
    & PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE !<Quasistatic Elasticity Transient Darcy problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE = &
    & PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE !<Quasistatic Elasticity Transient Darcy Material Solve problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE = &
    & PROBLEM_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE !<Coupled source diffusion-diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE = &
    & PROBLEM_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE !<Coupled source diffusion & advection-diffusion problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STANDARD_MULTI_COMPARTMENT_TRANSPORT_SUBTYPE = &
    & PROBLEM_STANDARD_MULTI_COMPARTMENT_TRANSPORT_SUBTYPE !<Standard multi-compartment transport problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE = &
    & PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE !<Standard elasticity fluid pressure problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_GUDUNOV_MONODOMAIN_SIMPLE_ELASTICITY_SUBTYPE = &
    & PROBLEM_GUDUNOV_MONODOMAIN_SIMPLE_ELASTICITY_SUBTYPE !<Transient monodomain simple elasticity problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_GUDUNOV_MONODOMAIN_1D3D_ELASTICITY_SUBTYPE = & 
    & PROBLEM_GUDUNOV_MONODOMAIN_1D3D_ELASTICITY_SUBTYPE !<Transient monodomain simple elasticity problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE = & 
    & PROBLEM_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE !<Transient monodomain simple elasticity problem subtype with titin \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE = &
    & PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE !<Coupled Finite Elasticity Navier Stokes moving mesh subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE = PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE !<Quasistatic finite elasticity subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FINITE_ELASTICITY_CELLML_SUBTYPE = PROBLEM_FINITE_ELASTICITY_CELLML_SUBTYPE !<Quasistatic finite elasticity subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MONODOMAIN_GUDUNOV_SPLIT_SUBTYPE = PROBLEM_MONODOMAIN_GUDUNOV_SPLIT_SUBTYPE !<Monodomain Gudunov split problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MONODOMAIN_STRANG_SPLIT_SUBTYPE = PROBLEM_MONODOMAIN_STRANG_SPLIT_SUBTYPE !<Monodomain Gudunov split problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_BIDOMAIN_GUDUNOV_SPLIT_SUBTYPE = PROBLEM_BIDOMAIN_GUDUNOV_SPLIT_SUBTYPE !<Bidomain Gudunov split problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_BIDOMAIN_STRANG_SPLIT_SUBTYPE = PROBLEM_BIDOMAIN_STRANG_SPLIT_SUBTYPE !<Bidomain Gudunov split problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MONODOMAIN_BUENOOROVIO_SUBTYPE = PROBLEM_MONODOMAIN_BUENOOROVIO_SUBTYPE !<Generalised Laplace problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_MONODOMAIN_TENTUSSCHER06_SUBTYPE = PROBLEM_MONODOMAIN_TENTUSSCHER06_SUBTYPE !<Generalised Laplace problem subtype \see OPENCMISS_ProblemSubtypes,OPENCMISS

  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE=PROBLEM_LE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE !<linear elasticity problem subject to contact constraint, transform field at load increments and reproject at Newton iterations \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LE_CONTACT_TRANSFORM_SUBTYPE=PROBLEM_LE_CONTACT_TRANSFORM_SUBTYPE !<linear elasticity problem subject to contact constraint, transform field at load increments \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_LE_CONTACT_REPROJECT_SUBTYPE=PROBLEM_LE_CONTACT_REPROJECT_SUBTYPE !<linear elasticity problem subject to contact constraint, reproject at Newton iterations \see OPENCMISS_ProblemSubtypes,OPENCMISS
    
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE=PROBLEM_FE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE !<linear elasticity problem subject to contact constraint, transform field at load increments and reproject at Newton iterations \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FE_CONTACT_TRANSFORM_SUBTYPE=PROBLEM_FE_CONTACT_TRANSFORM_SUBTYPE !<finear elasticity problem subject to contact constraint, transform field at load increments \see OPENCMISS_ProblemSubtypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_FE_CONTACT_REPROJECT_SUBTYPE=PROBLEM_FE_CONTACT_REPROJECT_SUBTYPE !<finear elasticity problem subject to contact constraint, reproject at Newton iterations \see OPENCMISS_ProblemSubtypes,OPENCMISS

  !>@}
  !> \addtogroup OPENCMISS_ProblemControlLoopTypes OPENCMISS::Problem::ControlLoopTypes
  !> \brief Problem control loop type parameters
  !> \see OPENCMISS::Problem,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CONTROL_SIMPLE_TYPE = PROBLEM_CONTROL_SIMPLE_TYPE !<Simple, one iteration control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CONTROL_FIXED_LOOP_TYPE = PROBLEM_CONTROL_FIXED_LOOP_TYPE !<Fixed iteration control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CONTROL_TIME_LOOP_TYPE = PROBLEM_CONTROL_TIME_LOOP_TYPE !<Time control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CONTROL_WHILE_LOOP_TYPE = PROBLEM_CONTROL_WHILE_LOOP_TYPE !<While control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_PROBLEM_CONTROL_LOAD_INCREMENT_LOOP_TYPE = PROBLEM_CONTROL_LOAD_INCREMENT_LOOP_TYPE !<Load increment control loop. \see OPENCMISS_ProblemControlLoopTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  PUBLIC CMISS_PROBLEM_NO_CLASS,CMISS_PROBLEM_ELASTICITY_CLASS,CMISS_PROBLEM_FLUID_MECHANICS_CLASS, &
    & CMISS_PROBLEM_ELECTROMAGNETICS_CLASS, &
    & CMISS_PROBLEM_CLASSICAL_FIELD_CLASS,CMISS_PROBLEM_BIOELECTRICS_CLASS,CMISS_PROBLEM_MODAL_CLASS,CMISS_PROBLEM_FITTING_CLASS, &
    & CMISS_PROBLEM_OPTIMISATION_CLASS,CMISS_PROBLEM_MULTI_PHYSICS_CLASS

  PUBLIC CMISS_PROBLEM_NO_TYPE

  PUBLIC CMISS_PROBLEM_LINEAR_ELASTICITY_TYPE,CMISS_PROBLEM_FINITE_ELASTICITY_TYPE
  
  PUBLIC CMISS_PROBLEM_LINEAR_ELASTICITY_CONTACT_TYPE, CMISS_PROBLEM_FINITE_ELASTICITY_CONTACT_TYPE

  PUBLIC CMISS_PROBLEM_STOKES_EQUATION_TYPE,CMISS_PROBLEM_NAVIER_STOKES_EQUATION_TYPE,CMISS_PROBLEM_DARCY_EQUATION_TYPE, &
    & CMISS_PROBLEM_POISEUILLE_EQUATION_TYPE,CMISS_PROBLEM_BURGERS_EQUATION_TYPE

  PUBLIC CMISS_PROBLEM_ELECTROSTATIC_TYPE,CMISS_PROBLEM_MAGNETOSTATIC_TYPE,CMISS_PROBLEM_MAXWELLS_EQUATIONS_TYPE

  PUBLIC CMISS_PROBLEM_LAPLACE_EQUATION_TYPE,CMISS_PROBLEM_POISSON_EQUATION_TYPE,CMISS_PROBLEM_HELMHOLTZ_EQUATION_TYPE, &
    & CMISS_PROBLEM_WAVE_EQUATION_TYPE,CMISS_PROBLEM_DIFFUSION_EQUATION_TYPE,CMISS_PROBLEM_ADVECTION_DIFFUSION_EQUATION_TYPE, &
    & CMISS_PROBLEM_REACTION_DIFFUSION_EQUATION_TYPE,CMISS_PROBLEM_BIHARMONIC_EQUATION_TYPE

  PUBLIC CMISS_PROBLEM_MONODOMAIN_EQUATION_TYPE,CMISS_PROBLEM_BIDOMAIN_EQUATION_TYPE

  PUBLIC CMISS_PROBLEM_LINEAR_ELASTIC_MODAL_TYPE

  PUBLIC CMISS_PROBLEM_DATA_FITTING_TYPE

  PUBLIC CMISS_PROBLEM_FINITE_ELASTICITY_DARCY_TYPE, &
    & CMISS_PROBLEM_FINITE_ELASTICITY_STOKES_TYPE, CMISS_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_TYPE, &
    & CMISS_PROBLEM_DIFFUSION_DIFFUSION_TYPE, CMISS_PROBLEM_DIFFUSION_ADVECTION_DIFFUSION_TYPE, &
    & CMISS_PROBLEM_MULTI_COMPARTMENT_TRANSPORT_TYPE,CMISS_PROBLEM_FINITE_ELASTICITY_FLUID_PRESSURE_TYPE, &
    & CMISS_PROBLEM_BIOELECTRIC_FINITE_ELASTICITY_TYPE

  PUBLIC CMISS_PROBLEM_NO_SUBTYPE
  
  PUBLIC CMISS_PROBLEM_LE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE, CMISS_PROBLEM_LE_CONTACT_TRANSFORM_SUBTYPE, &
    & CMISS_PROBLEM_LE_CONTACT_REPROJECT_SUBTYPE
    
  PUBLIC CMISS_PROBLEM_FE_CONTACT_TRANSFORM_REPROJECT_SUBTYPE, CMISS_PROBLEM_FE_CONTACT_TRANSFORM_SUBTYPE, &
    & CMISS_PROBLEM_FE_CONTACT_REPROJECT_SUBTYPE

  PUBLIC CMISS_PROBLEM_STATIC_STOKES_SUBTYPE,CMISS_PROBLEM_LAPLACE_STOKES_SUBTYPE,CMISS_PROBLEM_TRANSIENT_STOKES_SUBTYPE, &
    & CMISS_PROBLEM_OPTIMISED_STOKES_SUBTYPE,CMISS_PROBLEM_ALE_STOKES_SUBTYPE,CMISS_PROBLEM_PGM_STOKES_SUBTYPE

  PUBLIC CMISS_PROBLEM_STATIC_NAVIER_STOKES_SUBTYPE,CMISS_PROBLEM_LAPLACE_NAVIER_STOKES_SUBTYPE, &
    & CMISS_PROBLEM_TRANSIENT_NAVIER_STOKES_SUBTYPE,CMISS_PROBLEM_TRANSIENT_SUPG_NAVIER_STOKES_SUBTYPE, &
    & CMISS_PROBLEM_1DTRANSIENT_NAVIER_STOKES_SUBTYPE,CMISS_PROBLEM_OPTIMISED_NAVIER_STOKES_SUBTYPE, &
    & CMISS_PROBLEM_ALE_NAVIER_STOKES_SUBTYPE,CMISS_PROBLEM_TRANSIENT_SUPG_NAVIER_STOKES_CMM_SUBTYPE, &
    & CMISS_PROBLEM_PGM_NAVIER_STOKES_SUBTYPE,CMISS_PROBLEM_Coupled1D0D_NAVIER_STOKES_SUBTYPE, &
    & CMISS_PROBLEM_Coupled1dDae_NAVIER_STOKES_SUBTYPE

  PUBLIC CMISS_PROBLEM_STANDARD_DARCY_SUBTYPE,CMISS_PROBLEM_QUASISTATIC_DARCY_SUBTYPE,CMISS_PROBLEM_ALE_DARCY_SUBTYPE, &
    & CMISS_PROBLEM_TRANSIENT_DARCY_SUBTYPE,CMISS_PROBLEM_PGM_DARCY_SUBTYPE,CMISS_PROBLEM_PGM_TRANSIENT_DARCY_SUBTYPE

  PUBLIC CMISS_PROBLEM_STATIC_POISEUILLE_SUBTYPE,CMISS_PROBLEM_DYNAMIC_POISEUILLE_SUBTYPE

  PUBLIC CMISS_PROBLEM_STATIC_BURGERS_SUBTYPE,CMISS_PROBLEM_DYNAMIC_BURGERS_SUBTYPE

  PUBLIC CMISS_PROBLEM_STANDARD_LAPLACE_SUBTYPE,CMISS_PROBLEM_GENERALISED_LAPLACE_SUBTYPE, &
    & CMISS_PROBLEM_MONODOMAIN_STRANG_SPLITTING_EQUATION_TYPE

  PUBLIC CMISS_PROBLEM_LINEAR_SOURCE_POISSON_SUBTYPE,CMISS_PROBLEM_NONLINEAR_SOURCE_POISSON_SUBTYPE, &
    & CMISS_PROBLEM_LINEAR_PRESSURE_POISSON_SUBTYPE,CMISS_PROBLEM_NONLINEAR_PRESSURE_POISSON_SUBTYPE, &
    & CMISS_PROBLEM_ALE_PRESSURE_POISSON_SUBTYPE, CMISS_PROBLEM_FITTED_PRESSURE_POISSON_SUBTYPE, &
    & CMISS_PROBLEM_EXTRACELLULAR_BIDOMAIN_POISSON_SUBTYPE


  PUBLIC CMISS_PROBLEM_STANDARD_HELMHOLTZ_SUBTYPE,CMISS_PROBLEM_GENERALISED_HELMHOLTZ_SUBTYPE

  PUBLIC CMISS_PROBLEM_NO_SOURCE_DIFFUSION_SUBTYPE,CMISS_PROBLEM_LINEAR_SOURCE_DIFFUSION_SUBTYPE, &
    & CMISS_PROBLEM_NONLINEAR_SOURCE_DIFFUSION_SUBTYPE

  PUBLIC CMISS_PROBLEM_NO_SOURCE_ALE_DIFFUSION_SUBTYPE,CMISS_PROBLEM_LINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE, &
    & CMISS_PROBLEM_NONLINEAR_SOURCE_ALE_DIFFUSION_SUBTYPE

  PUBLIC CMISS_PROBLEM_NO_SOURCE_ADVECTION_DIFFUSION_SUBTYPE,CMISS_PROBLEM_LINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMISS_PROBLEM_NONLINEAR_SOURCE_ADVECTION_DIFFUSION_SUBTYPE

  PUBLIC CMISS_PROBLEM_NO_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE,CMISS_PROBLEM_LINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE, &
    & CMISS_PROBLEM_NONLINEAR_SOURCE_ALE_ADVECTION_DIFFUSION_SUBTYPE

  PUBLIC CMISS_PROBLEM_NO_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE,CMISS_PROBLEM_LINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE, &
    & CMISS_PROBLEM_NONLINEAR_SOURCE_STATIC_ADVEC_DIFF_SUBTYPE

  PUBLIC CMISS_PROBLEM_CELLML_REAC_INTEG_REAC_DIFF_STRANG_SPLIT_SUBTYPE, &
    & CMISS_PROBLEM_CELLML_REAC_EVAL_REAC_DIFF_NO_SPLIT_SUBTYPE, &
    & CMISS_PROBLEM_CONSTANT_REAC_DIFF_NO_SPLIT_SUBTYPE


  PUBLIC CMISS_PROBLEM_STANDARD_DATA_FITTING_SUBTYPE,CMISS_PROBLEM_GENERALISED_DATA_FITTING_SUBTYPE, &
    & CMISS_PROBLEM_VECTOR_DATA_FITTING_SUBTYPE,CMISS_PROBLEM_DIV_FREE_VECTOR_DATA_FITTING_SUBTYPE, &
    & CMISS_PROBLEM_VECTOR_DATA_PRE_FITTING_SUBTYPE,CMISS_PROBLEM_DIV_FREE_VECTOR_DATA_PRE_FITTING_SUBTYPE, &
    & CMISS_PROBLEM_MAT_PROPERTIES_DATA_FITTING_SUBTYPE,CMISS_PROBLEM_DATA_POINT_VECTOR_STATIC_FITTING_SUBTYPE, &
    & CMISS_PROBLEM_DATA_PT_VECTOR_QUASISTATIC_FITTING_SUBTYPE

  PUBLIC CMISS_PROBLEM_MONODOMAIN_GUDUNOV_SPLIT_SUBTYPE,CMISS_PROBLEM_MONODOMAIN_STRANG_SPLIT_SUBTYPE, &
    & CMISS_PROBLEM_BIDOMAIN_GUDUNOV_SPLIT_SUBTYPE,CMISS_PROBLEM_BIDOMAIN_STRANG_SPLIT_SUBTYPE

  PUBLIC CMISS_PROBLEM_MONODOMAIN_BUENOOROVIO_SUBTYPE, CMISS_PROBLEM_MONODOMAIN_TENTUSSCHER06_SUBTYPE

  PUBLIC CMISS_PROBLEM_CONTROL_SIMPLE_TYPE,CMISS_PROBLEM_CONTROL_FIXED_LOOP_TYPE,CMISS_PROBLEM_CONTROL_TIME_LOOP_TYPE, &
    & CMISS_PROBLEM_CONTROL_WHILE_LOOP_TYPE,CMISS_PROBLEM_CONTROL_LOAD_INCREMENT_LOOP_TYPE

  PUBLIC CMISS_PROBLEM_STANDARD_ELASTICITY_DARCY_SUBTYPE, CMISS_PROBLEM_PGM_ELASTICITY_DARCY_SUBTYPE, &
   & CMISS_PROBLEM_QUASISTATIC_ELASTICITY_TRANSIENT_DARCY_SUBTYPE,CMISS_PROBLEM_QUASISTATIC_ELAST_TRANS_DARCY_MAT_SOLVE_SUBTYPE, &
   & CMISS_PROBLEM_COUPLED_SOURCE_DIFFUSION_DIFFUSION_SUBTYPE, CMISS_PROBLEM_COUPLED_SOURCE_DIFFUSION_ADVEC_DIFFUSION_SUBTYPE, &
   & CMISS_PROBLEM_STANDARD_MULTI_COMPARTMENT_TRANSPORT_SUBTYPE,CMISS_PROBLEM_STANDARD_ELASTICITY_FLUID_PRESSURE_SUBTYPE, &
   & CMISS_PROBLEM_GUDUNOV_MONODOMAIN_SIMPLE_ELASTICITY_SUBTYPE,CMISS_PROBLEM_GUDUNOV_MONODOMAIN_1D3D_ELASTICITY_SUBTYPE, &
   & CMISS_PROBLEM_MONODOMAIN_ELASTICITY_W_TITIN_SUBTYPE,CMISS_PROBLEM_FINITE_ELASTICITY_NAVIER_STOKES_ALE_SUBTYPE

  PUBLIC CMISS_PROBLEM_QUASISTATIC_FINITE_ELASTICITY_SUBTYPE,CMISS_PROBLEM_FINITE_ELASTICITY_CELLML_SUBTYPE
!!==================================================================================================================================
!!
!! PROBLEM_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Finish the creation of CellML equations for a problem. \see OPENCMISS::CMISSProblem_CellMLEquationsCreateStart
  INTERFACE CMISSProblem_CellMLEquationsCreateFinish
    MODULE PROCEDURE CMISSProblem_CellMLEquationsCreateFinishNumber
    MODULE PROCEDURE CMISSProblem_CellMLEquationsCreateFinishObj
  END INTERFACE !CMISSProblem_CellMLEquationsCreateFinish

  !>Start the creation of solver equations for a problem. \see OPENCMISS::CMISSProblem_CellMLEquationsCreateFinish
  INTERFACE CMISSProblem_CellMLEquationsCreateStart
    MODULE PROCEDURE CMISSProblem_CellMLEquationsCreateStartNumber
    MODULE PROCEDURE CMISSProblem_CellMLEquationsCreateStartObj
  END INTERFACE !CMISSProblem_CellMLEquationsCreateStart

  !>Returns the CellML equations for a problem.
  INTERFACE CMISSProblem_CellMLEquationsGet
    MODULE PROCEDURE CMISSProblem_CellMLEquationsGetNumber0
    MODULE PROCEDURE CMISSProblem_CellMLEquationsGetNumber1
    MODULE PROCEDURE CMISSProblem_CellMLEquationsGetObj0
    MODULE PROCEDURE CMISSProblem_CellMLEquationsGetObj1
  END INTERFACE !CMISSProblem_CellMLEquationsGet

  !>Finishes the process of creating a problem. \see OPENCMISS::CMISSProblem_CreateStart
  INTERFACE CMISSProblem_CreateFinish
    MODULE PROCEDURE CMISSProblem_CreateFinishNumber
    MODULE PROCEDURE CMISSProblem_CreateFinishObj
  END INTERFACE !CMISSProblem_CreateFinish

  !>Start the process of creating a problem. \see OPENCMISS::CMISSProblem_CreateFinish
  INTERFACE CMISSProblem_CreateStart
    MODULE PROCEDURE CMISSProblem_CreateStartNumber
    MODULE PROCEDURE CMISSProblem_CreateStartObj
  END INTERFACE !CMISSProblem_CreateStart

  !>Finishes the process of creating a control loop on a problem. \see OPENCMISS::CMISSProblem_ControlLoopCreateStart
  INTERFACE CMISSProblem_ControlLoopCreateFinish
    MODULE PROCEDURE CMISSProblem_ControlLoopCreateFinishNumber
    MODULE PROCEDURE CMISSProblem_ControlLoopCreateFinishObj
  END INTERFACE !CMISSProblem_ControlLoopCreateFinish

  !>Starts the process of creating a control loop on a problem. \see OPENCMISS::CMISSProblem_ControlLoopCreateFinish
  INTERFACE CMISSProblem_ControlLoopCreateStart
    MODULE PROCEDURE CMISSProblem_ControlLoopCreateStartNumber
    MODULE PROCEDURE CMISSProblem_ControlLoopCreateStartObj
  END INTERFACE !CMISSProblem_ControlLoopCreateStart

  !>Destroys the control loop for a problem.
  INTERFACE CMISSProblem_ControlLoopDestroy
    MODULE PROCEDURE CMISSProblem_ControlLoopDestroyNumber
    MODULE PROCEDURE CMISSProblem_ControlLoopDestroyObj
  END INTERFACE !CMISSProblem_ControlLoopDestroy

  !>Returns a control loop for a problem.
  INTERFACE CMISSProblem_ControlLoopGet
    MODULE PROCEDURE CMISSProblem_ControlLoopGetNumber0
    MODULE PROCEDURE CMISSProblem_ControlLoopGetNumber1
    MODULE PROCEDURE CMISSProblem_ControlLoopGetObj0
    MODULE PROCEDURE CMISSProblem_ControlLoopGetObj1
  END INTERFACE !CMISSProblem_ControlLoopGet

  !>Destroys a problem.
  INTERFACE CMISSProblem_Destroy
    MODULE PROCEDURE CMISSProblem_DestroyNumber
    MODULE PROCEDURE CMISSProblem_DestroyObj
  END INTERFACE !CMISSProblem_Destroy

  !>Solve a problem.
  INTERFACE CMISSProblem_Solve
    MODULE PROCEDURE CMISSProblem_SolveNumber
    MODULE PROCEDURE CMISSProblem_SolveObj
  END INTERFACE !CMISSProblem_Solve

  !>Returns the solver for a problem control loop.
  INTERFACE CMISSProblem_SolverGet
    MODULE PROCEDURE CMISSProblem_SolverGetNumber0
    MODULE PROCEDURE CMISSProblem_SolverGetNumber1
    MODULE PROCEDURE CMISSProblem_SolverGetObj0
    MODULE PROCEDURE CMISSProblem_SolverGetObj1
  END INTERFACE !CMISSProblem_SolverGet

  !>Set boundary conditions for solver equations according to the analytic equations.
  INTERFACE CMISSSolverEquations_BoundaryConditionsAnalytic
    MODULE PROCEDURE CMISSSolverEquations_BoundaryConditionsAnalyticNumber0
    MODULE PROCEDURE CMISSSolverEquations_BoundaryConditionsAnalyticNumber1
    MODULE PROCEDURE CMISSSolverEquations_BoundaryConditionsAnalyticObj
  END INTERFACE !CMISSSolverEquations_BoundaryConditionsAnalytic

  !>Finish the creation of solver equations for a problem. \see OPENCMISS::CMISSProblem_SolverEquationsCreateStart
  INTERFACE CMISSProblem_SolverEquationsCreateFinish
    MODULE PROCEDURE CMISSProblem_SolverEquationsCreateFinishNumber
    MODULE PROCEDURE CMISSProblem_SolverEquationsCreateFinishObj
  END INTERFACE !CMISSProblem_SolverEquationsCreateFinish

  !>Start the creation of solver equations for a problem. \see OPENCMISS::CMISSProblem_SolverEquationsCreateFinish
  INTERFACE CMISSProblem_SolverEquationsCreateStart
    MODULE PROCEDURE CMISSProblem_SolverEquationsCreateStartNumber
    MODULE PROCEDURE CMISSProblem_SolverEquationsCreateStartObj
  END INTERFACE !CMISSProblem_SolverEquationsCreateStart

  !>Destroys the solver equations for a problem.
  INTERFACE CMISSProblem_SolverEquationsDestroy
    MODULE PROCEDURE CMISSProblem_SolverEquationsDestroyNumber
    MODULE PROCEDURE CMISSProblem_SolverEquationsDestroyObj
  END INTERFACE !CMISSProblem_SolverEquationsDestroy

  !>Returns the solver equations for a problem.
  INTERFACE CMISSProblem_SolverEquationsGet
    MODULE PROCEDURE CMISSProblem_SolverEquationsGetNumber0
    MODULE PROCEDURE CMISSProblem_SolverEquationsGetNumber1
    MODULE PROCEDURE CMISSProblem_SolverEquationsGetObj0
    MODULE PROCEDURE CMISSProblem_SolverEquationsGetObj1
  END INTERFACE !CMISSProblem_SolverEquationsGet

  !>Finish the creation of solvers for a problem. \see OPENCMISS::CMISSProblem_SolversCreateStart
  INTERFACE CMISSProblem_SolversCreateFinish
    MODULE PROCEDURE CMISSProblem_SolversCreateFinishNumber
    MODULE PROCEDURE CMISSProblem_SolversCreateFinishObj
  END INTERFACE !CMISSProblem_SolversCreateFinish

  !>Start the creation of solvers for a problem. \see OPENCMISS::CMISSProblem_SolversCreateFinish
  INTERFACE CMISSProblem_SolversCreateStart
    MODULE PROCEDURE CMISSProblem_SolversCreateStartNumber
    MODULE PROCEDURE CMISSProblem_SolversCreateStartObj
  END INTERFACE !CMISSProblem_SolversCreateStart

  !>Destroy the solvers for a problem.
  INTERFACE CMISSProblem_SolversDestroy
    MODULE PROCEDURE CMISSProblem_SolversDestroyNumber
    MODULE PROCEDURE CMISSProblem_SolversDestroyObj
  END INTERFACE !CMISSProblem_SolversDestroy

  !>Returns the problem specification i.e., problem class, type and subtype for a problem.
  INTERFACE CMISSProblem_SpecificationGet
    MODULE PROCEDURE CMISSProblem_SpecificationGetNumber
    MODULE PROCEDURE CMISSProblem_SpecificationGetObj
  END INTERFACE !CMISSProblem_SpecificationGet

  !>Sets/changes the problem specification i.e., problem class, type and subtype for a problem.
  INTERFACE CMISSProblem_SpecificationSet
    MODULE PROCEDURE CMISSProblem_SpecificationSetNumber
    MODULE PROCEDURE CMISSProblem_SpecificationSetObj
  END INTERFACE !CMISSProblem_SpecificationSet

  PUBLIC CMISSProblem_CellMLEquationsCreateFinish,CMISSProblem_CellMLEquationsCreateStart

  PUBLIC CMISSProblem_CellMLEquationsGet

  PUBLIC CMISSProblem_CreateFinish,CMISSProblem_CreateStart

  PUBLIC CMISSProblem_ControlLoopCreateFinish,CMISSProblem_ControlLoopCreateStart

  PUBLIC CMISSProblem_ControlLoopDestroy

  PUBLIC CMISSProblem_ControlLoopGet

  PUBLIC CMISSProblem_Destroy

  PUBLIC CMISSProblem_Solve

  PUBLIC CMISSProblem_SolverGet

  PUBLIC CMISSSolverEquations_BoundaryConditionsAnalytic

  PUBLIC CMISSProblem_SolverEquationsCreateFinish,CMISSProblem_SolverEquationsCreateStart

  PUBLIC CMISSProblem_SolverEquationsDestroy

  PUBLIC CMISSProblem_SolverEquationsGet

  PUBLIC CMISSProblem_SolversCreateFinish,CMISSProblem_SolversCreateStart

  PUBLIC CMISSProblem_SolversDestroy

  PUBLIC CMISSProblem_SpecificationGet,CMISSProblem_SpecificationSet

!!==================================================================================================================================
!!
!! REGION_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !Module types

  !Module variables

  !Interfaces

  !>Returns the coordinate system of region.
  INTERFACE CMISSRegion_CoordinateSystemGet
    MODULE PROCEDURE CMISSRegion_CoordinateSystemGetNumber
    MODULE PROCEDURE CMISSRegion_CoordinateSystemGetObj
  END INTERFACE !CMISSRegion_CoordinateSystemGet

  !>Sets/changes the coordinate system of region.
  INTERFACE CMISSRegion_CoordinateSystemSet
    MODULE PROCEDURE CMISSRegion_CoordinateSystemSetNumber
    MODULE PROCEDURE CMISSRegion_CoordinateSystemSetObj
  END INTERFACE !CMISSRegion_CoordinateSystemSet

  !>Finishes the creation of a region. \see OPENCMISS::CMISSRegion_CreateStart
  INTERFACE CMISSRegion_CreateFinish
    MODULE PROCEDURE CMISSRegion_CreateFinishNumber
    MODULE PROCEDURE CMISSRegion_CreateFinishObj
  END INTERFACE !CMISSRegion_CreateFinish

  !>Starts the creation of a region. \see OPENCMISS::CMISSRegion_CreateFinish
  INTERFACE CMISSRegion_CreateStart
    MODULE PROCEDURE CMISSRegion_CreateStartNumber
    MODULE PROCEDURE CMISSRegion_CreateStartObj
  END INTERFACE !CMISSRegion_CreateStart

  !>Returns the data points for a region.
  INTERFACE CMISSRegion_DataPointsGet
    MODULE PROCEDURE CMISSRegion_DataPointsGetObj
  END INTERFACE !CMISSRegion_DataPointsGet

  !>Destroys a region.
  INTERFACE CMISSRegion_Destroy
    MODULE PROCEDURE CMISSRegion_DestroyNumber
    MODULE PROCEDURE CMISSRegion_DestroyObj
  END INTERFACE !CMISSRegion_Destroy

  !>Returns the label of a region.
  INTERFACE CMISSRegion_LabelGet
    MODULE PROCEDURE CMISSRegion_LabelGetCNumber
    MODULE PROCEDURE CMISSRegion_LabelGetCObj
    MODULE PROCEDURE CMISSRegion_LabelGetVSNumber
    MODULE PROCEDURE CMISSRegion_LabelGetVSObj
  END INTERFACE !CMISSRegion_LabelGet

  !>Sets/changes the label of a region.
  INTERFACE CMISSRegion_LabelSet
    MODULE PROCEDURE CMISSRegion_LabelSetCNumber
    MODULE PROCEDURE CMISSRegion_LabelSetCObj
    MODULE PROCEDURE CMISSRegion_LabelSetVSNumber
    MODULE PROCEDURE CMISSRegion_LabelSetVSObj
  END INTERFACE !CMISSRegion_LabelSet

  !>Returns the nodes for a region.
  INTERFACE CMISSRegion_NodesGet
    MODULE PROCEDURE CMISSRegion_NodesGetObj
  END INTERFACE !CMISSRegion_NodesGet

  PUBLIC CMISSRegion_CoordinateSystemGet,CMISSRegion_CoordinateSystemSet

  PUBLIC CMISSRegion_CreateFinish,CMISSRegion_CreateStart

  PUBLIC CMISSRegion_DataPointsGet

  PUBLIC CMISSRegion_Destroy

  PUBLIC CMISSRegion_LabelGet,CMISSRegion_LabelSet

  PUBLIC CMISSRegion_NodesGet

!!==================================================================================================================================
!!
!! SOLVER_ROUTINES
!!
!!==================================================================================================================================

  !Module parameters

  !> \addtogroup OPENCMISS_SolverConstants OPENCMISS::Solver::Constants
  !> \brief Solver constants.
  !>@{
  !> \addtogroup OPENCMISS_SolverTypes OPENCMISS::Solver::SolverTypes
  !> \brief The types of solver
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_LINEAR_TYPE = SOLVER_LINEAR_TYPE !<A linear solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NONLINEAR_TYPE = SOLVER_NONLINEAR_TYPE !<A nonlinear solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_TYPE = SOLVER_DYNAMIC_TYPE !<A dynamic solver. \see  OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_TYPE = SOLVER_DAE_TYPE !<A differential-algebraic equation solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_EIGENPROBLEM_TYPE = SOLVER_EIGENPROBLEM_TYPE !<A eigenproblem solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_OPTIMISER_TYPE = SOLVER_OPTIMISER_TYPE !<An optimiser solver. \see OPENCMISS_SolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISSSolverCellMLEvaluatorType = SOLVER_CELLML_EVALUATOR_TYPE !<A CellML evaluator solver. \see OPENCMISS_SolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_SolverLibraries OPENCMISS::Solver::SolverLibraries
  !> \brief The types of solver libraries.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_CMISS_LIBRARY = SOLVER_CMISS_LIBRARY !<CMISS (internal) solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_PETSC_LIBRARY = SOLVER_PETSC_LIBRARY !<PETSc solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_MUMPS_LIBRARY = SOLVER_MUMPS_LIBRARY !<MUMPS solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_SUPERLU_LIBRARY = SOLVER_SUPERLU_LIBRARY !<SuperLU solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_SPOOLES_LIBRARY = SOLVER_SPOOLES_LIBRARY !<SPOOLES solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_UMFPACK_LIBRARY = SOLVER_UMFPACK_LIBRARY !<UMFPACK solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_LUSOL_LIBRARY = SOLVER_LUSOL_LIBRARY !<LUSOL solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ESSL_LIBRARY = SOLVER_ESSL_LIBRARY !<ESSL solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_LAPACK_LIBRARY = SOLVER_LAPACK_LIBRARY !<LAPACK solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_TAO_LIBRARY = SOLVER_TAO_LIBRARY !<TAO solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_HYPRE_LIBRARY = SOLVER_HYPRE_LIBRARY !<Hypre solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_PASTIX_LIBRARY = SOLVER_PASTIX_LIBRARY !<PaStiX solver library. \see OPENCMISS_SolverLibraries,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_LinearSolverTypes OPENCMISS::Solver::LinearSolverTypes
  !> \brief The types of linear solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_LINEAR_DIRECT_SOLVE_TYPE = SOLVER_LINEAR_DIRECT_SOLVE_TYPE !<Direct linear solver type. \see OPENCMISS_LinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE = SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE !<Iterative linear solver type. \see OPENCMISS_LinearSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DirectLinearSolverTypes OPENCMISS::Solver::DirectLinearSolverTypes
  !> \brief The types of direct linear solvers. \todo Move libraries to a more appropriate place.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DIRECT_LU = SOLVER_DIRECT_LU !<LU direct linear solver. \see OPENCMISS_DirectLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DIRECT_CHOLESKY = SOLVER_DIRECT_CHOLESKY !<Cholesky direct linear solver. \see OPENCMISS_DirectLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DIRECT_SVD = SOLVER_DIRECT_SVD !<SVD direct linear solver. \see OPENCMISS_DirectLinearSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_IterativeLinearSolverTypes OPENCMISS::Solver::IterativeLinearSolverTypes
  !> \brief The types of iterative linear solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_RICHARDSON = SOLVER_ITERATIVE_RICHARDSON !<Richardson iterative solver type. \see  OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
#if ( PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 3 )
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_CHEBYSHEV = SOLVER_ITERATIVE_CHEBYSHEV !<Chebychev iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
#else  
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_CHEBYCHEV = SOLVER_ITERATIVE_CHEBYCHEV !<Chebychev iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
#endif
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_CONJUGATE_GRADIENT = SOLVER_ITERATIVE_CONJUGATE_GRADIENT !<Conjugate gradient iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_BICONJUGATE_GRADIENT = SOLVER_ITERATIVE_BICONJUGATE_GRADIENT !<Bi-conjugate gradient iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_GMRES = SOLVER_ITERATIVE_GMRES !<Generalised minimum residual iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_BiCGSTAB = SOLVER_ITERATIVE_BiCGSTAB !<Stabalised bi-conjugate gradient iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_CONJGRAD_SQUARED = SOLVER_ITERATIVE_CONJGRAD_SQUARED !<Conjugate gradient squared iterative solver type. \see OPENCMISS_IterativeLinearSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_IterativePreconditionerTypes OPENCMISS::Solver::IterativePreconditionerTypes
  !> \brief The types of iterative preconditioners.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_NO_PRECONDITIONER = SOLVER_ITERATIVE_NO_PRECONDITIONER !<No preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_JACOBI_PRECONDITIONER = SOLVER_ITERATIVE_JACOBI_PRECONDITIONER !<Jacobi preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER = SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER !<Iterative block Jacobi preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_SOR_PRECONDITIONER = SOLVER_ITERATIVE_SOR_PRECONDITIONER !<Successive over relaxation preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER = &
    & SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER !<Incomplete Cholesky preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER = SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER !<Incomplete LU preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER =  &
    & SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER !<Additive Schwrz preconditioner type. \see OPENCMISS_IterativePreconditionerTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_NonlinearSolverTypes OPENCMISS::Solver::NonlinearSolverTypes
  !> \brief The types of nonlinear solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NONLINEAR_NEWTON = SOLVER_NONLINEAR_NEWTON !<Newton nonlinear solver type. \see OPENCMISS_NonlinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NONLINEAR_BFGS_INVERSE = SOLVER_NONLINEAR_BFGS_INVERSE !<BFGS inverse nonlinear solver type. \see OPENCMISS_NonlinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NONLINEAR_SQP = SOLVER_NONLINEAR_SQP !<Sequential Quadratic Program nonlinear solver type. \see OPENCMISS_NonlinearSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NONLINEAR_QUASI_NEWTON = SOLVER_NONLINEAR_QUASI_NEWTON !<Quasi-Newton nonlinear solver type. \see OPENCMISS_NonlinearSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_QuasiNewtonSolverTypes OPENCMISS::Solver::QuasiNewtonSolverTypes
  !> \brief The types of nonlinear Quasi-Newton solvers
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_QUASI_NEWTON_LINESEARCH=SOLVER_QUASI_NEWTON_LINESEARCH !<Quasi-Newton line search nonlinear solver type \see OPENCMISS_QuasiNewtonSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_QUASI_NEWTON_TRUSTREGION=SOLVER_QUASI_NEWTON_TRUSTREGION !<Quasi-Newton trust region nonlinear solver type \see OPENCMISS_QuasiNewtonSolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_QuasiNewtonTypes OPENCMISS::Solver::QuasiNewtonTypes
  !> \brief The nonlinear Quasi-Newton types
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_QUASI_NEWTON_LBFGS=SOLVER_QUASI_NEWTON_LBFGS !<LBFGS Quasi-Newton type \see OPENCMISS_QuasiNewtonTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_QUASI_NEWTON_GOODBROYDEN=SOLVER_QUASI_NEWTON_GOODBROYDEN !<"Good" Broyden Quasi-Newton type \see OPENCMISS_QuasiNewtonTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_QUASI_NEWTON_BADBROYDEN=SOLVER_QUASI_NEWTON_BADBROYDEN !<"Bad" Broyden Quasi-Newton type \see OPENCMISS_QuasiNewtonTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_QuasiNewtonLineSearchTypes OPENCMISS::Solver::NonlinearQuasiNewtonLineSearchTypes
  !> \brief The types line search techniques for Quasi-Newton line search nonlinear solvers
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_QUASI_NEWTON_LINESEARCH_BASIC=SOLVER_QUASI_NEWTON_LINESEARCH_BASIC !<Simple damping line search. \see OPENCMISS_QuasiNewtonLineSearchTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_QUASI_NEWTON_LINESEARCH_L2=SOLVER_QUASI_NEWTON_LINESEARCH_L2 !<Secant line search over the L2 norm of the function \see OPENCMISS_QuasiNewtonLineSearchTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_QUASI_NEWTON_LINESEARCH_CP=SOLVER_QUASI_NEWTON_LINESEARCH_CP !<Critical point secant line search \see OPENCMISS_QuasiNewtonLineSearchTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_QuasiNewtonRestartTypes OPENCMISS::Solver::QuasiNewtonRestartTypes
  !> \brief The nonlinear Quasi-Newton restart types
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_QUASI_NEWTON_RESTART_NONE=SOLVER_QUASI_NEWTON_RESTART_NONE !<Never restart \see OPENCMISS_QuasiNewtonRestartTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_QUASI_NEWTON_RESTART_POWELL=SOLVER_QUASI_NEWTON_RESTART_POWELL !<Restart based upon descent criteria \see OPENCMISS_QuasiNewtonRestartTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_QUASI_NEWTON_RESTART_PERIODIC=SOLVER_QUASI_NEWTON_RESTART_PERIODIC !<Restart after a fixed number of iterations \see OPENCMISS_QuasiNewtonRestartTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_QuasiNewtonScaleTypes OPENCMISS::Solver::QuasiNewtonScaleTypes
  !> \brief The nonlinear Quasi-Newton scale types
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_QUASI_NEWTON_SCALE_NONE=SOLVER_QUASI_NEWTON_SCALE_NONE !<Don't scale the problem \see OPENCMISS_QuasiNewtonScaleTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_QUASI_NEWTON_SCALE_SHANNO=SOLVER_QUASI_NEWTON_SCALE_SHANNO !<Use Shanno scaling \see OPENCMISS_QuasiNewtonScaleTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_QUASI_NEWTON_SCALE_LINESEARCH=SOLVER_QUASI_NEWTON_SCALE_LINESEARCH !<Scale based upon line search lambda \see OPENCMISS_QuasiNewtonScaleTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_QUASI_NEWTON_SCALE_JACOBIAN=SOLVER_QUASI_NEWTON_SCALE_JACOBIAN !<Scale by inverting a previously computed Jacobian \see OPENCMISS_QuasiNewtonScaleTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_NewtonSolverTypes OPENCMISS::Solver::NewtonSolverTypes
  !> \brief The types of nonlinear Newton solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_LINESEARCH = SOLVER_NEWTON_LINESEARCH !<Newton line search nonlinear solver type. \see OPENCMISS_NewtonSolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_TRUSTREGION = SOLVER_NEWTON_TRUSTREGION !<Newton trust region nonlinear solver type. \see OPENCMISS_NewtonSolverTypes,OPENCMISS
  !>@}
#if ( PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 3 )
  !> \addtogroup OPENCMISS_NewtonLineSearchTypes OPENCMISS::Solver::NewtonLineSearchTypes
  !> \brief The types line search techniques for Newton line search nonlinear solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_LINESEARCH_LINEAR = SOLVER_NEWTON_LINESEARCH_LINEAR !<Linear line search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_LINESEARCH_QUADRATIC = SOLVER_NEWTON_LINESEARCH_QUADRATIC !<Quadratic search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_LINESEARCH_CUBIC = SOLVER_NEWTON_LINESEARCH_CUBIC !<Cubic search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  !>@}
#else
  !> \addtogroup OPENCMISS_NewtonLineSearchTypes OPENCMISS::Solver::NewtonLineSearchTypes
  !> \brief The types line search techniques for Newton line search nonlinear solvers.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_LINESEARCH_NONORMS = SOLVER_NEWTON_LINESEARCH_NONORMS !<No norms line search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_LINESEARCH_NONE = SOLVER_NEWTON_LINESEARCH_NONE !<No line search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_LINESEARCH_QUADRATIC = SOLVER_NEWTON_LINESEARCH_QUADRATIC !<Quadratic search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_LINESEARCH_CUBIC = SOLVER_NEWTON_LINESEARCH_CUBIC !<Cubic search for Newton line search nonlinear solves \see OPENCMISS_NewtonLineSearchTypes,OPENCMISS
  !>@}
#endif  
  !> \addtogroup OPENCMISS_JacobianCalculationTypes OPENCMISS::Solver::JacobianCalculationTypes
  !> \brief The Jacobian calculation types for a nonlinear solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED = SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED !<The Jacobian values will not be calculated for the nonlinear equations set. \see OPENCMISS_JacobianCalculationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED = SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED !<The Jacobian values will be calculated analytically for the nonlinear equations set. \see OPENCMISS_JacobianCalculationTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_JACOBIAN_FD_CALCULATED = SOLVER_NEWTON_JACOBIAN_FD_CALCULATED !<The Jacobian values will be calcualted using finite differences for the nonlinear equations set. \see OPENCMISS_JacobianCalculationTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_NewtonConvergenceTypes OPENCMISS::Solver::NewtonConvergenceTypes
  !> \brief The convergence test types for a nonlinear newton solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT = SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT !<Newton solver Petsc default convergence test type. \see OPENCMISS_NewtonConvergenceTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM = SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM !<Newton solver energy norm convergence test type. \see OPENCMISS_NewtonConvergenceTypes,OPENCMISS 
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO = SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO !<Newton solver Sum of differentiated ratios of unconstrained to constrained residuals convergence test type. \see OPENCMISS_NewtonConvergenceTypes,OPENCMISS 
  !>@}
  !> \addtogroup OPENCMISS_DynamicOrderTypes OPENCMISS::Solver::DynamicOrderTypes
  !> \brief The order types for a dynamic solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_FIRST_ORDER = SOLVER_DYNAMIC_FIRST_ORDER !<Dynamic solver has first order terms. \see OPENCMISS_DynamicOrderTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_SECOND_ORDER = SOLVER_DYNAMIC_SECOND_ORDER !<Dynamic solver has second order terms. \see OPENCMISS_DynamicOrderTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DynamicLinearityTypes OPENCMISS::Solver::DynamicLinearityTypes
  !> \brief The time linearity types for a dynamic solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_LINEAR = SOLVER_DYNAMIC_LINEAR !<Dynamic solver has linear terms. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_NONLINEAR = SOLVER_DYNAMIC_NONLINEAR !<Dynamic solver has nonlinear terms. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DynamicDegreeTypes OPENCMISS::Solver::DynamicDegreeTypes
  !> \brief The time interpolation polynomial degree types for a dynamic solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_FIRST_DEGREE = SOLVER_DYNAMIC_FIRST_DEGREE !<Dynamic solver uses a first degree polynomial for time interpolation. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_SECOND_DEGREE = SOLVER_DYNAMIC_SECOND_DEGREE !<Dynamic solver uses a second degree polynomial for time interpolation. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_THIRD_DEGREE = SOLVER_DYNAMIC_THIRD_DEGREE !<Dynamic solver uses a third degree polynomial for time interpolation. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DynamicSchemeTypes OPENCMISS::Solver::DynamicSchemeTypes
  !> \brief The types of dynamic solver scheme.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_EULER_SCHEME = SOLVER_DYNAMIC_EULER_SCHEME !<Euler (explicit) dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME = SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME !<Backward Euler (implicit) dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME = SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME !<Crank-Nicolson dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_GALERKIN_SCHEME = SOLVER_DYNAMIC_GALERKIN_SCHEME !<Galerkin dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_ZLAMAL_SCHEME = SOLVER_DYNAMIC_ZLAMAL_SCHEME !<Zlamal dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME = SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME !<2nd degree Gear dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME = SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME !<1st 2nd degree Liniger dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME = SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME !<2nd 2nd degree Liniger dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_NEWMARK1_SCHEME = SOLVER_DYNAMIC_NEWMARK1_SCHEME !<1st Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_NEWMARK2_SCHEME = SOLVER_DYNAMIC_NEWMARK2_SCHEME !<2nd Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_NEWMARK3_SCHEME = SOLVER_DYNAMIC_NEWMARK3_SCHEME !<3rd Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME = SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME !<3rd degree Gear dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME = SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME !<1st 3rd degree Liniger dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME = SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME !<2nd 3rd degree Liniger dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_HOUBOLT_SCHEME = SOLVER_DYNAMIC_HOUBOLT_SCHEME !<Houbolt dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_WILSON_SCHEME = SOLVER_DYNAMIC_WILSON_SCHEME !<Wilson dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME = SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME !<1st Bossak-Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME = SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME !<2nd Bossak-Newmark dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME = SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME !<1st Hilbert-Hughes-Taylor dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME = SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME !<1st Hilbert-Hughes-Taylor dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DYNAMIC_USER_DEFINED_SCHEME = SOLVER_DYNAMIC_USER_DEFINED_SCHEME !<User specified degree and theta dynamic solver. \see OPENCMISS_DynamicSchemeTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DAETypes OPENCMISS::Solver::DAETypes
  !> \brief The type of differential-algebraic equation.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_DIFFERENTIAL_ONLY = SOLVER_DAE_DIFFERENTIAL_ONLY !<Differential equations only. \see OPENCMISS_DAETypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_INDEX_1 = SOLVER_DAE_INDEX_1 !<Index 1 differential-algebraic equation. \see OPENCMISS_DAETypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_INDEX_2 = SOLVER_DAE_INDEX_2 !<Index 2 differential-algebraic equation. \see OPENCMISS_DAETypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_INDEX_3 = SOLVER_DAE_INDEX_3 !<Index 3 differential-algebraic equation. \see OPENCMISS_DAETypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_DAESolverTypes OPENCMISS::Solver::DAESolverTypes
  !> \brief The differential-algebraic equation solver types for a differential-algebraic equation solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_EULER = SOLVER_DAE_EULER !<Euler differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_CRANK_NICOLSON = SOLVER_DAE_CRANK_NICOLSON !<Crank-Nicolson differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_RUNGE_KUTTA = SOLVER_DAE_RUNGE_KUTTA !<Runge-Kutta differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_ADAMS_MOULTON = SOLVER_DAE_ADAMS_MOULTON !<Adams-Moulton differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_BDF = SOLVER_DAE_BDF !<General BDF differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_RUSH_LARSON = SOLVER_DAE_RUSH_LARSON !<Rush-Larson differential-algebraic equation solver. \see
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_EXTERNAL = SOLVER_DAE_EXTERNAL !<External (e.g., CellML generated) differential-algebraic equation solver. \see
  !>@}
  !> \addtogroup OPENCMISS_EulerDAESolverTypes OPENCMISS::Solver::EulerDAESolverTypes
  !> \brief The Euler solver types for a differential-algebriac equation solver.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_EULER_FORWARD = SOLVER_DAE_EULER_FORWARD !<Forward Euler differential equation solver. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_EULER_BACKWARD = SOLVER_DAE_EULER_BACKWARD !<Backward Euler differential equation solver. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_DAE_EULER_IMPROVED = SOLVER_DAE_EULER_IMPROVED !<Improved Euler differential equation solver. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_SolutionInitialiseTypes OPENCMISS::Solver::SolutionInitialiseTypes
  !> \brief The types of solution initialisation.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_SOLUTION_INITIALISE_ZERO = SOLVER_SOLUTION_INITIALISE_ZERO !<Initialise the solution by zeroing it before a solve. \see OPENCMISS_SolutionInitialiseTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD = SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD !<Initialise the solution by copying in the current dependent field values. \see OPENCMISS_SolutionInitialiseTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_SOLUTION_INITIALISE_NO_CHANGE = SOLVER_SOLUTION_INITIALISE_NO_CHANGE !<Do not change the solution before a solve. \see OPENCMISS_SolutionInitialiseTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_SolverOutputTypes OPENCMISS::Solver::OutputTypes
  !> \brief The types of output.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_NO_OUTPUT = SOLVER_NO_OUTPUT !<No output from the solver routines. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_PROGRESS_OUTPUT = SOLVER_PROGRESS_OUTPUT !<Progress output from solver routines. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_TIMING_OUTPUT = SOLVER_TIMING_OUTPUT !<Timing output from the solver routines plus below. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_SOLVER_OUTPUT = SOLVER_SOLVER_OUTPUT !<Solver specific output from the solver routines plus below. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_MATRIX_OUTPUT = SOLVER_MATRIX_OUTPUT !<Solver matrices output from the solver routines plus below. \see OPENCMISS_SolverOutputTypes,OPENCMISS
  !>@}
  !> \addtogroup OPENCMISS_SolverEquationsSparsityTypes OPENCMISS::SolverEquations::SparsityTypes
  !> \brief The types of sparse solver equations matrices.
  !> \see OPENCMISS::Solver::Constants,OPENCMISS
  !>@{
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_SPARSE_MATRICES = SOLVER_SPARSE_MATRICES !<Use sparse solver matrices. \see OPENCMISS_SolverEquationsSparsityTypes,OPENCMISS
  INTEGER(INTG), PARAMETER :: CMISS_SOLVER_FULL_MATRICES = SOLVER_FULL_MATRICES !<Use fully populated solver matrices. \see OPENCMISS_SolverEquationsSparsityTypes,OPENCMISS
  !>@}
  !>@}

  !Module types

  !Module variables

  !Interfaces

  !>Returns the CellML equations for a solver.
  INTERFACE CMISSSolver_CellMLEquationsGet
    MODULE PROCEDURE CMISSSolver_CellMLEquationsGetNumber0
    MODULE PROCEDURE CMISSSolver_CellMLEquationsGetNumber1
    MODULE PROCEDURE CMISSSolver_CellMLEquationsGetObj
  END INTERFACE !CMISSSolver_CellMLEquationsGet

  !>Adds CellML environments to CellML equations.
  INTERFACE CMISSCellMLEquations_CellMLAdd
    MODULE PROCEDURE CMISSCellMLEquations_CellMLAddNumber0
    MODULE PROCEDURE CMISSCellMLEquations_CellMLAddNumber1
    MODULE PROCEDURE CMISSCellMLEquations_CellMLAddObj
  END INTERFACE !CMISSCellMLEquations_CellMLAdd

  !>Returns the solver type for an Euler differential-algebraic equation solver. \todo should this be CMISSSolver_DAEEulerSolverTypeGet???
  INTERFACE CMISSSolver_DAEEulerSolverTypeGet
    MODULE PROCEDURE CMISSSolver_DAEEulerSolverTypeGetNumber0
    MODULE PROCEDURE CMISSSolver_DAEEulerSolverTypeGetNumber1
    MODULE PROCEDURE CMISSSolver_DAEEulerSolverTypeGetObj
  END INTERFACE !CMISSSolver_DAEEulerSolverTypeGet

  !>Sets/changes the solver type for an Euler differential-algebraic equation solver. \todo should this be CMISSSolver_DAEEulerSolverTypeSet???
  INTERFACE CMISSSolver_DAEEulerSolverTypeSet
    MODULE PROCEDURE CMISSSolver_DAEEulerSolverTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_DAEEulerSolverTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_DAEEulerSolverTypeSetObj
  END INTERFACE !CMISSSolver_DAEEulerSolverTypeSet

  !>Returns the solver type for an differential-algebraic equation solver.
  INTERFACE CMISSSolver_DAESolverTypeGet
    MODULE PROCEDURE CMISSSolver_DAESolverTypeGetNumber0
    MODULE PROCEDURE CMISSSolver_DAESolverTypeGetNumber1
    MODULE PROCEDURE CMISSSolver_DAESolverTypeGetObj
  END INTERFACE !CMISSSolver_DAESolverTypeGet

  !>Sets/changes the solver type for an differential-algebraic equation solver.
  INTERFACE CMISSSolver_DAESolverTypeSet
    MODULE PROCEDURE CMISSSolver_DAESolverTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_DAESolverTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_DAESolverTypeSetObj
  END INTERFACE !CMISSSolver_DAESolverTypeSet

  !>Sets/changes the times for a differential-algebraic equation solver.
  INTERFACE CMISSSolver_DAETimesSet
    MODULE PROCEDURE CMISSSolver_DAETimesSetNumber0
    MODULE PROCEDURE CMISSSolver_DAETimesSetNumber1
    MODULE PROCEDURE CMISSSolver_DAETimesSetObj
  END INTERFACE !CMISSSolver_DAETimesSet

  !>Sets/changes the (initial) time step for a differential-algebraic equation solver.
  INTERFACE CMISSSolver_DAETimeStepSet
    MODULE PROCEDURE CMISSSolver_DAETimeStepSetNumber0
    MODULE PROCEDURE CMISSSolver_DAETimeStepSetNumber1
    MODULE PROCEDURE CMISSSolver_DAETimeStepSetObj
  END INTERFACE !CMISSSolver_DAETimeStepSet

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver.
  INTERFACE CMISSSolver_DynamicDegreeGet
    MODULE PROCEDURE CMISSSolver_DynamicDegreeGetNumber0
    MODULE PROCEDURE CMISSSolver_DynamicDegreeGetNumber1
    MODULE PROCEDURE CMISSSolver_DynamicDegreeGetObj
  END INTERFACE !CMISSSolver_DynamicDegreeGet

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver.
  INTERFACE CMISSSolver_DynamicDegreeSet
    MODULE PROCEDURE CMISSSolver_DynamicDegreeSetNumber0
    MODULE PROCEDURE CMISSSolver_DynamicDegreeSetNumber1
    MODULE PROCEDURE CMISSSolver_DynamicDegreeSetObj
  END INTERFACE !CMISSSolver_DynamicDegreeSet

  !>Returns the linearity type for the dynamic solver.
  INTERFACE CMISSSolver_DynamicLinearityTypeGet
    MODULE PROCEDURE CMISSSolver_DynamicLinearityTypeGetNumber0
    MODULE PROCEDURE CMISSSolver_DynamicLinearityTypeGetNumber1
    MODULE PROCEDURE CMISSSolver_DynamicLinearityTypeGetObj
  END INTERFACE !CMISSSolver_DynamicLinearityTypeGet

  !>Returns the linear solver associated with a linear dynamic solver.
  INTERFACE CMISSSolver_DynamicLinearSolverGet
    MODULE PROCEDURE CMISSSolver_DynamicLinearSolverGetNumber0
    MODULE PROCEDURE CMISSSolver_DynamicLinearSolverGetNumber1
    MODULE PROCEDURE CMISSSolver_DynamicLinearSolverGetObj
  END INTERFACE !CMISSSolver_DynamicNonlinearSolverGet

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver.
  INTERFACE CMISSSolver_DynamicNonlinearSolverGet
    MODULE PROCEDURE CMISSSolver_DynamicNonlinearSolverGetNumber0
    MODULE PROCEDURE CMISSSolver_DynamicNonlinearSolverGetNumber1
    MODULE PROCEDURE CMISSSolver_DynamicNonlinearSolverGetObj
  END INTERFACE !CMISSSolver_DynamicNonlinearSolverGet

  !>Sets/changes the scheme for a dynamic solver.
  INTERFACE CMISSSolver_DynamicSchemeSet
    MODULE PROCEDURE CMISSSolver_DynamicSchemeSetNumber0
    MODULE PROCEDURE CMISSSolver_DynamicSchemeSetNumber1
    MODULE PROCEDURE CMISSSolver_DynamicSchemeSetObj
  END INTERFACE !CMISSSolver_DynamicSchemeSet

  !>Sets/changes the theta scheme values for a dynamic solver.
  INTERFACE CMISSSolver_DynamicThetaSet
    MODULE PROCEDURE CMISSSolver_DynamicThetaSetNumber00
    MODULE PROCEDURE CMISSSolver_DynamicThetaSetNumber01
    MODULE PROCEDURE CMISSSolver_DynamicThetaSetNumber10
    MODULE PROCEDURE CMISSSolver_DynamicThetaSetNumber11
    MODULE PROCEDURE CMISSSolver_DynamicThetaSetObj0
    MODULE PROCEDURE CMISSSolver_DynamicThetaSetObj1
  END INTERFACE !CMISSSolver_DynamicThetaSet

  !>Sets/changes the dynamic times for a dynamic solver.
  INTERFACE CMISSSolver_DynamicTimesSet
    MODULE PROCEDURE CMISSSolver_DynamicTimesSetNumber0
    MODULE PROCEDURE CMISSSolver_DynamicTimesSetNumber1
    MODULE PROCEDURE CMISSSolver_DynamicTimesSetObj
  END INTERFACE !CMISSSolver_DynamicTimesSet
  
  !Sets the arbitrary path logical for the transformation
  INTERFACE CMISSSolver_GeometricTransformationArbitraryPathSet
    MODULE PROCEDURE CMISSSolver_GeometricTransformationArbitraryPathSetNumber
    MODULE PROCEDURE CMISSSolver_GeometricTransformationArbitraryPathSetObj
  END INTERFACE CMISSSolver_GeometricTransformationArbitraryPathSet
  
  !Clear transformation for a geometric transformation solver
  INTERFACE CMISSSolver_GeometricTransformationClear
    MODULE PROCEDURE CMISSSolver_GeometricTransformationClearNumber
    MODULE PROCEDURE CMISSSolver_GeometricTransformationClearObj
  END INTERFACE CMISSSolver_GeometricTransformationClear
  
  !Sets the field to transform
  INTERFACE CMISSSolver_GeometricTransformationFieldSet
    MODULE PROCEDURE CMISSSolver_GeometricTransformationFieldSetNumber
    MODULE PROCEDURE CMISSSolver_GeometricTransformationFieldSetObj
  END INTERFACE CMISSSolver_GeometricTransformationFieldSet
  
  !Sets the full transformation matrix for a geometric transformation
  INTERFACE CMISSSolver_GeometricTransformationMatrixSet
    MODULE PROCEDURE CMISSSolver_GeometricTransformationMatrixSetNumber0
    MODULE PROCEDURE CMISSSolver_GeometricTransformationMatrixSetObj0
    MODULE PROCEDURE CMISSSolver_GeometricTransformationMatrixSetNumber1
    MODULE PROCEDURE CMISSSolver_GeometricTransformationMatrixSetObj1
  END INTERFACE CMISSSolver_GeometricTransformationMatrixSet
  
  !Sets number of load increments for the transformation
  INTERFACE CMISSSolver_GeometricTransformationNumberOfLoadIncrementsSet
    MODULE PROCEDURE CMISSSolver_GeometricTransformationNoLoadIncrementsSetNumber
    MODULE PROCEDURE CMISSSolver_GeometricTransformationNoLoadIncrementsSetObj
  END INTERFACE CMISSSolver_GeometricTransformationNumberOfLoadIncrementsSet
  
  !Sets the rotation for a geometric transformation
  INTERFACE CMISSSolver_GeometricTransformationRotationSet
    MODULE PROCEDURE CMISSSolver_GeometricTransformationRotationSetNumber0
    MODULE PROCEDURE CMISSSolver_GeometricTransformationRotationSetObj0
    MODULE PROCEDURE CMISSSolver_GeometricTransformationRotationSetNumber1
    MODULE PROCEDURE CMISSSolver_GeometricTransformationRotationSetObj1
  END INTERFACE CMISSSolver_GeometricTransformationRotationSet
  
  !Sets the scalings for a uni-directional geometric transformation
  INTERFACE CMISSSolver_GeometricTransformationScalingsSet
    MODULE PROCEDURE CMISSSolver_GeometricTransformationScalingsSetNumber
    MODULE PROCEDURE CMISSSolver_GeometricTransformationScalingsSetObj
  END INTERFACE CMISSSolver_GeometricTransformationScalingsSet
  
  !Sets the translation for a geometric transformation
  INTERFACE CMISSSolver_GeometricTransformationTranslationSet
    MODULE PROCEDURE CMISSSolver_GeometricTransformationTranslationSetNumber0
    MODULE PROCEDURE CMISSSolver_GeometricTransformationTranslationSetObj0
    MODULE PROCEDURE CMISSSolver_GeometricTransformationTranslationSetNumber1
    MODULE PROCEDURE CMISSSolver_GeometricTransformationTranslationSetObj1
  END INTERFACE CMISSSolver_GeometricTransformationTranslationSet

  !>Returns the label of a solver.
  INTERFACE CMISSSolver_LabelGet
    MODULE PROCEDURE CMISSSolver_LabelGetCNumber0
    MODULE PROCEDURE CMISSSolver_LabelGetCNumber1
    MODULE PROCEDURE CMISSSolver_LabelGetCObj
    MODULE PROCEDURE CMISSSolver_LabelGetVSNumber0
    MODULE PROCEDURE CMISSSolver_LabelGetVSNumber1
    MODULE PROCEDURE CMISSSolver_LabelGetVSObj
  END INTERFACE !CMISSSolver_LabelGet

  !>Sets/changes the label of a control loop.
  INTERFACE CMISSSolver_LabelSet
    MODULE PROCEDURE CMISSSolver_LabelSetCNumber0
    MODULE PROCEDURE CMISSSolver_LabelSetCNumber1
    MODULE PROCEDURE CMISSSolver_LabelSetCObj
    MODULE PROCEDURE CMISSSolver_LabelSetVSNumber0
    MODULE PROCEDURE CMISSSolver_LabelSetVSNumber1
    MODULE PROCEDURE CMISSSolver_LabelSetVSObj
  END INTERFACE !CMISSSolver_LabelSet

  !>Returns the type of library to use for the solver.
  INTERFACE CMISSSolver_LibraryTypeGet
    MODULE PROCEDURE CMISSSolver_LibraryTypeGetNumber0
    MODULE PROCEDURE CMISSSolver_LibraryTypeGetNumber1
    MODULE PROCEDURE CMISSSolver_LibraryTypeGetObj
  END INTERFACE !CMISSSolver_LibraryTypeGet

  !>Sets/changes the type of library to use for the solver.
  INTERFACE CMISSSolver_LibraryTypeSet
    MODULE PROCEDURE CMISSSolver_LibraryTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_LibraryTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_LibraryTypeSetObj
  END INTERFACE !CMISSSolver_LibraryTypeSet

  !>Sets/changes the type of direct linear solver.
  INTERFACE CMISSSolver_LinearDirectTypeSet
    MODULE PROCEDURE CMISSSolver_LinearDirectTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_LinearDirectTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_LinearDirectTypeSetObj
  END INTERFACE !CMISSSolver_LinearDirectTypeSet

  !>Sets/changes the absolute tolerance for an iterative linear solver.
  INTERFACE CMISSSolver_LinearIterativeAbsoluteToleranceSet
    MODULE PROCEDURE CMISSSolver_LinearIterativeAbsoluteToleranceSetNumber0
    MODULE PROCEDURE CMISSSolver_LinearIterativeAbsoluteToleranceSetNumber1
    MODULE PROCEDURE CMISSSolver_LinearIterativeAbsoluteToleranceSetObj
  END INTERFACE !CMISSSolver_LinearIterativeAbsoluteToleranceSet

  !>Sets/changes the divergence tolerance for an iterative linear solver.
  INTERFACE CMISSSolver_LinearIterativeDivergenceToleranceSet
    MODULE PROCEDURE CMISSSolver_LinearIterativeDivergenceToleranceSetNumber0
    MODULE PROCEDURE CMISSSolver_LinearIterativeDivergenceToleranceSetNumber1
    MODULE PROCEDURE CMISSSolver_LinearIterativeDivergenceToleranceSetObj
  END INTERFACE !CMISSSolver_LinearIterativeDivergenceToleranceSet

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver.
  INTERFACE CMISSSolver_LinearIterativeGMRESRestartSet
    MODULE PROCEDURE CMISSSolver_LinearIterativeGMRESRestartSetNumber0
    MODULE PROCEDURE CMISSSolver_LinearIterativeGMRESRestartSetNumber1
    MODULE PROCEDURE CMISSSolver_LinearIterativeGMRESRestartSetObj
  END INTERFACE !CMISSSolver_LinearIterativeGMRESRestartSet

  !>Sets/changes the maximum number of iterations for an iterative linear solver.
  INTERFACE CMISSSolver_LinearIterativeMaximumIterationsSet
    MODULE PROCEDURE CMISSSolver_LinearIterativeMaximumIterationsSetNumber0
    MODULE PROCEDURE CMISSSolver_LinearIterativeMaximumIterationsSetNumber1
    MODULE PROCEDURE CMISSSolver_LinearIterativeMaximumIterationsSetObj
  END INTERFACE !CMISSSolver_LinearIterativeMaximumIterationsSet

  !>Sets/changes the type of preconditioner for an iterative linear solver.
  INTERFACE CMISSSolver_LinearIterativePreconditionerTypeSet
    MODULE PROCEDURE CMISSSolver_LinearIterativePreconditionerTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_LinearIterativePreconditionerTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_LinearIterativePreconditionerTypeSetObj
  END INTERFACE !CMISSSolver_LinearIterativePreconditionerTypeSet

  !>Sets/changes the relative tolerance for an iterative linear solver.
  INTERFACE CMISSSolver_LinearIterativeRelativeToleranceSet
    MODULE PROCEDURE CMISSSolver_LinearIterativeRelativeToleranceSetNumber0
    MODULE PROCEDURE CMISSSolver_LinearIterativeRelativeToleranceSetNumber1
    MODULE PROCEDURE CMISSSolver_LinearIterativeRelativeToleranceSetObj
  END INTERFACE !CMISSSolver_LinearIterativeRelativeToleranceSet

  !>Sets/changes the type of iterative linear solver.
  INTERFACE CMISSSolver_LinearIterativeTypeSet
    MODULE PROCEDURE CMISSSolver_LinearIterativeTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_LinearIterativeTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_LinearIterativeTypeSetObj
  END INTERFACE !CMISSSolver_LinearIterativeTypeSet

  !>Sets/changes the type of linear solver.
  INTERFACE CMISSSolver_LinearTypeSet
    MODULE PROCEDURE CMISSSolver_LinearTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_LinearTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_LinearTypeSetObj
  END INTERFACE !CMISSSolver_LinearTypeSet

  !>Sets/changes the absolute tolerance for a nonlinear Quasi-Newton solver.
  INTERFACE CMISSSolver_QuasiNewtonAbsoluteToleranceSet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonAbsoluteToleranceSetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonAbsoluteToleranceSetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonAbsoluteToleranceSetObj
  END INTERFACE !CMISSSolver_QuasiNewtonAbsoluteToleranceSet

  !>Enables/disables output monitoring for a nonlinear Quasi-Newton line search solver.
  INTERFACE CMISSSolver_QuasiNewtonLineSearchMonitorOutputSet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetObj
  END INTERFACE !CMISSSolver_QuasiNewtonLineSearchMonitorOutputSet

  !>Sets/changes the Jacobian calculation type for a nonlinear Quasi-Newton solver.
  INTERFACE CMISSSolver_QuasiNewtonJacobianCalculationTypeSet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonJacobianCalculationTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonJacobianCalculationTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonJacobianCalculationTypeSetObj
  END INTERFACE !CMISSSolver_QuasiNewtonJacobianCalculationTypeSet

  !>Returns the linear solver associated with a nonlinear Quasi-Newton solver.
  INTERFACE CMISSSolver_QuasiNewtonLinearSolverGet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonLinearSolverGetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonLinearSolverGetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonLinearSolverGetObj
  END INTERFACE !CMISSSolver_QuasiNewtonLinearSolverGet

  !>Returns the linear solver associated with a nonlinear Quasi-Newton solver.
  INTERFACE CMISSSolver_QuasiNewtonCellMLSolverGet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonCellMLSolverGetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonCellMLSolverGetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonCellMLSolverGetObj
  END INTERFACE !CMISSSolver_QuasiNewtonCellMLSolverGet

  !>Sets/change the convergence test for a nonlinear Quasi-Newton solver.
  INTERFACE CMISSSolver_QuasiNewtonConvergenceTestTypeSet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonConvergenceTestTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonConvergenceTestTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonConvergenceTestTypeSetObj
  END INTERFACE CMISSSolver_QuasiNewtonConvergenceTestTypeSet

  !>Sets/changes the line search maximum step for a nonlinear Quasi-Newton solver.
  INTERFACE CMISSSolver_QuasiNewtonLineSearchMaxStepSet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonLineSearchMaxStepSetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonLineSearchMaxStepSetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonLineSearchMaxStepSetObj
  END INTERFACE !CMISSSolver_QuasiNewtonLineSearchMaxStepSet

  !>Sets/changes the line search step tolerance for a nonlinear Quasi-Newton solver.
  INTERFACE CMISSSolver_QuasiNewtonLineSearchStepTolSet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonLineSearchStepTolSetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonLineSearchStepTolSetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonLineSearchStepTolSetObj
  END INTERFACE !CMISSSolver_QuasiNewtonLineSearchStepTolSet

  !>Sets/changes the type of line search for a nonlinear Quasi-Newton solver.
  INTERFACE CMISSSolver_QuasiNewtonLineSearchTypeSet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonLineSearchTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonLineSearchTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonLineSearchTypeSetObj
  END INTERFACE !CMISSSolver_QuasiNewtonLineSearchTypeSet

  !>Sets/changes the maximum number of function evaluations for a nonlinear Quasi-Newton solver.
  INTERFACE CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetObj
  END INTERFACE !CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSet

  !>Sets/changes the maximum number of iterations for a nonlinear Quasi-Newton solver.
  INTERFACE CMISSSolver_QuasiNewtonMaximumIterationsSet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonMaximumIterationsSetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonMaximumIterationsSetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonMaximumIterationsSetObj
  END INTERFACE !CMISSSolver_QuasiNewtonMaximumIterationsSet

  !>Sets/changes the relative tolerance for a nonlinear Quasi-Newton solver.
  INTERFACE CMISSSolver_QuasiNewtonRelativeToleranceSet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonRelativeToleranceSetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonRelativeToleranceSetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonRelativeToleranceSetObj
  END INTERFACE !CMISSSolver_QuasiNewtonRelativeToleranceSet

  !>Sets/changes the solution tolerance for a nonlinear Quasi-Newton solver.
  INTERFACE CMISSSolver_QuasiNewtonSolutionToleranceSet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonSolutionToleranceSetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonSolutionToleranceSetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonSolutionToleranceSetObj
  END INTERFACE !CMISSSolver_QuasiNewtonSolutionToleranceSet

  !>Sets/changes the trust region delta0 tolerance for a nonlinear Quasi-Newton trust region solver.
  INTERFACE CMISSSolver_QuasiNewtonTrustRegionDelta0Set
    MODULE PROCEDURE CMISSSolver_QuasiNewtonTrustRegionDelta0SetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonTrustRegionDelta0SetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonTrustRegionDelta0SetObj
  END INTERFACE !CMISSSolver_QuasiNewtonTrustRegionDelta0Set

  !>Sets/changes the trust region tolerance for a nonlinear Quasi-Newton trust region solver.
  INTERFACE CMISSSolver_QuasiNewtonTrustRegionToleranceSet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonTrustRegionToleranceSetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonTrustRegionToleranceSetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonTrustRegionToleranceSetObj
  END INTERFACE !CMISSSolver_QuasiNewtonTrustRegionToleranceSet

  !>Sets/changes the nonlinear Quasi-Newton restart.
  INTERFACE CMISSSolver_QuasiNewtonRestartSet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonRestartSetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonRestartSetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonRestartSetObj
  END INTERFACE !CMISSSolver_QuasiNewtonRestartSet

  !>Sets/changes the nonlinear Quasi-Newton restart type.
  INTERFACE CMISSSolver_QuasiNewtonRestartTypeSet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonRestartTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonRestartTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonRestartTypeSetObj
  END INTERFACE !CMISSSolver_QuasiNewtonRestartTypeSet

  !>Sets/changes the nonlinear Quasi-Newton scale type.
  INTERFACE CMISSSolver_QuasiNewtonScaleTypeSet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonScaleTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonScaleTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonScaleTypeSetObj
  END INTERFACE !CMISSSolver_QuasiNewtonScaleTypeSet

  !>Sets/changes the type of nonlinear Quasi-Newton solver.
  INTERFACE CMISSSolver_QuasiNewtonSolveTypeSet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonSolveTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonSolveTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonSolveTypeSetObj
  END INTERFACE !CMISSSolver_QuasiNewtonSolveTypeSet

  !>Sets/changes the nonlinear Quasi-Newton type.
  INTERFACE CMISSSolver_QuasiNewtonTypeSet
    MODULE PROCEDURE CMISSSolver_QuasiNewtonTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_QuasiNewtonTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_QuasiNewtonTypeSetObj
  END INTERFACE !CMISSSolver_QuasiNewtonTypeSet

  !>Sets/changes the absolute tolerance for a nonlinear Newton solver.
  INTERFACE CMISSSolver_NewtonAbsoluteToleranceSet
    MODULE PROCEDURE CMISSSolver_NewtonAbsoluteToleranceSetNumber0
    MODULE PROCEDURE CMISSSolver_NewtonAbsoluteToleranceSetNumber1
    MODULE PROCEDURE CMISSSolver_NewtonAbsoluteToleranceSetObj
  END INTERFACE !CMISSSolver_NewtonAbsoluteToleranceSet

  !>Enables/disables output monitoring for a nonlinear Newton line search solver.
  INTERFACE CMISSSolver_NewtonLineSearchMonitorOutputSet
    MODULE PROCEDURE CMISSSolver_NewtonLineSearchMonitorOutputSetNumber0
    MODULE PROCEDURE CMISSSolver_NewtonLineSearchMonitorOutputSetNumber1
    MODULE PROCEDURE CMISSSolver_NewtonLineSearchMonitorOutputSetObj
  END INTERFACE !CMISSSolver_NewtonLineSearchMonitorOutputSet

  !>Sets/changes the Jacobian calculation type for a nonlinear Newton solver.
  INTERFACE CMISSSolver_NewtonJacobianCalculationTypeSet
    MODULE PROCEDURE CMISSSolver_NewtonJacobianCalculationTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_NewtonJacobianCalculationTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_NewtonJacobianCalculationTypeSetObj
  END INTERFACE !CMISSSolver_NewtonJacobianCalculationTypeSet

  !>Returns the linear solver associated with a nonlinear Newton solver.
  INTERFACE CMISSSolver_NewtonLinearSolverGet
    MODULE PROCEDURE CMISSSolver_NewtonLinearSolverGetNumber0
    MODULE PROCEDURE CMISSSolver_NewtonLinearSolverGetNumber1
    MODULE PROCEDURE CMISSSolver_NewtonLinearSolverGetObj
  END INTERFACE !CMISSSolver_NewtonLinearSolverGet

  !>Returns the linear solver associated with a nonlinear Newton solver.
  INTERFACE CMISSSolver_NewtonCellMLSolverGet
    MODULE PROCEDURE CMISSSolver_NewtonCellMLSolverGetNumber0
    MODULE PROCEDURE CMISSSolver_NewtonCellMLSolverGetNumber1
    MODULE PROCEDURE CMISSSolver_NewtonCellMLSolverGetObj
  END INTERFACE !CMISSSolver_NewtonCellMLSolverGet

  !>Sets/change the convergence test for a nonlinear Newton solver.
  INTERFACE CMISSSolver_NewtonConvergenceTestTypeSet
    MODULE PROCEDURE CMISSSolver_NewtonConvergenceTestTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_NewtonConvergenceTestTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_NewtonConvergenceTestTypeSetObj
  END INTERFACE CMISSSolver_NewtonConvergenceTestTypeSet

  !>Sets/changes the line search alpha for a nonlinear Newton solver.
  INTERFACE CMISSSolver_NewtonLineSearchAlphaSet
    MODULE PROCEDURE CMISSSolver_NewtonLineSearchAlphaSetNumber0
    MODULE PROCEDURE CMISSSolver_NewtonLineSearchAlphaSetNumber1
    MODULE PROCEDURE CMISSSolver_NewtonLineSearchAlphaSetObj
  END INTERFACE !CMISSSolver_NewtonLineSearchAlphaSet

  !>Sets/changes the line search maximum step for a nonlinear Newton solver.
  INTERFACE CMISSSolver_NewtonLineSearchMaxStepSet
    MODULE PROCEDURE CMISSSolver_NewtonLineSearchMaxStepSetNumber0
    MODULE PROCEDURE CMISSSolver_NewtonLineSearchMaxStepSetNumber1
    MODULE PROCEDURE CMISSSolver_NewtonLineSearchMaxStepSetObj
  END INTERFACE !CMISSSolver_NewtonLineSearchMaxStepSet

  !>Sets/changes the line search step tolerance for a nonlinear Newton solver.
  INTERFACE CMISSSolver_NewtonLineSearchStepTolSet
    MODULE PROCEDURE CMISSSolver_NewtonLineSearchStepTolSetNumber0
    MODULE PROCEDURE CMISSSolver_NewtonLineSearchStepTolSetNumber1
    MODULE PROCEDURE CMISSSolver_NewtonLineSearchStepTolSetObj
  END INTERFACE !CMISSSolver_NewtonLineSearchStepTolSet

  !>Sets/changes the type of line search for a nonlinear Newton solver.
  INTERFACE CMISSSolver_NewtonLineSearchTypeSet
    MODULE PROCEDURE CMISSSolver_NewtonLineSearchTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_NewtonLineSearchTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_NewtonLineSearchTypeSetObj
  END INTERFACE !CMISSSolver_NewtonLineSearchTypeSet

  !>Sets/changes the maximum number of function evaluations for a nonlinear Newton solver.
  INTERFACE CMISSSolver_NewtonMaximumFunctionEvaluationsSet
    MODULE PROCEDURE CMISSSolver_NewtonMaximumFunctionEvaluationsSetNumber0
    MODULE PROCEDURE CMISSSolver_NewtonMaximumFunctionEvaluationsSetNumber1
    MODULE PROCEDURE CMISSSolver_NewtonMaximumFunctionEvaluationsSetObj
  END INTERFACE !CMISSSolver_NewtonMaximumFunctionEvaluationsSet

  !>Sets/changes the maximum number of iterations for a nonlinear Newton solver.
  INTERFACE CMISSSolver_NewtonMaximumIterationsSet
    MODULE PROCEDURE CMISSSolver_NewtonMaximumIterationsSetNumber0
    MODULE PROCEDURE CMISSSolver_NewtonMaximumIterationsSetNumber1
    MODULE PROCEDURE CMISSSolver_NewtonMaximumIterationsSetObj
  END INTERFACE !CMISSSolver_NewtonMaximumIterationsSet

  !>Sets/changes the relative tolerance for a nonlinear Newton solver.
  INTERFACE CMISSSolver_NewtonRelativeToleranceSet
    MODULE PROCEDURE CMISSSolver_NewtonRelativeToleranceSetNumber0
    MODULE PROCEDURE CMISSSolver_NewtonRelativeToleranceSetNumber1
    MODULE PROCEDURE CMISSSolver_NewtonRelativeToleranceSetObj
  END INTERFACE !CMISSSolver_NewtonRelativeToleranceSet

  !>Sets/changes the solution tolerance for a nonlinear Newton solver.
  INTERFACE CMISSSolver_NewtonSolutionToleranceSet
    MODULE PROCEDURE CMISSSolver_NewtonSolutionToleranceSetNumber0
    MODULE PROCEDURE CMISSSolver_NewtonSolutionToleranceSetNumber1
    MODULE PROCEDURE CMISSSolver_NewtonSolutionToleranceSetObj
  END INTERFACE !CMISSSolver_NewtonSolutionToleranceSet

  !>Sets/changes the trust region delta0 tolerance for a nonlinear Newton trust region solver.
  INTERFACE CMISSSolver_NewtonTrustRegionDelta0Set
    MODULE PROCEDURE CMISSSolver_NewtonTrustRegionDelta0SetNumber0
    MODULE PROCEDURE CMISSSolver_NewtonTrustRegionDelta0SetNumber1
    MODULE PROCEDURE CMISSSolver_NewtonTrustRegionDelta0SetObj
  END INTERFACE !CMISSSolver_NewtonTrustRegionDelta0Set

  !>Sets/changes the trust region tolerance for a nonlinear Newton trust region solver.
  INTERFACE CMISSSolver_NewtonTrustRegionToleranceSet
    MODULE PROCEDURE CMISSSolver_NewtonTrustRegionToleranceSetNumber0
    MODULE PROCEDURE CMISSSolver_NewtonTrustRegionToleranceSetNumber1
    MODULE PROCEDURE CMISSSolver_NewtonTrustRegionToleranceSetObj
  END INTERFACE !CMISSSolver_NewtonTrustRegionToleranceSet

  !>Sets/changes the type of nonlinear Newton trust region solver.
  INTERFACE CMISSSolver_NewtonTypeSet
    MODULE PROCEDURE CMISSSolver_NewtonTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_NewtonTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_NewtonTypeSetObj
  END INTERFACE !CMISSSolver_NewtonTypeSet

  !>Sets/changes the type of nonlinear solver.
  INTERFACE CMISSSolver_NonlinearTypeSet
    MODULE PROCEDURE CMISSSolver_NonlinearTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_NonlinearTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_NonlinearTypeSetObj
  END INTERFACE !CMISSSolver_NonlinearTypeSet

  !>Sets/changes the output type for a solver.
  INTERFACE CMISSSolver_OutputTypeSet
    MODULE PROCEDURE CMISSSolver_OutputTypeSetNumber0
    MODULE PROCEDURE CMISSSolver_OutputTypeSetNumber1
    MODULE PROCEDURE CMISSSolver_OutputTypeSetObj
  END INTERFACE !CMISSSolver_OutputTypeSet

  !>Returns the solver equations for a solver.
  INTERFACE CMISSSolver_SolverEquationsGet
    MODULE PROCEDURE CMISSSolver_SolverEquationsGetNumber0
    MODULE PROCEDURE CMISSSolver_SolverEquationsGetNumber1
    MODULE PROCEDURE CMISSSolver_SolverEquationsGetObj
  END INTERFACE !CMISSSolver_SolverEquationsGet

  !>Adds equations sets to solver equations.
  INTERFACE CMISSSolverEquations_EquationsSetAdd
    MODULE PROCEDURE CMISSSolverEquations_EquationsSetAddNumber0
    MODULE PROCEDURE CMISSSolverEquations_EquationsSetAddNumber1
    MODULE PROCEDURE CMISSSolverEquations_EquationsSetAddObj
  END INTERFACE !CMISSSolverEquations_EquationsSetAdd

  !>Adds an interface condition to solver equations.
  INTERFACE CMISSSolverEquations_InterfaceConditionAdd
    MODULE PROCEDURE CMISSSolverEquations_InterfaceConditionAddNumber0
    MODULE PROCEDURE CMISSSolverEquations_InterfaceConditionAddNumber1
    MODULE PROCEDURE CMISSSolverEquations_InterfaceConditionAddObj
  END INTERFACE !CMISSSolverEquations_InterfaceConditionAdd

  !>Sets/changes the sparsity type for solver equations.
  INTERFACE CMISSSolverEquations_SparsityTypeSet
    MODULE PROCEDURE CMISSSolverEquations_SparsityTypeSetNumber0
    MODULE PROCEDURE CMISSSolverEquations_SparsityTypeSetNumber1
    MODULE PROCEDURE CMISSSolverEquations_SparsityTypeSetObj
  END INTERFACE !CMISSSolverEquations_SparsityTypeSet

  !>Finish the creation of boundary conditions for solver equations. \see OPENCMISS::CMISSSolverEquations_BoundaryConditionsCreateStart
  INTERFACE CMISSSolverEquations_BoundaryConditionsCreateFinish
    MODULE PROCEDURE CMISSSolverEquations_BoundaryConditionsCreateFinishNumber0
    MODULE PROCEDURE CMISSSolverEquations_BoundaryConditionsCreateFinishNumber1
    MODULE PROCEDURE CMISSSolverEquations_BoundaryConditionsCreateFinishObj
  END INTERFACE !CMISSSolverEquations_BoundaryConditionsCreateFinish

  !>Start the creation of boundary conditions for solver equations. \see OPENCMISS::CMISSSolverEquations_BoundaryConditionsCreateFinish
  INTERFACE CMISSSolverEquations_BoundaryConditionsCreateStart
    MODULE PROCEDURE CMISSSolverEquations_BoundaryConditionsCreateStartNumber0
    MODULE PROCEDURE CMISSSolverEquations_BoundaryConditionsCreateStartNumber1
    MODULE PROCEDURE CMISSSolverEquations_BoundaryConditionsCreateStartObj
  END INTERFACE !CMISSSolverEquations_BoundaryConditionsCreateStart

  !>Get the boundary conditions for solver equations. \see OPENCMISS::CMISSSolverEquations_BoundaryConditionsCreateFinish
  INTERFACE CMISSSolverEquations_BoundaryConditionsGet
    MODULE PROCEDURE CMISSSolverEquations_BoundaryConditionsGetNumber0
    MODULE PROCEDURE CMISSSolverEquations_BoundaryConditionsGetNumber1
    MODULE PROCEDURE CMISSSolverEquations_BoundaryConditionsGetObj
  END INTERFACE !CMISSSolverEquations_BoundaryConditionsGet

  PUBLIC CMISS_SOLVER_LINEAR_TYPE,CMISS_SOLVER_NONLINEAR_TYPE,CMISS_SOLVER_DYNAMIC_TYPE,CMISS_SOLVER_DAE_TYPE, &
    & CMISS_SOLVER_EIGENPROBLEM_TYPE, &
    & CMISS_SOLVER_OPTIMISER_TYPE

  PUBLIC CMISS_SOLVER_CMISS_LIBRARY,CMISS_SOLVER_PETSC_LIBRARY,CMISS_SOLVER_MUMPS_LIBRARY,CMISS_SOLVER_SUPERLU_LIBRARY, &
    & CMISS_SOLVER_SPOOLES_LIBRARY,CMISS_SOLVER_UMFPACK_LIBRARY,CMISS_SOLVER_LUSOL_LIBRARY,CMISS_SOLVER_ESSL_LIBRARY, &
    & CMISS_SOLVER_LAPACK_LIBRARY,CMISS_SOLVER_TAO_LIBRARY,CMISS_SOLVER_HYPRE_LIBRARY,CMISS_SOLVER_PASTIX_LIBRARY

  PUBLIC CMISS_SOLVER_LINEAR_DIRECT_SOLVE_TYPE,CMISS_SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE
  !################################
  !These two lines below were changed (first one removed) in most recent merge with main opencmiss/cm on 26 Aug 2013
  PUBLIC CMISS_SOLVER_DIRECT_LU,CMISS_SOLVER_DIRECT_CHOLESKY,CMISS_SOLVER_DIRECT_SVD

  !PUBLIC CMISS_SOLVER_ITERATIVE_RICHARDSON,CMISS_SOLVER_ITERATIVE_CHEBYCHEV,CMISS_SOLVER_ITERATIVE_CONJUGATE_GRADIENT, &
  !################################
  PUBLIC CMISS_SOLVER_ITERATIVE_RICHARDSON,CMISS_SOLVER_ITERATIVE_CONJUGATE_GRADIENT, &
    & CMISS_SOLVER_ITERATIVE_BICONJUGATE_GRADIENT,CMISS_SOLVER_ITERATIVE_GMRES,CMISS_SOLVER_ITERATIVE_BiCGSTAB, &
    & CMISS_SOLVER_ITERATIVE_CONJGRAD_SQUARED
#if ( PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 3 )
  PUBLIC CMISS_SOLVER_ITERATIVE_CHEBYSHEV
#else
  PUBLIC CMISS_SOLVER_ITERATIVE_CHEBYCHEV
#endif
  
  PUBLIC CMISS_SOLVER_ITERATIVE_NO_PRECONDITIONER,CMISS_SOLVER_ITERATIVE_JACOBI_PRECONDITIONER, &
    & CMISS_SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER,CMISS_SOLVER_ITERATIVE_SOR_PRECONDITIONER, &
    & CMISS_SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER,CMISS_SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER, &
    & CMISS_SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER

  PUBLIC CMISS_SOLVER_NONLINEAR_NEWTON,CMISS_SOLVER_NONLINEAR_BFGS_INVERSE,CMISS_SOLVER_NONLINEAR_SQP, &
    & CMISS_SOLVER_NONLINEAR_QUASI_NEWTON

  PUBLIC CMISS_SOLVER_QUASI_NEWTON_LINESEARCH,CMISS_SOLVER_QUASI_NEWTON_TRUSTREGION
  
  PUBLIC CMISS_SOLVER_QUASI_NEWTON_LINESEARCH_BASIC,CMISS_SOLVER_QUASI_NEWTON_LINESEARCH_L2, &
    & CMISS_SOLVER_QUASI_NEWTON_LINESEARCH_CP

  PUBLIC CMISS_SOLVER_QUASI_NEWTON_RESTART_NONE,CMISS_SOLVER_QUASI_NEWTON_RESTART_POWELL, &
    & CMISS_SOLVER_QUASI_NEWTON_RESTART_PERIODIC

  PUBLIC CMISS_SOLVER_QUASI_NEWTON_SCALE_NONE,CMISS_SOLVER_QUASI_NEWTON_SCALE_SHANNO, &
    & CMISS_SOLVER_QUASI_NEWTON_SCALE_LINESEARCH,CMISS_SOLVER_QUASI_NEWTON_SCALE_JACOBIAN

  PUBLIC CMISS_SOLVER_NEWTON_LINESEARCH,CMISS_SOLVER_NEWTON_TRUSTREGION

#if ( PETSC_VERSION_MAJOR >= 3 && PETSC_VERSION_MINOR >= 3 )
  PUBLIC CMISS_SOLVER_NEWTON_LINESEARCH_LINEAR,CMISS_SOLVER_NEWTON_LINESEARCH_QUADRATIC,CMISS_SOLVER_NEWTON_LINESEARCH_CUBIC
#else  
  PUBLIC CMISS_SOLVER_NEWTON_LINESEARCH_NONORMS,CMISS_SOLVER_NEWTON_LINESEARCH_NONE,CMISS_SOLVER_NEWTON_LINESEARCH_QUADRATIC, &
    & CMISS_SOLVER_NEWTON_LINESEARCH_CUBIC
#endif
  
  PUBLIC CMISS_SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED,CMISS_SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED, &
    & CMISS_SOLVER_NEWTON_JACOBIAN_FD_CALCULATED

  PUBLIC CMISS_SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT,CMISS_SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM, &
    & CMISS_SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO

  PUBLIC CMISS_SOLVER_DYNAMIC_FIRST_ORDER,CMISS_SOLVER_DYNAMIC_SECOND_ORDER

  PUBLIC CMISS_SOLVER_DYNAMIC_LINEAR,CMISS_SOLVER_DYNAMIC_NONLINEAR

  PUBLIC CMISS_SOLVER_DYNAMIC_FIRST_DEGREE,CMISS_SOLVER_DYNAMIC_SECOND_DEGREE,CMISS_SOLVER_DYNAMIC_THIRD_DEGREE

  PUBLIC CMISS_SOLVER_DYNAMIC_EULER_SCHEME,CMISS_SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME,CMISS_SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME, &
    & CMISS_SOLVER_DYNAMIC_GALERKIN_SCHEME,CMISS_SOLVER_DYNAMIC_ZLAMAL_SCHEME,CMISS_SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME, &
    & CMISS_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME,CMISS_SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME, &
    & CMISS_SOLVER_DYNAMIC_NEWMARK1_SCHEME,CMISS_SOLVER_DYNAMIC_NEWMARK2_SCHEME,CMISS_SOLVER_DYNAMIC_NEWMARK3_SCHEME, &
    & CMISS_SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME,CMISS_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME, &
    & CMISS_SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME,CMISS_SOLVER_DYNAMIC_HOUBOLT_SCHEME,CMISS_SOLVER_DYNAMIC_WILSON_SCHEME, &
    & CMISS_SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME,CMISS_SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME, &
    & CMISS_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME, &
    & CMISS_SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME,CMISS_SOLVER_DYNAMIC_USER_DEFINED_SCHEME

  PUBLIC CMISS_SOLVER_DAE_DIFFERENTIAL_ONLY,CMISS_SOLVER_DAE_INDEX_1,CMISS_SOLVER_DAE_INDEX_2,CMISS_SOLVER_DAE_INDEX_3

  PUBLIC CMISS_SOLVER_DAE_EULER,CMISS_SOLVER_DAE_CRANK_NICOLSON,CMISS_SOLVER_DAE_RUNGE_KUTTA,CMISS_SOLVER_DAE_ADAMS_MOULTON, &
    & CMISS_SOLVER_DAE_BDF, &
    & CMISS_SOLVER_DAE_RUSH_LARSON,CMISS_SOLVER_DAE_EXTERNAL

  PUBLIC CMISS_SOLVER_DAE_EULER_FORWARD,CMISS_SOLVER_DAE_EULER_BACKWARD,CMISS_SOLVER_DAE_EULER_IMPROVED

  PUBLIC CMISS_SOLVER_SOLUTION_INITIALISE_ZERO,CMISS_SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD, &
    & CMISS_SOLVER_SOLUTION_INITIALISE_NO_CHANGE

  PUBLIC CMISS_SOLVER_NO_OUTPUT,CMISS_SOLVER_PROGRESS_OUTPUT,CMISS_SOLVER_TIMING_OUTPUT,CMISS_SOLVER_SOLVER_OUTPUT, &
    & CMISS_SOLVER_MATRIX_OUTPUT

  PUBLIC CMISS_SOLVER_SPARSE_MATRICES,CMISS_SOLVER_FULL_MATRICES

  PUBLIC CMISSSolver_CellMLEquationsGet

  PUBLIC CMISSCellMLEquations_CellMLAdd

  PUBLIC CMISSSolver_DAEEulerSolverTypeGet, CMISSSolver_DAEEulerSolverTypeSet

  PUBLIC CMISSSolver_DAESolverTypeGet,CMISSSolver_DAESolverTypeSet

  PUBLIC CMISSSolver_DAETimesSet,CMISSSolver_DAETimeStepSet

  PUBLIC CMISSSolver_DynamicDegreeGet,CMISSSolver_DynamicDegreeSet

  PUBLIC CMISSSolver_DynamicLinearityTypeGet

  PUBLIC CMISSSolver_DynamicLinearSolverGet,CMISSSolver_DynamicNonlinearSolverGet

  PUBLIC CMISSSolver_DynamicSchemeSet

  PUBLIC CMISSSolver_DynamicThetaSet

  PUBLIC CMISSSolver_DynamicTimesSet
  
  PUBLIC CMISSSolver_GeometricTransformationArbitraryPathSet,CMISSSolver_GeometricTransformationClear
  
  PUBLIC CMISSSolver_GeometricTransformationNumberOfLoadIncrementsSet
  
  PUBLIC CMISSSolver_GeometricTransformationScalingsSet
  
  PUBLIC CMISSSolver_GeometricTransformationFieldSet
  
  PUBLIC CMISSSolver_GeometricTransformationMatrixSet
  
  PUBLIC CMISSSolver_GeometricTransformationRotationSet,CMISSSolver_GeometricTransformationTranslationSet

  PUBLIC CMISSSolver_LabelGet,CMISSSolver_LabelSet

  PUBLIC CMISSSolver_LibraryTypeGet,CMISSSolver_LibraryTypeSet

  PUBLIC CMISSSolver_LinearDirectTypeSet

  PUBLIC CMISSSolver_MumpsSetIcntl,CMISSSolver_MumpsSetCntl

  PUBLIC CMISSSolver_LinearIterativeAbsoluteToleranceSet

  PUBLIC CMISSSolver_LinearIterativeDivergenceToleranceSet

  PUBLIC CMISSSolver_LinearIterativeGMRESRestartSet

  PUBLIC CMISSSolver_LinearIterativeMaximumIterationsSet

  PUBLIC CMISSSolver_LinearIterativePreconditionerTypeSet

  PUBLIC CMISSSolver_LinearIterativeRelativeToleranceSet

  PUBLIC CMISSSolver_LinearIterativeTypeSet

  PUBLIC CMISSSolver_LinearTypeSet

  PUBLIC CMISSSolver_NewtonAbsoluteToleranceSet

  PUBLIC CMISSSolver_NewtonLineSearchMonitorOutputSet

  PUBLIC CMISSSolver_NewtonJacobianCalculationTypeSet

  PUBLIC CMISSSolver_NewtonLinearSolverGet

  PUBLIC CMISSSolver_NewtonCellMLSolverGet

  PUBLIC CMISSSolver_NewtonConvergenceTestTypeSet

  PUBLIC CMISSSolver_NewtonLineSearchAlphaSet

  PUBLIC CMISSSolver_NewtonLineSearchMaxStepSet

  PUBLIC CMISSSolver_NewtonLineSearchStepTolSet

  PUBLIC CMISSSolver_NewtonLineSearchTypeSet

  PUBLIC CMISSSolver_NewtonMaximumFunctionEvaluationsSet

  PUBLIC CMISSSolver_NewtonMaximumIterationsSet

  PUBLIC CMISSSolver_NewtonRelativeToleranceSet

  PUBLIC CMISSSolver_NewtonSolutionToleranceSet

  PUBLIC CMISSSolver_NewtonTrustRegionDelta0Set

  PUBLIC CMISSSolver_NewtonTrustRegionToleranceSet

  PUBLIC CMISSSolver_NewtonTypeSet

  PUBLIC CMISSSolver_QuasiNewtonAbsoluteToleranceSet

  PUBLIC CMISSSolver_QuasiNewtonLineSearchMonitorOutputSet

  PUBLIC CMISSSolver_QuasiNewtonJacobianCalculationTypeSet

  PUBLIC CMISSSolver_QuasiNewtonLinearSolverGet

  PUBLIC CMISSSolver_QuasiNewtonCellMLSolverGet

  PUBLIC CMISSSolver_QuasiNewtonConvergenceTestTypeSet

  PUBLIC CMISSSolver_QuasiNewtonLineSearchMaxStepSet

  PUBLIC CMISSSolver_QuasiNewtonLineSearchStepTolSet

  PUBLIC CMISSSolver_QuasiNewtonLineSearchTypeSet

  PUBLIC CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSet

  PUBLIC CMISSSolver_QuasiNewtonMaximumIterationsSet

  PUBLIC CMISSSolver_QuasiNewtonRelativeToleranceSet

  PUBLIC CMISSSolver_QuasiNewtonSolutionToleranceSet

  PUBLIC CMISSSolver_QuasiNewtonTrustRegionDelta0Set

  PUBLIC CMISSSolver_QuasiNewtonTrustRegionToleranceSet

  PUBLIC CMISSSolver_QuasiNewtonRestartSet

  PUBLIC CMISSSolver_QuasiNewtonRestartTypeSet

  PUBLIC CMISSSolver_QuasiNewtonScaleTypeSet

  PUBLIC CMISSSolver_QuasiNewtonSolveTypeSet

  PUBLIC CMISSSolver_QuasiNewtonTypeSet

  PUBLIC CMISSSolver_NonlinearTypeSet

  PUBLIC CMISSSolver_OutputTypeSet

  PUBLIC CMISSSolver_SolverEquationsGet

  PUBLIC CMISSSolverEquations_EquationsSetAdd

  PUBLIC CMISSSolverEquations_InterfaceConditionAdd

  PUBLIC CMISSSolverEquations_SparsityTypeSet

  PUBLIC CMISSSolverEquations_BoundaryConditionsCreateFinish,CMISSSolverEquations_BoundaryConditionsCreateStart

  PUBLIC CMISSSolverEquations_BoundaryConditionsGet

  PUBLIC CMISSSolverEquations_NumberOfMatricesGet

  PUBLIC CMISSSolverEquations_MatrixGet

  PUBLIC CMISSSolverEquations_JacobianMatrixGet

  PUBLIC CMISSSolverEquations_VectorGet

  PUBLIC CMISSSolverEquations_ResidualVectorGet

  PUBLIC CMISSSolverEquations_RhsVectorGet

  PUBLIC CMISSBioelectricsFiniteElasticity_UpdateGeometricField
  
!!==================================================================================================================================
!!
!! FieldML routines
!!
!!==================================================================================================================================

  !> Provides input and output of fields through the FieldML API
  TYPE CMISSFieldMLIOType
    PRIVATE
#ifdef USEFIELDML
    TYPE(FIELDML_IO_TYPE), POINTER :: fieldmlInfo
#endif
  END TYPE CMISSFieldMLIOType

  !> Creates a mesh component using the given FieldML evaluator.
  INTERFACE CMISSFieldML_InputCreateMeshComponent
    MODULE PROCEDURE CMISSFieldML_InputCreateMeshComponentObjVS
    MODULE PROCEDURE CMISSFieldML_InputCreateMeshComponentNumberVS
    MODULE PROCEDURE CMISSFieldML_InputCreateMeshComponentObjC
    MODULE PROCEDURE CMISSFieldML_InputCreateMeshComponentNumberC
  END INTERFACE CMISSFieldML_InputCreateMeshComponent

  !> Creates a field component using the given FieldML evaluator.
  INTERFACE CMISSFieldML_InputFieldCreateStart
    MODULE PROCEDURE CMISSFieldML_InputFieldCreateStartObjVS
    MODULE PROCEDURE CMISSFieldML_InputFieldCreateStartNumberVS
    MODULE PROCEDURE CMISSFieldML_InputFieldCreateStartObjC
    MODULE PROCEDURE CMISSFieldML_InputFieldCreateStartNumberC
  END INTERFACE CMISSFieldML_InputFieldCreateStart

  !> Updates the given field's dofs using the given parameter evaluator.
  INTERFACE CMISSFieldML_InputFieldParametersUpdate
    MODULE PROCEDURE CMISSFieldML_InputFieldParametersUpdateObjVS
    MODULE PROCEDURE CMISSFieldML_InputFieldParametersUpdateNumberVS
    MODULE PROCEDURE CMISSFieldML_InputFieldParametersUpdateObjC
    MODULE PROCEDURE CMISSFieldML_InputFieldParametersUpdateNumberC
  END INTERFACE CMISSFieldML_InputFieldParametersUpdate

  !> Creates a basis using the given FieldML evaluator.
  INTERFACE CMISSFieldML_InputBasisCreateStart
    MODULE PROCEDURE CMISSFieldML_InputBasisCreateStartObjVS
    MODULE PROCEDURE CMISSFieldML_InputBasisCreateStartNumberVS
    MODULE PROCEDURE CMISSFieldML_InputBasisCreateStartObjC
    MODULE PROCEDURE CMISSFieldML_InputBasisCreateStartNumberC
  END INTERFACE CMISSFieldML_InputBasisCreateStart

  !> Creates the region's nodes using the given FieldML evaluator.
  INTERFACE CMISSFieldML_InputNodesCreateStart
    MODULE PROCEDURE CMISSFieldML_InputNodesCreateStartObjVS
    MODULE PROCEDURE CMISSFieldML_InputNodesCreateStartNumberVS
    MODULE PROCEDURE CMISSFieldML_InputNodesCreateStartObjC
    MODULE PROCEDURE CMISSFieldML_InputNodesCreateStartNumberC
  END INTERFACE CMISSFieldML_InputNodesCreateStart

  !> Creates the region's coordinate system using the given FieldML evaluator.
  INTERFACE CMISSFieldML_InputCoordinateSystemCreateStart
    MODULE PROCEDURE CMISSFieldML_InputCoordinateSystemCreateStartObjVS
    MODULE PROCEDURE CMISSFieldML_InputCoordinateSystemCreateStartNumberVS
    MODULE PROCEDURE CMISSFieldML_InputCoordinateSystemCreateStartObjC
    MODULE PROCEDURE CMISSFieldML_InputCoordinateSystemCreateStartNumberC
  END INTERFACE CMISSFieldML_InputCoordinateSystemCreateStart

  !> Creates a mesh using the given FieldML evaluator.
  INTERFACE CMISSFieldML_InputMeshCreateStart
    MODULE PROCEDURE CMISSFieldML_InputMeshCreateStartObjVS
    MODULE PROCEDURE CMISSFieldML_InputMeshCreateStartNumberVS
    MODULE PROCEDURE CMISSFieldML_InputMeshCreateStartObjC
    MODULE PROCEDURE CMISSFieldML_InputMeshCreateStartNumberC
  END INTERFACE CMISSFieldML_InputMeshCreateStart

  !> Initialise the given FieldML context using the given FieldML XML file.
  INTERFACE CMISSFieldML_InputCreateFromFile
    MODULE PROCEDURE CMISSFieldML_InputCreateFromFileVS
    MODULE PROCEDURE CMISSFieldML_InputCreateFromFileC
  END INTERFACE CMISSFieldML_InputCreateFromFile

  PUBLIC :: CMISSFieldML_InputCreateFromFile, CMISSFieldML_InputMeshCreateStart, &
    & CMISSFieldML_InputCoordinateSystemCreateStart, CMISSFieldML_InputCreateMeshComponent, &
    & CMISSFieldML_InputFieldCreateStart, CMISSFieldML_InputBasisCreateStart, CMISSFieldML_InputNodesCreateStart, &
    & CMISSFieldML_InputFieldParametersUpdate

  PUBLIC :: CMISSFieldMLIO_Finalise, CMISSFieldMLIO_Initialise, CMISSFieldMLIO_GetSession

  !> Add the given field to the current FieldML context.
  INTERFACE CMISSFieldML_OutputAddField
    MODULE PROCEDURE CMISSFieldML_OutputAddFieldNoTypeObjVS
    MODULE PROCEDURE CMISSFieldML_OutputAddFieldNoTypeNumberVS
    MODULE PROCEDURE CMISSFieldML_OutputAddFieldWithTypeObjVS
    MODULE PROCEDURE CMISSFieldML_OutputAddFieldWithTypeNumberVS
    MODULE PROCEDURE CMISSFieldML_OutputAddFieldNoTypeObjC
    MODULE PROCEDURE CMISSFieldML_OutputAddFieldNoTypeNumberC
    MODULE PROCEDURE CMISSFieldML_OutputAddFieldWithTypeObjC
    MODULE PROCEDURE CMISSFieldML_OutputAddFieldWithTypeNumberC
  END INTERFACE CMISSFieldML_OutputAddField

  !> Initialise a new FieldML context.
  INTERFACE CMISSFieldML_OutputCreate
    MODULE PROCEDURE CMISSFieldML_OutputCreateObjVS
    MODULE PROCEDURE CMISSFieldML_OutputCreateNumberVS
    MODULE PROCEDURE CMISSFieldML_OutputCreateObjC
    MODULE PROCEDURE CMISSFieldML_OutputCreateNumberC
  END INTERFACE CMISSFieldML_OutputCreate

  !> Add the given field to the current FieldML context, using only the given components.
  INTERFACE CMISSFieldML_OutputAddFieldComponents
    MODULE PROCEDURE CMISSFieldML_OutputAddFieldComponentsObjVS
    MODULE PROCEDURE CMISSFieldML_OutputAddFieldComponentsNumberVS
    MODULE PROCEDURE CMISSFieldML_OutputAddFieldComponentsObjC
    MODULE PROCEDURE CMISSFieldML_OutputAddFieldComponentsNumberC
  END INTERFACE CMISSFieldML_OutputAddFieldComponents

  !> Write the current FieldML document to the given file.
  INTERFACE CMISSFieldML_OutputWrite
    MODULE PROCEDURE CMISSFieldML_OutputWriteVS
    MODULE PROCEDURE CMISSFieldML_OutputWriteC
  END INTERFACE CMISSFieldML_OutputWrite

  PUBLIC :: CMISSFieldMLIOType

  PUBLIC :: CMISSFieldML_OutputWrite, CMISSFieldML_OutputAddField, CMISSFieldML_OutputCreate, &
    & CMISSFieldML_OutputAddFieldComponents, &
    & CMISSFieldML_OutputAddImport

!!==================================================================================================================================
!!
!! GENERAL_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the user number of an object.
  INTERFACE CMISSUserNumberGet
    MODULE PROCEDURE CMISSUserNumberGetRegion
    MODULE PROCEDURE CMISSUserNumberGetMesh
    MODULE PROCEDURE CMISSUserNumberGetBasis
  END INTERFACE !CMISSUserNumberGet

  PUBLIC CMISSUserNumberGet

!!
!!==================================================================================================================================
!!

CONTAINS

  !
  !================================================================================================================================
  !

  !>Finalises CMISS.
  SUBROUTINE CMISSFinalise(err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL CMISS_FINALISE(err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('OpenCMISS World Phase')
#endif

    RETURN
999 CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFinalise

  !
  !================================================================================================================================
  !

  !>Initialises CMISS returning a user number to the world coordinate system and region.
  SUBROUTINE CMISSInitialiseNumber(worldCoordinateSystemUserNumber,worldRegionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: worldCoordinateSystemUserNumber !<On return, the world coordinate system user number.
    INTEGER(INTG), INTENT(OUT) :: worldRegionUserNumber !<On return, the world region user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: WORLD_COORDINATE_SYSTEM
    TYPE(REGION_TYPE), POINTER :: WORLD_REGION

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('OpenCMISS World Phase')
#endif

    NULLIFY(WORLD_COORDINATE_SYSTEM)
    NULLIFY(WORLD_REGION)
    CALL CMISS_Initialise(WORLD_REGION,err,error,*999)
    !CALL CMISS_Initialise(WORLD_COORDINATE_SYSTEM,WORLD_REGION,err,error,*999)
    worldCoordinateSystemUserNumber=0
    !WorldCoordinateUserNumber=WORLD_COORDINATE_SYSTEM%USER_NUMBER
    worldRegionUserNumber=WORLD_REGION%USER_NUMBER

    RETURN
999 CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInitialiseNumber

  !
  !================================================================================================================================
  !

  !>Initialises CMISS returning a pointer to the world coordinate system and region.
  SUBROUTINE CMISSInitialiseObj(worldCoordinateSystem,worldRegion,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: worldCoordinateSystem !<On return, the world coordinate system.
    TYPE(CMISSRegionType), INTENT(INOUT) :: worldRegion !<On return, the world region.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('OpenCMISS World Phase')
#endif

    CALL CMISSCoordinateSystem_Initialise(worldCoordinateSystem,err)
    CALL CMISSRegion_Initialise(worldRegion,err)
    CALL CMISS_INITIALISE(worldRegion%REGION,err,error,*999)
    !CALL CMISS_Initialise(worldCoordinateSystem%COORDINATE_SYSTEM,worldRegion%REGION,err,error,*999)

    RETURN
999 CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInitialiseObj

  !
  !================================================================================================================================
  !

  !>Copy an array of CMISSBasisTypes from C to an allocated Fortran array, for use by the C bindings
  SUBROUTINE CMISSBasisTypesCopy(bases,basesSize,basesPtr,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: bases(:) !<On return, the array of CMISSBasisTypes
    INTEGER(C_INT), INTENT(IN) :: basesSize !<The length of the C array of pointers to CMISSBasisTypes
    TYPE(C_PTR), INTENT(IN) :: basesPtr !<The pointer to the first CMISSBasisType pointer
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: basis_idx
    TYPE(C_PTR), POINTER :: BasesCPtrs(:)
    TYPE(CMISSBasisType), POINTER :: Basis

    CALL ENTERS("CMISSBasisTypesCopy",err,error,*999)

    IF(C_ASSOCIATED(basesPtr)) THEN
      CALL C_F_POINTER(basesPtr,BasesCPtrs,[basesSize])
      IF(ASSOCIATED(BasesCPtrs)) THEN
        DO basis_idx=1,basesSize
          CALL C_F_POINTER(BasesCPtrs(basis_idx),Basis)
          IF(ASSOCIATED(BasesCPtrs)) THEN
            bases(basis_idx)%BASIS => Basis%BASIS
          ELSE
            CALL FLAG_ERROR("error converting C pointer.",ERR,error,*999)
          END IF
        END DO
      ELSE
        CALL FLAG_ERROR("error converting C pointer.",ERR,error,*999)
      END IF
    ELSE
      CALL FLAG_ERROR("bases C pointer is not associated.",ERR,error,*999)
    END IF

    CALL EXITS("CMISSBasisTypesCopy")
    RETURN
999 CALL ERRORS("CMISSBasisTypesCopy",err,error)
    CALL EXITS("CMISSBasisTypesCopy")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasisTypesCopy

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSBasisType object.
  SUBROUTINE CMISSBasis_Finalise(CMISSBasis,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(OUT) :: CMISSBasis !<The CMISSBasisType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSBasis%BASIS)) CALL BASIS_DESTROY(CMISSBasis%BASIS,err,error,*999)

    CALL EXITS("CMISSBasis_Finalise")
    RETURN
999 CALL ERRORS("CMISSBasis_Finalise",err,error)
    CALL EXITS("CMISSBasis_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSBasisType object.
  SUBROUTINE CMISSBasis_Initialise(CMISSBasis,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(OUT) :: CMISSBasis !<The CMISSBasisType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_Initialise",err,error,*999)

    NULLIFY(CMISSBasis%BASIS)

    CALL EXITS("CMISSBasis_Initialise")
    RETURN
999 CALL ERRORS("CMISSBasis_Initialise",err,error)
    CALL EXITS("CMISSBasis_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSBoundaryConditionsType object.
  SUBROUTINE CMISSBoundaryConditions_Finalise(CMISSBoundaryConditions,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(OUT) :: CMISSBoundaryConditions !<The CMISSBoundaryConditionsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditions_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSBoundaryConditions%BOUNDARY_CONDITIONS))  &
      & CALL BOUNDARY_CONDITIONS_DESTROY(CMISSBoundaryConditions%BOUNDARY_CONDITIONS,err,error,*999)

    CALL EXITS("CMISSBoundaryConditions_Finalise")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_Finalise",err,error)
    CALL EXITS("CMISSBoundaryConditions_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_Finalise
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSBoundaryConditionsType object.
  SUBROUTINE CMISSBoundaryConditions_Initialise(CMISSBoundaryConditions,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(OUT) :: CMISSBoundaryConditions !<The CMISSBoundaryConditionsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditions_Initialise",err,error,*999)

    NULLIFY(CMISSBoundaryConditions%BOUNDARY_CONDITIONS)

    CALL EXITS("CMISSBoundaryConditions_Initialise")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_Initialise",err,error)
    CALL EXITS("CMISSBoundaryConditions_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSCellMLType object.
  SUBROUTINE CMISSCellML_Finalise(CMISSCellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(OUT) :: CMISSCellML !<The CMISSCellMLType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSCellML%CELLML))  &
      & CALL CELLML_DESTROY(CMISSCellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellML_Finalise")
    RETURN
999 CALL ERRORS("CMISSCellML_Finalise",err,error)
    CALL EXITS("CMISSCellML_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_Finalise
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSCellMLType object.
  SUBROUTINE CMISSCellML_Initialise(CMISSCellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(OUT) :: CMISSCellML !<The CMISSCellMLType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_Initialise",err,error,*999)

    NULLIFY(CMISSCellML%CELLML)

    CALL EXITS("CMISSCellML_Initialise")
    RETURN
999 CALL ERRORS("CMISSCellML_Initialise",err,error)
    CALL EXITS("CMISSCellML_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSCellMLEquationsType object.
  SUBROUTINE CMISSCellMLEquations_Finalise(CMISSCellMLEquations,err)

    !Argument variables
    TYPE(CMISSCellMLEquationsType), INTENT(OUT) :: CMISSCellMLEquations !<The CMISSCellMLEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLEquations_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSCellMLEquations%CELLML_EQUATIONS))  &
      & CALL CELLML_EQUATIONS_DESTROY(CMISSCellMLEquations%CELLML_EQUATIONS,err,error,*999)

    CALL EXITS("CMISSCellMLEquations_Finalise")
    RETURN
999 CALL ERRORS("CMISSCellMLEquations_Finalise",err,error)
    CALL EXITS("CMISSCellMLEquations_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLEquations_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSComputationalWorkGroupType object.
  SUBROUTINE CMISSComputationalWorkGroup_Initialise(CMISSComputationalWorkGroup,err)

    !Argument variables
    TYPE(CMISSComputationalWorkGroupType), INTENT(OUT) :: CMISSComputationalWorkGroup !<The CMISSComputationalWorkGroupType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSComputationalWorkGroup_Initialise",err,error,*999)

    NULLIFY(CMISSComputationalWorkGroup%COMPUTATIONAL_WORK_GROUP)

    CALL EXITS("CMISSComputationalWorkGroup_Initialise")
    RETURN
999 CALL ERRORS("CMISSComputationalWorkGroup_Initialise",err,error)
    CALL EXITS("CMISSComputationalWorkGroup_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSComputationalWorkGroup_Initialise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSCellMLEquationsType object.
  SUBROUTINE CMISSCellMLEquations_Initialise(CMISSCellMLEquations,err)

    !Argument variables
    TYPE(CMISSCellMLEquationsType), INTENT(OUT) :: CMISSCellMLEquations !<The CMISSCellMLEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLEquations_Initialise",err,error,*999)

    NULLIFY(CMISSCellMLEquations%CELLML_EQUATIONS)

    CALL EXITS("CMISSCellMLEquations_Initialise")
    RETURN
999 CALL ERRORS("CMISSCellMLEquations_Initialise",err,error)
    CALL EXITS("CMISSCellMLEquations_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLEquations_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSControlLoopType object.
  SUBROUTINE CMISSControlLoop_Finalise(CMISSControlLoop,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(OUT) :: CMISSControlLoop !<The CMISSControlLoopType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSControlLoop%CONTROL_LOOP))  &
      & CALL CONTROL_LOOP_DESTROY(CMISSControlLoop%CONTROL_LOOP,err,error,*999)

    CALL EXITS("CMISSControlLoop_Finalise")
    RETURN
999 CALL ERRORS("CMISSControlLoop_Finalise",err,error)
    CALL EXITS("CMISSControlLoop_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_Finalise
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSControlLoopType object.
  SUBROUTINE CMISSControlLoop_Initialise(CMISSControlLoop,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(OUT) :: CMISSControlLoop !<The CMISSControlLoopType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_Initialise",err,error,*999)

    NULLIFY(CMISSControlLoop%CONTROL_LOOP)

    CALL EXITS("CMISSControlLoop_Initialise")
    RETURN
999 CALL ERRORS("CMISSControlLoop_Initialise",err,error)
    CALL EXITS("CMISSControlLoop_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSCoordinateSystemType object.
  SUBROUTINE CMISSCoordinateSystem_Finalise(CMISSCoordinateSystem,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(OUT) :: CMISSCoordinateSystem !<The CMISSCoordinateSystemType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystem_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSCoordinateSystem%COORDINATE_SYSTEM))  &
      & CALL COORDINATE_SYSTEM_DESTROY(CMISSCoordinateSystem%COORDINATE_SYSTEM,err,error,*999)

    CALL EXITS("CMISSCoordinateSystem_Finalise")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_Finalise",err,error)
    CALL EXITS("CMISSCoordinateSystem_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_Finalise
  !
  !================================================================================================================================
  !

  !>Initialises a CMISSCoordinateSystemType object.
  SUBROUTINE CMISSCoordinateSystem_Initialise(CMISSCoordinateSystem,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(OUT) :: CMISSCoordinateSystem !<The CMISSCoordinateSystemType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables


    CALL ENTERS("CMISSCoordinateSystem_Initialise",err,error,*999)

    NULLIFY(CMISSCoordinateSystem%COORDINATE_SYSTEM)

    CALL EXITS("CMISSCoordinateSystem_Initialise")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_Initialise",err,error)
    CALL EXITS("CMISSCoordinateSystem_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSDataPointsType object.
  SUBROUTINE CMISSDataPoints_Finalise(CMISSDataPoints,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(OUT) :: CMISSDataPoints !<The CMISSDataPointsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPoints_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSDataPoints%DATA_POINTS))  &
      & CALL DATA_POINTS_DESTROY(CMISSDataPoints%DATA_POINTS,err,error,*999)

    CALL EXITS("CMISSDataPoints_Finalise")
    RETURN
999 CALL ERRORS("CMISSDataPoints_Finalise",err,error)
    CALL EXITS("CMISSDataPoints_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSDataPointsType object.
  SUBROUTINE CMISSDataPoints_Initialise(CMISSDataPoints,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(OUT) :: CMISSDataPoints !<The CMISSDataPointsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPoints_Initialise",err,error,*999)

    NULLIFY(CMISSDataPoints%DATA_POINTS)

    CALL EXITS("CMISSDataPoints_Initialise")
    RETURN
999 CALL ERRORS("CMISSDataPoints_Initialise",err,error)
    CALL EXITS("CMISSDataPoints_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSDataProjectionType object.
  SUBROUTINE CMISSDataProjection_Finalise(CMISSDataProjection,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(OUT) :: CMISSDataProjection !<The CMISSDataProjectionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSDataProjection%DATA_PROJECTION))  &
      & CALL DATA_PROJECTION_DESTROY(CMISSDataProjection%DATA_PROJECTION,err,error,*999)

    CALL EXITS("CMISSDataProjection_Finalise")
    RETURN
999 CALL ERRORS("CMISSDataProjection_Finalise",err,error)
    CALL EXITS("CMISSDataProjection_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSDataProjectionType object.
  SUBROUTINE CMISSDataProjection_Initialise(CMISSDataProjection,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(OUT) :: CMISSDataProjection !<The CMISSDataProjectionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_Initialise",err,error,*999)

    NULLIFY(CMISSDataProjection%DATA_PROJECTION)

    CALL EXITS("CMISSDataProjection_Initialise")
    RETURN
999 CALL ERRORS("CMISSDataProjection_Initialise",err,error)
    CALL EXITS("CMISSDataProjection_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSDecompositionType object.
  SUBROUTINE CMISSDecomposition_Finalise(CMISSDecomposition,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(OUT) :: CMISSDecomposition !<The CMISSDecompositionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSDecomposition%DECOMPOSITION))  &
      & CALL DECOMPOSITION_DESTROY(CMISSDecomposition%DECOMPOSITION,err,error,*999)

    CALL EXITS("CMISSDecomposition_Finalise")
    RETURN
999 CALL ERRORS("CMISSDecomposition_Finalise",err,error)
    CALL EXITS("CMISSDecomposition_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSDecompositionType object.
  SUBROUTINE CMISSDecomposition_Initialise(CMISSDecomposition,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(OUT) :: CMISSDecomposition !<The CMISSDecompositionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_Initialise",err,error,*999)

    NULLIFY(CMISSDecomposition%DECOMPOSITION)

    CALL EXITS("CMISSDecomposition_Initialise")
    RETURN
999 CALL ERRORS("CMISSDecomposition_Initialise",err,error)
    CALL EXITS("CMISSDecomposition_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSEquationsType object.
  SUBROUTINE CMISSEquations_Finalise(CMISSEquations,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(OUT) :: CMISSEquations !<The CMISSEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquations_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSEquations%EQUATIONS))  &
      & CALL EQUATIONS_DESTROY(CMISSEquations%EQUATIONS,err,error,*999)

    CALL EXITS("CMISSEquations_Finalise")
    RETURN
999 CALL ERRORS("CMISSEquations_Finalise",err,error)
    CALL EXITS("CMISSEquations_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSEquationsType object.
  SUBROUTINE CMISSEquations_Initialise(CMISSEquations,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(OUT) :: CMISSEquations !<The CMISSEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquations_Initialise",err,error,*999)

    NULLIFY(CMISSEquations%EQUATIONS)

    CALL EXITS("CMISSEquations_Initialise")
    RETURN
999 CALL ERRORS("CMISSEquations_Initialise",err,error)
    CALL EXITS("CMISSEquations_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSEquationsSetType object.
  SUBROUTINE CMISSEquationsSet_Finalise(CMISSEquationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(OUT) :: CMISSEquationsSet !<The CMISSEquationsSetType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSEquationsSet%EQUATIONS_SET))  &
      & CALL EQUATIONS_SET_DESTROY(CMISSEquationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSet_Finalise")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_Finalise",err,error)
    CALL EXITS("CMISSEquationsSet_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSEquationsSetType object.
  SUBROUTINE CMISSEquationsSet_Initialise(CMISSEquationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(OUT) :: CMISSEquationsSet !<The CMISSEquationsSetType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_Initialise",err,error,*999)

    NULLIFY(CMISSEquationsSet%EQUATIONS_SET)

    CALL EXITS("CMISSEquationsSet_Initialise")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_Initialise",err,error)
    CALL EXITS("CMISSEquationsSet_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSFieldType object.
  SUBROUTINE CMISSField_Finalise(CMISSField,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(OUT) :: CMISSField !<The CMISSFieldType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSField%FIELD))  &
      & CALL FIELD_DESTROY(CMISSField%FIELD,err,error,*999)

    CALL EXITS("CMISSField_Finalise")
    RETURN
999 CALL ERRORS("CMISSField_Finalise",err,error)
    CALL EXITS("CMISSField_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSFieldType object.
  SUBROUTINE CMISSField_Initialise(CMISSField,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(OUT) :: CMISSField !<The CMISSFieldType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_Initialise",err,error,*999)

    NULLIFY(CMISSField%FIELD)

    CALL EXITS("CMISSField_Initialise")
    RETURN
999 CALL ERRORS("CMISSField_Initialise",err,error)
    CALL EXITS("CMISSField_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_Initialise

  !
  !================================================================================================================================
  !

  !>Creates a CMISSFieldsType object for an inteface by an object reference.
  SUBROUTINE CMISSFields_CreateInterface(interface,fields,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: interface !<The interface to get the fields from
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<On return, the fields attached to the specified interface. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFields_CreateInterface",err,error,*999)

    IF(ASSOCIATED(interface%INTERFACE)) THEN
      IF(ASSOCIATED(fields%FIELDS)) THEN
        CALL FLAG_ERROR("fields is already associated.",ERR,error,*999)
      ELSE
        fields%FIELDS=>interface%INTERFACE%FIELDS
      END IF
    ELSE
      CALL FLAG_ERROR("The interface is not associated.",ERR,error,*999)
    END IF

    CALL EXITS("CMISSFields_CreateInterface")
    RETURN
999 CALL ERRORS("CMISSFields_CreateInterface",err,error)
    CALL EXITS("CMISSFields_CreateInterface")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFields_CreateInterface

  !
  !================================================================================================================================
  !

  !>Creates a CMISSFieldsType object for a region by an object reference.
  SUBROUTINE CMISSFields_CreateRegion(region,fields,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to get the fields from
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<On return, the fields attached to the specified region. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFields_CreateRegion",err,error,*999)

    IF(ASSOCIATED(region%REGION)) THEN
      IF(ASSOCIATED(fields%FIELDS)) THEN
        CALL FLAG_ERROR("fields is already associated.",ERR,error,*999)
      ELSE
        fields%FIELDS=>region%REGION%FIELDS
      END IF
    ELSE
      CALL FLAG_ERROR("The region is not associated.",ERR,error,*999)
    END IF

    CALL EXITS("CMISSFields_CreateRegion")
    RETURN
999 CALL ERRORS("CMISSFields_CreateRegion",err,error)
    CALL EXITS("CMISSFields_CreateRegion")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFields_CreateRegion

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSFieldsType object.
  SUBROUTINE CMISSFields_Finalise(CMISSFields,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(OUT) :: CMISSFields !<The CMISSFieldsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFields_Finalise",err,error,*999)

    NULLIFY(CMISSFields%FIELDS)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Fields Type')
#endif

    CALL EXITS("CMISSFields_Finalise")
    RETURN
999 CALL ERRORS("CMISSFields_Finalise",err,error)
    CALL EXITS("CMISSFields_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFields_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSFieldsType object.
  SUBROUTINE CMISSFields_Initialise(CMISSFields,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(OUT) :: CMISSFields !<The CMISSFieldsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFields_Initialise",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Fields Type')
#endif

    NULLIFY(CMISSFields%FIELDS)

    CALL EXITS("CMISSFields_Initialise")
    RETURN
999 CALL ERRORS("CMISSFields_Initialise",err,error)
    CALL EXITS("CMISSFields_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFields_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSGeneratedMeshType object.
  SUBROUTINE CMISSGeneratedMesh_Finalise(CMISSGeneratedMesh,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(OUT) :: CMISSGeneratedMesh !<The CMISSGeneratedMeshType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMesh_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSGeneratedMesh%GENERATED_MESH))  &
      & CALL GENERATED_MESH_DESTROY(CMISSGeneratedMesh%GENERATED_MESH,err,error,*999)

    CALL EXITS("CMISSGeneratedMesh_Finalise")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_Finalise",err,error)
    CALL EXITS("CMISSGeneratedMesh_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSGeneratedMeshType object.
  SUBROUTINE CMISSGeneratedMesh_Initialise(CMISSGeneratedMesh,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(OUT) :: CMISSGeneratedMesh !<The CMISSGeneratedMeshType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMesh_Initialise",err,error,*999)

    NULLIFY(CMISSGeneratedMesh%GENERATED_MESH)

    CALL EXITS("CMISSGeneratedMesh_Initialise")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_Initialise",err,error)
    CALL EXITS("CMISSGeneratedMesh_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSInterfaceType object.
  SUBROUTINE CMISSInterface_Finalise(CMISSInterface,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(OUT) :: CMISSInterface !<The CMISSInterfaceType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterface_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSInterface%INTERFACE))  &
      & CALL INTERFACE_DESTROY(CMISSInterface%INTERFACE,err,error,*999)

    CALL EXITS("CMISSInterface_Finalise")
    RETURN
999 CALL ERRORS("CMISSInterface_Finalise",err,error)
    CALL EXITS("CMISSInterface_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSInterfaceType object.
  SUBROUTINE CMISSInterface_Initialise(CMISSInterface,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(OUT) :: CMISSInterface !<The CMISSInterfaceType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterface_Initialise",err,error,*999)

    NULLIFY(CMISSInterface%Interface)

    CALL EXITS("CMISSInterface_Initialise")
    RETURN
999 CALL ERRORS("CMISSInterface_Initialise",err,error)
    CALL EXITS("CMISSInterface_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSInterfaceConditionType object.
  SUBROUTINE CMISSInterfaceCondition_Finalise(CMISSInterfaceCondition,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(OUT) :: CMISSInterfaceCondition !<The CMISSInterfaceConditionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCondition_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSInterfaceCondition%INTERFACE_CONDITION))  &
      & CALL INTERFACE_CONDITION_DESTROY(CMISSInterfaceCondition%INTERFACE_CONDITION,err,error,*999)

    CALL EXITS("CMISSInterfaceCondition_Finalise")
    RETURN
999 CALL ERRORS("CMISSInterfaceTypeConditionFinalise",err,error)
    CALL EXITS("CMISSInterfaceTypeConditionFinalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSInterfaceConditionType object.
  SUBROUTINE CMISSInterfaceCondition_Initialise(CMISSInterfaceCondition,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(OUT) :: CMISSInterfaceCondition !<The CMISSInterfaceConditionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCondition_Initialise",err,error,*999)

    NULLIFY(CMISSInterfaceCondition%INTERFACE_CONDITION)

    CALL EXITS("CMISSInterfaceCondition_Initialise")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_Initialise",err,error)
    CALL EXITS("CMISSInterfaceCondition_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_Initialise

   !
  !================================================================================================================================
  !

  !>Finalises a CMISSInterfaceEquationsType object.
  SUBROUTINE CMISSInterfaceEquations_Finalise(CMISSInterfaceEquations,err)

    !Argument variables
    TYPE(CMISSInterfaceEquationsType), INTENT(OUT) :: CMISSInterfaceEquations !<The CMISSInterfaceEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceEquations_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSInterfaceEquations%INTERFACE_EQUATIONS))  &
      & CALL INTERFACE_EQUATIONS_DESTROY(CMISSInterfaceEquations%INTERFACE_EQUATIONS,err,error,*999)

    CALL EXITS("CMISSInterfaceEquations_Finalise")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquations_Finalise",err,error)
    CALL EXITS("CMISSInterfaceEquations_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquations_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSInterfaceEquationsType object.
  SUBROUTINE CMISSInterfaceEquations_Initialise(CMISSInterfaceEquations,err)

    !Argument variables
    TYPE(CMISSInterfaceEquationsType), INTENT(OUT) :: CMISSInterfaceEquations !<The CMISSInterfaceEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceEquations_Initialise",err,error,*999)

    NULLIFY(CMISSInterfaceEquations%INTERFACE_EQUATIONS)

    CALL EXITS("CMISSInterfaceEquations_Initialise")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquations_Initialise",err,error)
    CALL EXITS("CMISSInterfaceEquations_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquations_Initialise
  
  !
  !================================================================================================================================
  !
  
  !>Finalise a CMISSInterfaceMeshConnectivityType object.
  SUBROUTINE CMISSInterfacePointsConnectivity_Finalise(CMISSInterfacePointsConnectivity,Err)
   
    !Argument variables
    TYPE(CMISSInterfacePointsConnectivityType), INTENT(OUT) :: CMISSInterfacePointsConnectivity !<The CMISSInterfacePointsConnectivityType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfacePointsConnectivity_Finalise",Err,ERROR,*999)
    
    IF(ASSOCIATED(CMISSInterfacePointsConnectivity%pointsConnectivity)) THEN
      CALL InterfacePointsConnectivity_Destroy(CMISSInterfacePointsConnectivity%pointsConnectivity,err,ERROR,*999)
    ENDIF
 
    CALL EXITS("CMISSInterfacePointsConnectivity_Finalise")
    RETURN
999 CALL ERRORS("CMISSInterfacePointsConnectivity_Finalise",Err,ERROR)
    CALL EXITS("CMISSInterfacePointsConnectivity_Finalise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
     
  END SUBROUTINE CMISSInterfacePointsConnectivity_Finalise
  
  !
  !================================================================================================================================
  !
  
  !>Initialises a CMISSInterfaceMeshConnectivityType object.
  SUBROUTINE CMISSInterfacePointsConnectivity_Initialise(CMISSInterfacePointsConnectivity,Err)
   
    !Argument variables
    TYPE(CMISSInterfacePointsConnectivityType), INTENT(OUT) :: CMISSInterfacePointsConnectivity !<The CMISSInterfacePointsConnectivityType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfacePointsConnectivity_Initialise",Err,ERROR,*999)
    
    NULLIFY(CMISSInterfacePointsConnectivity%pointsConnectivity)
 
    CALL EXITS("CMISSInterfacePointsConnectivity_Initialise")
    RETURN
999 CALL ERRORS("CMISSInterfacePointsConnectivity_Initialise",Err,ERROR)
    CALL EXITS("CMISSInterfacePointsConnectivity_Initialise")    
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
     
  END SUBROUTINE CMISSInterfacePointsConnectivity_Initialise

  !
  !================================================================================================================================
  !

   !>Finalises a CMISSInterfaceMeshConnectivityType object.
   SUBROUTINE CMISSInterfaceMeshConnectivity_Finalise(CMISSInterfaceMeshConnectivity,err)

     !Argument variables
     TYPE(CMISSInterfaceMeshConnectivityType), INTENT(OUT) :: CMISSInterfaceMeshConnectivity !<The CMISSInterfaceMeshConnectivityType object to finalise.
     INTEGER(INTG), INTENT(OUT) :: err !<The error code.
     !Local variables

     CALL ENTERS("CMISSInterfaceMeshConnectivity_Finalise",err,error,*999)

     IF(ASSOCIATED(CMISSInterfaceMeshConnectivity%MESH_CONNECTIVITY)) &
       & CALL INTERFACE_MESH_CONNECTIVITY_DESTROY(CMISSInterfaceMeshConnectivity%MESH_CONNECTIVITY,err,error,*999)

     CALL EXITS("CMISSInterfaceMeshConnectivity_Finalise")
     RETURN
 999 CALL ERRORS("CMISSInterfaceMeshConnectivity_Finalise",err,error)
     CALL EXITS("CMISSInterfaceMeshConnectivity_Finalise")
     CALL CMISS_HANDLE_ERROR(err,error)
     RETURN

   END SUBROUTINE CMISSInterfaceMeshConnectivity_Finalise

  !
  !================================================================================================================================
  !

   !>Initialises a CMISSInterfaceMeshConnectivityType object.
   SUBROUTINE CMISSInterfaceMeshConnectivity_Initialise(CMISSInterfaceMeshConnectivity,err)

     !Argument variables
     TYPE(CMISSInterfaceMeshConnectivityType), INTENT(OUT) :: CMISSInterfaceMeshConnectivity !<The CMISSInterfaceMeshConnectivityType object to initialise.
     INTEGER(INTG), INTENT(OUT) :: err !<The error code.
     !Local variables

     CALL ENTERS("CMISSInterfaceMeshConnectivity_Initialise",err,error,*999)

     NULLIFY(CMISSInterfaceMeshConnectivity%MESH_CONNECTIVITY)

     CALL EXITS("CMISSInterfaceMeshConnectivity_Initialise")
     RETURN
 999 CALL ERRORS("CMISSInterfaceMeshConnectivity_Initialise",err,error)
     CALL EXITS("CMISSInterfaceMeshConnectivity_Initialise")
     CALL CMISS_HANDLE_ERROR(err,error)
     RETURN

   END SUBROUTINE CMISSInterfaceMeshConnectivity_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSHistoryType object.
  SUBROUTINE CMISSHistory_Finalise(CMISSHistory,err)

    !Argument variables
    TYPE(CMISSHistoryType), INTENT(OUT) :: CMISSHistory !<The CMISSHistoryType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSHistory_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSHistory%HISTORY))  &
      & CALL HISTORY_DESTROY(CMISSHistory%HISTORY,err,error,*999)

    CALL EXITS("CMISSHistory_Finalise")
    RETURN
999 CALL ERRORS("CMISSHistory_Finalise",err,error)
    CALL EXITS("CMISSHistory_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSHistory_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSHistoryType object.
  SUBROUTINE CMISSHistory_Initialise(CMISSHistory,err)

    !Argument variables
    TYPE(CMISSHistoryType), INTENT(OUT) :: CMISSHistory !<The CMISSHistoryType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSHistory_Initialise",err,error,*999)

    NULLIFY(CMISSHistory%HISTORY)

    CALL EXITS("CMISSHistory_Initialise")
    RETURN
999 CALL ERRORS("CMISSHistory_Initialise",err,error)
    CALL EXITS("CMISSHistory_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSHistory_Initialise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSDistributedMatrixType object.
  SUBROUTINE CMISSDistributedMatrix_Initialise(CMISSDistributedMatrix,err)

    !Argument variables
    TYPE(CMISSDistributedMatrixType), INTENT(OUT) :: CMISSDistributedMatrix !<The CMISSDistributedMatrixType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDistributedMatrix_Initialise",err,error,*999)

    NULLIFY(CMISSDistributedMatrix%distributedMatrix)

    CALL EXITS("CMISSDistributedMatrix_Initialise")
    RETURN
999 CALL ERRORS("CMISSDistributedMatrix_Initialise",err,error)
    CALL EXITS("CMISSDistributedMatrix_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedMatrix_Initialise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSDistributedVectorType object.
  SUBROUTINE CMISSDistributedVector_Initialise(CMISSDistributedVector,err)

    !Argument variables
    TYPE(CMISSDistributedVectorType), INTENT(OUT) :: CMISSDistributedVector !<The CMISSDistributedVectorType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDistributedVector_Initialise",err,error,*999)

    NULLIFY(CMISSDistributedVector%distributedVector)

    CALL EXITS("CMISSDistributedVector_Initialise")
    RETURN
999 CALL ERRORS("CMISSDistributedVector_Initialise",err,error)
    CALL EXITS("CMISSDistributedVector_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedVector_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSMeshType object.
  SUBROUTINE CMISSMesh_Finalise(CMISSMesh,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(OUT) :: CMISSMesh !<The CMISSMeshType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMesh_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSMesh%MESH))  &
      & CALL MESH_DESTROY(CMISSMesh%MESH,err,error,*999)

    CALL EXITS("CMISSMesh_Finalise")
    RETURN
999 CALL ERRORS("CMISSMesh_Finalise",err,error)
    CALL EXITS("CMISSMesh_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSMeshType object.
  SUBROUTINE CMISSMesh_Initialise(CMISSMesh,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(OUT) :: CMISSMesh !<The CMISSMeshType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMesh_Initialise",err,error,*999)

    NULLIFY(CMISSMesh%MESH)

    CALL EXITS("CMISSMesh_Initialise")
    RETURN
999 CALL ERRORS("CMISSMesh_Initialise",err,error)
    CALL EXITS("CMISSMesh_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSMeshElementsType object.
  SUBROUTINE CMISSMeshElements_Finalise(CMISSMeshElements,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(OUT) :: CMISSMeshElements !<The CMISSMeshElementsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElements_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSMeshElements%MESH_ELEMENTS))  &
      & CALL MESH_TOPOLOGY_ELEMENTS_DESTROY(CMISSMeshElements%MESH_ELEMENTS,err,error,*999)

    CALL EXITS("CMISSMeshElements_Finalise")
    RETURN
999 CALL ERRORS("CMISSMeshElements_Finalise",err,error)
    CALL EXITS("CMISSMeshElements_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSMeshElementsType object.
  SUBROUTINE CMISSMeshElements_Initialise(CMISSMeshElements,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(OUT) :: CMISSMeshElements !<The CMISSMeshElementsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElements_Initialise",err,error,*999)

    NULLIFY(CMISSMeshElements%MESH_ELEMENTS)

    CALL EXITS("CMISSMeshElements_Initialise")
    RETURN
999 CALL ERRORS("CMISSMeshElements_Initialise",err,error)
    CALL EXITS("CMISSMeshElements_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSMeshNodesType object.
  SUBROUTINE CMISSMeshNodes_Finalise(CMISSMeshNodes,err)

    !Argument variables
    TYPE(CMISSMeshNodesType), INTENT(OUT) :: CMISSMeshNodes !<The CMISSMeshNodesType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL Enters("CMISSMeshNodes_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSMeshNodes%meshNodes))  &
      & CALL MeshTopologyNodesDestroy(CMISSMeshNodes%meshNodes,err,error,*999)

    CALL Exits("CMISSMeshNodes_Finalise")
    RETURN
999 CALL Errors("CMISSMeshNodes_Finalise",err,error)
    CALL Exits("CMISSMeshNodes_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNodes_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSMeshNodesType object.
  SUBROUTINE CMISSMeshNodes_Initialise(CMISSMeshNodes,err)

    !Argument variables
    TYPE(CMISSMeshNodesType), INTENT(OUT) :: CMISSMeshNodes !<The CMISSMeshNodesType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL Enters("CMISSMeshNodes_Initialise",err,error,*999)

    NULLIFY(CMISSMeshNodes%meshNodes)

    CALL Exits("CMISSMeshNodes_Initialise")
    RETURN
999 CALL Errors("CMISSMeshNodes_Initialise",err,error)
    CALL Exits("CMISSMeshNodes_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNodes_Initialise

    !
  !================================================================================================================================
  !

  !>Finalises a CMISSNodesType object.
  SUBROUTINE CMISSNodes_Finalise(CMISSNodes,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(OUT) :: CMISSNodes !<The CMISSNodesType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodes_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSNodes%NODES))  &
      & CALL NODES_DESTROY(CMISSNodes%NODES,err,error,*999)

    CALL EXITS("CMISSNodes_Finalise")
    RETURN
999 CALL ERRORS("CMISSNodes_Finalise",err,error)
    CALL EXITS("CMISSNodes_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSNodesType object.
  SUBROUTINE CMISSNodes_Initialise(CMISSNodes,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(OUT) :: CMISSNodes !<The CMISSNodesType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodes_Initialise",err,error,*999)

    NULLIFY(CMISSNodes%NODES)

    CALL EXITS("CMISSNodes_Initialise")
    RETURN
999 CALL ERRORS("CMISSNodes_Initialise",err,error)
    CALL EXITS("CMISSNodes_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSProblemType object.
  SUBROUTINE CMISSProblem_Finalise(CMISSProblem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(OUT) :: CMISSProblem !<The CMISSProblemType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSProblem%PROBLEM))  &
      & CALL PROBLEM_DESTROY(CMISSProblem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblem_Finalise")
    RETURN
999 CALL ERRORS("CMISSProblem_Finalise",err,error)
    CALL EXITS("CMISSProblem_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSProblemType object.
  SUBROUTINE CMISSProblem_Initialise(CMISSProblem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(OUT) :: CMISSProblem !<The CMISSProblemType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_Initialise",err,error,*999)

    NULLIFY(CMISSProblem%PROBLEM)

    CALL EXITS("CMISSProblem_Initialise")
    RETURN
999 CALL ERRORS("CMISSProblem_Initialise",err,error)
    CALL EXITS("CMISSProblem_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSQuadratureType object.
  SUBROUTINE CMISSQuadrature_Finalise(CMISSQuadrature,err)

    !Argument variables
    TYPE(CMISSQuadratureType), INTENT(OUT) :: CMISSQuadrature !<The CMISSQuadratureType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSQuadrature_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSQuadrature%QUADRATURE))  &
      & CALL BASIS_QUADRATURE_DESTROY(CMISSQuadrature%QUADRATURE,err,error,*999)

    CALL EXITS("CMISSQuadrature_Finalise")
    RETURN
999 CALL ERRORS("CMISSQuadrature_Finalise",err,error)
    CALL EXITS("CMISSQuadrature_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSQuadrature_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSQuadratureType object.
  SUBROUTINE CMISSQuadrature_Initialise(CMISSQuadrature,err)

    !Argument variables
    TYPE(CMISSQuadratureType), INTENT(OUT) :: CMISSQuadrature !<The CMISSQuadratureType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSQuadrature_Initialise",err,error,*999)

    NULLIFY(CMISSQuadrature%QUADRATURE)

    CALL EXITS("CMISSQuadrature_Initialise")
    RETURN
999 CALL ERRORS("CMISSQuadrature_Initialise",err,error)
    CALL EXITS("CMISSQuadrature_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSQuadrature_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSRegionType object.
  SUBROUTINE CMISSRegion_Finalise(CMISSRegion,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(OUT) :: CMISSRegion !<The CMISSRegionType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegion_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSRegion%REGION))  &
      & CALL REGION_DESTROY(CMISSRegion%REGION,err,error,*999)

    CALL EXITS("CMISSRegion_Finalise")
    RETURN
999 CALL ERRORS("CMISSRegion_Finalise",err,error)
    CALL EXITS("CMISSRegion_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSRegionType object.
  SUBROUTINE CMISSRegion_Initialise(CMISSRegion,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(OUT) :: CMISSRegion !<The CMISSRegionType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegion_Initialise",err,error,*999)

    NULLIFY(CMISSRegion%REGION)

    CALL EXITS("CMISSRegion_Initialise")
    RETURN
999 CALL ERRORS("CMISSRegion_Initialise",err,error)
    CALL EXITS("CMISSRegion_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSSolverType object.
  SUBROUTINE CMISSSolver_Finalise(CMISSSolver,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(OUT) :: CMISSSolver !<The CMISSSolverType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSSolver%SOLVER))  &
      & CALL SOLVER_DESTROY(CMISSSolver%SOLVER,err,error,*999)

    CALL EXITS("CMISSSolver_Finalise")
    RETURN
999 CALL ERRORS("CMISSSolver_Finalise",err,error)
    CALL EXITS("CMISSSolver_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSSolverType object.
  SUBROUTINE CMISSSolver_Initialise(CMISSSolver,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(OUT) :: CMISSSolver !<The CMISSSolverType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_Initialise",err,error,*999)

    NULLIFY(CMISSSolver%SOLVER)

    CALL EXITS("CMISSSolver_Initialise")
    RETURN
999 CALL ERRORS("CMISSSolver_Initialise",err,error)
    CALL EXITS("CMISSSolver_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_Initialise

  !
  !================================================================================================================================
  !

  !>Finalises a CMISSSolverEquationsType object.
  SUBROUTINE CMISSSolverEquations_Finalise(CMISSSolverEquations,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(OUT) :: CMISSSolverEquations !<The CMISSSolverEquationsType object to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverEquations_Finalise",err,error,*999)

    IF(ASSOCIATED(CMISSSolverEquations%SOLVER_EQUATIONS))  &
      & CALL SOLVER_EQUATIONS_DESTROY(CMISSSolverEquations%SOLVER_EQUATIONS,err,error,*999)

    CALL EXITS("CMISSSolverEquations_Finalise")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_Finalise",err,error)
    CALL EXITS("CMISSSolverEquations_Finalise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a CMISSSolverEquationsType object.
  SUBROUTINE CMISSSolverEquations_Initialise(CMISSSolverEquations,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(OUT) :: CMISSSolverEquations !<The CMISSSolverEquationsType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverEquations_Initialise",err,error,*999)

    NULLIFY(CMISSSolverEquations%SOLVER_EQUATIONS)

    CALL EXITS("CMISSSolverEquations_Initialise")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_Initialise",err,error)
    CALL EXITS("CMISSSolverEquations_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_Initialise

!!==================================================================================================================================
!!
!! ANALYTIC_ANALYSIS_ROUTINES
!!
!!==================================================================================================================================

  !>Output the analytic error analysis for a field specified by a user number compared to the analytic values parameter set.
  SUBROUTINE CMISSAnalyticAnalysisOutputNumber(regionUserNumber,fieldUserNumber,fileName,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<If not empty, the filename to output the analytic analysis to. If empty, the analysis will be output to the standard output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisOutputNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_OUTPUT(FIELD,fileName,err,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisOutputNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisOutputNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisOutputNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisOutputNumber

  !
  !================================================================================================================================
  !

  !>Output the analytic error analysis for a field identified by an object compared to the analytic values parameter set.
  SUBROUTINE CMISSAnalyticAnalysisOutputObj(field,fileName,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<If not empty, the filename to output the analytic analysis to. If empty, the analysis will be output to the standard output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisOutputObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_OUTPUT(field%FIELD,fileName,err,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisOutputObj")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisOutputObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisOutputObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisOutputObj

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber(regionUserNumber,fieldUserNumber,variableType,versionNumber, &
    & derivativeNumber, nodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_NODE(FIELD,variableType,versionNumber,derivativeNumber,nodeNumber, &
          & componentNumber,value,ERR, error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_NODE(field%FIELD,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetNodeObj

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetNodeNumber(regionUserNumber,fieldUserNumber,variableType,versionNumber, &
    & derivativeNumber,nodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_NODE(FIELD,variableType,versionNumber,derivativeNumber,nodeNumber, &
          & componentNumber,value,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetNodeNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetNodeNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetNodeNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetNodeObj(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetNodeObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_NODE(field%FIELD,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetNodeObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetNodeObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetNodeObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetNodeObj


  !
  !================================================================================================================================
  !

  !>Get relative error value for the node in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetNodeNumber(regionUserNumber,fieldUserNumber,variableType,versionNumber, &
    & derivativeNumber,nodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_NODE(FIELD,variableType,versionNumber,derivativeNumber,nodeNumber, &
          & componentNumber,value,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetNodeNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetNodeNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetNodeNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the node in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetNodeObj(field,variableType,versionNumber,derivativeNumber,nodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<derivative version number
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<derivative number
    INTEGER(INTG), INTENT(IN) :: nodeNumber !<node number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetNodeObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_NODE(field%FIELD,variableType,versionNumber,derivativeNumber,nodeNumber, &
      & componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetNodeObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetNodeObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetNodeObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetNodeObj

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber(regionUserNumber,fieldUserNumber,variableType,elementNumber, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_ELEMENT(FIELD,variableType,elementNumber,componentNumber,value,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetElementObj(field,variableType,elementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetElementObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_ELEMENT(field%FIELD,variableType,elementNumber,componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetElementObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetElementObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetElementObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetElementObj

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetElementNumber(regionUserNumber,fieldUserNumber,variableType,elementNumber, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_ELEMENT(FIELD,variableType,elementNumber,componentNumber,value,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetElementNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetElementNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetElementNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetElementObj(field,variableType,elementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetElementObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_ELEMENT(field%FIELD,variableType,elementNumber,componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetElementObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetElementObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetElementObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetElementObj


  !
  !================================================================================================================================
  !

  !>Get relative error value for the element in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetElementNumber(regionUserNumber,fieldUserNumber,variableType,elementNumber, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_ELEMENT(FIELD,variableType,elementNumber,componentNumber,value,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetElementNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetElementNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetElementNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the element in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetElementObj(field,variableType,elementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<element number
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetElementObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_ELEMENT(field%FIELD,variableType,elementNumber,componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetElementObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetElementObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetElementObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetElementObj

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_CONSTANT(FIELD,variableType,componentNumber,value,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetElementNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetConstantNumber

  !
  !================================================================================================================================
  !

  !>Get absolute error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj(field,variableType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the absolute error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_ABSOLUTE_ERROR_GET_CONSTANT(field%FIELD,variableType,componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisAbsoluteErrorGetConstantObj

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetConstantNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetConstantNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_CONSTANT(FIELD,variableType,componentNumber,value,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetConstantNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetConstantNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetConstantNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetConstantNumber

  !
  !================================================================================================================================
  !

  !>Get percentage error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetConstantObj(field,variableType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the percentage error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisPercentageErrorGetConstantObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_PERCENTAGE_ERROR_GET_CONSTANT(field%FIELD,variableType,componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetConstantObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisPercentageErrorGetConstantObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisPercentageErrorGetConstantObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisPercentageErrorGetConstantObj


  !
  !================================================================================================================================
  !

  !>Get relative error value for the constant in a field specified by a user number compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetConstantNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetConstantNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_CONSTANT(FIELD,variableType,componentNumber,value,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetConstantNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetConstantNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetConstantNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetConstantNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetConstantObj(field,variableType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: VALUE !<On return, the relative error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisRelativeErrorGetConstantObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_RELATIVE_ERROR_GET_CONSTANT(field%FIELD,variableType,componentNumber,value,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetConstantObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRelativeErrorGetConstantObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRelativeErrorGetConstantObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRelativeErrorGetConstantObj

  !
  !================================================================================================================================
  !

  !>Get rms error value for nodes in a field compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetNodeNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, errorType, &
    & localValue,localGhostValue,globalValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    INTEGER(INTG), INTENT(IN) :: errorType !<error type
    REAL(DP), INTENT(OUT) :: localValue(8) !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue(8) !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue(8) !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisRmsErrorGetNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_RMS_ERROR_GET_NODE(FIELD,variableType,componentNumber,errorType,localValue,localGhostValue, &
          & globalValue,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetNodeNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRmsErrorGetNodeNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetNodeNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetNodeNumber

  !
  !================================================================================================================================
  !

  !>Get rms error value for nodes in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetNodeObj(field,variableType,componentNumber,errorType,localValue,localGhostValue, &
    & globalValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    INTEGER(INTG), INTENT(IN) :: errorType !<error type
    REAL(DP), INTENT(OUT) :: localValue(8) !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue(8) !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue(8) !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisRmsErrorGetNodeObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_RMS_ERROR_GET_NODE(field%FIELD,variableType,componentNumber,errorType,localValue,localGhostValue, &
      & globalValue,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetNodeObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRmsErrorGetNodeObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetNodeObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetNodeObj

  !
  !================================================================================================================================
  !

  !>Get rms error value for elements in a field compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetElementNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & errorType,localValue,localGhostValue,globalValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    INTEGER(INTG), INTENT(IN) :: errorType !<error type
    REAL(DP), INTENT(OUT) :: localValue !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisRmsErrorGetElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_RMS_ERROR_GET_ELEMENT(FIELD,variableType,componentNumber,errorType,localValue,localGhostValue, &
          & globalValue,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetElementNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRmsErrorGetElementNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetElementNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetElementNumber

  !
  !================================================================================================================================
  !

  !>Get relative error value for the constant in a field identified by an object compared to the analytic value.
  SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetElementObj(field,variableType,componentNumber,errorType,localValue,localGhostValue, &
    & globalValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    INTEGER(INTG), INTENT(IN) :: errorType !<error type
    REAL(DP), INTENT(OUT) :: localValue !<On return, the local error
    REAL(DP), INTENT(OUT) :: localGhostValue !<On return, the local ghost error
    REAL(DP), INTENT(OUT) :: globalValue !<On return, the global error
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisRmsErrorGetNodeObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_RMS_ERROR_GET_ELEMENT(field%FIELD,variableType,componentNumber,errorType,localValue,localGhostValue, &
      & globalValue,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetElementObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisRmsErrorGetElementObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisRmsErrorGetElementObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisRmsErrorGetElementObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the numerical values.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNumericalValueGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNumericalValueGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_NUMERICAL_VALUE_GET(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisIntegralNumericalValueGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNumericalValueGetNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNumericalValueGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralNumericalValueGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the numerical values.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNumericalValueGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNumericalValueGetObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_INTEGRAL_NUMERICAL_VALUE_GET(field%FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralNumericalValueGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNumericalValueGetObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNumericalValueGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralNumericalValueGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the analytic values.
  SUBROUTINE CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_ANALYTIC_VALUE_GET(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralAnalyticValueGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the analytic values.
  SUBROUTINE CMISSAnalyticAnalysisIntegralAnalyticValueGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralAnalyticValueGetObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_INTEGRAL_ANALYTIC_VALUE_GET(field%FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralAnalyticValueGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralAnalyticValueGetObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralAnalyticValueGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralAnalyticValueGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the percentage errors.
  SUBROUTINE CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_PERCENTAGE_ERROR_GET(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralPercentageErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the percentage errors.
  SUBROUTINE CMISSAnalyticAnalysisIntegralPercentageErrorGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralPercentageErrorGetObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_INTEGRAL_PERCENTAGE_ERROR_GET(field%FIELD,variableType,componentNumber,integralValue, &
      & ghostIntegralValue,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralPercentageErrorGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralPercentageErrorGetObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralPercentageErrorGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralPercentageErrorGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the absolute errors.
  SUBROUTINE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_ABSOLUTE_ERROR_GET(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the absolute errors.
  SUBROUTINE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_INTEGRAL_ABSOLUTE_ERROR_GET(field%FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralAbsoluteErrorGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the relative error.
  SUBROUTINE CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_RELATIVE_ERROR_GET(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
          & ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralRelativeErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the relative error.
  SUBROUTINE CMISSAnalyticAnalysisIntegralRelativeErrorGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralRelativeErrorGetObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_INTEGRAL_RELATIVE_ERROR_GET(field%FIELD,variableType,componentNumber,integralValue,ghostIntegralValue, &
      & ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralRelativeErrorGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralRelativeErrorGetObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralRelativeErrorGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralRelativeErrorGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid numerical.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber(regionUserNumber,fieldUserNumber,variableType, &
    & componentNumber,integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_NID_NUMERICAL_VALUE_GET(FIELD,variableType,componentNumber,integralValue, &
          & ghostIntegralValue,ERR,error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralNidNumericalValueGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid numerical.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj(field,variableType,componentNumber,integralValue, &
    & ghostIntegralValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_INTEGRAL_NID_NUMERICAL_VALUE_GET(field%FIELD,variableType,componentNumber,integralValue, &
      & ghostIntegralValue,ERR,error,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralNidNumericalValueGetObj

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid error.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNidErrorGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & integralValue,ghostIntegralValue,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field for analytic error analysis.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNidErrorGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL ANALYTIC_ANALYSIS_INTEGRAL_NID_ERROR_GET(FIELD,variableType,componentNumber,integralValue,ghostIntegralValue,ERR, &
          & error,*999)
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSAnalyticAnalysisIntegralNidErrorGetNumber")
    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNidErrorGetNumber",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNidErrorGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralNidErrorGetNumber

  !
  !================================================================================================================================
  !

  !>Get integral value for the nid error.
  SUBROUTINE CMISSAnalyticAnalysisIntegralNidErrorGetObj(field,variableType,componentNumber,integralValue,ghostIntegralValue,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to calculate the analytic error analysis for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<component number
    INTEGER(INTG), INTENT(IN) :: variableType !<variable type
    REAL(DP), INTENT(OUT) :: integralValue(2) !<On return, the integral value
    REAL(DP), INTENT(OUT) :: ghostIntegralValue(2) !<On return, ghost integral value
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSAnalyticAnalysisIntegralNidErrorGetObj",err,error,*999)

    CALL ANALYTIC_ANALYSIS_INTEGRAL_NID_ERROR_GET(field%FIELD,variableType,componentNumber,integralValue,ghostIntegralValue,ERR, &
      & error,*999)

    CALL EXITS("CMISSAnalyticAnalysisIntegralNidErrorGetObj")

    RETURN
999 CALL ERRORS("CMISSAnalyticAnalysisIntegralNidErrorGetObj",err,error)
    CALL EXITS("CMISSAnalyticAnalysisIntegralNidErrorGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSAnalyticAnalysisIntegralNidErrorGetObj




!!==================================================================================================================================
!!
!! BASE_ROUTINES
!!
!!==================================================================================================================================

  !>Sets diagnostics off. \see OPENCMISS::CMISSDiagnosticsSetOn
  SUBROUTINE CMISSDiagnosticsSetOff(err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSDiagnosticsSetOff",err,error,*999)

    CALL DIAGNOSTICS_SET_OFF(err,error,*999)

    CALL EXITS("CMISSDiagnosticsSetOff")
    RETURN
999 CALL ERRORS("CMISSDiagnosticsSetOff",err,error)
    CALL EXITS("CMISSDiagnosticsSetOff")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDiagnosticsSetOff

  !
  !================================================================================================================================
  !

  !>Sets diagnostics on \see OPENCMISS::CMISSDiagnosticsSetOff
  SUBROUTINE CMISSDiagnosticsSetOn(diagType,levelList,diagFilename,routineList,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: diagType !<The type of diagnostics to set on \see OPENCMISS_DiagnosticTypes.
    INTEGER(INTG), INTENT(IN) :: levelList(:) !<The list of diagnostic levels to set on.
    CHARACTER(LEN=*), INTENT(IN) :: diagFilename !<If present the name of the file to output diagnostic information to. If omitted the diagnostic output is sent to the screen.
    CHARACTER(LEN=*), INTENT(IN) :: routineList(:) !<The list of routines to set diagnostics on in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSDiagnosticsSetOn",err,error,*999)

    CALL DIAGNOSTICS_SET_ON(diagType,levelList,diagFilename,routineList,err,error,*999)

    CALL EXITS("CMISSDiagnosticsSetOn")
    RETURN
999 CALL ERRORS("CMISSDiagnosticsSetOn",err,error)
    CALL EXITS("CMISSDiagnosticsSetOn")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDiagnosticsSetOn

  !
  !================================================================================================================================
  !

  !>Sets output off \see OPENCMISS::CMISSOutputSetOff
  SUBROUTINE CMISSOutputSetOff(err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSOutputSetOff",err,error,*999)

    CALL OUTPUT_SET_OFF(err,error,*999)

    CALL EXITS("CMISSOutputSetOff")
    RETURN
999 CALL ERRORS("CMISSOutputSetOff",err,error)
    CALL EXITS("CMISSOutputSetOff")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSOutputSetOff

  !
  !================================================================================================================================
  !

  !>Sets output on \see OPENCMISS::CMISSOutputSetOff
  SUBROUTINE CMISSOutputSetOn(echoFilename,err)

    !Argument variables
    CHARACTER(LEN=*), INTENT(IN) :: echoFilename !<The filename of the file to echo output to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSOutputSetOn",err,error,*999)

    CALL OUTPUT_SET_ON(echoFilename,err,error,*999)

    CALL EXITS("CMISSOutputSetOn")
    RETURN
999 CALL ERRORS("CMISSOutputSetOn",err,error)
    CALL EXITS("CMISSOutputSetOn")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSOutputSetOn

  !
  !================================================================================================================================
  !

  !>Sets timing off \see OPENCMISS::CMISSTimingSetOn
  SUBROUTINE CMISSTimingSetOff(err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSTimingSetOff",ERR,error,*999)

    CALL TIMING_SET_OFF(err,error,*999)

    CALL EXITS("CMISSTimingSetOff")
    RETURN
999 CALL ERRORS("CMISSTimingSetOff",err,error)
    CALL EXITS("CMISSTimingSetOff")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSTimingSetOff

  !
  !================================================================================================================================
  !

  !>Sets timing on \see OPENCMISS::CMISSTimingSetOff
  SUBROUTINE CMISSTimingSetOn(timingType,timingSummaryFlag,timingFilename,routineList,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: timingType !<The type of timing to set on \see OPENCMISS_TimingTypes.
    LOGICAL, INTENT(IN) :: timingSummaryFlag !<.TRUE. if the timing information will be output with subsequent OPENCMISS::CMISSTimingSummaryOutput calls, .FALSE. if the timing information will be output every time the routine exits.
    CHARACTER(LEN=*), INTENT(IN) :: timingFilename !<If present the name of the file to output timing information to. If omitted the timing output is sent to the screen.
    CHARACTER(LEN=*), INTENT(IN) :: routineList(:) !<The list of routines to set timing on in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSTimingSetOn",err,error,*999)

    CALL TIMING_SET_ON(timingType,timingSummaryFlag,timingFilename,routineList,err,error,*999)

    CALL EXITS("CMISSTimingSetOn")
    RETURN
999 CALL ERRORS("CMISSTimingSetOn",err,error)
    CALL EXITS("CMISSTimingSetOn")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSTimingSetOn

  !
  !================================================================================================================================
  !

  !>Outputs the timing summary.
  SUBROUTINE CMISSTimingSummaryOutput(err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: ERR !<The error code
    !Local variables

    CALL ENTERS("CMISSTimingSummaryOutput",err,error,*999)

    CALL TIMING_SUMMARY_OUTPUT(err,error,*999)

    CALL EXITS("CMISSTimingSummaryOutput")
    RETURN
999 CALL ERRORS("CMISSTimingSummaryOutput",err,error)
    CALL EXITS("CMISSTimingSummaryOutput")
    RETURN

  END SUBROUTINE CMISSTimingSummaryOutput

!!==================================================================================================================================
!!
!! BASIS_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the collapsed Xi flags of a basis identified by a user number.
  SUBROUTINE CMISSBasis_CollapsedXiGetNumber(userNumber,collapsedXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the collapsed Xi flags for.
    INTEGER(INTG), INTENT(OUT) :: collapsedXi(:) !<collapsedXi(ni). On return, the collapsed Xi parameter for the ni'th Xi direction. \see OPENCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_CollapsedXiGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_COLLAPSED_XI_GET(BASIS,collapsedXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_CollapsedXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_CollapsedXiGetNumber",err,error)
    CALL EXITS("CMISSBasis_CollapsedXiGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_CollapsedXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the collapsed Xi flags of a basis identified by an object.
  SUBROUTINE CMISSBasis_CollapsedXiGetObj(basis,collapsedXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the collapsed Xi flags for.
    INTEGER(INTG), INTENT(OUT) :: collapsedXi(:) !<collapsedXi(ni). On return, the collapsed Xi parameter for the ni'th Xi direction. \see OPENCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_CollapsedXiGetObj",err,error,*999)

    CALL BASIS_COLLAPSED_XI_GET(basis%BASIS,collapsedXi,err,error,*999)

    CALL EXITS("CMISSBasis_CollapsedXiGetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_CollapsedXiGetObj",err,error)
    CALL EXITS("CMISSBasis_CollapsedXiGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_CollapsedXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the collapsed Xi flags of a basis identified by a user number.
  SUBROUTINE CMISSBasis_CollapsedXiSetNumber(userNumber,collapsedXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to set the collapsed Xi flags for.
    INTEGER(INTG), INTENT(IN) :: collapsedXi(:) !<collapsedXi(ni). The collapsed Xi parameter for the ni'th Xi direction to set. \see OPENCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_CollapsedXiSetNumber",ERR,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_COLLAPSED_XI_SET(BASIS,collapsedXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_CollapsedXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_CollapsedXiSetNumber",err,error)
    CALL EXITS("CMISSBasis_CollapsedXiSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_CollapsedXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the collapsed Xi flags of a basis identified by an object.
  SUBROUTINE CMISSBasis_CollapsedXiSetObj(basis,collapsedXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to set the collapsed Xi flags for.
    INTEGER(INTG), INTENT(IN) :: collapsedXi(:) !<collapsedXi(ni). The collapsed Xi parameter for the ni'th Xi direction to set. \see OPENCMISS_BasisXiCollapse
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_CollapsedXiSetObj",err,error,*999)

    CALL BASIS_COLLAPSED_XI_SET(basis%BASIS,collapsedXi,err,error,*999)

    CALL EXITS("CMISSBasis_CollapsedXiSetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_CollapsedXiSetObj",err,error)
    CALL EXITS("CMISSBasis_CollapsedXiSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_CollapsedXiSetObj

  !
  !================================================================================================================================
  !

   !>Finishes the creation of a new basis identified by a user number.
  SUBROUTINE CMISSBasis_CreateFinishNumber(userNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_CreateFinishNumber",ERR,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,err,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_CREATE_FINISH(Basis,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Basis Create')
#endif

    CALL EXITS("CMISSBasis_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_CreateFinishNumber",err,error)
    CALL EXITS("CMISSBasis_CreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a new basis identified by an object.
  SUBROUTINE CMISSBasis_CreateFinishObj(basis,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSBasis_CreateFinishObj",err,error,*999)

    CALL BASIS_CREATE_FINISH(basis%BASIS,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('basis Create')
#endif

    CALL EXITS("CMISSBasis_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSBasis_CreateFinishObj",err,error)
    CALL EXITS("CMISSBasis_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new basis for a basis identified by a user number.
  SUBROUTINE CMISSBasis_CreateStartNumber(userNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS

    CALL ENTERS("CMISSBasis_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Basis Create')
#endif

    NULLIFY(BASIS)
    CALL BASIS_CREATE_START(userNumber,BASIS,err,error,*999)

    CALL EXITS("CMISSBasis_CreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_CreateStartNumber",err,error)
    CALL EXITS("CMISSBasis_CreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new basis for a basis identified by an object.
  SUBROUTINE CMISSBasis_CreateStartObj(userNumber,basis,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to start the creation of.
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<On exit, the newly created basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('basis Create')
#endif

    CALL BASIS_CREATE_START(userNumber,basis%BASIS,err,error,*999)

    CALL EXITS("CMISSBasis_CreateStartObj")
    RETURN
999 CALL ERRORS("CMISSBasis_CreateStartObj",err,error)
    CALL EXITS("CMISSBasis_CreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a basis identified by its basis user number.
  SUBROUTINE CMISSBasis_DestroyNumber(userNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_DestroyNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_DESTROY(BASIS,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_DestroyNumber",err,error)
    CALL EXITS("CMISSBasis_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a basis identified by an object.
  SUBROUTINE CMISSBasis_DestroyObj(basis,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_DestroyObj",err,error,*999)

    CALL BASIS_DESTROY(basis%BASIS,err,error,*999)

    CALL EXITS("CMISSBasis_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSBasis_DestroyObj",err,error)
    CALL EXITS("CMISSBasis_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_DestroyObj

  !
  !================================================================================================================================
  !

  !>Get the interpolation type in each xi directions for a basis identified by a user number.
  SUBROUTINE CMISSBasis_InterpolationXiGetNumber(userNumber,interpolationXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: interpolationXi(:) !<On return, the interpolation xi parameters for each Xi direction \see OPENCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_InterpolationXiGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_INTERPOLATION_XI_GET(BASIS,interpolationXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_InterpolationXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_InterpolationXiGetNumber",err,error)
    CALL EXITS("CMISSBasis_InterpolationXiGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_InterpolationXiGetNumber

  !
  !================================================================================================================================
  !

  !>Get the interpolation type in each xi directions for a basis indentified by an object.
  SUBROUTINE CMISSBasis_InterpolationXiGetObj(basis,interpolationXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: interpolationXi(:) !<On return, the interpolation xi parameters for each Xi direction \see OPENCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_InterpolationXiGetObj",err,error,*999)

    CALL BASIS_INTERPOLATION_XI_GET(basis%BASIS,interpolationXi,err,error,*999)

    CALL EXITS("CMISSBasis_InterpolationXiGetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_InterpolationXiGetObj",err,error)
    CALL CMISS_HANDLE_ERROR(err,error)
    CALL EXITS("CMISSBasis_InterpolationXiGetObj")
    RETURN

  END SUBROUTINE CMISSBasis_InterpolationXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type in each xi directions for a basis identified by a user number.
  SUBROUTINE CMISSBasis_InterpolationXiSetNumber(userNumber,interpolationXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(IN) :: interpolationXi(:) !<The interpolation xi parameters for each Xi direction \see OPENCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_InterpolationXiSetNumber",ERR,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_INTERPOLATION_XI_SET(BASIS,interpolationXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_InterpolationXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_InterpolationXiSetNumber",err,error)
    CALL EXITS("CMISSBasis_InterpolationXiSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_InterpolationXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type in each xi directions for a basis indentified by an object.
  SUBROUTINE CMISSBasis_InterpolationXiSetObj(basis,interpolationXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(IN) :: interpolationXi(:) !<The interpolation xi parameters for each Xi direction \see OPENCMISS_BasisInterpolationSpecifications.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_InterpolationXiSetObj",err,error,*999)

    CALL BASIS_INTERPOLATION_XI_SET(basis%BASIS,interpolationXi,err,error,*999)

    CALL EXITS("CMISSBasis_InterpolationXiSetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_InterpolationXiSetObj",err,error)
    CALL EXITS("CMISSBasis_InterpolationXiSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_InterpolationXiSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of local nodes in a basis identified by a user number.
  SUBROUTINE CMISSBasis_NumberOfLocalNodesGetNumber(userNumber,numberOfLocalNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the interpolation xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfLocalNodes !<On return, the number of local nodes in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_NumberOfLocalNodesGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_NUMBER_OF_LOCAL_NODES_GET(BASIS,numberOfLocalNodes,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_NumberOfLocalNodesGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_NumberOfLocalNodesGetNumber",err,error)
    CALL EXITS("CMISSBasis_NumberOfLocalNodesGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_NumberOfLocalNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of local nodes in a basis identified by an object.
  SUBROUTINE CMISSBasis_NumberOfLocalNodesGetObj(basis,numberOfLocalNodes,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the number of local nodes for.
    INTEGER(INTG), INTENT(OUT) :: numberOfLocalNodes !<On return, the number of local nodes in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_NumberOfLocalNodesGetObj",err,error,*999)

    CALL BASIS_NUMBER_OF_LOCAL_NODES_GET(basis%BASIS,numberOfLocalNodes,err,error,*999)

    CALL EXITS("CMISSBasis_NumberOfLocalNodesGetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_NumberOfLocalNodesGetObj",err,error)
    CALL EXITS("CMISSBasis_NumberOfLocalNodesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_NumberOfLocalNodesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of Xi directions in a basis identified by a user number.
  SUBROUTINE CMISSBasis_NumberOfXiGetNumber(userNumber,numberOfXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the number xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfXi !<On return, the number of xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_NumberOfXiGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_NUMBER_OF_XI_GET(BASIS,numberOfXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_NumberOfXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_NumberOfXiGetNumber",err,error)
    CALL EXITS("CMISSBasis_NumberOfXiGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_NumberOfXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of Xi directions in a basis identified by an object.
  SUBROUTINE CMISSBasis_NumberOfXiGetObj(basis,numberOfXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the number of xi directions for.
    INTEGER(INTG), INTENT(OUT) :: numberOfXi !<On return, the number of xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_NumberOfXiGetObj",err,error,*999)

    CALL BASIS_NUMBER_OF_XI_GET(basis%BASIS,numberOfXi,err,error,*999)

    CALL EXITS("CMISSBasis_NumberOfXiGetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_NumberOfXiGetObj",err,error)
    CALL EXITS("CMISSBasis_NumberOfXiGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_NumberOfXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of Xi directions in a basis identified by a user number.
  SUBROUTINE CMISSBasis_NumberOfXiSetNumber(userNumber,numberOfXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to set the number xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfXi !<The number of xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_NumberOfXiSetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_NUMBER_OF_XI_SET(BASIS,numberOfXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_NumberOfXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_NumberOfXiSetNumber",err,error)
    CALL EXITS("CMISSBasis_NumberOfXiSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_NumberOfXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of Xi directions in a basis identified by an object.
  SUBROUTINE CMISSBasis_NumberOfXiSetObj(basis,numberOfXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to set the number of xi directions for.
    INTEGER(INTG), INTENT(IN) :: numberOfXi !<The number of xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_NumberOfXiSetObj",err,error,*999)

    CALL BASIS_NUMBER_OF_XI_SET(basis%BASIS,numberOfXi,err,error,*999)

    CALL EXITS("CMISSBasis_NumberOfXiSetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_NumberOfXiSetObj",err,error)
    CALL EXITS("CMISSBasis_NumberOfXiSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_NumberOfXiSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of Gauss points in each Xi directions for a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasis_QuadratureNumberOfGaussXiGetNumber(userNumber,numberOfGaussXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfGaussXi(:) !<On return, the number of Gauss points in each Xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_QuadratureNumberOfGaussXiGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_NUMBER_OF_GAUSS_XI_GET(BASIS,numberOfGaussXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_QuadratureNumberOfGaussXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureNumberOfGaussXiGetNumber",err,error)
    CALL EXITS("CMISSBasis_QuadratureNumberOfGaussXiGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureNumberOfGaussXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number Gauss points in each Xi directions for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasis_QuadratureNumberOfGaussXiGetObj(basis,numberOfGaussXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(OUT) :: numberOfGaussXi(:) !<On return, the number of Gauss points in each Xi directions in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_QuadratureNumberOfGaussXiGetObj",err,error,*999)

    CALL BASIS_QUADRATURE_NUMBER_OF_GAUSS_XI_GET(basis%BASIS,numberOfGaussXi,err,error,*999)

    CALL EXITS("CMISSBasis_QuadratureNumberOfGaussXiGetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureNumberOfGaussXiGetObj",err,error)
    CALL EXITS("CMISSBasis_QuadratureNumberOfGaussXiGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureNumberOfGaussXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of Gauss points in each Xi directions for a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasis_QuadratureNumberOfGaussXiSetNumber(userNumber,numberOfGaussXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to set the number of Gauss Xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfGaussXi(:) !<The number of Gauss points in each Xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_QuadratureNumberOfGaussXiSetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_NUMBER_OF_GAUSS_XI_SET(BASIS,numberOfGaussXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_QuadratureNumberOfGaussXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureNumberOfGaussXiSetNumber",err,error)
    CALL EXITS("CMISSBasis_QuadratureNumberOfGaussXiSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureNumberOfGaussXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the number Gauss points in each Xi directions for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasis_QuadratureNumberOfGaussXiSetObj(basis,numberOfGaussXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to get the number of Gauss Xi for.
    INTEGER(INTG), INTENT(IN) :: numberOfGaussXi(:) !<The number of Gauss points in each Xi directions in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_QuadratureNumberOfGaussXiSetObj",err,error,*999)

    CALL BASIS_QUADRATURE_NUMBER_OF_GAUSS_XI_SET(basis%BASIS,numberOfGaussXi,err,error,*999)

    CALL EXITS("CMISSBasis_QuadratureNumberOfGaussXiSetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureNumberOfGaussXiSetObj",err,error)
    CALL EXITS("CMISSBasis_QuadratureNumberOfGaussXiSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureNumberOfGaussXiSetObj

  !
  !================================================================================================================================
  !
  !>Returns the xi position of a Gauss point on a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasis_QuadratureSingleGaussXiGetNumber(userNumber,quadratureScheme,GaussPoint,GaussXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the Gauss Xi positions for.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to return the Gauss positions for.
    INTEGER(INTG), INTENT(IN) :: GaussPoint !<The Gauss point to return the element xi positions for.
    REAL(DP), INTENT(OUT) :: GaussXi(:) !<On return, GaussXi(xi_direction) the xi position of the specified Gauss point for the specified quadrature scheme.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_QuadratureSingleGaussXiGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_SINGLE_GAUSS_XI_GET(BASIS,quadratureScheme,GaussPoint,GaussXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_QuadratureSingleGaussXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureSingleGaussXiGetNumber",err,error)
    CALL EXITS("CMISSBasis_QuadratureSingleGaussXiGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureSingleGaussXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the xi position of a Gauss point on a basis quadrature identified by an object.
  SUBROUTINE CMISSBasis_QuadratureSingleGaussXiGetObj(basis,quadratureScheme,GaussPoint,GaussXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the Gauss Xi positions for.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to return the Gauss xi positions for.
    INTEGER(INTG), INTENT(IN) :: GaussPoint !<The Gauss point to return the element xi positions for.
    REAL(DP), INTENT(OUT) :: GaussXi(:) !<On return, GaussXi(xi_direction) the xi position of the specified Gauss point for the specified quadrature scheme.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_QuadratureSingleGaussXiGetObj",err,error,*999)

    CALL BASIS_QUADRATURE_SINGLE_GAUSS_XI_GET(basis%BASIS,quadratureScheme,GaussPoint,GaussXi,err,error,*999)

    CALL EXITS("CMISSBasis_QuadratureSingleGaussXiGetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureSingleGaussXiGetObj",err,error)
    CALL EXITS("CMISSBasis_QuadratureSingleGaussXiGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureSingleGaussXiGetObj

  !
  !================================================================================================================================
  !

  !>Returns the xi positions of Gauss points on a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasis_QuadratureMultipleGaussXiGetNumber(userNumber,quadratureScheme,GaussPoints,GaussXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the Gauss Xi positions for.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to return the Gauss positions for.
    INTEGER(INTG), INTENT(IN) :: GaussPoints(:) !<The Gauss points to return the element xi positions for.
    REAL(DP), INTENT(OUT) :: GaussXi(:,:) !<On return, GaussXi(Gauss_point,xi_direction) the Gauss xi positions for the specified quadrature scheme.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_QuadratureMultipleGaussXiGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_MULTIPLE_GAUSS_XI_GET(BASIS,quadratureScheme,GaussPoints,GaussXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_QuadratureMultipleGaussXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureMultipleGaussXiGetNumber",err,error)
    CALL EXITS("CMISSBasis_QuadratureMultipleGaussXiGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureMultipleGaussXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the xi positions of Gauss points on a basis quadrature identified by an object.
  SUBROUTINE CMISSBasis_QuadratureMultipleGaussXiGetObj(basis,quadratureScheme,GaussPoints,GaussXi,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the Gauss Xi positions for.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to return the Gauss xi positions for.
    INTEGER(INTG), INTENT(IN) :: GaussPoints(:) !<The Gauss points to return the element xi positions for.
    REAL(DP), INTENT(OUT) :: GaussXi(:,:) !<On return, GaussXi(Gauss_point,xi_direction) the Gauss xi positions for the specified quadrature scheme.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_QuadratureMultipleGaussXiGetObj",err,error,*999)

    CALL BASIS_QUADRATURE_MULTIPLE_GAUSS_XI_GET(basis%BASIS,quadratureScheme,GaussPoints,GaussXi,err,error,*999)

    CALL EXITS("CMISSBasis_QuadratureMultipleGaussXiGetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureMultipleGaussXiGetObj",err,error)
    CALL EXITS("CMISSBasis_QuadratureMultipleGaussXiGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureMultipleGaussXiGetObj

  !
  !================================================================================================================================
  !

  !>Returns the order of quadrature a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasis_QuadratureOrderGetNumber(userNumber,quadratureOrder,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: quadratureOrder !<On return, the order of quadrature in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_QuadratureOrderGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_ORDER_GET(BASIS,quadratureOrder,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_QuadratureOrderGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureOrderGetNumber",err,error)
    CALL EXITS("CMISSBasis_QuadratureOrderGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureOrderGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the the order of quadrature for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasis_QuadratureOrderGetObj(basis,quadratureOrder,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: quadratureOrder !<On return, the order of quadrature in the specified basis.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_QuadratureOrderGetObj",err,error,*999)

    CALL BASIS_QUADRATURE_ORDER_GET(basis%BASIS,quadratureOrder,err,error,*999)

    CALL EXITS("CMISSBasis_QuadratureOrderGetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureOrderGetObj",err,error)
    CALL EXITS("CMISSBasis_QuadratureOrderGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureOrderGetObj


  !
  !================================================================================================================================
  !

  !>Sets/changes the order of quadrature a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasis_QuadratureOrderSetNumber(userNumber,quadratureOrder,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to set the quadrature order for.
    INTEGER(INTG), INTENT(IN) :: quadratureOrder !<The order of quadrature in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_QuadratureOrderSetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_ORDER_SET(BASIS,quadratureOrder,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_QuadratureOrderSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureOrderSetNumber",err,error)
    CALL EXITS("CMISSBasis_QuadratureOrderSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureOrderSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the the order of quadrature for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasis_QuadratureOrderSetObj(basis,quadratureOrder,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to set the quadrature order for.
    INTEGER(INTG), INTENT(IN) :: quadratureOrder !<The order of quadrature in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_QuadratureOrderSetObj",err,error,*999)

    CALL BASIS_QUADRATURE_ORDER_SET(basis%BASIS,quadratureOrder,err,error,*999)

    CALL EXITS("CMISSBasis_QuadratureOrderSetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureOrderSetObj",err,error)
    CALL EXITS("CMISSBasis_QuadratureOrderSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureOrderSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of quadrature a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasis_QuadratureTypeGetNumber(userNumber,quadratureType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the quadrature type for.
    INTEGER(INTG), INTENT(OUT) :: quadratureType !<On return, the type of quadrature in the specified basis. \see OPENCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_QuadratureTypeGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_TYPE_GET(BASIS,quadratureType,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_QuadratureTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureTypeGetNumber",err,error)
    CALL EXITS("CMISSBasis_QuadratureTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the the type of quadrature for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasis_QuadratureTypeGetObj(basis,quadratureType,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the quadrature order for.
    INTEGER(INTG), INTENT(OUT) :: quadratureType !<On return, the type of quadrature in the specified basis. \see OPENCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_QuadratureTypeGetObj",err,error,*999)

    CALL BASIS_QUADRATURE_TYPE_GET(basis%BASIS,quadratureType,err,error,*999)

    CALL EXITS("CMISSBasis_QuadratureTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureTypeGetObj",err,error)
    CALL EXITS("CMISSBasis_QuadratureTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of quadrature a basis quadrature identified by a user number.
  SUBROUTINE CMISSBasis_QuadratureTypeSetNumber(userNumber,quadratureType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the quadrature type for.
    INTEGER(INTG), INTENT(IN) :: quadratureType !<The type of quadrature in the specified basis to set. \see OPENCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_QuadratureTypeSetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_TYPE_SET(BASIS,quadratureType,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_QuadratureTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureTypeSetNumber",err,error)
    CALL EXITS("CMISSBasis_QuadratureTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the the type of quadrature for a basis quadrature identified by an object.
  SUBROUTINE CMISSBasis_QuadratureTypeSetObj(basis,quadratureType,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to get the quadrature type for.
    INTEGER(INTG), INTENT(OUT) :: quadratureType !<The type of quadrature in the specified basis to set. \see OPENCMISS_QuadratureTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_QuadratureTypeSetObj",err,error,*999)

    CALL BASIS_QUADRATURE_TYPE_SET(basis%BASIS,quadratureType,err,error,*999)

    CALL EXITS("CMISSBasis_QuadratureTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureTypeSetObj",err,error)
    CALL EXITS("CMISSBasis_QuadratureTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the local face Gauss scheme calculation, on a basis identified by a user number.
  SUBROUTINE CMISSBasis_QuadratureLocalFaceGaussEvaluateSetNumber(userNumber,faceGaussEvaluate,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the quadrature type for.
    LOGICAL, INTENT(IN) :: faceGaussEvaluate !<The value to set face Gauss evaluation flag to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_QuadratureLocalFaceGaussEvaluateSetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_QUADRATURE_LOCAL_FACE_GAUSS_EVALUATE_SET(BASIS,faceGaussEvaluate,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_QuadratureLocalFaceGaussEvaluateSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureLocalFaceGaussEvaluateSetNumber",err,error)
    CALL EXITS("CMISSBasis_QuadratureLocalFaceGaussEvaluateSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureLocalFaceGaussEvaluateSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the local face Gauss scheme calculation, on a basis identified by an object.
  SUBROUTINE CMISSBasis_QuadratureLocalFaceGaussEvaluateSetObj(basis,faceGaussEvaluate,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to get the quadrature type for.
    LOGICAL, INTENT(IN) :: faceGaussEvaluate !<The type of quadrature in the specified basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL ENTERS("CMISSBasis_QuadratureLocalFaceGaussEvaluateSetObj",err,error,*999)

    CALL BASIS_QUADRATURE_LOCAL_FACE_GAUSS_EVALUATE_SET(basis%BASIS,faceGaussEvaluate,err,error,*999)

    CALL EXITS("CMISSBasis_QuadratureLocalFaceGaussEvaluateSetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_QuadratureLocalFaceGaussEvaluateSetObj",err,error)
    CALL EXITS("CMISSBasis_QuadratureLocalFaceGaussEvaluateSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_QuadratureLocalFaceGaussEvaluateSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a basis identified by a user number.
  SUBROUTINE CMISSBasis_TypeGetNumber(userNumber,basisType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to get the type for.
    INTEGER(INTG), INTENT(OUT) :: basisType !<On return, the type of the specified basis. \see OPENCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_TypeGetNumber",err,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_TYPE_GET(BASIS,basisType,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_TypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_TypeGetNumber",err,error)
    CALL EXITS("CMISSBasis_TypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a basis identified by an object.
  SUBROUTINE CMISSBasis_TypeGetObj(basis,basisType,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the type for.
    INTEGER(INTG), INTENT(OUT) :: basisType !<On return, the type of the specified basis. \see OPENCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_TypeGetObj",err,error,*999)

    CALL BASIS_TYPE_GET(basis%BASIS,basisType,err,error,*999)

    CALL EXITS("CMISSBasis_TypeGetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_TypeGetObj",err,error)
    CALL EXITS("CMISSBasis_TypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a basis identified by a user number.
  SUBROUTINE CMISSBasis_TypeSetNumber(userNumber,basisType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: userNumber !<The user number of the basis to set the type for.
    INTEGER(INTG), INTENT(IN) :: basisType !<The type of the specified basis to set. \see OPENCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBasis_TypeSetNumber",ERR,error,*999)

    NULLIFY(BASIS)
    CALL BASIS_USER_NUMBER_FIND(userNumber,BASIS,ERR,error,*999)
    IF(ASSOCIATED(BASIS)) THEN
      CALL BASIS_TYPE_SET(BASIS,basisType,err,error,*999)
    ELSE
      LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(userNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBasis_TypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSBasis_TypeSetNumber",err,error)
    CALL EXITS("CMISSBasis_TypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a basis identified by an object.
  SUBROUTINE CMISSBasis_TypeSetObj(basis,basisType,err)

    !Argument variables
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<The basis to set the type for.
    INTEGER(INTG), INTENT(IN) :: basisType !<The type of the specified basis to set. \see OPENCMISS_BasisTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBasis_TypeSetObj",err,error,*999)

    CALL BASIS_TYPE_SET(basis%BASIS,basisType,err,error,*999)

    CALL EXITS("CMISSBasis_TypeSetObj")
    RETURN
999 CALL ERRORS("CMISSBasis_TypeSetObj",err,error)
    CALL EXITS("CMISSBasis_TypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBasis_TypeSetObj


!!==================================================================================================================================
!!
!! BOUNDARY_CONDITIONS_ROUTINES
!!
!!==================================================================================================================================

  !>Destroys the boundary conditions for solver equations identified by a control loop identifier.
  SUBROUTINE CMISSBoundaryConditions_DestroyNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditions_DestroyNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
        IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
          CALL BOUNDARY_CONDITIONS_DESTROY(BOUNDARY_CONDITIONS,err,error,*999)
        ELSE
          LOCAL_ERROR="Solver equations boundary conditions is not associated."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBoundaryConditions_DestroyNumber0")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_DestroyNumber0",err,error)
    CALL EXITS("CMISSBoundaryConditions_DestroyNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_DestroyNumber0

  !
  !================================================================================================================================
  !

  !>Destroys the boundary conditions for solver equations identified by a control loop identifier.
  SUBROUTINE CMISSBoundaryConditions_DestroyNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditions_DestroyNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
        IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
          CALL BOUNDARY_CONDITIONS_DESTROY(BOUNDARY_CONDITIONS,err,error,*999)
        ELSE
          LOCAL_ERROR="Solver equations boundary conditions is not associated."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBoundaryConditions_DestroyNumber1")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_DestroyNumber1",err,error)
    CALL EXITS("CMISSBoundaryConditions_DestroyNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_DestroyNumber1

  !
  !================================================================================================================================
  !

  !>Destroys boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditions_DestroyObj(boundaryConditions,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<The boundary conditions to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditions_DestroyObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_DESTROY(boundaryConditions%BOUNDARY_CONDITIONS,err,error,*999)

    CALL EXITS("CMISSBoundaryConditions_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_DestroyObj",err,error)
    CALL EXITS("CMISSBoundaryConditions_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_DestroyObj

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditions_AddConstantNumber(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & fieldUserNumber,variableType,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the dependent field to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditions_AddConstantNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_ADD_CONSTANT(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,componentNumber, &
                & condition,value,err,error,*999)
            ELSE
              LOCAL_ERROR="A field with a user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            END IF
          ELSE
            CALL FLAG_ERROR("The solver equations boundary conditions are not associated.",err,error,*999)
          END IF
        ELSE
          CALL FLAG_ERROR("The solver equations are not associated.",err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBoundaryConditions_AddConstantNumber")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_AddConstantNumber",err,error)
    CALL EXITS("CMISSBoundaryConditions_AddConstantNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_AddConstantNumber

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditions_AddConstantObj(boundaryConditions,field,variableType,componentNumber,condition,value,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to add the constant to.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditions_AddConstantObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_ADD_CONSTANT(boundaryConditions%BOUNDARY_CONDITIONS,field%FIELD,variableType,componentNumber, &
      & condition,value,err,error,*999)

    CALL EXITS("CMISSBoundaryConditions_AddConstantObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_AddConstantObj",err,error)
    CALL EXITS("CMISSBoundaryConditions_AddConstantObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_AddConstantObj

  !
  !================================================================================================================================
  !


  !>Sets the value of the specified constant as a boundary condition on the specified constant for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditions_SetConstantNumber(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & variableType,fieldUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditions_SetConstantNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_SET_CONSTANT(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,componentNumber, &
                & condition,value,err,error,*999)
            ELSE
              LOCAL_ERROR="A field with a user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            END IF
          ELSE
            CALL FLAG_ERROR("The solver equations boundary conditions are not associated.",err,error,*999)
          END IF
        ELSE
          CALL FLAG_ERROR("The solver equations are not associated.",err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBoundaryConditions_SetConstantNumber")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_SetConstantNumber",err,error)
    CALL EXITS("CMISSBoundaryConditions_SetConstantNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_SetConstantNumber

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified constant and sets this as a boundary condition on the specified constant for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditions_SetConstantObj(boundaryConditions,field,variableType,componentNumber,condition,value,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to set the constant to.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditions_SetConstantObj",ERR,error,*999)

    CALL BOUNDARY_CONDITIONS_SET_CONSTANT(boundaryConditions%BOUNDARY_CONDITIONS,field%FIELD,variableType,componentNumber, &
      & condition,value,err,error,*999)

    CALL EXITS("CMISSBoundaryConditions_SetConstantObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_SetConstantObj",err,error)
    CALL EXITS("CMISSBoundaryConditions_SetConstantObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_SetConstantObj

  !
  !================================================================================================================================
  !

  !>Adds the value to the specified element and sets this as a boundary condition on the specified element for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditions_AddElementNumber(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & fieldUserNumber,variableType,elementUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditions_AddElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_ADD_ELEMENT(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,elementUserNumber, &
                & componentNumber,condition,value,err,error,*999)
            ELSE
              LOCAL_ERROR="A field with a user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            END IF
          ELSE
            CALL FLAG_ERROR("The solver equations boundary conditions are not associated.",err,error,*999)
          END IF
        ELSE
          CALL FLAG_ERROR("The solver equations are not associated.",err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBoundaryConditions_AddElementNumber")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_AddElementNumber",err,error)
    CALL EXITS("CMISSBoundaryConditions_AddElementNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_AddElementNumber

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified element and sets this as a boundary condition on the specified element for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditions_AddElementObj(boundaryConditions,field,variableType,elementUserNumber,componentNumber, &
    & condition,value,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to add the element to.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditions_AddElementObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_ADD_ELEMENT(boundaryConditions%BOUNDARY_CONDITIONS,field%FIELD,variableType,elementUserNumber, &
      & componentNumber,condition,value,err,error,*999)

    CALL EXITS("CMISSBoundaryConditions_AddElementObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_AddElementObj",err,error)
    CALL EXITS("CMISSBoundaryConditions_AddElementObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_AddElementObj

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified element as a boundary condition on the specified element for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditions_SetElementNumber(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & fieldUserNumber,variableType,elementUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditions_SetElementNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_SET_ELEMENT(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,elementUserNumber, &
                & componentNumber,condition,value,err,error,*999)
            ELSE
              LOCAL_ERROR="A field with a user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            END IF
          ELSE
            CALL FLAG_ERROR("The solver equations boundary conditions are not associated.",err,error,*999)
          END IF
        ELSE
          CALL FLAG_ERROR("The solver equations are not associated.",err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBoundaryConditions_SetElementNumber")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_SetElementNumber",err,error)
    CALL EXITS("CMISSBoundaryConditions_SetElementNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_SetElementNumber

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified element and sets this as a boundary condition on the specified elements for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditions_SetElementObj(boundaryConditions,field,variableType,elementUserNumber,componentNumber, &
    & condition,value,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to set the element to.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditions_SetElementObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_SET_ELEMENT(boundaryConditions%BOUNDARY_CONDITIONS,field%FIELD,variableType,elementUserNumber, &
      & componentNumber,condition,value,err,error,*999)

    CALL EXITS("CMISSBoundaryConditions_SetElementObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_SetElementObj",err,error)
    CALL EXITS("CMISSBoundaryConditions_SetElementObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_SetElementObj

  !
  !================================================================================================================================
  !

  !>Adds the value to the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditions_AddNodeNumber(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & fieldUserNumber,variableType,versionNumber,derivativeNumber,nodeUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to add the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditions_AddNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_ADD_NODE(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,versionNumber,derivativeNumber, &
                & nodeUserNumber,componentNumber,condition,value,err,error,*999)
            ELSE
              LOCAL_ERROR="A field with a user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            END IF
          ELSE
            CALL FLAG_ERROR("The solver equations boundary conditions are not associated.",err,error,*999)
          END IF
        ELSE
          CALL FLAG_ERROR("The solver equations are not associated.",err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBoundaryConditions_AddNodeNumber")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_AddNodeNumber",err,error)
    CALL EXITS("CMISSBoundaryConditions_AddNodeNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_AddNodeNumber

  !
  !================================================================================================================================
  !

  !>Adds to the value of the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditions_AddNodeObj(boundaryConditions,field,variableType,versionNumber,derivativeNumber, &
      & nodeUserNumber,componentNumber,condition,value,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to add the node to.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to add the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to add the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditions_AddNodeObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_ADD_NODE(boundaryConditions%BOUNDARY_CONDITIONS,field%FIELD,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,condition,value,err,error,*999)

    CALL EXITS("CMISSBoundaryConditions_AddNodeObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_AddNodeObj",err,error)
    CALL EXITS("CMISSBoundaryConditions_AddNodeObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_AddNodeObj

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified node as a boundary condition on the specified node for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditions_SetNodeNumber0(regionUserNumber,problemUserNumber,controlLoopIdentifier,solverIndex, &
    & fieldUserNumber,variableType,versionNumber,derivativeNumber,nodeUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditions_SetNodeNumber0",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_SET_NODE(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,versionNumber,derivativeNumber, &
                & nodeUserNumber,componentNumber,condition,value,err,error,*999)
            ELSE
              LOCAL_ERROR="A field with a user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            END IF
          ELSE
            CALL FLAG_ERROR("The solver equations boundary conditions are not associated.",err,error,*999)
          END IF
        ELSE
          CALL FLAG_ERROR("The solver equations are not associated.",err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBoundaryConditions_SetNodeNumber0")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_SetNodeNumber0",err,error)
    CALL EXITS("CMISSBoundaryConditions_SetNodeNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_SetNodeNumber0

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified node as a boundary condition on the specified node for boundary conditions identified by a user number.
  SUBROUTINE CMISSBoundaryConditions_SetNodeNumber1(regionUserNumber,problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & fieldUserNumber,variableType,versionNumber,derivativeNumber,nodeUserNumber,componentNumber,condition,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the equations set to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field for the boundary condition.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSBoundaryConditions_SetNodeNumber1",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
      IF(ASSOCIATED(PROBLEM)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
        IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
          CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
          IF(ASSOCIATED(BOUNDARY_CONDITIONS)) THEN
            CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,DEPENDENT_FIELD,err,error,*999)
            IF(ASSOCIATED(DEPENDENT_FIELD)) THEN
              CALL BOUNDARY_CONDITIONS_SET_NODE(BOUNDARY_CONDITIONS,DEPENDENT_FIELD,variableType,versionNumber,derivativeNumber, &
                & nodeUserNumber,componentNumber,condition,value,err,error,*999)
            ELSE
              LOCAL_ERROR="A field with a user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            END IF
          ELSE
            CALL FLAG_ERROR("The solver equations boundary conditions are not associated.",err,error,*999)
          END IF
        ELSE
          CALL FLAG_ERROR("The solver equations are not associated.",err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSBoundaryConditions_SetNodeNumber1")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_SetNodeNumber1",err,error)
    CALL EXITS("CMISSBoundaryConditions_SetNodeNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_SetNodeNumber1

  !
  !================================================================================================================================
  !

  !>Sets the value of the specified node and sets this as a boundary condition on the specified node for boundary conditions identified by an object.
  SUBROUTINE CMISSBoundaryConditions_SetNodeObj(boundaryConditions,field,variableType,versionNumber,derivativeNumber, &
    & nodeUserNumber,componentNumber,condition,value,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to set the node to.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The dependent field to set the boundary condition on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the boundary condition at. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the dependent field to set the boundary condition at.
    INTEGER(INTG), INTENT(IN) :: condition !<The boundary condition type to set \see OPENCMISS_BoundaryConditionsTypes,OPENCMISS
    REAL(DP), INTENT(IN) :: value !<The value of the boundary condition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditions_SetNodeObj",err,error,*999)

    CALL BOUNDARY_CONDITIONS_SET_NODE(boundaryConditions%BOUNDARY_CONDITIONS,field%FIELD,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,condition,value,err,error,*999)

    CALL EXITS("CMISSBoundaryConditions_SetNodeObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_SetNodeObj",err,error)
    CALL EXITS("CMISSBoundaryConditions_SetNodeObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_SetNodeObj

  !
  !================================================================================================================================
  !

  !>Sets the Neumann integration matrix sparsity for boundary conditions identified by a control loop identifier.
  SUBROUTINE CMISSBoundaryConditions_NeumannSparsityTypeSetNumber0( &
      & problemUserNumber,controlLoopIdentifier,solverIndex,sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier of the solver equations containing the boundary conditions.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type for the Neumann integration matrices. \see OPENCMISS_BoundaryConditionSparsityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: solverEquations
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: boundaryConditions
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSBoundaryConditions_NeumannSparsityTypeSetNumber0",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
      IF(ASSOCIATED(solverEquations)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(solverEquations,boundaryConditions,err,error,*999)
        IF(ASSOCIATED(boundaryConditions)) THEN
          CALL BoundaryConditions_NeumannSparsityTypeSet(boundaryConditions,sparsityType,err,error,*999)
        ELSE
          localError="Solver equations boundary conditions is not associated."
          CALL FLAG_ERROR(localError,err,error,*999)
        END IF
      ELSE
        localError="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSBoundaryConditions_NeumannSparsityTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_NeumannSparsityTypeSetNumber0",err,error)
    CALL EXITS("CMISSBoundaryConditions_NeumannSparsityTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_NeumannSparsityTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the Neumann integration matrix sparsity for boundary conditions identified by a control loop identifier.
  SUBROUTINE CMISSBoundaryConditions_NeumannSparsityTypeSetNumber1( &
      & problemUserNumber,controlLoopIdentifiers,solverIndex,sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to destroy the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type for the Neumann integration matrices. \see OPENCMISS_BoundaryConditionSparsityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: solverEquations
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: boundaryConditions
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSBoundaryConditions_NeumannSparsityTypeSetNumber1",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(boundaryConditions)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(problem,controlLoopIdentifiers,solverIndex,solverEquations,err,error,*999)
      IF(ASSOCIATED(solverEquations)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(solverEquations,boundaryConditions,err,error,*999)
        IF(ASSOCIATED(boundaryConditions)) THEN
          CALL BoundaryConditions_NeumannSparsityTypeSet(boundaryConditions,sparsityType,err,error,*999)
        ELSE
          localError="Solver equations boundary conditions is not associated."
          CALL FLAG_ERROR(localError,err,error,*999)
        END IF
      ELSE
        localError="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSBoundaryConditions_NeumannSparsityTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_NeumannSparsityTypeSetNumber1",err,error)
    CALL EXITS("CMISSBoundaryConditions_NeumannSparsityTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_NeumannSparsityTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the Neumann integration matrix sparsity type for the boundary conditions
  SUBROUTINE CMISSBoundaryConditions_NeumannSparsityTypeSetObj(boundaryConditions,sparsityType,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<The boundary conditions
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type for the Neumann integration matrices. \see OPENCMISS_BoundaryConditionSparsityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSBoundaryConditions_NeumannSparsityTypeSetObj",err,error,*999)

    CALL BoundaryConditions_NeumannSparsityTypeSet(boundaryConditions%BOUNDARY_CONDITIONS,sparsityType,err,error,*999)

    CALL EXITS("CMISSBoundaryConditions_NeumannSparsityTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSBoundaryConditions_NeumannSparsityTypeSetObj",err,error)
    CALL EXITS("CMISSBoundaryConditions_NeumannSparsityTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_NeumannSparsityTypeSetObj

  !
  !================================================================================================================================
  !

  !>Constrain multiple nodal equations dependent field DOFs to be a single solver DOF in the solver equations
  SUBROUTINE CMISSBoundaryConditions_ConstrainNodeDofsEqualNumber(regionUserNumber,problemUserNumber,controlLoopIdentifier, &
    & solverIndex,fieldUserNumber,fieldVariableType,versionNumber,derivativeNumber,component,nodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field DOFs to constrain.
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index of the solver equations.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the dependent field containing the DOFs to contrain.
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The variable type of the dependent field containing the DOFs to constrain. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number.
    INTEGER(INTG), INTENT(IN) :: component !<The field component number of the DOFs to be constrained.
    INTEGER(INTG), INTENT(IN) :: nodes(:) !<The user numbers of the nodes to be constrained to be equal.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: solverEquations
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: boundaryConditions
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(VARYING_STRING) :: localError

    CALL Enters("CMISSBoundaryConditions_ConstrainNodeDofsEqualNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(problem)
    NULLIFY(solverEquations)
    NULLIFY(field)

    CALL Region_user_number_find(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL Problem_user_number_find(problemUserNumber,problem,err,error,*999)
      IF(ASSOCIATED(problem)) THEN
        CALL Problem_solver_equations_get(problem,controlLoopIdentifier,solverIndex,solverEquations,err,error,*999)
        IF(ASSOCIATED(solverEquations)) THEN
          CALL Solver_equations_boundary_conditions_get(solverEquations,boundaryConditions,err,error,*999)
          IF(ASSOCIATED(boundaryConditions)) THEN
            CALL Field_user_number_find(fieldUserNumber,region,field,err,error,*999)
            IF(ASSOCIATED(field)) THEN
              CALL BoundaryConditions_ConstrainNodeDofsEqual(boundaryConditions,field, &
                & fieldVariableType,versionNumber,derivativeNumber,component,nodes,err,error,*999)
            ELSE
              localError="A field with a user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
                & " does not exist."
              CALL FlagError(localError,err,error,*999)
            END IF
          ELSE
            localError="The boundary conditions for the solver equations are not associated."
            CALL FLAG_ERROR(localError,err,error,*999)
          END IF
        ELSE
          CALL FlagError("The solver equations are not associated.",err,error,*999)
        END IF
      ELSE
        localError="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    CALL Exits("CMISSBoundaryConditions_ConstrainNodeDofsEqualNumber")
    RETURN
999 CALL Errors("CMISSBoundaryConditions_ConstrainNodeDofsEqualNumber",err,error)
    CALL Exits("CMISSBoundaryConditions_ConstrainNodeDofsEqualNumber")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_ConstrainNodeDofsEqualNumber

  !
  !================================================================================================================================
  !

  !>Constrain multiple nodal equations dependent field DOFs to be a single solver DOF in the solver equations
  SUBROUTINE CMISSBoundaryConditions_ConstrainNodeDofsEqualObj( &
      & boundaryConditions,field,fieldVariableType,versionNumber,derivativeNumber,component,nodes,err)

    !Argument variables
    TYPE(CMISSBoundaryConditionsType), INTENT(IN) :: boundaryConditions !<The boundary conditions to constrain the DOFs in.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The equations dependent field containing the field DOFs to be constrained.
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The field variable type of the DOFs to be constrained. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number.
    INTEGER(INTG), INTENT(IN) :: component !<The field component number of the DOFs to be constrained.
    INTEGER(INTG), INTENT(IN) :: nodes(:) !<The user numbers of the nodes to be constrained to be equal.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL Enters("CMISSBoundaryConditions_ConstrainNodeDofsEqualObj",err,error,*999)

    CALL BoundaryConditions_ConstrainNodeDofsEqual(boundaryConditions%boundary_conditions,field%field, &
      & fieldVariableType,versionNumber,derivativeNumber,component,nodes,err,error,*999)

    CALL Exits("CMISSBoundaryConditions_ConstrainNodeDofsEqualObj")
    RETURN
999 CALL Errors("CMISSBoundaryConditions_ConstrainNodeDofsEqualObj",err,error)
    CALL Exits("CMISSBoundaryConditions_ConstrainNodeDofsEqualObj")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSBoundaryConditions_ConstrainNodeDofsEqualObj

!!==================================================================================================================================
!!
!! CMISS
!!
!!==================================================================================================================================

  !>Returns the error handling mode for OpenCMISS
  SUBROUTINE CMISSErrorHandlingModeGet(errorHandlingMode,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: errorHandlingMode !<On return, the error handling mode. \see OPENCMISS_CMISSErrorHandlingModes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSErrorHandlingModeGet",err,error,*999)

    CALL CMISS_ERROR_HANDLING_MODE_GET(errorHandlingMode,err,error,*999)

    CALL EXITS("CMISSErrorHandlingModeGet")
    RETURN
999 CALL ERRORS("CMISSErrorHandlingModeGet",err,error)
    CALL EXITS("CMISSErrorHandlingModeGet")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSErrorHandlingModeGet

  !
  !================================================================================================================================
  !

  !>Sets the error handling mode for OpenCMISS
  SUBROUTINE CMISSErrorHandlingModeSet(errorHandlingMode,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: errorHandlingMode !<The error handling mode to set. \see OPENCMISS_CMISSErrorHandlingModes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSErrorHandlingModeSet",err,error,*999)

    CALL CMISS_ERROR_HANDLING_MODE_SET(errorHandlingMode,err,error,*999)

    CALL EXITS("CMISSErrorHandlingModeSet")
    RETURN
999 CALL ERRORS("CMISSErrorHandlingModeSet",err,error)
    CALL EXITS("CMISSErrorHandlingModeSet")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSErrorHandlingModeSet

  !
  !================================================================================================================================
  !

  !>Extracts the most recent error string for OpenCMISS
  SUBROUTINE CMISSExtractErrorMessageC(errorMessage,err)

    !Argument variables
    CHARACTER(LEN=*), INTENT(OUT) :: errorMessage !<On return, the extracted error message.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL EXTRACT_ERROR_MESSAGE(errorMessage,err,error,*999)

    RETURN
999 RETURN

  END SUBROUTINE CMISSExtractErrorMessageC

  !
  !================================================================================================================================
  !

  !>Extracts the most recent error string for OpenCMISS
  SUBROUTINE CMISSExtractErrorMessageVS(errorMessage,err)

    !Argument variables
    TYPE(VARYING_STRING), INTENT(OUT) :: errorMessage !<On return, the extracted error message.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL EXTRACT_ERROR_MESSAGE(errorMessage,err,error,*999)

    RETURN
999 RETURN

  END SUBROUTINE CMISSExtractErrorMessageVS

  !
  !================================================================================================================================
  !

  !>Returns the random seeds for OpenCMISS
  SUBROUTINE CMISSRandomSeedsGet0(randomSeed,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: randomSeed !<On return, the random seed.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: RandomSeeds(1)

    CALL ENTERS("CMISSRandomSeedsGet0",err,error,*999)

    CALL RANDOM_SEEDS_GET(RandomSeeds,err,error,*999)
    randomSeed=RandomSeeds(1)

    CALL EXITS("CMISSRandomSeedsGet0")
    RETURN
999 CALL ERRORS("CMISSRandomSeedsGet0",err,error)
    CALL EXITS("CMISSRandomSeedsGet0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRandomSeedsGet0

  !
  !================================================================================================================================
  !

  !>Returns the random seeds for OpenCMISS
  SUBROUTINE CMISSRandomSeedsGet1(randomSeeds,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: randomSeeds(:) !<On return, the random seeds.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRandomSeedsGet1",err,error,*999)

    CALL RANDOM_SEEDS_GET(randomSeeds,err,error,*999)

    CALL EXITS("CMISSRandomSeedsGet1")
    RETURN
999 CALL ERRORS("CMISSRandomSeedsGet1",err,error)
    CALL EXITS("CMISSRandomSeedsGet1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRandomSeedsGet1

  !
  !================================================================================================================================
  !

  !>Returns the size of the random seeds array for OpenCMISS
  SUBROUTINE CMISSRandomSeedsSizeGet(randomSeedsSize,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: randomSeedsSize !<On return, the size of the random seeds array.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRandomSeedsSizeGet",err,error,*999)

    CALL RANDOM_SEEDS_SIZE_GET(randomSeedsSize,err,error,*999)

    CALL EXITS("CMISSRandomSeedsSizeGet")
    RETURN
999 CALL ERRORS("CMISSRandomSeedsSizeGet",err,error)
    CALL EXITS("CMISSRandomSeedsSizeGet")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRandomSeedsSizeGet

  !
  !================================================================================================================================
  !

  !>Sets the random seeds for OpenCMISS
  SUBROUTINE CMISSRandomSeedsSet0(randomSeed,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: randomSeed !<The random seed to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRandomSeedsSet0",err,error,*999)

    CALL RANDOM_SEEDS_SET([randomSeed],err,error,*999)

    CALL EXITS("CMISSRandomSeedsSet0")
    RETURN
999 CALL ERRORS("CMISSRandomSeedsSet0",err,error)
    CALL EXITS("CMISSRandomSeedsSet0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRandomSeedsSet0

  !
  !================================================================================================================================
  !

  !>Sets the random seeds for OpenCMISS
  SUBROUTINE CMISSRandomSeedsSet1(randomSeeds,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: randomSeeds(:) !<The random seeds to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRandomSeedsSet1",err,error,*999)

    CALL RANDOM_SEEDS_SET(randomSeeds,err,error,*999)

    CALL EXITS("CMISSRandomSeedsSet1")
    RETURN
999 CALL ERRORS("CMISSRandomSeedsSet1",err,error)
    CALL EXITS("CMISSRandomSeedsSet1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRandomSeedsSet1

!!==================================================================================================================================
!!
!! CMISS_CELLML
!!
!!==================================================================================================================================

  !>Sets a CellML model variable to be known by user number.
  SUBROUTINE CMISSCellML_VariableSetAsKnownNumberC(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_VariableSetAsKnownNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_VARIABLE_SET_AS_KNOWN(CELLML,CellMLModelUserNumber,variableID,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_VariableSetAsKnownNumberC")
    RETURN
999 CALL ERRORS("CMISSCellML_VariableSetAsKnownNumberC",err,error)
    CALL EXITS("CMISSCellML_VariableSetAsKnownNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_VariableSetAsKnownNumberC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be known by object.
  SUBROUTINE CMISSCellML_VariableSetAsKnownObjC(CellML,CellMLModelUserNumber,variableID,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_VariableSetAsKnownObjC",err,error,*999)

    CALL CELLML_VARIABLE_SET_AS_KNOWN(CellML%CELLML,CellMLModelUserNumber,variableID,err,error,*999)

    CALL EXITS("CMISSCellML_VariableSetAsKnownObjC")
    RETURN
999 CALL ERRORS("CMISSCellML_VariableSetAsKnownObjC",err,error)
    CALL EXITS("CMISSCellML_VariableSetAsKnownObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_VariableSetAsKnownObjC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be known by user number.
  SUBROUTINE CMISSCellML_VariableSetAsKnownNumberVS(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_VariableSetAsKnownNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_VARIABLE_SET_AS_KNOWN(CELLML,CellMLModelUserNumber,variableID,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_VariableSetAsKnownNumberVS")
    RETURN
999 CALL ERRORS("CMISSCellML_VariableSetAsKnownNumberVS",err,error)
    CALL EXITS("CMISSCellML_VariableSetAsKnownNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_VariableSetAsKnownNumberVS

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be known by object.
  SUBROUTINE CMISSCellML_VariableSetAsKnownObjVS(CellML,CellMLModelUserNumber,variableID,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as known (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_VariableSetAsKnownObjVS",err,error,*999)

    CALL CELLML_VARIABLE_SET_AS_KNOWN(CellML%CELLML,CellMLModelUserNumber,variableID,err,error,*999)

    CALL EXITS("CMISSCellML_VariableSetAsKnownObjVS")
    RETURN
999 CALL ERRORS("CMISSCellML_VariableSetAsKnownObjVS",err,error)
    CALL EXITS("CMISSCellML_VariableSetAsKnownObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_VariableSetAsKnownObjVS

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by user number.
  SUBROUTINE CMISSCellML_VariableSetAsWantedNumberC(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_VariableSetAsWantedNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_VARIABLE_SET_AS_WANTED(CELLML,CellMLModelUserNumber,variableID,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_VariableSetAsWantedNumberC")
    RETURN
999 CALL ERRORS("CMISSCellML_VariableSetAsWantedNumberC",err,error)
    CALL EXITS("CMISSCellML_VariableSetAsWantedNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_VariableSetAsWantedNumberC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by object.
  SUBROUTINE CMISSCellML_VariableSetAsWantedObjC(CellML,CellMLModelUserNumber,variableID,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_VariableSetAsWantedObjC",err,error,*999)

    CALL CELLML_VARIABLE_SET_AS_WANTED(CellML%CELLML,CellMLModelUserNumber,variableID,err,error,*999)

    CALL EXITS("CMISSCellML_VariableSetAsWantedObjC")
    RETURN
999 CALL ERRORS("CMISSCellML_VariableSetAsWantedObjC",err,error)
    CALL EXITS("CMISSCellML_VariableSetAsWantedObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_VariableSetAsWantedObjC

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by user number.
  SUBROUTINE CMISSCellML_VariableSetAsWantedNumberVS(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_VariableSetAsWantedNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_VARIABLE_SET_AS_WANTED(CELLML,CellMLModelUserNumber,variableID,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_VariableSetAsWantedNumberVS")
    RETURN
999 CALL ERRORS("CMISSCellML_VariableSetAsWantedNumberVS",err,error)
    CALL EXITS("CMISSCellML_VariableSetAsWantedNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_VariableSetAsWantedNumberVS

  !
  !================================================================================================================================
  !

  !>Sets a CellML model variable to be wanted by object.
  SUBROUTINE CMISSCellML_VariableSetAsWantedObjVS(CellML,CellMLModelUserNumber,variableID,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model in which to find the given variable.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable to set as wanted (in the format 'component_name/variable_name').
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_VariableSetAsWantedObjVS",err,error,*999)

    CALL CELLML_VARIABLE_SET_AS_WANTED(CellML%CELLML,CellMLModelUserNumber,variableID,err,error,*999)

    CALL EXITS("CMISSCellML_VariableSetAsWantedObjVS")
    RETURN
999 CALL ERRORS("CMISSCellML_VariableSetAsWantedObjVS",err,error)
    CALL EXITS("CMISSCellML_VariableSetAsWantedObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_VariableSetAsWantedObjVS

  !
  !================================================================================================================================
  !

  !>Defines a CellML model variable to field variable component map by user number
  SUBROUTINE CMISSCellML_CreateCellMLToFieldMapNumberC(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID, &
    & CellMLParameterSet,fieldUserNumber,variableType,componentNumber,fieldParameterSet,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map fom.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map from.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to map to
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_CreateCellMLToFieldMapNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
        IF(ASSOCIATED(FIELD)) THEN
          CALL CELLML_CREATE_CELLML_TO_FIELD_MAP(CELLML,CellMLModelUserNumber,variableID,CellMLParameterSet, &
            & FIELD,variableType,componentNumber,fieldParameterSet,err,error,*999)
        ELSE
          LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_CreateCellMLToFieldMapNumberC")
    RETURN
999 CALL ERRORS("CMISSCellML_CreateCellMLToFieldMapNumberC",err,error)
    CALL EXITS("CMISSCellML_CreateCellMLToFieldMapNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_CreateCellMLToFieldMapNumberC

  !
  !================================================================================================================================
  !

  !>Defines a CellML model variable to field variable component map by object.
  SUBROUTINE CMISSCellML_CreateCellMLToFieldMapObjC(CellML, CellMLModelUserNumber,variableID,CellMLParameterSet, &
    & field,variableType,componentNumber,fieldParameterSet,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map from.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to map to.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_CreateCellMLToFieldMapObjC",err,error,*999)

    CALL CELLML_CREATE_CELLML_TO_FIELD_MAP(CellML%CELLML,CellMLModelUserNumber,variableID,CellMLParameterSet, &
      & field%FIELD,variableType,componentNumber,fieldParameterSet,err,error,*999)

    CALL EXITS("CMISSCellML_CreateCellMLToFieldMapObjC")
    RETURN
999 CALL ERRORS("CMISSCellML_CreateCellMLToFieldMapObjC",err,error)
    CALL EXITS("CMISSCellML_CreateCellMLToFieldMapObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_CreateCellMLToFieldMapObjC

  !
  !================================================================================================================================
  !

  !>Defines a CellML model variable to field variable component map by user number
  SUBROUTINE CMISSCellML_CreateCellMLToFieldMapNumberVS(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,variableID, &
    & CellMLParameterSet,fieldUserNumber,variableType,componentNumber,fieldParameterSet,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable ID in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_CreateCellMLToFieldMapNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
        IF(ASSOCIATED(FIELD)) THEN
          CALL CELLML_CREATE_CELLML_TO_FIELD_MAP(CELLML,CellMLModelUserNumber,variableID,CellMLParameterSet, &
            & FIELD,variableType,componentNumber,fieldParameterSet,err,error,*999)
        ELSE
          LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_CreateCellMLToFieldMapNumberVS")
    RETURN
999 CALL ERRORS("CMISSCellML_CreateCellMLToFieldMapNumberVS",err,error)
    CALL EXITS("CMISSCellML_CreateCellMLToFieldMapNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_CreateCellMLToFieldMapNumberVS

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map, by object.
  SUBROUTINE CMISSCellML_CreateCellMLToFieldMapObjVS(CellML,CellMLModelUserNumber,variableID,CellMLParameterSet, &
    & field,variableType,componentNumber,fieldParameterSet,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map from.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to map to.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map to.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_CreateCellMLToFieldMapNumberVS",err,error,*999)

    CALL CELLML_CREATE_CELLML_TO_FIELD_MAP(CellML%CELLML,CellMLModelUserNumber,variableID,CellMLParameterSet, &
      & field%FIELD,variableType,componentNumber,fieldParameterSet,err,error,*999)

    CALL EXITS("CMISSCellML_CreateCellMLToFieldMapObjVS")
    RETURN
999 CALL ERRORS("CMISSCellML_CreateCellMLToFieldMapObjVS",err,error)
    CALL EXITS("CMISSCellML_CreateCellMLToFieldMapObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_CreateCellMLToFieldMapObjVS

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by user number.
  SUBROUTINE CMISSCellML_CreateFieldToCellMLMapNumberC(regionUserNumber,CellMLUserNumber,fieldUserNumber,variableType, &
    & componentNumber,fieldParameterSet,CellMLModelUserNumber,variableID,CellMLParameterSet,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map from.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map to.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_CreateFieldToCellMLMapNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
        IF(ASSOCIATED(FIELD)) THEN
          CALL CELLML_CREATE_FIELD_TO_CELLML_MAP(CELLML,FIELD,variableType,componentNumber,fieldParameterSet, &
            & CellMLModelUserNumber,variableID,CellMLParameterSet,err,error,*999)
        ELSE
          LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_CreateFieldToCellMLMapNumberC")
    RETURN
999 CALL ERRORS("CMISSCellML_CreateFieldToCellMLMapNumberC",err,error)
    CALL EXITS("CMISSCellML_CreateFieldToCellMLMapNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_CreateFieldToCellMLMapNumberC

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by object.
  SUBROUTINE CMISSCellML_CreateFieldToCellMLMapObjC(CellML,field,variableType,componentNumber,fieldParameterSet, &
    & CellMLModelUserNumber,variableID,CellMLParameterSet,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number to map from the given field variable.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map to.
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_CreateFieldToCellMLMapObjC",err,error,*999)

    CALL CELLML_CREATE_FIELD_TO_CELLML_MAP(CellML%CELLML,field%FIELD,variableType,componentNumber,fieldParameterSet, &
      & CellMLModelUserNumber,variableID,CellMLParameterSet,err,error,*999)

    CALL EXITS("CMISSCellML_CreateFieldToCellMLMapObjC")
    RETURN
999 CALL ERRORS("CMISSCellML_CreateFieldToCellMLMapObjC",err,error)
    CALL EXITS("CMISSCellML_CreateFieldToCellMLMapObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_CreateFieldToCellMLMapObjC

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by user number
  SUBROUTINE CMISSCellML_CreateFieldToCellMLMapNumberVS(regionUserNumber,CellMLUserNumber,fieldUserNumber,variableType, &
    & fieldParameterSet,componentNumber,CellMLModelUserNumber,variableID,CellMLParameterSet,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map from.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map to.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The of the CellML variable in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_CreateFieldToCellMLMapNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
        IF(ASSOCIATED(FIELD)) THEN
          CALL CELLML_CREATE_FIELD_TO_CELLML_MAP(CELLML,FIELD,variableType,componentNumber,fieldParameterSet, &
            & CellMLModelUserNumber,variableID,CellMLParameterSet,err,error,*999)
        ELSE
          LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_CreateFieldToCellMLMapNumberVS")
    RETURN
999 CALL ERRORS("CMISSCellML_CreateFieldToCellMLMapNumberVS",err,error)
    CALL EXITS("CMISSCellML_CreateFieldToCellMLMapNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_CreateFieldToCellMLMapNumberVS

  !
  !================================================================================================================================
  !

  !>Defines a field variable component to CellML model variable map by by object.
  SUBROUTINE CMISSCellML_CreateFieldToCellMLMapObjVS(CellML,field,variableType,componentNumber,fieldParameterSet, &
    & CellMLModelUserNumber,variableID,CellMLParameterSet,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML enviroment.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to map from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to map from.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The field variable component number to map from.
    INTEGER(INTG), INTENT(IN) :: fieldParameterSet !<The field variable parameter set to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map to.
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The CellML variable ID in the given model to map to.
    INTEGER(INTG), INTENT(IN) :: CellMLParameterSet !<The CellML variable parameter set to map to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_CreateFieldToCellMLMapNumberVS",err,error,*999)

    CALL CELLML_CREATE_FIELD_TO_CELLML_MAP(CellML%CELLML,field%FIELD,variableType,componentNumber,fieldParameterSet, &
      & CellMLModelUserNumber,variableID,CellMLParameterSet,err,error,*999)

    CALL EXITS("CMISSCellML_CreateFieldToCellMLMapObjVS")
    RETURN
999 CALL ERRORS("CMISSCellML_CreateFieldToCellMLMapObjVS",err,error)
    CALL EXITS("CMISSCellML_CreateFieldToCellMLMapObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_CreateFieldToCellMLMapObjVS

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_CreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    CALL EXITS("CMISSCellML_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellML_CreateFinishNumber",err,error)
    CALL EXITS("CMISSCellML_CreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_CreateFinishObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_CreateFinishObj",err,error,*999)

    CALL CELLML_CREATE_FINISH(CellML%CELLML,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    CALL EXITS("CMISSCellML_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellML_CreateFinishObj",err,error)
    CALL EXITS("CMISSCellML_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_CreateStartNumber(CellMLUserNumber,regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to start creating.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the field to start the CellML enviroment creation on.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_CREATE_START(CellMLUserNumber,REGION,CELLML,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_CreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellML_CreateStartNumber",err,error)
    CALL EXITS("CMISSCellML_CreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_CreateStartObj(CellMLUserNumber,region,CellML,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to start creating.
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region containing the field to start the CellML enviroment creation on.
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<On return, the created CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    CALL CELLML_CREATE_START(CellMLUserNumber,region%REGION,CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellML_CreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellML_CreateStartObj",err,error)
    CALL EXITS("CMISSCellML_CreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_DestroyNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to destroy.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_DESTROY(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSCellML_DestroyNumber",err,error)
    CALL EXITS("CMISSCellML_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_DestroyObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_DestroyObj",err,error,*999)

    CALL CELLML_DESTROY(CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellML_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSCellML_DestroyObj",err,error)
    CALL EXITS("CMISSCellML_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_DestroyObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of field maps for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_FieldMapsCreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_FieldMapsCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_FIELD_MAPS_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Create')
#endif

    CALL EXITS("CMISSCellML_FieldMapsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellML_FieldMapsCreateFinishNumber",err,error)
    CALL EXITS("CMISSCellML_FieldMapsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_FieldMapsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of field maps for a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_FieldMapsCreateFinishObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of maps for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_FieldMapsCreateFinishObj",err,error,*999)

    CALL CELLML_FIELD_MAPS_CREATE_FINISH(CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellML_FieldMapsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellML_FieldMapsCreateFinishObj",err,error)
    CALL EXITS("CMISSCellML_FieldMapsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_FieldMapsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of field maps for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_FieldMapsCreateStartNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to start creating the maps for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_FieldMapsCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_FIELD_MAPS_CREATE_START(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellMLFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellMLFieldCreateStartNumber",err,error)
    CALL EXITS("CMISSCellMLFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_FieldMapsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of field maps for a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_FieldMapsCreateStartObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment object to start the creation of maps for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_FieldMapsCreateStartObj",err,error,*999)

    CALL CELLML_FIELD_MAPS_CREATE_START(CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellML_FieldMapsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellML_FieldMapsCreateStartObj",err,error)
    CALL EXITS("CMISSCellML_FieldMapsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_FieldMapsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a character URI into a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_ModelImportNumberC(regionUserNumber,CellMLUserNumber,URI,modelIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to import the model into.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to import the model into.
    CHARACTER(LEN=*), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_ModelImportNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_MODEL_IMPORT(CELLML,URI,modelIndex,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_ModelImportNumberC")
    RETURN
999 CALL ERRORS("CMISSCellML_ModelImportNumberC",err,error)
    CALL EXITS("CMISSCellML_ModelImportNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_ModelImportNumberC

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a character URI into a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_ModelImportObjC(CellML,URI,modelIndex,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to import the model into.
    CHARACTER(LEN=*), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_ModelImportObjC",err,error,*999)

    CALL CELLML_MODEL_IMPORT(CellML%CELLML,URI,modelIndex,err,error,*999)

    CALL EXITS("CMISSCellML_ModelImportObjC")
    RETURN
999 CALL ERRORS("CMISSCellML_ModelImportObjC",err,error)
    CALL EXITS("CMISSCellML_ModelImportObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_ModelImportObjC

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a varying string URI into a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_ModelImportNumberVS(regionUserNumber,CellMLUserNumber,URI,modelIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to import the model into.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to import the model into.
    TYPE(VARYING_STRING), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_ModelImportNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_MODEL_IMPORT(CELLML,URI,modelIndex,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_ModelImportNumberVS")
    RETURN
999 CALL ERRORS("CMISSCellML_ModelImportNumberVS",err,error)
    CALL EXITS("CMISSCellML_ModelImportNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_ModelImportNumberVS

  !
  !================================================================================================================================
  !

  !>Imports a specified CellML model as specified by a varying string URI into a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_ModelImportObjVS(CellML,URI,modelIndex,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to import the model into.
    TYPE(VARYING_STRING), INTENT(IN) :: URI !<The URI of the CellML model to import.
    INTEGER(INTG), INTENT(OUT) :: modelIndex !<On return, the index of the imported model.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_ModelImportObjVS",err,error,*999)

    CALL CELLML_MODEL_IMPORT(CellML%CELLML,URI,modelIndex,err,error,*999)

    CALL EXITS("CMISSCellML_ModelImportObjVS")
    RETURN
999 CALL ERRORS("CMISSCellML_ModelImportObjVS",err,error)
    CALL EXITS("CMISSCellML_ModelImportObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_ModelImportObjVS

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML models field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_ModelsFieldCreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to finish creating.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the models field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_ModelsFieldCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_MODELS_FIELD_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_ModelsFieldCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellML_ModelsFieldCreateFinishNumber",err,error)
    CALL EXITS("CMISSCellML_ModelsFieldCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_ModelsFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML models field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_ModelsFieldCreateFinishObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the models field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_ModelsFieldCreateFinishObj",err,error,*999)

    CALL CELLML_MODELS_FIELD_CREATE_FINISH(CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellML_ModelsFieldCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellML_ModelsFieldCreateFinishObj",err,error)
    CALL EXITS("CMISSCellML_ModelsFieldCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_ModelsFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML models field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_ModelsFieldCreateStartNumber(regionUserNumber,CellMLUserNumber,CellMLModelsFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to start creating the models field for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelsFieldUserNumber !<The user number of the CellML models field to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_ModelsFieldCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_MODELS_FIELD_CREATE_START(CellMLModelsFieldUserNumber,CELLML,FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_ModelsFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellML_ModelsFieldCreateStartNumber",err,error)
    CALL EXITS("CMISSCellML_ModelsFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_ModelsFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML models field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_ModelsFieldCreateStartObj(CellML,CellMLModelsFieldUserNumber,field,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of models field for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelsFieldUserNumber !<The user number of the CellML models field to start creating.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the created CellML models field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_ModelsFieldCreateStartObj",err,error,*999)

    CALL CELLML_MODELS_FIELD_CREATE_START(CellMLModelsFieldUserNumber,CellML%CELLML,field%FIELD,err,error,*999)

    CALL EXITS("CMISSCellML_ModelsFieldCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellML_ModelsFieldCreateStartObj",err,error)
    CALL EXITS("CMISSCellML_ModelsFieldCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_ModelsFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML models field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_ModelsFieldGetNumber(regionUserNumber,CellMLUserNumber,CellMLModelsFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML enviroment to get the CellML models field for.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the CellML models field for.
    INTEGER(INTG), INTENT(OUT) :: CellMLModelsFieldUserNumber !<On return, the user number of the CellML models field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_ModelsFieldGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_MODELS_FIELD_GET(CELLML,FIELD,err,error,*999)
        CellMLModelsFieldUserNumber = FIELD%USER_NUMBER
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_ModelsFieldGetNumber")
    RETURN
999 CALL ERRORS("CMISSCellML_ModelsFieldGetNumber",err,error)
    CALL EXITS("CMISSCellML_ModelsFieldGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_ModelsFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML models field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_ModelsFieldGetObj(CellML,field,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the models field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the CellML models field. Must not be associated on entry.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_ModelsFieldGetObj",err,error,*999)

    CALL CELLML_MODELS_FIELD_GET(CellML%CELLML,field%FIELD,err,error,*999)

    CALL EXITS("CMISSCellML_ModelsFieldGetObj")
    RETURN
999 CALL ERRORS("CMISSCellML_ModelsFieldGetObj",err,error)
    CALL EXITS("CMISSCellML_ModelsFieldGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_ModelsFieldGetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML state field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_StateFieldCreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the state field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_StateFieldCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_STATE_FIELD_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_StateFieldCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellML_StateFieldCreateFinishNumber",err,error)
    CALL EXITS("CMISSCellML_StateFieldCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_StateFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML state field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_StateFieldCreateFinishObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the state field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_StateFieldCreateFinishObj",err,error,*999)

    CALL CELLML_STATE_FIELD_CREATE_FINISH(CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellML_StateFieldCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellML_StateFieldCreateFinishObj",err,error)
    CALL EXITS("CMISSCellML_StateFieldCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_StateFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML state field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_StateFieldCreateStartNumber(regionUserNumber,CellMLUserNumber,CellMLStateFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to start creating the state field for.
    INTEGER(INTG), INTENT(IN) :: CellMLStateFieldUserNumber !<The user number of the CellML state field to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_StateFieldCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_STATE_FIELD_CREATE_START(CellMLStateFieldUserNumber,CELLML,FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_StateFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellML_StateFieldCreateStartNumber",err,error)
    CALL EXITS("CMISSCellML_StateFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_StateFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML state field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_StateFieldCreateStartObj(CellML,CellMLStateFieldUserNumber,field,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of state field for.
    INTEGER(INTG), INTENT(IN) :: CellMLStateFieldUserNumber !<The user number of the CellML state field to start creating.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the created CellML state field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_StateFieldCreateStartObj",err,error,*999)

    CALL CELLML_STATE_FIELD_CREATE_START(CellMLStateFieldUserNumber,CellML%CELLML,field%FIELD,err,error,*999)

    CALL EXITS("CMISSCellML_StateFieldCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellML_StateFieldCreateStartObj",err,error)
    CALL EXITS("CMISSCellML_StateFieldCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_StateFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML state field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_StateFieldGetNumber(regionUserNumber,CellMLUserNumber,CellMLStateFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the CellML state field for.
    INTEGER(INTG), INTENT(OUT) :: CellMLStateFieldUserNumber !<On return, the user number of the CellML state field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_StateFieldGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_STATE_FIELD_GET(CELLML,FIELD,err,error,*999)
        CellMLStateFieldUserNumber = FIELD%USER_NUMBER
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_StateFieldGetNumber")
    RETURN
999 CALL ERRORS("CMISSCellML_StateFieldGetNumber",err,error)
    CALL EXITS("CMISSCellML_StateFieldGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_StateFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML state field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_StateFieldGetObj(CellML,field,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the state field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the CellML state field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_StateFieldGetObj",err,error,*999)

    CALL CELLML_STATE_FIELD_GET(CellML%CELLML,field%FIELD,err,error,*999)

    CALL EXITS("CMISSCellML_StateFieldGetObj")
    RETURN
999 CALL ERRORS("CMISSCellML_StateFieldGetObj",err,error)
    CALL EXITS("CMISSCellML_StateFieldGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_StateFieldGetObj

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a character string VariableID for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_FieldComponentGetNumberC(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,CellMLFieldType,&
  & variableID,fieldComponent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map fom.
    INTEGER(INTG), INTENT(IN) :: CellMLFieldType !<The type of CellML field to get the component for. \see OPENCMISS_CellMLFieldTypes,OPENCMISS
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The variable ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_FieldComponentGetNumberC",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_FIELD_COMPONENT_GET(CELLML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_FieldComponentGetNumberC")
    RETURN
999 CALL ERRORS("CMISSCellML_FieldComponentGetNumberC",err,error)
    CALL EXITS("CMISSCellML_FieldComponentGetNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)

    RETURN

  END SUBROUTINE CMISSCellML_FieldComponentGetNumberC

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a character string variable ID for a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_FieldComponentGetObjC(CellML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLFieldType !<The type of CellML field to get the component for. \see OPENCMISS_CellMLFieldTypes,OPENCMISS
    CHARACTER(LEN=*), INTENT(IN) :: variableID !<The ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_FieldComponentGetObjC",err,error,*999)

    CALL CELLML_FIELD_COMPONENT_GET(CellML%CELLML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err,error,*999)

    CALL EXITS("CMISSCellML_FieldComponentGetObjC")
    RETURN
999 CALL ERRORS("CMISSCellML_FieldComponentGetObjC",err,error)
    CALL EXITS("CMISSCellML_FieldComponentGetObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_FieldComponentGetObjC

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a varying string variable ID for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_FieldComponentGetNumberVS(regionUserNumber,CellMLUserNumber,CellMLModelUserNumber,CellMLFieldType,&
  & variableID,fieldComponent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLFieldType !<The type of CellML field to get the component for. \see OPENCMISS_CellMLFieldTypes,OPENCMISS
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_FieldComponentGetNumberVS",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_FIELD_COMPONENT_GET(CELLML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_FieldComponentGetNumberVS")
    RETURN
999 CALL ERRORS("CMISSCellML_FieldComponentGetNumberVS",err,error)
    CALL EXITS("CMISSCellML_FieldComponentGetNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_FieldComponentGetNumberVS

  !
  !================================================================================================================================
  !

  !>Returns the field component number that corresponds to a varying string variable ID for a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_FieldComponentGetObjVS(CellML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the field component for.
    INTEGER(INTG), INTENT(IN) :: CellMLModelUserNumber !<The user number of the CellML model to map from.
    INTEGER(INTG), INTENT(IN) :: CellMLFieldType !<The type of CellML field to get the component for. \see OPENCMISS_CellMLFieldTypes,OPENCMISS
    TYPE(VARYING_STRING), INTENT(IN) :: variableID !<The ID to get the corresponding field component for.
    INTEGER(INTG), INTENT(OUT) :: fieldComponent !<On return, the field component corresponding to the ID.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_FieldComponentGetObjVS",err,error,*999)

    CALL CELLML_FIELD_COMPONENT_GET(CellML%CELLML,CellMLModelUserNumber,CellMLFieldType,variableID,fieldComponent,err,error,*999)

    CALL EXITS("CMISSCellML_FieldComponentGetObjVS")
    RETURN
999 CALL ERRORS("CMISSCellML_FieldComponentGetObjVS",err,error)
    CALL EXITS("CMISSCellML_FieldComponentGetObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_FieldComponentGetObjVS

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_IntermediateFieldCreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_IntermediateFieldCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_INTERMEDIATE_FIELD_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_IntermediateFieldCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellML_IntermediateFieldCreateFinishNumber",err,error)
    CALL EXITS("CMISSCellML_IntermediateFieldCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_IntermediateFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_IntermediateFieldCreateFinishObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_IntermediateFieldCreateFinishObj",err,error,*999)

    CALL CELLML_INTERMEDIATE_FIELD_CREATE_FINISH(CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellML_IntermediateFieldCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellML_IntermediateFieldCreateFinishObj",err,error)
    CALL EXITS("CMISSCellML_IntermediateFieldCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_IntermediateFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_IntermediateFieldCreateStartNumber(regionUserNumber,CellMLUserNumber,CellMLIntermediateFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to start creating the intermediate field for.
    INTEGER(INTG), INTENT(IN) :: CellMLIntermediateFieldUserNumber !<The user number of the CellML intermediate field to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_IntermediateFieldCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_INTERMEDIATE_FIELD_CREATE_START(CellMLIntermediateFieldUserNumber,CELLML,FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_IntermediateFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellML_IntermediateFieldCreateStartNumber",err,error)
    CALL EXITS("CMISSCellML_IntermediateFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_IntermediateFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_IntermediateFieldCreateStartObj(CellML,CellMLIntermediateFieldUserNumber,field,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of intermediate field for.
    INTEGER(INTG), INTENT(IN) :: CellMLIntermediateFieldUserNumber !<The user number of the CellML intermediate field to start creating.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the created CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_IntermediateFieldCreateStartObj",err,error,*999)

    CALL CELLML_INTERMEDIATE_FIELD_CREATE_START(CellMLIntermediateFieldUserNumber,CellML%CELLML,field%FIELD,err,error,*999)

    CALL EXITS("CMISSCellML_IntermediateFieldCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellML_IntermediateFieldCreateStartObj",err,error)
    CALL EXITS("CMISSCellML_IntermediateFieldCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_IntermediateFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML intermediate field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_IntermediateFieldGetNumber(regionUserNumber,CellMLUserNumber,CellMLIntermediateFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the CellML intermediate field for.
    INTEGER(INTG), INTENT(OUT) :: CellMLIntermediateFieldUserNumber !<On return, the user number of the CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_IntermediateFieldGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_INTERMEDIATE_FIELD_GET(CELLML,FIELD,err,error,*999)
        CellMLIntermediateFieldUserNumber = FIELD%USER_NUMBER
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_IntermediateFieldGetNumber")
    RETURN
999 CALL ERRORS("CMISSCellML_IntermediateFieldGetNumber",err,error)
    CALL EXITS("CMISSCellML_IntermediateFieldGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_IntermediateFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML intermediate field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_IntermediateFieldGetObj(CellML,field,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the intermediate field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the CellML intermediate field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_IntermediateFieldGetObj",err,error,*999)

    CALL CELLML_INTERMEDIATE_FIELD_GET(CellML%CELLML,field%FIELD,err,error,*999)

    CALL EXITS("CMISSCellML_IntermediateFieldGetObj")
    RETURN
999 CALL ERRORS("CMISSCellML_IntermediateFieldGetObj",err,error)
    CALL EXITS("CMISSCellML_IntermediateFieldGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_IntermediateFieldGetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_ParametersFieldCreateFinishNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to finish creating the parameters field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_ParametersFieldCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_PARAMETERS_FIELD_CREATE_FINISH(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_ParametersFieldCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCellML_ParametersFieldCreateFinishNumber",err,error)
    CALL EXITS("CMISSCellML_ParametersFieldCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_ParametersFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_ParametersFieldCreateFinishObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to finish the creation of the parameters field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_ParametersFieldCreateFinishObj",err,error,*999)

    CALL CELLML_PARAMETERS_FIELD_CREATE_FINISH(CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellML_ParametersFieldCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCellML_ParametersFieldCreateFinishObj",err,error)
    CALL EXITS("CMISSCellML_ParametersFieldCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_ParametersFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_ParametersFieldCreateStartNumber(regionUserNumber,CellMLUserNumber,CellMLParametersFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to start creating the parameters field for.
    INTEGER(INTG), INTENT(IN) :: CellMLParametersFieldUserNumber !<The user number of the CellML parameters field to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_ParametersFieldCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_PARAMETERS_FIELD_CREATE_START(CellMLParametersFieldUserNumber,CELLML,FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_ParametersFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCellML_ParametersFieldCreateStartNumber",err,error)
    CALL EXITS("CMISSCellML_ParametersFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_ParametersFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_ParametersFieldCreateStartObj(CellML,CellMLParametersFieldUserNumber,field,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to start the creation of parameters field for.
    INTEGER(INTG), INTENT(IN) :: CellMLParametersFieldUserNumber !<The user number of the CellML parameters field to start creating.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the created CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_ParametersFieldCreateStartObj",err,error,*999)

    CALL CELLML_PARAMETERS_FIELD_CREATE_START(CellMLParametersFieldUserNumber,CellML%CELLML,field%FIELD,err,error,*999)

    CALL EXITS("CMISSCellML_ParametersFieldCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCellML_ParametersFieldCreateStartObj",err,error)
    CALL EXITS("CMISSCellML_ParametersFieldCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_ParametersFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML parameters field for a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_ParametersFieldGetNumber(regionUserNumber,CellMLUserNumber,CellMLParametersFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to get the CellML parameters field for.
    INTEGER(INTG), INTENT(OUT) :: CellMLParametersFieldUserNumber !<On return, the user number of the CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_ParametersFieldGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_PARAMETERS_FIELD_GET(CELLML,FIELD,err,error,*999)
        CellMLParametersFieldUserNumber = FIELD%USER_NUMBER
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_ParametersFieldGetNumber")
    RETURN
999 CALL ERRORS("CMISSCellML_ParametersFieldGetNumber",err,error)
    CALL EXITS("CMISSCellML_ParametersFieldGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_ParametersFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the CellML parameters field for a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_ParametersFieldGetObj(CellML,field,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to get the parameters field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the CellML parameters field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_ParametersFieldGetObj",err,error,*999)

    CALL CELLML_PARAMETERS_FIELD_GET(CellML%CELLML,field%FIELD,err,error,*999)

    CALL EXITS("CMISSCellML_ParametersFieldGetObj")
    RETURN
999 CALL ERRORS("CMISSCellML_ParametersFieldGetObj",err,error)
    CALL EXITS("CMISSCellML_ParametersFieldGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_ParametersFieldGetObj

  !
  !================================================================================================================================
  !

  !>Validiate and instantiate a CellML environment identified by a user number.
  SUBROUTINE CMISSCellML_GenerateNumber(regionUserNumber,CellMLUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML enviroment to generate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellML_GenerateNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
      IF(ASSOCIATED(CELLML)) THEN
        CALL CELLML_GENERATE(CELLML,err,error,*999)
      ELSE
        LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
          & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellML_GenerateNumber")
    RETURN
999 CALL ERRORS("CMISSCellML_GenerateNumber",err,error)
    CALL EXITS("CMISSCellML_GenerateNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_GenerateNumber

  !
  !================================================================================================================================
  !

  !>Validiate and instantiate a CellML environment identified by an object.
  SUBROUTINE CMISSCellML_GenerateObj(CellML,err)

    !Argument variables
    TYPE(CMISSCellMLType), INTENT(INOUT) :: CellML !<The CellML environment to generate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellML_GenerateObj",err,error,*999)

    CALL CELLML_GENERATE(CellML%CELLML,err,error,*999)

    CALL EXITS("CMISSCellML_GenerateObj")
    RETURN
999 CALL ERRORS("CMISSCellML_GenerateObj",err,error)
    CALL EXITS("CMISSCellML_GenerateObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellML_GenerateObj


!!==================================================================================================================================
!!
!! COMP_ENVIRONMENT
!!
!!==================================================================================================================================

  !>Returns the computational node number of the running process.
  SUBROUTINE CMISSComputationalNodeNumberGet(nodeNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: nodeNumber !<On return, the computational node number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSComputationalNodeNumberGet",ERR,error,*999)

    nodeNumber = COMPUTATIONAL_NODE_NUMBER_GET(err,error)

    CALL EXITS("CMISSComputationalNodeNumberGet")
    RETURN
999 CALL ERRORS("CMISSComputationalNodeNumberGet",err,error)
    CALL EXITS("CMISSComputationalNodeNumberGet")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSComputationalNodeNumberGet

  !
  !================================================================================================================================
  !

  !>Returns the number of computational nodes for the running process.
  SUBROUTINE CMISSComputationalNumberOfNodesGet(numberOfNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<On return, the number of computational nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSComputationalNumberOfNodesGet",ERR,error,*999)

    numberOfNodes = COMPUTATIONAL_NODES_NUMBER_GET(err,error)

    CALL EXITS("CMISSComputationalNumberOfNodesGet")
    RETURN
999 CALL ERRORS("CMISSComputationalNumberOfNodesGet",err,error)
    CALL EXITS("CMISSComputationalNumberOfNodesGet")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSComputationalNumberOfNodesGet

  !
  !================================================================================================================================
  !

  !>CREATE THE HIGHEST LEVEL WORK GROUP (DEFAULT: GROUP_WORLD)
  SUBROUTINE CMISSComputationalWorkGroup_CreateStart(worldWorkGroup, numberComputationalNodes, err)
    !Argument Variables
    TYPE(CMISSComputationalWorkGroupType), INTENT(INOUT) :: worldWorkGroup
    INTEGER(INTG),INTENT(IN) :: numberComputationalNodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL ENTERS("CMISSComputationalWorkGroup_CreateStart",ERR,error,*999)

    CALL COMPUTATIONAL_WORK_GROUP_CREATE_START(worldWorkGroup%COMPUTATIONAL_WORK_GROUP,numberComputationalNodes, &
      & err,error,*999)

    CALL EXITS("CMISSComputationalWorkGroup_CreateStart")
    RETURN
999 CALL ERRORS("CMISSComputationalWorkGroup_CreateStart",err,error)
    CALL EXITS("CMISSComputationalWorkGroup_CreateStart")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSComputationalWorkGroup_CreateStart

  !
  !================================================================================================================================
  !

  !>GENERATE THE HIERARCHY COMPUTATIONAL ENVIRONMENT BASED ON WORK GROUP TREE
  SUBROUTINE CMISSComputationalWorkGroup_CreateFinish(worldWorkGroup, err)
    !Argument Variables
    TYPE(CMISSComputationalWorkGroupType), INTENT(INOUT) :: worldWorkGroup
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL ENTERS("CMISSComputationalWorkGroup_CreateFinish",ERR,error,*999)

    CALL COMPUTATIONAL_WORK_GROUP_CREATE_FINISH(worldWorkGroup%COMPUTATIONAL_WORK_GROUP, err,error,*999)

    CALL EXITS("CMISSComputationalWorkGroup_CreateFinish")
    RETURN
999 CALL ERRORS("CMISSComputationalWorkGroup_CreateFinish",err,error)
    CALL EXITS("CMISSComputationalWorkGroup_CreateFinish")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSComputationalWorkGroup_CreateFinish

  !
  !================================================================================================================================
  !

  !>ADD WORK SUB-GROUP TO THE PARENT GROUP BASED ON THE COMPUTATIONAL REQUIREMENTS (CALLED BY THE USER)
  SUBROUTINE CMISSComputationalWorkGroup_SubgroupAdd(parentWorkGroup, numberComputationalNodes,addedWorkGroup, err)
    !Argument Variables
    TYPE(CMISSComputationalWorkGroupType), INTENT(INOUT) :: parentWorkGroup
    TYPE(CMISSComputationalWorkGroupType), INTENT(INOUT) :: addedWorkGroup
    INTEGER(INTG),INTENT(IN) :: numberComputationalNodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL ENTERS("CMISSComputationalWorkGroup_SubgroupAdd",ERR,error,*999)

    CALL COMPUTATIONAL_WORK_GROUP_SUBGROUP_ADD(parentWorkGroup%COMPUTATIONAL_WORK_GROUP,numberComputationalNodes, &
    & addedWorkGroup%COMPUTATIONAL_WORK_GROUP, err,error,*999)

    CALL EXITS("CMISSComputationalWorkGroup_SubgroupAdd")
    RETURN
999 CALL ERRORS("CMISSComputationalWorkGroup_SubgroupAdd",err,error)
    CALL EXITS("CMISSComputationalWorkGroup_SubgroupAdd")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSComputationalWorkGroup_SubgroupAdd  !
  !================================================================================================================================
  !

  !>Set the working group tree in order to performe mesh decomposition
  SUBROUTINE CMISSDecomposition_WorldWorkGroupSet(decomposition, worldWorkGroup, err)
    !Argument Variables
    TYPE(CMISSDecompositionType), INTENT(INOUT) :: decomposition
    TYPE(CMISSComputationalWorkGroupType),INTENT(IN) :: worldWorkGroup
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL ENTERS("CMISSDecomposition_WorldWorkGroupSet",err,error,*999)

    ! todo
    CALL FLAG_ERROR('not implemented yet', err,error, *999)

    CALL EXITS("CMISSDecomposition_WorldWorkGroupSet")
    RETURN
999 CALL ERRORS("CMISSDecomposition_WorldWorkGroupSet",err,error)
    CALL EXITS("CMISSDecomposition_WorldWorkGroupSet")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_WorldWorkGroupSet

!!==================================================================================================================================
!!
!! CONTROL_LOOP_ROUTINES
!!
!!==================================================================================================================================

  !>Gets the current time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_CurrentTimesGetNumber0(problemUserNumber,controlLoopIdentifier,currentTime,timeIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_CurrentTimesGetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_CURRENT_TIMES_GET(CONTROL_LOOP,currentTime,timeIncrement,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_CurrentTimesGetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_CurrentTimesGetNumber0",err,error)
    CALL EXITS("CMISSControlLoop_CurrentTimesGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_CurrentTimesGetNumber0

  !
  !================================================================================================================================
  !

  !>Gets the current time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_CurrentTimesGetNumber1(problemUserNumber,controlLoopIdentifiers,currentTime,timeIncrement,err)

    !Argument variables
     INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_CurrentTimesGetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_CURRENT_TIMES_GET(CONTROL_LOOP,currentTime,timeIncrement,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_CurrentTimesGetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_CurrentTimesGetNumber1",err,error)
    CALL EXITS("CMISSControlLoop_CurrentTimesGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_CurrentTimesGetNumber1

  !
  !================================================================================================================================
  !

  !>Gets the current time parameters for a time control loop identified by an object.
  SUBROUTINE CMISSControlLoop_CurrentTimesGetObj(controlLoop,currentTime,timeIncrement,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the current times for.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time of the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the current time increment of the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_CurrentTimesGetObj",err,error,*999)

    CALL CONTROL_LOOP_CURRENT_TIMES_GET(controlLoop%CONTROL_LOOP,currentTime,timeIncrement,err,error,*999)

    CALL EXITS("CMISSControlLoop_CurrentTimesGetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoop_CurrentTimesGetObj",err,error)
    CALL EXITS("CMISSControlLoop_CurrentTimesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_CurrentTimesGetObj

  !
  !================================================================================================================================
  !

  !>Destroys a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_DestroyNumber0(problemUserNumber,controlLoopIdentifier,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_DestroyNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_DESTROY(CONTROL_LOOP,err,error,*999)
   ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_DestroyNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_DestroyNumber0",err,error)
    CALL EXITS("CMISSControlLoop_DestroyNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_DestroyNumber0

  !
  !================================================================================================================================
  !

  !>Destroys a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_DestroyNumber1(problemUserNumber,controlLoopIdentifiers,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_DestroyNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_DESTROY(CONTROL_LOOP,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_DestroyNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_DestroyNumber1",err,error)
    CALL EXITS("CMISSControlLoop_DestroyNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_DestroyNumber1

  !
  !================================================================================================================================
  !

  !>Destroys a control loop identified by an object.
  SUBROUTINE CMISSControlLoop_DestroyObj(controlLoop,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_DestroyObj",err,error,*999)

    CALL CONTROL_LOOP_DESTROY(controlLoop%CONTROL_LOOP,err,error,*999)

    CALL EXITS("CMISSControlLoop_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSControlLoop_DestroyObj",err,error)
    CALL EXITS("CMISSControlLoop_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE CMISSControlLoop_ControlLoopGetNumber00(problemUserNumber,controlLoopRootIdentifier,controlLoopIdentifier, &
      & controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifier !<The root control loop identifier.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: ROOT_CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_ControlLoopGetNumber00",err,error,*999)

    NULLIFY(ROOT_CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopRootIdentifier,ROOT_CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_GET(ROOT_CONTROL_LOOP,controlLoopIdentifier,controlLoop%CONTROL_LOOP,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_ControlLoopGetNumber00")
    RETURN
999 CALL ERRORS("CMISSControlLoop_ControlLoopGetNumber00",err,error)
    CALL EXITS("CMISSControlLoop_ControlLoopGetNumber00")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_ControlLoopGetNumber00

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE CMISSControlLoop_ControlLoopGetNumber10(problemUserNumber,controlLoopRootIdentifiers,controlLoopIdentifier, &
      & controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifiers(:) !<The root control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: ROOT_CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_ControlLoopGetNumber10",err,error,*999)

    NULLIFY(ROOT_CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopRootIdentifiers,ROOT_CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_GET(ROOT_CONTROL_LOOP,controlLoopIdentifier,controlLoop%CONTROL_LOOP,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_ControlLoopGetNumber10")
    RETURN
999 CALL ERRORS("CMISSControlLoop_ControlLoopGetNumber10",err,error)
    CALL EXITS("CMISSControlLoop_ControlLoopGetNumber10")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_ControlLoopGetNumber10

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE CMISSControlLoop_ControlLoopGetNumber01(problemUserNumber,controlLoopRootIdentifier,controlLoopIdentifiers, &
      & controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifier !<The root control loop identifier.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: ROOT_CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_ControlLoopGetNumber01",err,error,*999)

    NULLIFY(ROOT_CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopRootIdentifier,ROOT_CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_GET(ROOT_CONTROL_LOOP,controlLoopIdentifiers,controlLoop%CONTROL_LOOP,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_ControlLoopGetNumber01")
    RETURN
999 CALL ERRORS("CMISSControlLoop_ControlLoopGetNumber01",err,error)
    CALL EXITS("CMISSControlLoop_ControlLoopGetNumber01")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_ControlLoopGetNumber01

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root identified by user numbers.
  SUBROUTINE CMISSControlLoop_ControlLoopGetNumber11(problemUserNumber,controlLoopRootIdentifiers,controlLoopIdentifiers, &
      & controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopRootIdentifiers(:) !<The root control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: ROOT_CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_ControlLoopGetNumber11",err,error,*999)

    NULLIFY(ROOT_CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopRootIdentifiers,ROOT_CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_GET(ROOT_CONTROL_LOOP,controlLoopIdentifiers,controlLoop%CONTROL_LOOP,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_ControlLoopGetNumber11")
    RETURN
999 CALL ERRORS("CMISSControlLoop_ControlLoopGetNumber11",err,error)
    CALL EXITS("CMISSControlLoop_ControlLoopGetNumber11")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_ControlLoopGetNumber11

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifier from the control loop root.
  SUBROUTINE CMISSControlLoop_ControlLoopGetObj0(controlLoopRoot,controlLoopIdentifier,controlLoop,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoopRoot !<The root control loop.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_ControlLoopGetObj0",err,error,*999)

    CALL CONTROL_LOOP_GET(controlLoopRoot%CONTROL_LOOP,controlLoopIdentifier,controlLoop%CONTROL_LOOP,err,error,*999)

    CALL EXITS("CMISSControlLoop_ControlLoopGetObj0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_ControlLoopGetObj0",err,error)
    CALL EXITS("CMISSControlLoop_ControlLoopGetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_ControlLoopGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the specified control loop as indexed by the control loop identifiers from the control loop root.
  SUBROUTINE CMISSControlLoop_ControlLoopGetObj1(controlLoopRoot,controlLoopIdentifiers,controlLoop,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoopRoot !<The root control loop.
    INTEGER(INTG), INTENT(INOUT) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(CMISSControlLoopType), INTENT(OUT) :: controlLoop !<On return, the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_ControlLoopGetObj1",err,error,*999)

    CALL CONTROL_LOOP_GET(controlLoopRoot%CONTROL_LOOP,controlLoopIdentifiers,controlLoop%CONTROL_LOOP,err,error,*999)

    CALL EXITS("CMISSControlLoop_ControlLoopGetObj1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_ControlLoopGetObj1",err,error)
    CALL EXITS("CMISSControlLoop_ControlLoopGetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_ControlLoopGetObj1

  !
  !================================================================================================================================
  !

  !>Sets/changes the iteration parameters for a fixed control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_IterationsSetNumber0(problemUserNumber,controlLoopIdentifier,startIteration,stopIteration, &
    & iterationIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: startIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: stopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: iterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_IterationsSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_ITERATIONS_SET(CONTROL_LOOP,startIteration,stopIteration,iterationIncrement,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_IterationsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_IterationsSetNumber0",err,error)
    CALL EXITS("CMISSControlLoop_IterationsSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_IterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the iteration parameters for a fixed control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_IterationsSetNumber1(problemUserNumber,controlLoopIdentifiers,startIteration,stopIteration, &
    & iterationIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: startIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: stopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: iterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_IterationsSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_ITERATIONS_SET(CONTROL_LOOP,startIteration,stopIteration,iterationIncrement,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_IterationsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_IterationsSetNumber1",err,error)
    CALL EXITS("CMISSControlLoop_IterationsSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_IterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the iteration parameters for a fixed control loop identified by an object.
  SUBROUTINE CMISSControlLoop_IterationsSetObj(controlLoop,startIteration,stopIteration,iterationIncrement,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the iteration parameters for.
    INTEGER(INTG), INTENT(IN) :: startIteration !<The start iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: stopIteration !<The stop iteration of the fixed control loop to set.
    INTEGER(INTG), INTENT(IN) :: iterationIncrement !<The iteration increment of the fixed control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_IterationsSetObj",err,error,*999)

    CALL CONTROL_LOOP_ITERATIONS_SET(controlLoop%CONTROL_LOOP,startIteration,stopIteration,iterationIncrement,err,error,*999)

    CALL EXITS("CMISSControlLoop_IterationsSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoop_IterationsSetObj",err,error)
    CALL EXITS("CMISSControlLoop_IterationsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_IterationsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a control loop identified by an user number.
  SUBROUTINE CMISSControlLoop_LabelGetCNumber0(problemUserNumber,controlLoopIdentifier,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_LabelGetCNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_GET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_LabelGetCNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_LabelGetCNumber0",err,error)
    CALL EXITS("CMISSControlLoop_LabelGetCNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_LabelGetCNumber0

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a control loop identified by an user number.
  SUBROUTINE CMISSControlLoop_LabelGetCNumber1(problemUserNumber,controlLoopIdentifiers,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_LabelGetCNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_GET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_LabelGetCNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_LabelGetCNumber1",err,error)
    CALL EXITS("CMISSControlLoop_LabelGetCNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_LabelGetCNumber1

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a control loop identified by an object.
  SUBROUTINE CMISSControlLoop_LabelGetCObj(controlLoop,label,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_LabelGetCObj",err,error,*999)

    CALL CONTROL_LOOP_LABEL_GET(controlLoop%CONTROL_LOOP,label,err,error,*999)

    CALL EXITS("CMISSControlLoop_LabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSControlLoop_LabelGetCObj",err,error)
    CALL EXITS("CMISSControlLoop_LabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a control loop identified by an user number.
  SUBROUTINE CMISSControlLoop_LabelGetVSNumber0(problemUserNumber,controlLoopIdentifier,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_LabelGetVSNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_GET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_LabelGetVSNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_LabelGetVSNumber0",err,error)
    CALL EXITS("CMISSControlLoop_LabelGetVSNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_LabelGetVSNumber0

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a control loop identified by an user number.
  SUBROUTINE CMISSControlLoop_LabelGetVSNumber1(problemUserNumber,controlLoopIdentifiers,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_LabelGetVSNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_GET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_LabelGetVSNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_LabelGetVSNumber1",err,error)
    CALL EXITS("CMISSControlLoop_LabelGetVSNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_LabelGetVSNumber1

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a control loop identified by an object.
  SUBROUTINE CMISSControlLoop_LabelGetVSObj(controlLoop,label,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the control loop label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_LabelGetVSObj",err,error,*999)

    CALL CONTROL_LOOP_LABEL_GET(controlLoop%CONTROL_LOOP,label,err,error,*999)

    CALL EXITS("CMISSControlLoop_LabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSControlLoop_LabelGetVSObj",err,error)
    CALL EXITS("CMISSControlLoop_LabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a control loop identified by an user number.
  SUBROUTINE CMISSControlLoop_LabelSetCNumber0(problemUserNumber,controlLoopIdentifier,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_LabelSetCNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_SET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_LabelSetCNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_LabelSetCNumber0",err,error)
    CALL EXITS("CMISSControlLoop_LabelSetCNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_LabelSetCNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a control loop identified by an user number.
  SUBROUTINE CMISSControlLoop_LabelSetCNumber1(problemUserNumber,controlLoopIdentifiers,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_LabelSetCNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_SET(CONTROL_LOOP,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_LabelSetCNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_LabelSetCNumber1",err,error)
    CALL EXITS("CMISSControlLoop_LabelSetCNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_LabelSetCNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a control loop identified by an object.
  SUBROUTINE CMISSControlLoop_LabelSetCObj(controlLoop,label,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_LabelSetCObj",err,error,*999)

    CALL CONTROL_LOOP_LABEL_SET(controlLoop%CONTROL_LOOP,label,err,error,*999)

    CALL EXITS("CMISSControlLoop_LabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSControlLoop_LabelSetCObj",err,error)
    CALL EXITS("CMISSControlLoop_LabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a control loop identified by an user number.
  SUBROUTINE CMISSControlLoop_LabelSetVSNumber0(problemUserNumber,controlLoopIdentifier,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_LabelSetVSNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_SET(CONTROL_LOOP,CHAR(label),err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoopLabelStVSNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_LabelSetVSNumber0",err,error)
    CALL EXITS("CMISSControlLabelSetVSNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_LabelSetVSNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a control loop identified by an user number.
  SUBROUTINE CMISSControlLoop_LabelSetVSNumber1(problemUserNumber,controlLoopIdentifiers,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_LabelSetVSNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_LABEL_SET(CONTROL_LOOP,CHAR(label),err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoopLabelStVSNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_LabelSetVSNumber1",err,error)
    CALL EXITS("CMISSControlLabelSetVSNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_LabelSetVSNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for a control loop identified by an object.
  SUBROUTINE CMISSControlLoop_LabelSetVSObj(controlLoop,label,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The control loop label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_LabelSetVSObj",err,error,*999)

    CALL CONTROL_LOOP_LABEL_SET(controlLoop%CONTROL_LOOP,CHAR(label),err,error,*999)

    CALL EXITS("CMISSControlLoop_LabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSControlLoop_LabelSetVSObj",err,error)
    CALL EXITS("CMISSControlLoop_LabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_MaximumIterationsSetNumber0(problemUserNumber,controlLoopIdentifier,maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_MaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_MAXIMUM_ITERATIONS_SET(CONTROL_LOOP,maximumIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_MaximumIterationsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_MaximumIterationsSetNumber0",err,error)
    CALL EXITS("CMISSControlLoop_MaximumIterationsSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_MaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_MaximumIterationsSetNumber1(problemUserNumber,controlLoopIdentifiers,maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_MaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_MAXIMUM_ITERATIONS_SET(CONTROL_LOOP,maximumIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_MaximumIterationsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_MaximumIterationsSetNumber1",err,error)
    CALL EXITS("CMISSControlLoop_MaximumIterationsSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_MaximumIterationsSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum iterations for a while control loop identified by an object.
  SUBROUTINE CMISSControlLoop_MaximumIterationsSetObj(controlLoop,maximumIterations,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations of the while control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_MaximumIterationsSetObj",err,error,*999)

    CALL CONTROL_LOOP_MAXIMUM_ITERATIONS_SET(controlLoop%CONTROL_LOOP,maximumIterations,err,error,*999)

    CALL EXITS("CMISSControlLoop_MaximumIterationsSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoop_MaximumIterationsSetObj",err,error)
    CALL EXITS("CMISSControlLoop_MaximumIterationsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_MaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a load control loop identified by an object.
  SUBROUTINE CMISSControlLoop_LoadOutputSet(controlLoop,outputFrequency,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the output parameters for.
    INTEGER(INTG), INTENT(IN) ::  outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_LoadOutputSet",err,error,*999)

    CALL CONTROL_LOOP_LOAD_OUTPUT_SET(controlLoop%CONTROL_LOOP,outputFrequency,err,error,*999)

    CALL EXITS("CMISSControlLoop_LoadOutputSet")
    RETURN
999 CALL ERRORS("CMISSControlLoop_LoadOutputSet",err,error)
    CALL EXITS("CMISSControlLoop_LoadOutputSet")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_LoadOutputSet

  !
  !================================================================================================================================
  !

  !>Returns the number of sub-control loops for a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_NumberOfSubLoopsGetNumber0(problemUserNumber,controlLoopIdentifier,numberOfSubLoops,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(OUT) :: numberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_NumberOfSubLoopsGetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_GET(CONTROL_LOOP,numberOfSubLoops,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_NumberOfSubLoopsGetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_NumberOfSubLoopsGetNumber0",err,error)
    CALL EXITS("CMISSControlLoop_NumberOfSubLoopsGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_NumberOfSubLoopsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the number of sub-control loops for a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_NumberOfSubLoopsGetNumber1(problemUserNumber,controlLoopIdentifiers,numberOfSubLoops,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(OUT) :: numberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_NumberOfSubLoopsGetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_GET(CONTROL_LOOP,numberOfSubLoops,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_NumberOfSubLoopsGetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_NumberOfSubLoopsGetNumber1",err,error)
    CALL EXITS("CMISSControlLoop_NumberOfSubLoopsGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_NumberOfSubLoopsGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the number of sub-control loops for a control loop identified by an object.
  SUBROUTINE CMISSControlLoop_NumberOfSubLoopsGetObj(controlLoop,numberOfSubLoops,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the number of sub loops for.
    INTEGER(INTG), INTENT(OUT) :: numberOfSubLoops !<On return, the number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_NumberOfSubLoopsGetObj",err,error,*999)

    CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_GET(controlLoop%CONTROL_LOOP,numberOfSubLoops,err,error,*999)

    CALL EXITS("CMISSControlLoop_NumberOfSubLoopsGetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoop_NumberOfSubLoopsGetObj",err,error)
    CALL EXITS("CMISSControlLoop_NumberOfSubLoopsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_NumberOfSubLoopsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of sub-control loops for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE CMISSControlLoop_NumberOfSubLoopsSetNumber0(problemUserNumber,controlLoopIdentifier,numberOfSubLoops,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the number of sub loops for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: numberOfSubLoops !<The number of sub loops for the specified control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoopNumberOfSubLoopsSetNumber",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_SET(CONTROL_LOOP,numberOfSubLoops,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_NumberOfSubLoopsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_NumberOfSubLoopsSetNumber0",err,error)
    CALL EXITS("CMISSControlLoop_NumberOfSubLoopsSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_NumberOfSubLoopsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of sub-control loops for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE CMISSControlLoop_NumberOfSubLoopsSetNumber1(problemUserNumber,controlLoopIdentifiers,numberOfSubLoops,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the number of sub loops for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: numberOfSubLoops !<The number of sub loops for the specified control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_NumberOfSubLoopsSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_SET(CONTROL_LOOP,numberOfSubLoops,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_NumberOfSubLoopsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_NumberOfSubLoopsSetNumber1",err,error)
    CALL EXITS("CMISSControlLoop_NumberOfSubLoopsSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_NumberOfSubLoopsSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of sub-control loops for a control loop identified by an object. \todo is this really public???
  SUBROUTINE CMISSControlLoop_NumberOfSubLoopsSetObj(controlLoop,numberOfSubLoops,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the number of sub loops for.
    INTEGER(INTG), INTENT(IN) :: numberOfSubLoops !<The number of sub loops for the specified control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_NumberOfSubLoopsSetObj",err,error,*999)

    CALL CONTROL_LOOP_NUMBER_OF_SUB_LOOPS_SET(controlLoop%CONTROL_LOOP,numberOfSubLoops,err,error,*999)

    CALL EXITS("CMISSControlLoop_NumberOfSubLoopsSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoop_NumberOfSubLoopsSetObj",err,error)
    CALL EXITS("CMISSControlLoop_NumberOfSubLoopsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_NumberOfSubLoopsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the output type for a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_OutputTypeGetNumber0(problemUserNumber,controlLoopIdentifier,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the control loop \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_OutputTypeGetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_OUTPUT_TYPE_GET(CONTROL_LOOP,outputType,err,error,*999)
   ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_OutputTypeGetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_OutputTypeGetNumber0",err,error)
    CALL EXITS("CMISSControlLoop_OutputTypeGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_OutputTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the output type for a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_OutputTypeGetNumber1(problemUserNumber,controlLoopIdentifiers,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the control loop \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_OutputTypeGetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_OUTPUT_TYPE_GET(CONTROL_LOOP,outputType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_OutputTypeGetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_OutputTypeGetNumber1",err,error)
    CALL EXITS("CMISSControlLoop_OutputTypeGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_OutputTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the output type for a control loop identified by an object.
  SUBROUTINE CMISSControlLoop_OutputTypeGetObj(controlLoop,outputType,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the control loop \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_OutputTypeGetObj",err,error,*999)

    CALL CONTROL_LOOP_OUTPUT_TYPE_GET(controlLoop%CONTROL_LOOP,outputType,err,error,*999)

    CALL EXITS("CMISSControlLoop_OutputTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoop_OutputTypeGetObj",err,error)
    CALL EXITS("CMISSControlLoop_OutputTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets the output type for a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_OutputTypeSetNumber0(problemUserNumber,controlLoopIdentifier,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type to set \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_OutputTypeSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_OUTPUT_TYPE_SET(CONTROL_LOOP,outputType,err,error,*999)
   ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_OutputTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_OutputTypeSetNumber0",err,error)
    CALL EXITS("CMISSControlLoop_OutputTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_OutputTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets the output type for a control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_OutputTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type to set \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_OutputTypeSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_OUTPUT_TYPE_SET(CONTROL_LOOP,outputType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_OutputTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_OutputTypeSetNumber1",err,error)
    CALL EXITS("CMISSControlLoop_OutputTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_OutputTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets the output type for a control loop identified by an object.
  SUBROUTINE CMISSControlLoop_OutputTypeSetObj(controlLoop,outputType,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type to set \see OPENCMISS_ControlLoopOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_OutputTypeSetObj",err,error,*999)

    CALL CONTROL_LOOP_OUTPUT_TYPE_SET(controlLoop%CONTROL_LOOP,outputType,err,error,*999)

    CALL EXITS("CMISSControlLoop_OutputTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoop_OutputTypeSetObj",err,error)
    CALL EXITS("CMISSControlLoop_OutputTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_TimeOutputSetNumber0(problemUserNumber,controlLoopIdentifier,outputFrequency,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_TimeOutputSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIME_OUTPUT_SET(CONTROL_LOOP,outputFrequency,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_TimeOutputSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_TimeOutputSetNumber0",err,error)
    CALL EXITS("CMISSControlLoop_TimeOutputSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_TimeOutputSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_TimeOutputSetNumber1(problemUserNumber,controlLoopIdentifiers,outputFrequency,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM

    CALL ENTERS("CMISSControlLoop_TimeOutputSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIME_OUTPUT_SET(CONTROL_LOOP,outputFrequency,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_TimeOutputSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_TimeOutputSetNumber1",err,error)
    CALL EXITS("CMISSControlLoop_TimeOutputSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_TimeOutputSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the output parameters for a time control loop identified by an object.
  SUBROUTINE CMISSControlLoop_TimeOutputSetObj(controlLoop,outputFrequency,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the output parameters for.
    INTEGER(INTG), INTENT(IN) ::  outputFrequency !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_TimeOutputSetObj",err,error,*999)

    CALL CONTROL_LOOP_TIME_OUTPUT_SET(controlLoop%CONTROL_LOOP,outputFrequency,err,error,*999)

    CALL EXITS("CMISSControlLoop_TimeOutputSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoop_TimeOutputSetObj",err,error)
    CALL EXITS("CMISSControlLoopTimeOuputSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_TimeOutputSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the input parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_TimeInputSetNumber0(problemUserNumber,controlLoopIdentifier,inputOption,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: inputOption !<The input option modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_TimeInputSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIME_OUTPUT_SET(CONTROL_LOOP,inputOption,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_TimeInputSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_TimeInputSetNumber0",err,error)
    CALL EXITS("CMISSControlLoop_TimeInputSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_TimeInputSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the input parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_TimeInputSetNumber1(problemUserNumber,controlLoopIdentifiers,inputOption,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the output parameters for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: inputOption !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM

    CALL ENTERS("CMISSControlLoop_TimeInputSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIME_OUTPUT_SET(CONTROL_LOOP,inputOption,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_TimeInputSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_TimeInputSetNumber1",err,error)
    CALL EXITS("CMISSControlLoop_TimeInputSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_TimeInputSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the input parameters for a time control loop identified by an object.
  SUBROUTINE CMISSControlLoop_TimeInputSetObj(controlLoop,inputOption,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the output parameters for.
    INTEGER(INTG), INTENT(IN) ::  inputOption !<The output frequency modulo to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_TimeInputSetObj",err,error,*999)

    CALL CONTROL_LOOP_TIME_INPUT_SET(controlLoop%CONTROL_LOOP,inputOption,err,error,*999)

    CALL EXITS("CMISSControlLoop_TimeInputSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoop_TimeInputSetObj",err,error)
    CALL EXITS("CMISSControlLoop_TimeInputSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_TimeInputSetObj


  !
  !================================================================================================================================
  !

  !>Returns the time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_TimesGetNumber0(problemUserNumber,controlLoopIdentifier,startTime,stopTime,timeIncrement, &
    & currentTime,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: startTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: stopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_TimesGetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIMES_GET(CONTROL_LOOP,startTime,stopTime,timeIncrement,currentTime,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_TimesGetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_TimesGetNumber0",err,error)
    CALL EXITS("CMISSControlLoop_TimesGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_TimesGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_TimesGetNumber1(problemUserNumber,controlLoopIdentifiers,startTime,stopTime,timeIncrement, &
    & currentTime,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    REAL(DP), INTENT(OUT) :: startTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: stopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_TimesGetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIMES_GET(CONTROL_LOOP,startTime,stopTime,timeIncrement,currentTime,err,error,*999)
   ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_TimesGetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_TimesGetNumber1",err,error)
    CALL EXITS("CMISSControlLoop_TimesGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_TimesGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the time parameters for a time control loop identified by an object.
  SUBROUTINE CMISSControlLoop_TimesGetObj(controlLoop,startTime,stopTime,timeIncrement,currentTime,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(IN) :: controlLoop !<The control loop to get the times for.
    REAL(DP), INTENT(OUT) :: startTime !<On return, the start time for the time control loop.
    REAL(DP), INTENT(OUT) :: stopTime !<On return, the stop time for the time control loop.
    REAL(DP), INTENT(OUT) :: timeIncrement !<On return, the time increment for the time control loop.
    REAL(DP), INTENT(OUT) :: currentTime !<On return, the current time for the time control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_TimesGetObj",err,error,*999)

    CALL CONTROL_LOOP_TIMES_GET(controlLoop%CONTROL_LOOP,startTime,stopTime,timeIncrement,currentTime,err,error,*999)

    CALL EXITS("CMISSControlLoop_TimesGetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoop_TimesGetObj",err,error)
    CALL EXITS("CMISSControlLoop_TimesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_TimesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_TimesSetNumber0(problemUserNumber,controlLoopIdentifier,startTime,stopTime,timeIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: stopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_TimesSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIMES_SET(CONTROL_LOOP,startTime,stopTime,timeIncrement,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_TimesSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_TimesSetNumber0",err,error)
    CALL EXITS("CMISSControlLoop_TimesSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_TimesSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the time parameters for a time control loop identified by user numbers.
  SUBROUTINE CMISSControlLoop_TimesSetNumber1(problemUserNumber,controlLoopIdentifiers,startTime,stopTime,timeIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the time parameters for for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: stopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM

    CALL ENTERS("CMISSControlLoop_TimesSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TIMES_SET(CONTROL_LOOP,startTime,stopTime,timeIncrement,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_TimesSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_TimesSetNumber1",err,error)
    CALL EXITS("CMISSControlLoop_TimesSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_TimesSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the time parameters for a time control loop identified by an object.
  SUBROUTINE CMISSControlLoop_TimesSetObj(controlLoop,startTime,stopTime,timeIncrement,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the time control loop to set.
    REAL(DP), INTENT(IN) :: stopTime !<The stop time for the time control loop to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment for the time control loop to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_TimesSetObj",err,error,*999)

    CALL CONTROL_LOOP_TIMES_SET(controlLoop%CONTROL_LOOP,startTime,stopTime,timeIncrement,err,error,*999)

    CALL EXITS("CMISSControlLoop_TimesSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoop_TimesSetObj",err,error)
    CALL EXITS("CMISSControlLoop_TimesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_TimesSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the loop type for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE CMISSControlLoop_TypeSetNumber0(problemUserNumber,controlLoopIdentifier,loopType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: loopType !<The type of control loop to set. \see OPENCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_TypeSetNumber0",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TYPE_SET(CONTROL_LOOP,loopType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_TypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSControlLoop_TypeSetNumber0",err,error)
    CALL EXITS("CMISSControlLoop_TypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_TypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the loop type for a control loop identified by user numbers. \todo is this really public???
  SUBROUTINE CMISSControlLoop_TypeSetNumber1(problemUserNumber,controlLoopIdentifiers,loopType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: loopType !<The type of control loop to set. \see OPENCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CONTROL_LOOP_TYPE), POINTER :: CONTROL_LOOP
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSControlLoop_TypeSetNumber1",err,error,*999)

    NULLIFY(CONTROL_LOOP)
    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,CONTROL_LOOP,err,error,*999)
      CALL CONTROL_LOOP_TYPE_SET(CONTROL_LOOP,loopType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSControlLoop_TypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSControlLoop_TypeSetNumber1",err,error)
    CALL EXITS("CMISSControlLoop_TypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_TypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the loop type for a control loop identified by an object. \todo is this really public???
  SUBROUTINE CMISSControlLoop_TypeSetObj(controlLoop,loopType,err)

    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The control loop to set the loop type for.
    INTEGER(INTG), INTENT(IN) :: loopType !<The type of control loop to set. \see OPENCMISS_ProblemControlLoopTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSControlLoop_TypeSetObj",err,error,*999)

    CALL CONTROL_LOOP_TYPE_SET(controlLoop%CONTROL_LOOP,loopType,err,error,*999)

    CALL EXITS("CMISSControlLoop_TypeSetObj")
    RETURN
999 CALL ERRORS("CMISSControlLoop_TypeSetObj",err,error)
    CALL EXITS("CMISSControlLoop_TypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSControlLoop_TypeSetObj

!!==================================================================================================================================
!!
!! COORDINATE_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the creation of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystem_CreateFinishNumber(coordinateSystemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystem_CreateFinishNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_CREATE_FINISH(COORDINATE_SYSTEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Coordinate System Create')
#endif

    CALL EXITS("CMISSCoordinateSystem_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_CreateFinishNumber",err,error)
    CALL EXITS("CMISSCoordinateSystem_CreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystem_CreateFinishObj(coordinateSystem,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystem_CreateFinishObj",err,error,*999)

    CALL COORDINATE_SYSTEM_CREATE_FINISH(coordinateSystem%COORDINATE_SYSTEM,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Coordinate System Create')
#endif

    CALL EXITS("CMISSCoordinateSystem_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_CreateFinishObj",err,error)
    CALL EXITS("CMISSCoordinateSystem_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystem_CreateStartNumber(coordinateSystemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to start creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM

    CALL ENTERS("CMISSCoordinateSystem_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Coordinate System Create')
#endif

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_CREATE_START(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)

    CALL EXITS("CMISSCoordinateSystem_CreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_CreateStartNumber",err,error)
    CALL EXITS("CMISSCoordinateSystem_CreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystem_CreateStartObj(coordinateSystemUserNumber,coordinateSystem,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to start creating.
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<On return, the coordinate system that has been created.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystem_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Coordinate System Create')
#endif

    CALL COORDINATE_SYSTEM_CREATE_START(coordinateSystemUserNumber,coordinateSystem%COORDINATE_SYSTEM,err,error,*999)

    CALL EXITS("CMISSCoordinateSystem_CreateStartObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_CreateStartObj",err,error)
    CALL EXITS("CMISSCoordinateSystem_CreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystem_DestroyNumber(coordinateSystemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystem_DestroyNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_DESTROY(COORDINATE_SYSTEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCoordinateSystem_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_DestroyNumber",err,error)
    CALL EXITS("CMISSCoordinateSystem_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystem_DestroyObj(coordinateSystem,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSysteDestroyObj",err,error,*999)

    CALL COORDINATE_SYSTEM_DESTROY(coordinateSystem%COORDINATE_SYSTEM,err,error,*999)

    CALL EXITS("CMISSCoordinateSystem_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_DestroyObj",err,error)
    CALL EXITS("CMISSCoordinateSystem_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the dimension of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystem_DimensionGetNumber(coordinateSystemUserNumber,coordinateSystemDimension,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the dimension for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemDimension !<On return, the dimension of the coordinate system
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystem_DimensionGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_DIMENSION_GET(COORDINATE_SYSTEM,coordinateSystemDimension,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCoordinateSystem_DimensionGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_DimensionGetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystem_DimensionGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_DimensionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the dimension of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystem_DimensionGetObj(coordinateSystem,coordinateSystemDimension,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the dimension for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemDimension !<On return, the dimension of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystem_DimensionGetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_DIMENSION_GET(coordinateSystem%COORDINATE_SYSTEM,coordinateSystemDimension,err,error,*999)

    CALL EXITS("CMISSCoordinateSystem_DimensionGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_DimensionGetObj",err,error)
    CALL EXITS("CMISSCoordinateSystem_DimensionGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_DimensionGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystem_DimensionSetNumber(coordinateSystemUserNumber,coordinateSystemDimension,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemDimension !<The dimension of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystem_DimensionSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_DIMENSION_SET(COORDINATE_SYSTEM,coordinateSystemDimension,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCoordinateSystem_DimensionSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_DimensionSetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystem_DimensionSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_DimensionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystem_DimensionSetObj(coordinateSystem,coordinateSystemDimension,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT)  :: coordinateSystem !<The coordinate system to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemDimension !<The dimension of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystem_DimensionSetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_DIMENSION_SET(coordinateSystem%COORDINATE_SYSTEM,coordinateSystemDimension,err,error,*999)

    CALL EXITS("CMISSCoordinateSystem_DimensionSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_DimensionSetObj",err,error)
    CALL EXITS("CMISSCoordinateSystem_DimensionSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_DimensionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the focus of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystem_FocusGetNumber(coordinateSystemUserNumber,focus,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the focus for.
    REAL(DP), INTENT(OUT) :: focus !<On return, the focus of the coordinate system
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystem_FocusGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_FOCUS_GET(COORDINATE_SYSTEM,focus,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCoordinateSystem_FocusGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_FocusGetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystem_FocusGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_FocusGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the focus of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystem_FocusGetObj(coordinateSystem,focus,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the focus for.
    REAL(DP), INTENT(OUT) :: focus !<On return, the focus of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystem_FocusGetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_FOCUS_GET(coordinateSystem%COORDINATE_SYSTEM,focus,err,error,*999)

    CALL EXITS("CMISSCoordinateSystem_FocusGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_FocusGetObj",err,error)
    CALL EXITS("CMISSCoordinateSystem_FocusGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_FocusGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the focus of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystem_FocusSetNumber(coordinateSystemUserNumber,focus,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the focus for.
    REAL(DP), INTENT(IN) :: focus !<The focus of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystem_FocusSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_FOCUS_SET(COORDINATE_SYSTEM,focus,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCoordinateSystem_FocusSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_FocusSetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystem_FocusSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_FocusSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the focus of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystem_FocusSetObj(coordinateSystem,focus,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to set the focus for.
    REAL(DP), INTENT(IN) :: focus !<The focus of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystem_FocusSetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_FOCUS_SET(coordinateSystem%COORDINATE_SYSTEM,focus,err,error,*999)

    CALL EXITS("CMISSCoordinateSystem_FocusSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_FocusSetObj",err,error)
    CALL EXITS("CMISSCoordinateSystem_FocusSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_FocusSetObj

  !
  !================================================================================================================================
  !

  !>Returns the radial interpolation type of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystem_RadialInterpolationGetNumber(coordinateSystemUserNumber,radialInterpolationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the radial interpolation for.
    INTEGER(INTG), INTENT(OUT) :: radialInterpolationType !<On return, the radial interpolation type of the coordinate system \see OPENCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystem_RadialInterpolationGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_RADIAL_INTERPOLATION_TYPE_GET(COORDINATE_SYSTEM,radialInterpolationType,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCoordinateSystem_RadialInterpolationGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_RadialInterpolationGetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystem_RadialInterpolationGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_RadialInterpolationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the radial interpolation type of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystem_RadialInterpolationGetObj(coordinateSystem,radialInterpolationType,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to get the radial interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: radialInterpolationType !<On return, the radial interpolation type of the coordinate system. \see OPENCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystem_RadialInterpolationGetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_RADIAL_INTERPOLATION_TYPE_GET(coordinateSystem%COORDINATE_SYSTEM,radialInterpolationType,err,error,*999)

    CALL EXITS("CMISSCoordinateSystem_RadialInterpolationGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_RadialInterpolationGetObj",err,error)
    CALL EXITS("CMISSCoordinateSystem_RadialInterpolationGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_RadialInterpolationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the radial interpolation type of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystem_RadialInterpolationSetNumber(coordinateSystemUserNumber,radialInterpolationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the radial interpolation for.
    INTEGER(INTG), INTENT(IN) :: radialInterpolationType !<The radial interpolation type of the coordinate system to set.\see OPENCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystem_RadialInterpolationSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_RADIAL_INTERPOLATION_TYPE_SET(COORDINATE_SYSTEM,radialInterpolationType,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCoordinateSystem_RadialInterpolationSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_RadialInterpolationSetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystem_RadialInterpolationSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_RadialInterpolationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the radial interpolation type of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystem_RadialInterpolationSetObj(coordinateSystem,radialInterpolationType,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT)  :: coordinateSystem !<The coordinate system to set the radial interpolation type for.
    INTEGER(INTG), INTENT(IN) :: radialInterpolationType !<The radial interpolation type of the coordinate system to set. \see OPENCMISS_CoordinateRadialInterpolations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystem_RadialInterpolationSetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_RADIAL_INTERPOLATION_TYPE_SET(coordinateSystem%COORDINATE_SYSTEM,radialInterpolationType,err,error,*999)

    CALL EXITS("CMISSCoordinateSystem_RadialInterpolationSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_RadialInterpolationSetObj",err,error)
    CALL EXITS("CMISSCoordinateSystem_RadialInterpolationSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_RadialInterpolationSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystem_TypeGetNumber(coordinateSystemUserNumber,coordinateSystemType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the type for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemType !<On return, the type of the coordinate system. \see OPENCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystem_TypeGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_TYPE_GET(COORDINATE_SYSTEM,coordinateSystemType,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCoordinateSystem_TypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_TypeGetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystem_TypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystem_TypeGetObj(coordinateSystem,coordinateSystemType,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the type for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemType !<On return, the type of the coordinate system. \see OPENCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystem_TypeGetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_TYPE_GET(coordinateSystem%COORDINATE_SYSTEM,coordinateSystemType,err,error,*999)

    CALL EXITS("CMISSCoordinateSystem_TypeGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_TypeGetObj",err,error)
    CALL EXITS("CMISSCoordinateSystem_TypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystem_TypeSetNumber(coordinateSystemUserNumber,coordinateSystemType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the type for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemType !<The type of the coordinate system to set. \see OPENCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystem_TypeSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_TYPE_SET(COORDINATE_SYSTEM,coordinateSystemType,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCoordinateSystem_TypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_TypeSetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystem_TypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystem_TypeSetObj(coordinateSystem,coordinateSystemType,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to set the type for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemType !<The type of the coordinate system to set. \see OPENCMISS_CoordinateSystemTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystem_TypeSetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_TYPE_SET(coordinateSystem%COORDINATE_SYSTEM,coordinateSystemType,err,error,*999)

    CALL EXITS("CMISSCoordinateSystem_TypeSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_TypeSetObj",err,error)
    CALL EXITS("CMISSCoordinateSystem_TypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_TypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the origin of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystem_OriginGetNumber(coordinateSystemUserNumber,origin,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<On return, the orign of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystem_OriginGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_ORIGIN_GET(COORDINATE_SYSTEM,origin,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCoordinateSystem_OriginGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_OriginGetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystem_OriginGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_OriginGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the origin of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystem_OriginGetObj(coordinateSystem,origin,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<On return, the origin of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystem_OriginGetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_ORIGIN_GET(coordinateSystem%COORDINATE_SYSTEM,origin,err,error,*999)

    CALL EXITS("CMISSCoordinateSystem_OriginGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_OriginGetObj",err,error)
    CALL EXITS("CMISSCoordinateSystem_OriginGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_OriginGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystem_OriginSetNumber(coordinateSystemUserNumber,origin,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<The orign of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystem_OriginSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_ORIGIN_SET(COORDINATE_SYSTEM,origin,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCoordinateSystem_OriginSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_OriginSetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystem_OriginSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_OriginSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystem_OriginSetObj(coordinateSystem,origin,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<The origin of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystem_OriginSetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_ORIGIN_SET(coordinateSystem%COORDINATE_SYSTEM,origin,err,error,*999)

    CALL EXITS("CMISSCoordinateSystem_OriginSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_OriginSetObj",err,error)
    CALL EXITS("CMISSCoordinateSystem_OriginSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_OriginSetObj

  !
  !================================================================================================================================
  !

  !>Returns the orientation of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystem_OrientationGetNumber(coordinateSystemUserNumber,orientation,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to get the orientation for.
    REAL(DP), INTENT(OUT) :: orientation(:,:) !<On return, the orientation of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystem_OrientationGetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_ORIENTATION_GET(COORDINATE_SYSTEM,ORIENTATION,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCoordinateSystem_OrientationGetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_OrientationGetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystem_OrientationGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_OrientationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the orientation of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystem_OrientationGetObj(coordinateSystem,orientation,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to get the orientation for.
    REAL(DP), INTENT(OUT) :: orientation(:,:) !<On return, the orientation of the coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystem_OrientationGetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_ORIENTATION_GET(coordinateSystem%COORDINATE_SYSTEM,orientation,err,error,*999)

    CALL EXITS("CMISSCoordinateSystem_OrientationGetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_OrientationGetObj",err,error)
    CALL EXITS("CMISSCoordinateSystem_OrientationGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_OrientationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the orientation of a coordinate system identified by a user number.
  SUBROUTINE CMISSCoordinateSystem_OrientationSetNumber(coordinateSystemUserNumber,orientation,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set the orientation for.
    REAL(DP), INTENT(IN) :: orientation(:,:) !<The orientation of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCoordinateSystem_OrientationSetNumber",err,error,*999)

    NULLIFY(COORDINATE_SYSTEM)
    CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
    IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
      CALL COORDINATE_SYSTEM_ORIENTATION_SET(COORDINATE_SYSTEM,ORIENTATION,err,error,*999)
    ELSE
      LOCAL_ERROR="A coordinate system with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCoordinateSystem_OrientationSetNumber")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_OrientationSetNumber",err,error)
    CALL EXITS("CMISSCoordinateSystem_OrientationSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_OrientationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the orientation of a coordinate system identified by an object.
  SUBROUTINE CMISSCoordinateSystem_OrientationSetObj(coordinateSystem,orientation,err)

    !Argument variables
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<The coordinate system to set the orientation for.
    REAL(DP), INTENT(IN) :: orientation(:,:) !<The orientation of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCoordinateSystem_OrientationSetObj",err,error,*999)

    CALL COORDINATE_SYSTEM_ORIENTATION_SET(coordinateSystem%COORDINATE_SYSTEM,orientation,err,error,*999)

    CALL EXITS("CMISSCoordinateSystem_OrientationSetObj")
    RETURN
999 CALL ERRORS("CMISSCoordinateSystem_OrientationSetObj",err,error)
    CALL EXITS("CMISSCoordinateSystem_OrientationSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCoordinateSystem_OrientationSetObj

!!==================================================================================================================================
!!
!! DATA_POINT_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the process of creating data points in a region for data points identified by user number.
  SUBROUTINE CMISSDataPoints_CreateFinishNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPoints_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_CREATE_FINISH(DATA_POINTS,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataPoints_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSDataPoints_CreateFinishNumber",err,error)
    CALL EXITS("CMISSDataPoints_CreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a data points in a region for data points identified by an object.
  SUBROUTINE CMISSDataPoints_CreateFinishObj(dataPoints,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPoints_CreateFinishObj",err,error,*999)

    CALL DATA_POINTS_CREATE_FINISH(dataPoints%DATA_POINTS,err,error,*999)

    CALL EXITS("CMISSDataPoints_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSDataPoints_CreateFinishObj",err,error)
    CALL EXITS("CMISSDataPoints_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating data points in a region for data points identified by user number.
  SUBROUTINE CMISSDataPoints_CreateStartNumber(regionUserNumber,numberOfDataPoints,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDataPoints !<The number of data points to create.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPoints_CreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL DATA_POINTS_CREATE_START(REGION,numberOfDataPoints,DATA_POINTS,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataPoints_CreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSDataPoints_CreateStartNumber",err,error)
    CALL EXITS("CMISSDataPoints_CreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a data points in a region for data points identified by an object.
  SUBROUTINE CMISSDataPoints_CreateStartObj(region,numberOfDataPoints,dataPoints,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to start the creation of data points on.
    INTEGER(INTG), INTENT(IN) :: numberOfDataPoints !<The number of data points to create.
    TYPE(CMISSDataPointsType), INTENT(INOUT) :: dataPoints !<On return, the created data points.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPoints_CreateStartObj",err,error,*999)

    CALL DATA_POINTS_CREATE_START(region%REGION,numberOfDataPoints,dataPoints%DATA_POINTS,err,error,*999)

    CALL EXITS("CMISSDataPoints_CreateStartObj")
    RETURN
999 CALL ERRORS("CMISSDataPoints_CreateStartObj",err,error)
    CALL EXITS("CMISSDataPoints_CreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a data points in a region for data points identified by an object.
  SUBROUTINE CMISSDataPoints_CreateStartInterfaceObj(interface,numberOfDataPoints,dataPoints,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: interface !<The interface to start the creation of data points on.
    INTEGER(INTG), INTENT(IN) :: numberOfDataPoints !<The number of data points to create.
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<On return, the created data points.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPoints_CreateStartInterfaceObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('dataPoints Create')
#endif

    CALL DATA_POINTS_CREATE_START(interface%INTERFACE,numberOfDataPoints,dataPoints%DATA_POINTS,err,error,*999)

    CALL EXITS("CMISSDataPoints_CreateStartInterfaceObj")
    RETURN
999 CALL ERRORS("CMISSDataPoints_CreateStartInterfaceObj",err,error)
    CALL EXITS("CMISSDataPoints_CreateStartInterfaceObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_CreateStartInterfaceObj


  !
  !================================================================================================================================
  !

  !>Destroys the data points in a region for data points identified by user number.
  SUBROUTINE CMISSDataPoints_DestroyNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPoints_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DESTROY(DATA_POINTS,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataPoints_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSDataPoints_DestroyNumber",err,error)
    CALL EXITS("CMISSDataPoints_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the data points in a region for data points identified by an object.
  SUBROUTINE CMISSDataPoints_DestroyObj(dataPoints,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPoints_DestroyObj",err,error,*999)

    CALL DATA_POINTS_DESTROY(dataPoints%DATA_POINTS,err,error,*999)

    CALL EXITS("CMISSDataPoints_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSDataPoints_DestroyObj",err,error)
    CALL EXITS("CMISSDataPoints_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the number of data points
  SUBROUTINE CMISSDataPoints_NumberOfDataPointsGetNumber(regionUserNumber,numberOfDataPoints,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get data point count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDataPoints !<On return, the number of data points
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPoints_NumberOfDataPointsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_NUMBER_OF_DATA_POINTS_GET(DATA_POINTS,numberOfDataPoints,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataPoints_NumberOfDataPointsGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPoints_NumberOfDataPointsGetNumber",err,error)
    CALL EXITS("CMISSDataPoints_NumberOfDataPointsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_NumberOfDataPointsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of data points
  SUBROUTINE CMISSDataPoints_NumberOfDataPointsGetObj(dataPoints,numberOfDataPoints,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points get data point count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDataPoints !<The number of data points
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPoints_NumberOfDataPointsGetObj",err,error,*999)

    CALL DATA_POINTS_NUMBER_OF_DATA_POINTS_GET(dataPoints%DATA_POINTS,numberOfDataPoints,err,error,*999)

    CALL EXITS("CMISSDataPoints_NumberOfDataPointsGetObj")
    RETURN
999 CALL ERRORS("CMISSDataPoints_NumberOfDataPointsGetObj",err,error)
    CALL EXITS("CMISSDataPoints_NumberOfDataPointsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_NumberOfDataPointsGetObj


  !
  !================================================================================================================================
  !

  !>Returns the character label for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPoints_LabelGetCNumber(regionUserNumber,dataPointGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPoints_LabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_LABEL_GET(DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataPoints_LabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSDataPoints_LabelGetCNumber",err,error)
    CALL EXITS("CMISSDataPoints_LabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character label for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPoints_LabelGetCObj(dataPoints,dataPointGlobalNumber,label,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPoints_LabelGetCObj",err,error,*999)

    CALL DATA_POINTS_LABEL_GET(dataPoints%DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)

    CALL EXITS("CMISSDataPoints_LabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSDataPoints_LabelGetCObj",err,error)
    CALL EXITS("CMISSDataPoints_LabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPoints_LabelGetVSNumber(regionUserNumber,dataPointGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPoints_LabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_LABEL_GET(DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataPoints_LabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSDataPoints_LabelGetVSNumber",err,error)
    CALL EXITS("CMISSDataPoints_LabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPoints_LabelGetVSObj(dataPoints,dataPointGlobalNumber,label,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to get the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPoints_LabelGetVSObj",err,error,*999)

    CALL DATA_POINTS_LABEL_GET(dataPoints%DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)

    CALL EXITS("CMISSDataPoints_LabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSDataPoints_LabelGetVSObj",err,error)
    CALL EXITS("CMISSDataPoints_LabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPoints_LabelSetCNumber(regionUserNumber,dataPointGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPoints_LabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_LABEL_SET(DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataPoints_LabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSDataPoints_LabelSetCNumber",err,error)
    CALL EXITS("CMISSDataPoints_LabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPoints_LabelSetCObj(dataPoints,dataPointGlobalNumber,label,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPoints_LabelSetCObj",err,error,*999)

    CALL DATA_POINTS_LABEL_SET(dataPoints%DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)

    CALL EXITS("CMISSDataPoints_LabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSDataPoints_LabelSetCObj",err,error)
    CALL EXITS("CMISSDataPoints_LabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPoints_LabelSetVSNumber(regionUserNumber,dataPointGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPoints_LabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_LABEL_SET(DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataPoints_LabelSetVSNumber")
    RETURN
999 CALL ERRORS("CMISSDataPoints_LabelSetVSNumber",err,error)
    CALL EXITS("CMISSDataPoints_LabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPoints_LabelSetVSObj(dataPoints,dataPointGlobalNumber,label,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to set the label for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPoints_LabelSetVSObj",err,error,*999)

    CALL DATA_POINTS_LABEL_SET(dataPoints%DATA_POINTS,dataPointGlobalNumber,label,err,error,*999)

    CALL EXITS("CMISSDataPoints_LabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSDataPoints_LabelSetVSObj",err,error)
    CALL EXITS("CMISSDataPoints_LabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the user number for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPoints_UserNumberGetNumber(regionUserNumber,dataPointGlobalNumber,dataPointUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointUserNumber !<On return, the user number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPoints_UserNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_USER_NUMBER_GET(DATA_POINTS,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataPoints_UserNumberGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPoints_UserNumberGetNumber",err,error)
    CALL EXITS("CMISSDataPoints_UserNumberGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_UserNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the user number for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPoints_UserNumberGetObj(dataPoints,dataPointGlobalNumber,dataPointUserNumber,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    INTEGER(INTG), INTENT(OUT) :: dataPointUserNumber !<On return, the user number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPoints_UserNumberGetObj",err,error,*999)

    CALL DATA_POINTS_USER_NUMBER_GET(dataPoints%DATA_POINTS,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)

    CALL EXITS("CMISSDataPoints_UserNumberGetObj")
    RETURN
999 CALL ERRORS("CMISSDataPoints_UserNumberGetObj",err,error)
    CALL EXITS("CMISSDataPoints_UserNumberGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_UserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPoints_UserNumberSetNumber(regionUserNumber,dataPointGlobalNumber,dataPointUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPoints_UserNumberSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_USER_NUMBER_SET(DATA_POINTS,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataPoints_UserNumberSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPoints_UserNumberSetNumber",err,error)
    CALL EXITS("CMISSDataPoints_UserNumberSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_UserNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPoints_UserNumberSetObj(dataPoints,dataPointGlobalNumber,dataPointUserNumber,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPoints_UserNumberSetObj",err,error,*999)

    CALL DATA_POINTS_USER_NUMBER_SET(dataPoints%DATA_POINTS,dataPointGlobalNumber,dataPointUserNumber,err,error,*999)

    CALL EXITS("CMISSDataPoints_UserNumberSetObj")
    RETURN
999 CALL ERRORS("CMISSDataPoints_UserNumberSetObj",err,error)
    CALL EXITS("CMISSDataPoints_UserNumberSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_UserNumberSetObj

  !
  !================================================================================================================================
  !

  !>Returns the values for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPoints_ValuesGetNumber(regionUserNumber,dataPointGlobalNumber,dataPointValues,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point values for.
    REAL(DP), INTENT(OUT) :: dataPointValues(:) !<On return, the values for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPoints_ValuesGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_VALUES_GET(DATA_POINTS,dataPointGlobalNumber,dataPointValues,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataPoints_ValuesGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPoints_ValuesGetNumber",err,error)
    CALL EXITS("CMISSDataPoints_ValuesGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_ValuesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the values for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPoints_ValuesGetObj(dataPoints,dataPointGlobalNumber,dataPointValues,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    REAL(DP), INTENT(OUT) :: dataPointValues(:) !<On return, the values for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPoints_ValuesGetObj",err,error,*999)

    CALL DATA_POINTS_VALUES_GET(dataPoints%DATA_POINTS,dataPointGlobalNumber,dataPointValues,err,error,*999)

    CALL EXITS("CMISSDataPoints_ValuesGetObj")
    RETURN
999 CALL ERRORS("CMISSDataPoints_ValuesGetObj",err,error)
    CALL EXITS("CMISSDataPoints_ValuesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_ValuesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the values for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPoints_ValuesSetNumber(regionUserNumber,dataPointGlobalNumber,dataPointValues,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    REAL(DP), INTENT(IN) :: dataPointValues(:) !<The values for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPoints_ValuesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_VALUES_SET(DATA_POINTS,dataPointGlobalNumber,dataPointValues,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataPoints_ValuesSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPoints_ValuesSetNumber",err,error)
    CALL EXITS("CMISSDataPoints_ValuesSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_ValuesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the values for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPoints_ValuesSetObj(dataPoints,dataPointGlobalNumber,dataPointValues,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    REAL(DP), INTENT(IN) :: dataPointValues(:) !<The values for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPoints_ValuesSetObj",err,error,*999)

    CALL DATA_POINTS_VALUES_SET(dataPoints%DATA_POINTS,dataPointGlobalNumber,dataPointValues,err,error,*999)

    CALL EXITS("CMISSDataPoints_ValuesSetObj")
    RETURN
999 CALL ERRORS("CMISSDataPoints_ValuesSetObj",err,error)
    CALL EXITS("CMISSDataPoints_ValuesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_ValuesSetObj

  !
  !================================================================================================================================
  !

  !>Returns the weights for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPoints_WeightsGetNumber(regionUserNumber,dataPointGlobalNumber,dataPointWeights,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    REAL(DP), INTENT(OUT) :: dataPointWeights(:) !<On return, the weights for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPoints_WeightsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_WEIGHTS_GET(DATA_POINTS,dataPointGlobalNumber,dataPointWeights,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataPoints_WeightsGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPoints_WeightsGetNumber",err,error)
    CALL EXITS("CMISSDataPoints_WeightsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_WeightsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the weights for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPoints_WeightsGetObj(dataPoints,dataPointGlobalNumber,dataPointWeights,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to get the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to get the data point user number for.
    REAL(DP), INTENT(OUT) :: dataPointWeights(:) !<On return, the weights for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPoints_WeightsGetObj",err,error,*999)

    CALL DATA_POINTS_WEIGHTS_GET(dataPoints%DATA_POINTS,dataPointGlobalNumber,dataPointWeights,err,error,*999)

    CALL EXITS("CMISSDataPoints_WeightsGetObj")
    RETURN
999 CALL ERRORS("CMISSDataPoints_WeightsGetObj",err,error)
    CALL EXITS("CMISSDataPoints_WeightsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_WeightsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the weights for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataPoints_WeightsSetNumber(regionUserNumber,dataPointGlobalNumber,dataPointWeights,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    REAL(DP), INTENT(IN) :: dataPointWeights(:) !<The weights for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataPoints_WeightsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_WEIGHTS_SET(DATA_POINTS,dataPointGlobalNumber,dataPointWeights,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataPoints_WeightsSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataPoints_WeightsSetNumber",err,error)
    CALL EXITS("CMISSDataPoints_WeightsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_WeightsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the weights for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataPoints_WeightsSetObj(dataPoints,dataPointGlobalNumber,dataPointWeights,err)

    !Argument variables
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to set the data point user number for.
    INTEGER(INTG), INTENT(IN) :: dataPointGlobalNumber !<The global number of the data points to set the data point user number for.
    REAL(DP), INTENT(IN) :: dataPointWeights(:) !<The weights for the data point to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataPoints_WeightsSetObj",err,error,*999)

    CALL DATA_POINTS_WEIGHTS_SET(dataPoints%DATA_POINTS,dataPointGlobalNumber,dataPointWeights,err,error,*999)

    CALL EXITS("CMISSDataPoints_WeightsSetObj")
    RETURN
999 CALL ERRORS("CMISSDataPoints_WeightsSetObj",err,error)
    CALL EXITS("CMISSDataPoints_WeightsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataPoints_WeightsSetObj

!!==================================================================================================================================
!!
!! DATA_PROJECTION_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the absolute tolerance of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_AbsoluteToleranceGetNumber(dataProjectionUserNumber,regionUserNumber,absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get tolerance for.
    REAL(DP), INTENT(OUT) :: absoluteTolerance !<On exit, the absolute tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    CALL ENTERS("CMISSDataProjection_AbsoluteToleranceGetNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,ERROR,*999)
      CALL DATA_PROJECTION_ABSOLUTE_TOLERANCE_GET(DATA_PROJECTION,absoluteTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_AbsoluteToleranceGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_AbsoluteToleranceGetNumber",err,error)
    CALL EXITS("CMISSDataProjection_AbsoluteToleranceGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_AbsoluteToleranceGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the absolute tolerance of data projection identified an object.
  SUBROUTINE CMISSDataProjection_AbsoluteToleranceGetObj(dataProjection,absoluteTolerance,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get tolerance for.
    REAL(DP), INTENT(OUT) :: absoluteTolerance !<On exit, the absolute tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_AbsoluteToleranceGetObj",err,error,*999)

    CALL DATA_PROJECTION_ABSOLUTE_TOLERANCE_GET(dataProjection%DATA_PROJECTION,absoluteTolerance,err,error,*999)

    CALL EXITS("CMISSDataProjection_AbsoluteToleranceGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_AbsoluteToleranceGetObj",err,error)
    CALL EXITS("CMISSDataProjection_AbsoluteToleranceGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_AbsoluteToleranceGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_AbsoluteToleranceSetNumber(dataProjectionUserNumber,regionUserNumber,absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<the absolute tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    CALL ENTERS("CMISSDataProjection_AbsoluteToleranceSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,ERROR,*999)
      CALL DATA_PROJECTION_ABSOLUTE_TOLERANCE_SET(DATA_PROJECTION,absoluteTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_AbsoluteToleranceSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_AbsoluteToleranceSetNumber",err,error)
    CALL EXITS("CMISSDataProjection_AbsoluteToleranceSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_AbsoluteToleranceSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance of data projection identified an object.
  SUBROUTINE CMISSDataProjection_AbsoluteToleranceSetObj(dataProjection,absoluteTolerance,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<the absolute tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_AbsoluteToleranceSetObj",err,error,*999)

    CALL DATA_PROJECTION_ABSOLUTE_TOLERANCE_SET(dataProjection%DATA_PROJECTION,absoluteTolerance,err,error,*999)

    CALL EXITS("CMISSDataProjection_AbsoluteToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_AbsoluteToleranceSetObj",err,error)
    CALL EXITS("CMISSDataProjection_AbsoluteToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_AbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a new data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_CreateFinishNumber(dataProjectionUserNumber,regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points which associates to the data projection to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    CALL ENTERS("CMISSDataProjection_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,ERROR,*999)
      CALL DATA_PROJECTION_CREATE_FINISH(DATA_PROJECTION,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_CreateFinishNumber",err,error)
    CALL EXITS("CMISSDataProjection_CreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a new data projection identified by an object.
  SUBROUTINE CMISSDataProjection_CreateFinishObj(dataProjection,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to finish the creation of
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSDataProjection_CreateFinishObj",err,error,*999)

    CALL DATA_PROJECTION_CREATE_FINISH(dataProjection%DATA_PROJECTION,err,error,*999)

    CALL EXITS("CMISSDataProjection_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_CreateFinishObj",err,error)
    CALL EXITS("CMISSDataProjection_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new data projection for a data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_CreateStartNumber(dataProjectionUserNumber,dataPointRegionUserNumber,meshUserNumber, &
    & meshRegionUserNumber,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number.
    INTEGER(INTG), INTENT(IN) :: dataPointRegionUserNumber !<The region user number of the data points to be projected.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The field user number of the geometric field data points are be projected on.
    INTEGER(INTG), INTENT(IN) :: meshRegionUserNumber !<The region user number of the geometric field data points are be projected on.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: DATA_POINTS_REGION
    TYPE(REGION_TYPE), POINTER :: MESH_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR    

    CALL ENTERS("CMISSDataProjection_CreateStartNumber",err,ERROR,*999)

    NULLIFY(DATA_PROJECTION)
    NULLIFY(DATA_POINTS) 
    NULLIFY(MESH)   
    NULLIFY(DATA_POINTS_REGION)
    NULLIFY(MESH_REGION)
    CALL REGION_USER_NUMBER_FIND(dataPointRegionUserNumber,DATA_POINTS_REGION,err,ERROR,*999)
    CALL REGION_USER_NUMBER_FIND(meshRegionUserNumber,MESH_REGION,err,ERROR,*999)
    IF(ASSOCIATED(DATA_POINTS_REGION)) THEN
      IF(ASSOCIATED(MESH_REGION)) THEN
        CALL MESH_USER_NUMBER_FIND(meshUserNumber,MESH_REGION,MESH,err,ERROR,*999)
        IF(ASSOCIATED(MESH)) THEN
          CALL REGION_DATA_POINTS_GET(DATA_POINTS_REGION,DATA_POINTS,err,ERROR,*999)
          CALL DATA_PROJECTION_CREATE_START_DATA_POINTS(dataProjectionUserNumber,DATA_POINTS,MESH,DATA_PROJECTION,err, &
            & ERROR,*999)
        ELSE
          LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,ERROR))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(meshRegionUserNumber,"*",err,ERROR))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(dataPointRegionUserNumber,"*",err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDataProjection_CreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_CreateStartNumber",err,ERROR)
    CALL EXITS("CMISSDataProjection_CreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSDataProjection_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a new data projection for a data projection identified by an object.
  SUBROUTINE CMISSDataProjection_CreateStartObj(dataProjectionUserNumber,dataPoints,mesh,dataProjection,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number.
    TYPE(CMISSDataPointsType), INTENT(IN) :: dataPoints !<The data points to be projected
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh where data points is projected on
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<On exit, the newly created data projection.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_CreateStartObj",err,error,*999)

    CALL DATA_PROJECTION_CREATE_START_DATA_POINTS(dataProjectionUserNumber,dataPoints%DATA_POINTS,mesh%MESH, &
      & dataProjection%DATA_PROJECTION,err,ERROR,*999)

    CALL EXITS("CMISSDataProjection_CreateStartObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_CreateStartObj",err,error)
    CALL EXITS("CMISSDataProjection_CreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a data projection identified by region user number.
  SUBROUTINE CMISSDataProjection_DestroyNumber(dataProjectionUserNumber,regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    CALL ENTERS("CMISSDataProjection_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,ERROR,*999)
      CALL DATA_PROJECTION_DESTROY(DATA_PROJECTION,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_DestroyNumber",err,error)
    CALL EXITS("CMISSDataProjection_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a data projection identified by an object.
  SUBROUTINE CMISSDataProjection_DestroyObj(dataProjection,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_DestroyObj",err,error,*999)

    CALL DATA_PROJECTION_DESTROY(dataProjection%DATA_PROJECTION,err,error,*999)

    CALL EXITS("CMISSDataProjection_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_DestroyObj",err,error)
    CALL EXITS("CMISSDataProjection_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_DestroyObj
  
  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection in a region, identified by user number
  SUBROUTINE CMISSDataProjection_DataPointsPositionEvaluateRegionNumber(dataProjectionUserNumber,regionUserNumber, &
    & fieldUserNumber,fieldVariableType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection 
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection and field
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field user number of the field to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The field variable type to be interpolated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: dataProjection
    TYPE(DATA_POINTS_TYPE), POINTER :: dataPoints
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    INTEGER(INTG) :: dataProjectionGlobalNumber !<The data projection global number.
    TYPE(VARYING_STRING) :: localError      

    CALL ENTERS("CMISSDataProjection_DataPointsPositionEvaluateRegionNumber",err,error,*999)
    
    NULLIFY(dataProjection)
    NULLIFY(dataPoints) 
    NULLIFY(field)   
    NULLIFY(region)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,ERROR,*999)
    IF(ASSOCIATED(region)) THEN
      CALL REGION_DATA_POINTS_GET(region,dataPoints,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(dataPoints,dataProjectionUserNumber,dataProjectionGlobalNumber, &
        & err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(dataPoints,dataProjectionGlobalNumber,dataProjection,err,ERROR,*999)
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,ERROR,*999)
      IF(ASSOCIATED(field)) THEN
        CALL DataProjection_DataPointsPositionEvaluate(dataProjection,field,fieldVariableType,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,ERROR))// &
          & " does not exist."
        CALL FLAG_ERROR(localError,err,ERROR,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_DataPointsPositionEvaluateRegionNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_DataPointsPositionEvaluateRegionNumber",err,error)
    CALL EXITS("CMISSDataProjection_DataPointsPositionEvaluateRegionNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_DataPointsPositionEvaluateRegionNumber

  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection in an interface, identified by user number
  SUBROUTINE CMISSDataProjection_DataPointsPositionEvaluateInterfaceNumber(dataProjectionUserNumber, &
      & parentRegionUserNumber,interfaceUserNumber,fieldUserNumber,fieldVariableType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection 
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection 
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field user number of the field to be interpolated
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The field variable type to be interpolated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: dataProjection
    TYPE(DATA_POINTS_TYPE), POINTER :: dataPoints
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: parentRegion
    TYPE(INTERFACE_TYPE), POINTER :: interface
    INTEGER(INTG) :: dataProjectionGlobalNumber !<The data projection global number.
    TYPE(VARYING_STRING) :: localError      

    CALL ENTERS("CMISSDataProjection_DataPointsPositionEvaluateInterfaceNumber",err,error,*999)
    
    NULLIFY(dataProjection)
    NULLIFY(dataPoints) 
    NULLIFY(field)   
    NULLIFY(parentRegion)
    NULLIFY(interface)  
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,parentRegion,Err,ERROR,*999)
    IF(ASSOCIATED(parentRegion)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,parentRegion,interface,Err,ERROR,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL INTERFACE_DATA_POINTS_GET(interface,dataPoints,err,error,*999)
        CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(dataPoints,dataProjectionUserNumber,dataProjectionGlobalNumber, &
          & err,ERROR,*999)
        CALL DATA_POINTS_DATA_PROJECTION_GET(dataPoints,dataProjectionGlobalNumber,dataProjection,err,ERROR,*999)
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,ERROR,*999)
        IF(ASSOCIATED(field)) THEN
          CALL DataProjection_DataPointsPositionEvaluate(dataProjection,field,fieldVariableType,err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,ERROR))// &
            & " does not exist."
          CALL FLAG_ERROR(localError,err,ERROR,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",Err,ERROR))// &
          & " does not exist."
        CALL FLAG_ERROR(localError,Err,ERROR,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentregionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSDataProjection_DataPointsPositionEvaluateInterfaceNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_DataPointsPositionEvaluateInterfaceNumber",err,error)
    CALL EXITS("CMISSDataProjection_DataPointsPositionEvaluateInterfaceNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_DataPointsPositionEvaluateInterfaceNumber
  
  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection, identified by object
  SUBROUTINE CMISSDataProjection_DataPointsPositionEvaluateObj(dataProjection,field,fieldVariableType,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to interpolate
    INTEGER(INTG), INTENT(IN) :: fieldVariableType !<The field variable type to be interpolated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables 

    CALL ENTERS("CMISSDataProjection_DataPointsPositionEvaluateObj",err,error,*999)
    
    CALL DataProjection_DataPointsPositionEvaluate(dataProjection%DATA_PROJECTION,field%FIELD,fieldVariableType,err,error,*999)
    
    CALL EXITS("CMISSDataProjection_DataPointsPositionEvaluateObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_DataPointsPositionEvaluateObj",err,error)
    CALL EXITS("CMISSDataProjection_DataPointsPositionEvaluateObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_DataPointsPositionEvaluateObj
  
  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection in a region, identified by user number
  SUBROUTINE CMISSDataProjection_ProjectionCandidatesSetRegionNumber(dataProjectionUserNumber,regionUserNumber, &
    & candidateElements,localFaceLineNumbers,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection 
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection and field
    INTEGER(INTG), INTENT(IN) :: candidateElements(:) !<The candidate element for the projection
    INTEGER(INTG), INTENT(IN) :: localFaceLineNumbers(:) !<The local face/line number for the candidate elements
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: dataProjection
    TYPE(DATA_POINTS_TYPE), POINTER :: dataPoints
    TYPE(REGION_TYPE), POINTER :: region
    INTEGER(INTG) :: dataProjectionGlobalNumber !<The data projection global number.
    TYPE(VARYING_STRING) :: localError      

    CALL ENTERS("CMISSDataProjection_ProjectionCandidatesSetRegionNumber",err,error,*999)
    
    NULLIFY(dataProjection)
    NULLIFY(dataPoints) 
    NULLIFY(region)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,ERROR,*999)
    IF(ASSOCIATED(region)) THEN
      CALL REGION_DATA_POINTS_GET(region,dataPoints,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(dataPoints,dataProjectionUserNumber,dataProjectionGlobalNumber, &
        & err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(dataPoints,dataProjectionGlobalNumber,dataProjection,err,ERROR,*999)
      CALL DataProjection_ProjectionCandidatesSet(dataProjection,candidateElements,localFaceLineNumbers,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_ProjectionCandidatesSetRegionNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ProjectionCandidatesSetRegionNumber",err,error)
    CALL EXITS("CMISSDataProjection_ProjectionCandidatesSetRegionNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ProjectionCandidatesSetRegionNumber

  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection in an interface, identified by user number
  SUBROUTINE CMISSDataProjection_ProjectionCandidatesSetInterfaceNumber(dataProjectionUserNumber, &
      & parentRegionUserNumber,interfaceUserNumber,candidateElements,localFaceLineNumbers,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection 
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The parent region number of the interface for the data projection 
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The interface number for the data projection
    INTEGER(INTG), INTENT(IN) :: candidateElements(:) !<The candidate element for the projection
    INTEGER(INTG), INTENT(IN) :: localFaceLineNumbers(:) !<The local face/line number for the candidate elements
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: dataProjection
    TYPE(DATA_POINTS_TYPE), POINTER :: dataPoints
    TYPE(REGION_TYPE), POINTER :: parentRegion
    TYPE(INTERFACE_TYPE), POINTER :: interface
    INTEGER(INTG) :: dataProjectionGlobalNumber !<The data projection global number.
    TYPE(VARYING_STRING) :: localError      

    CALL ENTERS("CMISSDataProjection_ProjectionCandidatesSetInterfaceNumber",err,error,*999)
    
    NULLIFY(dataProjection)
    NULLIFY(dataPoints)  
    NULLIFY(parentRegion)
    NULLIFY(interface)  
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,parentRegion,Err,ERROR,*999)
    IF(ASSOCIATED(parentRegion)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,parentRegion,interface,Err,ERROR,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL INTERFACE_DATA_POINTS_GET(interface,dataPoints,err,error,*999)
        CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(dataPoints,dataProjectionUserNumber,dataProjectionGlobalNumber, &
          & err,ERROR,*999)
        CALL DATA_POINTS_DATA_PROJECTION_GET(dataPoints,dataProjectionGlobalNumber,dataProjection,err,ERROR,*999)
        CALL DataProjection_ProjectionCandidatesSet(dataProjection,candidateElements,localFaceLineNumbers,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",Err,ERROR))// &
          & " does not exist."
        CALL FLAG_ERROR(localError,Err,ERROR,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentregionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,Err,ERROR,*999)
    ENDIF
    
    CALL EXITS("CMISSDataProjection_ProjectionCandidatesSetInterfaceNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ProjectionCandidatesSetInterfaceNumber",err,error)
    CALL EXITS("CMISSDataProjection_ProjectionCandidatesSetInterfaceNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ProjectionCandidatesSetInterfaceNumber
  
  !
  !================================================================================================================================
  !

  !>Evaluate the data points position in a field based on data projection, identified by object
  SUBROUTINE CMISSDataProjection_ProjectionCandidatesSetObj(dataProjection,candidateElements,localFaceLineNumbers,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection used to evaluate data points position
    INTEGER(INTG), INTENT(IN) :: candidateElements(:) !<The candidate element for the projection
    INTEGER(INTG), INTENT(IN) :: localFaceLineNumbers(:) !<The local face/line number for the candidate elements
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables 

    CALL ENTERS("CMISSDataProjection_ProjectionCandidatesSetObj",err,error,*999)
    
    CALL DataProjection_ProjectionCandidatesSet(dataProjection%DATA_PROJECTION,candidateElements,localFaceLineNumbers, &
      & err,error,*999)
    
    CALL EXITS("CMISSDataProjection_ProjectionCandidatesSetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ProjectionCandidatesSetObj",err,error)
    CALL EXITS("CMISSDataProjection_ProjectionCandidatesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ProjectionCandidatesSetObj

  !
  !================================================================================================================================
  !

  !>Evaluate a data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_ProjectionEvaluateNumber(dataProjectionUserNumber,dataPointsRegionUserNumber, &
    & projectionFieldUserNumber,projectionFieldRegionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointsRegionUserNumber !<The region user number of the data projection to evaluate.
    INTEGER(INTG), INTENT(IN) :: projectionFieldUserNumber !<The field user number of the field data points are be projected on.
    INTEGER(INTG), INTENT(IN) :: projectionFieldRegionUserNumber !<The region user number of the field data points are be projected on.    
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(FIELD_TYPE), POINTER :: PROJECTION_FIELD
    TYPE(REGION_TYPE), POINTER :: DATA_POINTS_REGION
    TYPE(REGION_TYPE), POINTER :: PROJECTION_FIELD_REGION
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.
    TYPE(VARYING_STRING) :: LOCAL_ERROR      

    CALL ENTERS("CMISSDataProjection_ProjectionEvaluateNumber",err,error,*999)
    
    NULLIFY(DATA_PROJECTION)
    NULLIFY(DATA_POINTS) 
    NULLIFY(PROJECTION_FIELD)   
    NULLIFY(DATA_POINTS_REGION)
    NULLIFY(PROJECTION_FIELD_REGION)
    CALL REGION_USER_NUMBER_FIND(dataPointsRegionUserNumber,DATA_POINTS_REGION,err,ERROR,*999)
    CALL REGION_USER_NUMBER_FIND(projectionFieldRegionUserNumber,PROJECTION_FIELD_REGION,err,ERROR,*999)
    IF(ASSOCIATED(DATA_POINTS_REGION)) THEN
      CALL REGION_DATA_POINTS_GET(DATA_POINTS_REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,dataProjectionUserNumber,GLOBAL_NUMBER,err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,ERROR,*999)
      IF(ASSOCIATED(PROJECTION_FIELD_REGION)) THEN
        CALL FIELD_USER_NUMBER_FIND(projectionFieldUserNumber,PROJECTION_FIELD_REGION,PROJECTION_FIELD,err,ERROR,*999)
        IF(ASSOCIATED(PROJECTION_FIELD)) THEN
          CALL DATA_PROJECTION_DATA_POINTS_PROJECTION_EVALUATE(DATA_PROJECTION,PROJECTION_FIELD,err,error,*999)
        ELSE
          LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(projectionFieldUserNumber,"*",err,ERROR))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(projectionFieldRegionUserNumber,"*",err,ERROR))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(dataPointsRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_ProjectionEvaluateNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ProjectionEvaluateNumber",err,error)
    CALL EXITS("CMISSDataProjection_ProjectionEvaluateNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ProjectionEvaluateNumber


  !
  !================================================================================================================================
  !

  !>Evaluate a data projection identified by an object.
  SUBROUTINE CMISSDataProjection_ProjectionEvaluateObj(dataProjection,projectionField,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to evaluate.
    TYPE(CMISSFieldType), INTENT(IN) :: projectionField !<The field data points is projected on
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_ProjectionEvaluateObj",err,error,*999)

    CALL DATA_PROJECTION_DATA_POINTS_PROJECTION_EVALUATE(dataProjection%DATA_PROJECTION,projectionField%FIELD,err,error,*999)

    CALL EXITS("CMISSDataProjection_ProjectionEvaluateObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ProjectionEvaluateObj",err,error)
    CALL EXITS("CMISSDataProjection_ProjectionEvaluateObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ProjectionEvaluateObj

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_MaximumIterationUpdateGetNumber(dataProjectionUserNumber,regionUserNumber, &
      & maximumIterationUpdate,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get tolerance for.
    REAL(DP), INTENT(OUT) :: maximumIterationUpdate !<On exit, the maximum iteration update of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    CALL ENTERS("CMISSDataProjection_MaximumIterationUpdateGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,ERROR,*999)
      CALL DATA_PROJECTION_MAXIMUM_ITERATION_UPDATE_GET(DATA_PROJECTION,maximumIterationUpdate,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_MaximumIterationUpdateGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_MaximumIterationUpdateGetNumber",err,error)
    CALL EXITS("CMISSDataProjection_MaximumIterationUpdateGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_MaximumIterationUpdateGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified an object.
  SUBROUTINE CMISSDataProjection_MaximumIterationUpdateGetObj(dataProjection,maximumIterationUpdate,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get tolerance for.
    REAL(DP), INTENT(OUT) :: maximumIterationUpdate !<On exit, the maximum iteration update of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_MaximumIterationUpdateGetObj",err,error,*999)

    CALL DATA_PROJECTION_MAXIMUM_ITERATION_UPDATE_GET(dataProjection%DATA_PROJECTION,maximumIterationUpdate,err,error,*999)

    CALL EXITS("CMISSDataProjection_MaximumIterationUpdateGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_MaximumIterationUpdateGetObj",err,error)
    CALL EXITS("CMISSDataProjection_MaximumIterationUpdateGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_MaximumIterationUpdateGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_MaximumIterationUpdateSetNumber(dataProjectionUserNumber,regionUserNumber, &
      & maximumIterationUpdate,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set tolerance for.
    REAL(DP), INTENT(IN) :: maximumIterationUpdate !<the maximum iteration update to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    CALL ENTERS("CMISSDataProjection_MaximumIterationUpdateSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,ERROR,*999)
      CALL DATA_PROJECTION_MAXIMUM_ITERATION_UPDATE_SET(DATA_PROJECTION,maximumIterationUpdate,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_MaximumIterationUpdateSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_MaximumIterationUpdateSetNumber",err,error)
    CALL EXITS("CMISSDataProjection_MaximumIterationUpdateSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_MaximumIterationUpdateSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified an object.
  SUBROUTINE CMISSDataProjection_MaximumIterationUpdateSetObj(dataProjection,maximumIterationUpdate,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set tolerance for.
    REAL(DP), INTENT(IN) :: maximumIterationUpdate !<the maximum iteration update to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_MaximumIterationUpdateSetObj",err,error,*999)

    CALL DATA_PROJECTION_MAXIMUM_ITERATION_UPDATE_SET(dataProjection%DATA_PROJECTION,maximumIterationUpdate,err,error,*999)

    CALL EXITS("CMISSDataProjection_MaximumIterationUpdateSetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_MaximumIterationUpdateSetObj",err,error)
    CALL EXITS("CMISSDataProjection_MaximumIterationUpdateSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_MaximumIterationUpdateSetObj

  !
  !================================================================================================================================
  !

  !>Returns the maximum number of iterations of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_MaximumNumberOfIterationsGetNumber(dataProjectionUserNumber,regionUserNumber, &
      & maximumNumberOfIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get maximum number of iterations for.
    INTEGER(INTG), INTENT(OUT) :: maximumNumberOfIterations !<On exit, the maximum number of iterations of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    CALL ENTERS("CMISSDataProjection_MaximumNumberOfIterationsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,ERROR,*999)
      CALL DATA_PROJECTION_MAXIMUM_NUMBER_OF_ITERATIONS_GET(DATA_PROJECTION,maximumNumberOfIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_MaximumNumberOfIterationsGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_MaximumNumberOfIterationsGetNumber",err,error)
    CALL EXITS("CMISSDataProjection_MaximumNumberOfIterationsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_MaximumNumberOfIterationsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection distance for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataProjection_ResultDistanceGetNumber(regionUserNumber,dataProjectionUserNumber,dataPointUserNumber, &
    & ProjectionDistance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: ProjectionDistance !<On return, the projection distance for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    INTEGER(INTG) :: DATA_PROJECTION_GLOBAL_NUMBER    
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR 

    CALL ENTERS("CMISSDataProjection_ResultDistanceGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)    
    NULLIFY(DATA_PROJECTION) 
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,dataProjectionUserNumber,DATA_PROJECTION_GLOBAL_NUMBER,ERR, &
        & error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION_GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      IF(ASSOCIATED(DATA_PROJECTION)) THEN
        CALL DATA_PROJECTION_RESULT_DISTANCE_GET(DATA_PROJECTION,dataPointUserNumber,ProjectionDistance,err,error,*999)
      ELSE
        LOCAL_ERROR="A data projection with an user number of "//TRIM(NUMBER_TO_VSTRING(dataProjectionUserNumber,"*",err,error)) &
          & //" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjection_ResultDistanceGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ResultDistanceGetNumber",err,error)
    CALL EXITS("CMISSDataProjection_ResultDistanceGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ResultDistanceGetNumber


   !
   !================================================================================================================================
   !

  !>Returns the projection distance for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataProjection_ResultDistanceGetObj(dataProjection,dataPointUserNumber,ProjectionDistance,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: ProjectionDistance !<On return, the projection distance for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_ResultDistanceGetObj",err,error,*999)

    CALL DATA_PROJECTION_RESULT_DISTANCE_GET(dataProjection%DATA_PROJECTION,dataPointUserNumber,ProjectionDistance, &
      & err,error,*999)

    CALL EXITS("CMISSDataProjection_ResultDistanceGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ResultDistanceGetObj",err,error)
    CALL EXITS("CMISSDataProjection_ResultDistanceGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ResultDistanceGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection element number for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataProjection_ResultElementNumberGetNumber(regionUserNumber,dataProjectionUserNumber,dataPointUserNumber, &
    & ProjectionElementNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: ProjectionElementNumber !<On return, the projection element number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    INTEGER(INTG) :: DATA_PROJECTION_GLOBAL_NUMBER  
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjection_ResultElementNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)    
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,dataProjectionUserNumber,DATA_PROJECTION_GLOBAL_NUMBER,ERR, &
        & error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION_GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      IF(ASSOCIATED(DATA_PROJECTION)) THEN
        CALL DATA_PROJECTION_RESULT_ELEMENT_NUMBER_GET(DATA_PROJECTION,dataPointUserNumber,ProjectionElementNumber,err,error,*999)
      ELSE
        LOCAL_ERROR="A data projection with an user number of "//TRIM(NUMBER_TO_VSTRING(dataProjectionUserNumber,"*",err,error)) &
          & //" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF    

    CALL EXITS("CMISSDataProjection_ResultElementNumberGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ResultElementNumberGetNumber",err,error)
    CALL EXITS("CMISSDataProjection_ResultElementNumberGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ResultElementNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection element number for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataProjection_ResultElementNumberGetObj(dataProjection,dataPointUserNumber,ProjectionElementNumber,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: ProjectionElementNumber !<On return, the projection element number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_ResultElementNumberGetObj",err,error,*999)

    CALL DATA_PROJECTION_RESULT_ELEMENT_NUMBER_GET(dataProjection%DATA_PROJECTION,dataPointUserNumber,ProjectionElementNumber, &
      & err,error,*999)

    CALL EXITS("CMISSDataProjection_ResultElementNumberGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ResultElementNumberGetObj",err,error)
    CALL EXITS("CMISSDataProjection_ResultElementNumberGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ResultElementNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection element face number for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataProjection_ResultElementFaceNumberGetNumber(regionUserNumber,dataProjectionUserNumber,dataPointUserNumber, &
    & ProjectionElementFaceNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: ProjectionElementFaceNumber !<On return, the projection element face number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    INTEGER(INTG) :: DATA_PROJECTION_GLOBAL_NUMBER  
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjection_ResultElementFaceNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)    
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,dataProjectionUserNumber,DATA_PROJECTION_GLOBAL_NUMBER,ERR, &
        & error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION_GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      IF(ASSOCIATED(DATA_PROJECTION)) THEN
        CALL DATA_PROJECTION_RESULT_ELEMENT_FACE_NUMBER_GET(DATA_PROJECTION,dataPointUserNumber,ProjectionElementFaceNumber,err, &
          & error,*999)
      ELSE
        LOCAL_ERROR="A data projection with an user number of "//TRIM(NUMBER_TO_VSTRING(dataProjectionUserNumber,"*",err,error)) &
          & //" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF    

    CALL EXITS("CMISSDataProjection_ResultElementFaceNumberGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ResultElementFaceNumberGetNumber",err,error)
    CALL EXITS("CMISSDataProjection_ResultElementFaceNumberGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ResultElementFaceNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection element face number for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataProjection_ResultElementFaceNumberGetObj(dataProjection,dataPointUserNumber, &
    & ProjectionElementFaceNumber,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: ProjectionElementFaceNumber !<On return, the projection element face number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_ResultElementFaceNumberGetObj",err,error,*999)

    CALL DATA_PROJECTION_RESULT_ELEMENT_FACE_NUMBER_GET(dataProjection%DATA_PROJECTION,dataPointUserNumber, &
      & ProjectionElementFaceNumber,err,error,*999)

    CALL EXITS("CMISSDataProjection_ResultElementFaceNumberGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ResultElementFaceNumberGetObj",err,error)
    CALL EXITS("CMISSDataProjection_ResultElementFaceNumberGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ResultElementFaceNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection element line number for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataProjection_ResultElementLineNumberGetNumber(regionUserNumber,dataProjectionUserNumber,dataPointUserNumber, &
    & ProjectionElementLineNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: ProjectionElementLineNumber !<On return, the projection element line number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    INTEGER(INTG) :: DATA_PROJECTION_GLOBAL_NUMBER  
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjection_ResultElementLineNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)    
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,dataProjectionUserNumber,DATA_PROJECTION_GLOBAL_NUMBER,ERR, &
        & error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION_GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      IF(ASSOCIATED(DATA_PROJECTION)) THEN
        CALL DATA_PROJECTION_RESULT_ELEMENT_LINE_NUMBER_GET(DATA_PROJECTION,dataPointUserNumber,ProjectionElementLineNumber,err, &
          & error,*999)
      ELSE
        LOCAL_ERROR="A data projection with an user number of "//TRIM(NUMBER_TO_VSTRING(dataProjectionUserNumber,"*",err,error)) &
          & //" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF    

    CALL EXITS("CMISSDataProjection_ResultElementLineNumberGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ResultElementLineNumberGetNumber",err,error)
    CALL EXITS("CMISSDataProjection_ResultElementLineNumberGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ResultElementLineNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection element line number for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataProjection_ResultElementLineNumberGetObj(dataProjection,dataPointUserNumber, &
    & ProjectionElementLineNumber,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: ProjectionElementLineNumber !<On return, the projection element line number for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_ResultElementLineNumberGetObj",err,error,*999)

    CALL DATA_PROJECTION_RESULT_ELEMENT_LINE_NUMBER_GET(dataProjection%DATA_PROJECTION,dataPointUserNumber, &
      & ProjectionElementLineNumber,err,error,*999)

    CALL EXITS("CMISSDataProjection_ResultElementLineNumberGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ResultElementLineNumberGetObj",err,error)
    CALL EXITS("CMISSDataProjection_ResultElementLineNumberGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ResultElementLineNumberGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection exit tag for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataProjection_ResultExitTagGetNumber(regionUserNumber,dataProjectionUserNumber,dataPointUserNumber, &
    & ProjectionExitTag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: ProjectionExitTag !<On return, the projection exit tag for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    INTEGER(INTG) :: DATA_PROJECTION_GLOBAL_NUMBER  
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjection_ResultExitTagGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)    
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,dataProjectionUserNumber,DATA_PROJECTION_GLOBAL_NUMBER,ERR, &
        & error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION_GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      IF(ASSOCIATED(DATA_PROJECTION)) THEN
        CALL DATA_PROJECTION_RESULT_EXIT_TAG_GET(DATA_PROJECTION,dataPointUserNumber,ProjectionExitTag,err,error,*999)
      ELSE
        LOCAL_ERROR="A data projection with an user number of "//TRIM(NUMBER_TO_VSTRING(dataProjectionUserNumber,"*",err,error)) &
          & //" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF    

    CALL EXITS("CMISSDataProjection_ResultExitTagGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ResultExitTagGetNumber",err,error)
    CALL EXITS("CMISSDataProjection_ResultExitTagGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ResultExitTagGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection exit tag for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataProjection_ResultExitTagGetObj(dataProjection,dataPointUserNumber,ProjectionExitTag,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    INTEGER(INTG), INTENT(OUT) :: ProjectionExitTag !<On return, the projection exit tag for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_ResultExitTagGetObj",err,error,*999)

    CALL DATA_PROJECTION_RESULT_EXIT_TAG_GET(dataProjection%DATA_PROJECTION,dataPointUserNumber,ProjectionExitTag, &
      & err,error,*999)

    CALL EXITS("CMISSDataProjection_ResultExitTagGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ResultExitTagGetObj",err,error)
    CALL EXITS("CMISSDataProjection_ResultExitTagGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ResultExitTagGetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection xi for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataProjection_ResultXiGetNumber(regionUserNumber,dataProjectionUserNumber,dataPointUserNumber,ProjectionXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.
    REAL(DP), INTENT(OUT) :: ProjectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    INTEGER(INTG) :: DATA_PROJECTION_GLOBAL_NUMBER  
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjection_ResultXiGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)    
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,dataProjectionUserNumber,DATA_PROJECTION_GLOBAL_NUMBER,ERR, &
        & error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION_GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      IF(ASSOCIATED(DATA_PROJECTION)) THEN
        CALL DATA_PROJECTION_RESULT_XI_GET(DATA_PROJECTION,dataPointUserNumber,ProjectionXi,err,error,*999)
      ELSE
        LOCAL_ERROR="A data projection with an user number of "//TRIM(NUMBER_TO_VSTRING(dataProjectionUserNumber,"*",err,error)) &
          & //" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjection_ResultXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ResultXiGetNumber",err,error)
    CALL EXITS("CMISSDataProjection_ResultXiGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ResultXiGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection xi for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataProjection_ResultXiGetObj(dataProjection,dataPointUserNumber,ProjectionXi,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(IN) :: dataProjection !<The data projection to get attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to get attributes for.        
    REAL(DP), INTENT(OUT) :: ProjectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_ResultXiGetObj",err,error,*999)

    CALL DATA_PROJECTION_RESULT_XI_GET(dataProjection%DATA_PROJECTION,dataPointUserNumber,ProjectionXi,err,error,*999)

    CALL EXITS("CMISSDataProjection_ResultXiGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ResultXiGetObj",err,error)
    CALL EXITS("CMISSDataProjection_ResultXiGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ResultXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets the projection xi for a data point in a set of data points identified by user number.
  SUBROUTINE CMISSDataProjection_ResultXiSetNumber(regionUserNumber,dataProjectionUserNumber,dataPointUserNumber,ProjectionXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the data points to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The user number of the data projection containing the data points to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set attributes for.
    REAL(DP), INTENT(IN) :: ProjectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    INTEGER(INTG) :: DATA_PROJECTION_GLOBAL_NUMBER  
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjection_ResultXiSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)    
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,dataProjectionUserNumber,DATA_PROJECTION_GLOBAL_NUMBER,ERR, &
        & error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION_GLOBAL_NUMBER,DATA_PROJECTION,err,error,*999)
      IF(ASSOCIATED(DATA_PROJECTION)) THEN
        CALL DATA_PROJECTION_RESULT_XI_SET(DATA_PROJECTION,dataPointUserNumber,ProjectionXi,err,error,*999)
      ELSE
        LOCAL_ERROR="A data projection with an user number of "//TRIM(NUMBER_TO_VSTRING(dataProjectionUserNumber,"*",err,error)) &
          & //" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSDataProjection_ResultXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ResultXiSetNumber",err,error)
    CALL EXITS("CMISSDataProjection_ResultXiSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ResultXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the projection xi for a data point in a set of data points identified by an object.
  SUBROUTINE CMISSDataProjection_ResultXiSetObj(dataProjection,dataPointUserNumber,ProjectionXi,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(IN) :: dataProjection !<The data projection to set attributes for.
    INTEGER(INTG), INTENT(IN) :: dataPointUserNumber !<The user number of the data points to set attributes for 
    REAL(DP), INTENT(IN) :: ProjectionXi(:) !<On return, the projection xi for the data point.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_ResultXiSetObj",err,error,*999)

    CALL DATA_PROJECTION_RESULT_XI_SET(dataProjection%DATA_PROJECTION,dataPointUserNumber,ProjectionXi,err,error,*999)

    CALL EXITS("CMISSDataProjection_ResultXiSetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ResultXiSetObj",err,error)
    CALL EXITS("CMISSDataProjection_ResultXiSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ResultXiSetObj

  !
  !================================================================================================================================
  !

  !>Returns the maximum number of iterations of data projection identified an object.
  SUBROUTINE CMISSDataProjection_MaximumNumberOfIterationsGetObj(dataProjection,maximumNumberOfIterations,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get maximum number of iterations for.
    INTEGER(INTG), INTENT(OUT) :: maximumNumberOfIterations !<On exit, the maximum number of iterations of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_MaximumNumberOfIterationsGetObj",err,error,*999)

    CALL DATA_PROJECTION_MAXIMUM_NUMBER_OF_ITERATIONS_GET(dataProjection%DATA_PROJECTION,maximumNumberOfIterations,err,error,*999)

    CALL EXITS("CMISSDataProjection_MaximumNumberOfIterationsGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_MaximumNumberOfIterationsGetObj",err,error)
    CALL EXITS("CMISSDataProjection_MaximumNumberOfIterationsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_MaximumNumberOfIterationsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_MaximumNumberOfIterationsSetNumber(dataProjectionUserNumber,regionUserNumber, &
      & maximumNumberOfIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumNumberOfIterations !<the maximum number of iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    CALL ENTERS("CMISSDataProjection_MaximumNumberOfIterationsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,ERROR,*999)
      CALL DATA_PROJECTION_MAXIMUM_NUMBER_OF_ITERATIONS_SET(DATA_PROJECTION,maximumNumberOfIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_MaximumNumberOfIterationsSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_MaximumNumberOfIterationsSetNumber",err,error)
    CALL EXITS("CMISSDataProjection_MaximumNumberOfIterationsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_MaximumNumberOfIterationsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations of data projection identified an object.
  SUBROUTINE CMISSDataProjection_MaximumNumberOfIterationsSetObj(dataProjection,maximumNumberOfIterations,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumNumberOfIterations !<the maximum number of iterations to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_MaximumNumberOfIterationsSetObj",err,error,*999)

    CALL DATA_PROJECTION_MAXIMUM_NUMBER_OF_ITERATIONS_SET(dataProjection%DATA_PROJECTION,maximumNumberOfIterations,err,error,*999)

    CALL EXITS("CMISSDataProjection_MaximumNumberOfIterationsSetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_MaximumNumberOfIterationsSetObj",err,error)
    CALL EXITS("CMISSDataProjection_MaximumNumberOfIterationsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_MaximumNumberOfIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of closest elements of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_NumberOfClosestElementsGetNumber(dataProjectionUserNumber,regionUserNumber, &
      & numberOfClosestElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get number of closest elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfClosestElements !<On exit, the number of closest elements of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    CALL ENTERS("CMISSDataProjection_NumberOfClosestElementsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,ERROR,*999)
      CALL DATA_PROJECTION_NUMBER_OF_CLOSEST_ELEMENTS_GET(DATA_PROJECTION,numberOfClosestElements,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_NumberOfClosestElementsGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_NumberOfClosestElementsGetNumber",err,error)
    CALL EXITS("CMISSDataProjection_NumberOfClosestElementsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_NumberOfClosestElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of closest elements of data projection identified an object.
  SUBROUTINE CMISSDataProjection_NumberOfClosestElementsGetObj(dataProjection,numberOfClosestElements,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get number of closest elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfClosestElements !<On exit, the number of closest elements of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_NumberOfClosestElementsGetObj",err,error,*999)

    CALL DATA_PROJECTION_NUMBER_OF_CLOSEST_ELEMENTS_GET(dataProjection%DATA_PROJECTION,numberOfClosestElements,err,error,*999)

    CALL EXITS("CMISSDataProjection_NumberOfClosestElementsGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_NumberOfClosestElementsGetObj",err,error)
    CALL EXITS("CMISSDataProjection_NumberOfClosestElementsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_NumberOfClosestElementsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of closest elements of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_NumberOfClosestElementsSetNumber(dataProjectionUserNumber,regionUserNumber, &
      & numberOfClosestElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set number of closest elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfClosestElements !<the number of closest elements to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    CALL ENTERS("CMISSDataProjection_NumberOfClosestElementsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,ERROR,*999)
      CALL DATA_PROJECTION_NUMBER_OF_CLOSEST_ELEMENTS_SET(DATA_PROJECTION,numberOfClosestElements,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_NumberOfClosestElementsSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_NumberOfClosestElementsSetNumber",err,error)
    CALL EXITS("CMISSDataProjection_NumberOfClosestElementsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_NumberOfClosestElementsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of closest elements of data projection identified an object.
  SUBROUTINE CMISSDataProjection_NumberOfClosestElementsSetObj(dataProjection,numberOfClosestElements,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set number of closest elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfClosestElements !<the number of closest elements to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_NumberOfClosestElementsSetObj",err,error,*999)

    CALL DATA_PROJECTION_NUMBER_OF_CLOSEST_ELEMENTS_SET(dataProjection%DATA_PROJECTION,numberOfClosestElements,err,error,*999)

    CALL EXITS("CMISSDataProjection_NumberOfClosestElementsSetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_NumberOfClosestElementsSetObj",err,error)
    CALL EXITS("CMISSDataProjection_NumberOfClosestElementsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_NumberOfClosestElementsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the projection type of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_ProjectionTypeGetNumber(dataProjectionUserNumber,regionUserNumber,projectionType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get projection type for.
    INTEGER(INTG), INTENT(OUT) :: projectionType !<On exit, the projection type of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    CALL ENTERS("CMISSDataProjection_ProjectionTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,ERROR,*999)
      CALL DATA_PROJECTION_PROJECTION_TYPE_GET(DATA_PROJECTION,projectionType,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_ProjectionTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ProjectionTypeGetNumber",err,error)
    CALL EXITS("CMISSDataProjection_ProjectionTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ProjectionTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the projection type of data projection identified an object.
  SUBROUTINE CMISSDataProjection_ProjectionTypeGetObj(dataProjection,projectionType,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get projection type for.
    INTEGER(INTG), INTENT(OUT) :: projectionType !<On exit, the projection type of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_ProjectionTypeGetObj",err,error,*999)

    CALL DATA_PROJECTION_PROJECTION_TYPE_GET(dataProjection%DATA_PROJECTION,projectionType,err,error,*999)

    CALL EXITS("CMISSDataProjection_ProjectionTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ProjectionTypeGetObj",err,error)
    CALL EXITS("CMISSDataProjection_ProjectionTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ProjectionTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the projection type of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_ProjectionTypeSetNumber(dataProjectionUserNumber,regionUserNumber,projectionType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set projection type for.
    INTEGER(INTG), INTENT(IN) :: projectionType !<the projection type to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    CALL ENTERS("CMISSDataProjection_ProjectionTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,ERROR,*999)
      CALL DATA_PROJECTION_PROJECTION_TYPE_SET(DATA_PROJECTION,projectionType,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_ProjectionTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ProjectionTypeSetNumber",err,error)
    CALL EXITS("CMISSDataProjection_ProjectionTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ProjectionTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the projection type of data projection identified an object.
  SUBROUTINE CMISSDataProjection_ProjectionTypeSetObj(dataProjection,projectionType,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set projection type for.
    INTEGER(INTG), INTENT(IN) :: projectionType !<the projection type to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_ProjectionTypeSetObj",err,error,*999)

    CALL DATA_PROJECTION_PROJECTION_TYPE_SET(dataProjection%DATA_PROJECTION,projectionType,err,error,*999)

    CALL EXITS("CMISSDataProjection_ProjectionTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ProjectionTypeSetObj",err,error)
    CALL EXITS("CMISSDataProjection_ProjectionTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ProjectionTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified by a data projection user number and a region user number.
  SUBROUTINE CMISSDataProjection_RelativeToleranceGetNumber(dataProjectionUserNumber,regionUserNumber,relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get relative tolerance for.
    REAL(DP), INTENT(OUT) :: relativeTolerance !<On exit, the absolute relative tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    CALL ENTERS("CMISSDataProjection_RelativeToleranceGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,ERROR,*999)
      CALL DATA_PROJECTION_RELATIVE_TOLERANCE_GET(DATA_PROJECTION,relativeTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_RelativeToleranceGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_RelativeToleranceGetNumber",err,error)
    CALL EXITS("CMISSDataProjection_RelativeToleranceGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_RelativeToleranceGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the relative tolerance of data projection identified an object.
  SUBROUTINE CMISSDataProjection_RelativeToleranceGetObj(dataProjection,relativeTolerance,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get relative tolerance for.
    REAL(DP), INTENT(OUT) :: relativeTolerance !<On exit, the absolute relative tolerance of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_RelativeToleranceGetObj",err,error,*999)

    CALL DATA_PROJECTION_RELATIVE_TOLERANCE_GET(dataProjection%DATA_PROJECTION,relativeTolerance,err,error,*999)

    CALL EXITS("CMISSDataProjection_RelativeToleranceGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_RelativeToleranceGetObj",err,error)
    CALL EXITS("CMISSDataProjection_RelativeToleranceGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_RelativeToleranceGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified by a data projection user number and a region user number.
  SUBROUTINE CMISSDataProjection_RelativeToleranceSetNumber(dataProjectionUserNumber,regionUserNumber,relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<the absolute relative tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    CALL ENTERS("CMISSDataProjection_RelativeToleranceSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,ERROR,*999)
      CALL DATA_PROJECTION_RELATIVE_TOLERANCE_SET(DATA_PROJECTION,relativeTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_RelativeToleranceSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_RelativeToleranceSetNumber",err,error)
    CALL EXITS("CMISSDataProjection_RelativeToleranceSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_RelativeToleranceSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance of data projection identified an object.
  SUBROUTINE CMISSDataProjection_RelativeToleranceSetObj(dataProjection,relativeTolerance,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<the absolute relative tolerance to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_RelativeToleranceSetObj",err,error,*999)

    CALL DATA_PROJECTION_RELATIVE_TOLERANCE_SET(dataProjection%DATA_PROJECTION,relativeTolerance,err,error,*999)

    CALL EXITS("CMISSDataProjection_RelativeToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_RelativeToleranceSetObj",err,error)
    CALL EXITS("CMISSDataProjection_RelativeToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_RelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Returns the starting xi of data projection identified by a data projection user number and region user number.
  SUBROUTINE CMISSDataProjection_StartingXiGetNumber(dataProjectionUserNumber,regionUserNumber,startingXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of the data projection to get starting xi for.
    REAL(DP), INTENT(OUT) :: startingXi(:) !<On exit, the absolute starting xi of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<The data projection global number.

    CALL ENTERS("CMISSDataProjection_StartingXiGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,ERROR,*999)
      CALL DATA_PROJECTION_STARTING_XI_GET(DATA_PROJECTION,startingXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_StartingXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_StartingXiGetNumber",err,error)
    CALL EXITS("CMISSDataProjection_StartingXiGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_StartingXiGetNumber


  !
  !================================================================================================================================
  !

  !>Returns the starting xi of data projection identified an object.
  SUBROUTINE CMISSDataProjection_StartingXiGetObj(dataProjection,startingXi,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get starting xi for.
    REAL(DP), INTENT(OUT) :: startingXi(:) !<On exit, the absolute starting xi of the specified data projection
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_StartingXiGetObj",err,error,*999)

    CALL DATA_PROJECTION_STARTING_XI_GET(dataProjection%DATA_PROJECTION,startingXi,err,error,*999)

    CALL EXITS("CMISSDataProjection_StartingXiGetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_StartingXiGetObj",err,error)
    CALL EXITS("CMISSDataProjection_StartingXiGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_StartingXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_StartingXiSetNumber(dataProjectionUserNumber,regionUserNumber,startingXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region use number of data projection to set starting xi for.
    REAL(DP), INTENT(IN) :: startingXi(:) !<the absolute starting xi to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<data projection global number

    CALL ENTERS("CMISSDataProjection_StartingXiSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,err,ERROR,*999)
      CALL DATA_PROJECTION_STARTING_XI_SET(DATA_PROJECTION,startingXi,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_StartingXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_StartingXiSetNumber",err,error)
    CALL EXITS("CMISSDataProjection_StartingXiSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_StartingXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified an object.
  SUBROUTINE CMISSDataProjection_StartingXiSetObj(dataProjection,startingXi,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set starting xi for.
    REAL(DP), INTENT(IN) :: startingXi(:) !<the absolute starting xi to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_StartingXiSetObj",err,error,*999)

    CALL DATA_PROJECTION_STARTING_XI_SET(dataProjection%DATA_PROJECTION,startingXi,err,error,*999)

    CALL EXITS("CMISSDataProjection_StartingXiSetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_StartingXiSetObj",err,error)
    CALL EXITS("CMISSDataProjection_StartingXiSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_StartingXiSetObj
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_ElementSetInterfaceNumber(dataProjectionUserNumber,parentRegionUserNumber,interfaceUserNumber, &
      & dataPointNumber,elementNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The data point number to set xi position for
    INTEGER(INTG), INTENT(IN) :: elementNumber !<the element number to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<data projection global number

    CALL ENTERS("CMISSDataProjection_ElementSetInterfaceNumber",ERR,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,Err,ERROR,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,Err,ERROR,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_DATA_POINTS_GET(INTERFACE,DATA_POINTS,err,error,*999)
        CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,Err,ERROR,*999)
        CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,Err,ERROR,*999)
        CALL DATA_PROJECTION_ELEMENT_SET(DATA_PROJECTION,dataPointNumber,elementNumber,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",Err,ERROR))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentregionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDataProjection_ElementSetInterfaceNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ElementSetInterfaceNumber",err,error)
    CALL EXITS("CMISSDataProjection_ElementSetInterfaceNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ElementSetInterfaceNumber
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_ElementSetRegionNumber(dataProjectionUserNumber,regionUserNumber,dataPointNumber,elementNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get starting xi for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to set starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The data point number to set xi position for
    INTEGER(INTG), INTENT(IN) :: elementNumber !<the element number to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: GLOBAL_NUMBER !<data projection global number

    CALL ENTERS("CMISSDataProjection_ElementSetRegionNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_POINTS)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,DataProjectionUserNumber,GLOBAL_NUMBER,Err,ERROR,*999)
      CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,GLOBAL_NUMBER,DATA_PROJECTION,Err,ERROR,*999)
      CALL DATA_PROJECTION_ELEMENT_SET(DATA_PROJECTION,dataPointNumber,elementNumber,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_ElementSetRegionNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ElementSetRegionNumber",err,error)
    CALL EXITS("CMISSDataProjection_ElementSetRegionNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ElementSetRegionNumber
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the starting xi of data projection identified an object.
  SUBROUTINE CMISSDataProjection_ElementSetObj(dataProjection,dataPointNumber,elementNumber,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set starting xi for.
    INTEGER(INTG), INTENT(IN) :: dataPointNumber !<The data point number to set xi position for
    INTEGER(INTG), INTENT(IN) :: elementNumber !<the element number to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_ElementSetObj",err,error,*999)

    CALL DATA_PROJECTION_ELEMENT_SET(dataProjection%DATA_PROJECTION,dataPointNumber,elementNumber,err,error,*999)

    CALL EXITS("CMISSDataProjection_ElementSetObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_ElementSetObj",err,error)
    CALL EXITS("CMISSDataProjection_ElementSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_ElementSetObj

  !
  !================================================================================================================================
  !

  !>Get the character string label of a data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_LabelGetCInterfaceNumber(dataProjectionUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get the label for.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjection_LabelGetCInterfaceNumber",ERR,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,Err,ERROR,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,Err,ERROR,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL DATA_PROJECTION_LABEL_GET(DATA_PROJECTION,label,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",Err,ERROR))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentregionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDataProjection_LabelGetCInterfaceNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_LabelGetCInterfaceNumber",err,error)
    CALL EXITS("CMISSDataProjection_LabelGetCInterfaceNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_LabelGetCInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Get the varying string label of a data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_LabelGetVSInterfaceNumber(dataProjectionUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get the label for.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjection_LabelGetVSInterfaceNumber",ERR,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,Err,ERROR,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,Err,ERROR,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL DATA_PROJECTION_LABEL_GET(DATA_PROJECTION,label,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",Err,ERROR))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentregionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDataProjection_LabelGetVSInterfaceNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_LabelGetVSInterfaceNumber",err,error)
    CALL EXITS("CMISSDataProjection_LabelGetVSInterfaceNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_LabelGetVSInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Get the character string label of a data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_LabelGetCRegionNumber(dataProjectionUserNumber,regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get the label for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjection_LabelGetCRegionNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL DATA_PROJECTION_LABEL_GET(DATA_PROJECTION,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_LabelGetRegionNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_LabelGetCRegionNumber",err,error)
    CALL EXITS("CMISSDataProjection_LabelGetCRegionNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_LabelGetCRegionNumber

  !
  !================================================================================================================================
  !

  !>Get the varying string label of a data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_LabelGetVSRegionNumber(dataProjectionUserNumber,regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to get the label for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjection_LabelGetVSRegionNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL DATA_PROJECTION_LABEL_GET(DATA_PROJECTION,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_LabelGetVSRegionNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_LabelGetVSRegionNumber",err,error)
    CALL EXITS("CMISSDataProjection_LabelGetVSRegionNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_LabelGetVSRegionNumber

  !
  !================================================================================================================================
  !

  !>Gets the character string label of a data projection identified an object.
  SUBROUTINE CMISSDataProjection_LabelGetCObj(dataProjection,label,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_LabelGetCObj",err,error,*999)

    CALL DATA_PROJECTION_LABEL_GET(dataProjection%DATA_PROJECTION,label,err,error,*999)

    CALL EXITS("CMISSDataProjection_LabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_LabelGetCObj",err,error)
    CALL EXITS("CMISSDataProjection_LabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Gets the varying string label of a data projection identified an object.
  SUBROUTINE CMISSDataProjection_LabelGetVSObj(dataProjection,label,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<the label to get
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_LabelGetVSObj",err,error,*999)

    CALL DATA_PROJECTION_LABEL_GET(dataProjection%DATA_PROJECTION,label,err,error,*999)

    CALL EXITS("CMISSDataProjection_LabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_LabelGetVSObj",err,error)
    CALL EXITS("CMISSDataProjection_LabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label of a data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_LabelSetCInterfaceNumber(dataProjectionUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to set the label for.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    CHARACTER(LEN=*), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjection_LabelSetCInterfaceNumber",ERR,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,Err,ERROR,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,Err,ERROR,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL DATA_PROJECTION_LABEL_SET(DATA_PROJECTION,label,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",Err,ERROR))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentregionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDataProjection_LabelSetCInterfaceNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_LabelSetCInterfaceNumber",err,error)
    CALL EXITS("CMISSDataProjection_LabelSetCInterfaceNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_LabelSetCInterfaceNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label of a data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_LabelSetVSInterfaceNumber(dataProjectionUserNumber,parentRegionUserNumber,interfaceUserNumber, &
    & label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to set the label for.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjection_LabelSetVSInterfaceNumber",ERR,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,Err,ERROR,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,Err,ERROR,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL DATA_PROJECTION_LABEL_SET(DATA_PROJECTION,label,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",Err,ERROR))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentregionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSDataProjection_LabelSetVSInterfaceNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_LabelSetVSInterfaceNumber",err,error)
    CALL EXITS("CMISSDataProjection_LabelSetVSInterfaceNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_LabelSetVSInterfaceNumber
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label of a data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_LabelSetCRegionNumber(dataProjectionUserNumber,regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to set the label for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjection_LabelSetCRegionNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL DATA_PROJECTION_LABEL_SET(DATA_PROJECTION,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_LabelSetRegionNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_LabelSetCRegionNumber",err,error)
    CALL EXITS("CMISSDataProjection_LabelSetCRegionNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_LabelSetCRegionNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label of a data projection identified by a region user number.
  SUBROUTINE CMISSDataProjection_LabelSetVSRegionNumber(dataProjectionUserNumber,regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to set the label for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number of data projection to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDataProjection_LabelSetVSRegionNumber",ERR,error,*999)

    NULLIFY(REGION)
    NULLIFY(DATA_PROJECTION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL DATA_PROJECTION_LABEL_SET(DATA_PROJECTION,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDataProjection_LabelSetVSRegionNumber")
    RETURN
999 CALL ERRORS("CMISSDataProjection_LabelSetVSRegionNumber",err,error)
    CALL EXITS("CMISSDataProjection_LabelSetVSRegionNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_LabelSetVSRegionNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label of a data projection identified an object.
  SUBROUTINE CMISSDataProjection_LabelSetCObj(dataProjection,label,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_LabelSetCObj",err,error,*999)

    CALL DATA_PROJECTION_LABEL_SET(dataProjection%DATA_PROJECTION,label,err,error,*999)

    CALL EXITS("CMISSDataProjection_LabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_LabelSetCObj",err,error)
    CALL EXITS("CMISSDataProjection_LabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label of a data projection identified an object.
  SUBROUTINE CMISSDataProjection_LabelSetVSObj(dataProjection,label,err)

    !Argument variables
    TYPE(CMISSDataProjectionType), INTENT(INOUT) :: dataProjection !<The data projection to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<the label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDataProjection_LabelSetVSObj",err,error,*999)

    CALL DATA_PROJECTION_LABEL_SET(dataProjection%DATA_PROJECTION,label,err,error,*999)

    CALL EXITS("CMISSDataProjection_LabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSDataProjection_LabelSetVSObj",err,error)
    CALL EXITS("CMISSDataProjection_LabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDataProjection_LabelSetVSObj

!!==================================================================================================================================
!!
!! EQUATIONS_ROUTINES
!!
!!==================================================================================================================================

  !>Destroys equations for equations identified by a user number.
  SUBROUTINE CMISSEquations_DestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to destroy.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquations_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_DESTROY(EQUATIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquations_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquations_DestroyNumber",err,error)
    CALL EXITS("CMISSEquations_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy equations for equations identified by an object.
  SUBROUTINE CMISSEquations_DestroyObj(equations,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(INOUT) :: equations !<The equations to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquations_DestroyObj",err,error,*999)

    CALL EQUATIONS_DESTROY(equations%EQUATIONS,err,error,*999)

    CALL EXITS("CMISSEquations_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquations_DestroyObj",err,error)
    CALL EXITS("CMISSEquations_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_DestroyObj

  !
  !================================================================================================================================
  !

  !>Gets the linearity type for equations identified by a user number.
  SUBROUTINE CMISSEquations_LinearityTypeGetNumber(regionUserNumber,equationsSetUserNumber,linearityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the linearity type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the linearity type of the equations \see OPENCMISS_EquationsLinearityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquations_LinearityTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_LINEARITY_TYPE_GET(EQUATIONS,linearityType,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquations_LinearityTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquations_LinearityTypeGetNumber",err,error)
    CALL EXITS("CMISSEquations_LinearityTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_LinearityTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the linearity type for equations identified by an object.
  SUBROUTINE CMISSEquations_LinearityTypeGetObj(equations,linearityType,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the linearity type of the equations \see OPENCMISS_EquationsLinearityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquations_LinearityTypeGetObj",err,error,*999)

    CALL EQUATIONS_LINEARITY_TYPE_GET(equations%EQUATIONS,linearityType,err,error,*999)

    CALL EXITS("CMISSEquations_LinearityTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSEquations_LinearityTypeGetObj",err,error)
    CALL EXITS("CMISSEquations_LinearityTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_LinearityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Gets the lumping type for equations identified by a user number.
  SUBROUTINE CMISSEquations_LumpingTypeGetNumber(regionUserNumber,equationsSetUserNumber,lumpingType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the lumping type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the lumping type for.
    INTEGER(INTG), INTENT(OUT) :: lumpingType !<On return, the lumping type of the equations \see OPENCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquations_LumpingTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_LUMPING_TYPE_GET(EQUATIONS,lumpingType,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquations_LumpingTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquations_LumpingTypeGetNumber",err,error)
    CALL EXITS("CMISSEquations_LumpingTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_LumpingTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the lumping type for equations identified by an object.
  SUBROUTINE CMISSEquations_LumpingTypeGetObj(equations,lumpingType,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the lumping type for.
    INTEGER(INTG), INTENT(OUT) :: lumpingType !<On return, the lumping type of the equations \see OPENCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquations_LumpingTypeGetObj",err,error,*999)

    CALL EQUATIONS_LUMPING_TYPE_GET(equations%EQUATIONS,lumpingType,err,error,*999)

    CALL EXITS("CMISSEquations_LumpingTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSEquations_LumpingTypeGetObj",err,error)
    CALL EXITS("CMISSEquations_LumpingTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_LumpingTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the lumping type for equations identified by a user number.
  SUBROUTINE CMISSEquations_LumpingTypeSetNumber(regionUserNumber,equationsSetUserNumber,lumpingType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: lumpingType !<The lumping type of the equations to set\see OPENCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquations_LumpingTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_LUMPING_TYPE_SET(EQUATIONS,lumpingType,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquations_LumpingTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquations_LumpingTypeSetNumber",err,error)
    CALL EXITS("CMISSEquations_LumpingTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_LumpingTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the lumping type for equations identified by an object.
  SUBROUTINE CMISSEquations_LumpingTypeSetObj(equations,lumpingType,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(INOUT) :: equations !<The equations to set the lumping type for.
    INTEGER(INTG), INTENT(IN) :: lumpingType !<The lumping type of the equations to set\see OPENCMISS_EquationsLumpingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquations_LumpingTypeSetObj",err,error,*999)

    CALL EQUATIONS_LUMPING_TYPE_SET(equations%EQUATIONS,lumpingType,err,error,*999)

    CALL EXITS("CMISSEquations_LumpingTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSEquations_LumpingTypeSetObj",err,error)
    CALL EXITS("CMISSEquations_LumpingTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_LumpingTypeSetObj

  !
  !================================================================================================================================
  !

  !>Gets the output type for equations identified by a user number.
  SUBROUTINE CMISSEquations_OutputTypeGetNumber(regionUserNumber,equationsSetUserNumber,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the output type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the equations \see OPENCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquations_OutputTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_OUTPUT_TYPE_GET(EQUATIONS,outputType,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquations_OutputTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquations_OutputTypeGetNumber",err,error)
    CALL EXITS("CMISSEquations_OutputTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_OutputTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the output type for equations identified by an object.
  SUBROUTINE CMISSEquations_OutputTypeGetObj(equations,outputType,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the output type of the equations \see OPENCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquations_OutputTypeGetObj",err,error,*999)

    CALL EQUATIONS_OUTPUT_TYPE_GET(equations%EQUATIONS,outputType,err,error,*999)

    CALL EXITS("CMISSEquations_OutputTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSEquations_OutputTypeGetObj",err,error)
    CALL EXITS("CMISSEquations_OutputTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for equations identified by a user number.
  SUBROUTINE CMISSEquations_OutputTypeSetNumber(regionUserNumber,equationsSetUserNumber,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the equations to set \see OPENCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquations_OutputTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_OUTPUT_TYPE_SET(EQUATIONS,outputType,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquations_OutputTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquations_OutputTypeSetNumber",err,error)
    CALL EXITS("CMISSEquations_OutputTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_OutputTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for equations identified by an object.
  SUBROUTINE CMISSEquations_OutputTypeSetObj(equations,outputType,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(INOUT) :: equations !<The equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The output type of the equations to set \see OPENCMISS_EquationsOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquations_OutputTypeSetObj",err,error,*999)

    CALL EQUATIONS_OUTPUT_TYPE_SET(equations%EQUATIONS,outputType,err,error,*999)

    CALL EXITS("CMISSEquations_OutputTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSEquations_OutputTypeSetObj",err,error)
    CALL EXITS("CMISSEquations_OutputTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for equations identified by a user number.
  SUBROUTINE CMISSEquations_SparsityTypeGetNumber(regionUserNumber,equationsSetUserNumber,sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the sparsity type of the equations \see OPENCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquations_SparsityTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_SPARSITY_TYPE_GET(EQUATIONS,sparsityType,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquations_SparsityTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquations_SparsityTypeGetNumber",err,error)
    CALL EXITS("CMISSEquations_SparsityTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_SparsityTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for equations identified by an object.
  SUBROUTINE CMISSEquations_SparsityTypeGetObj(equations,sparsityType,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the sparsity type of the equations \see OPENCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquations_SparsityTypeGetObj",err,error,*999)

    CALL EQUATIONS_SPARSITY_TYPE_GET(equations%EQUATIONS,sparsityType,err,error,*999)

    CALL EXITS("CMISSEquations_SparsityTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSEquations_SparsityTypeGetObj",err,error)
    CALL EXITS("CMISSEquations_SparsityTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_SparsityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for equations identified by a user number.
  SUBROUTINE CMISSEquations_SparsityTypeSetNumber(regionUserNumber,equationsSetUserNumber,sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type of the equations to set \see OPENCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquations_SparsityTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_SPARSITY_TYPE_SET(EQUATIONS,sparsityType,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquations_SparsityTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquations_SparsityTypeSetNumber",err,error)
    CALL EXITS("CMISSEquations_SparsityTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_SparsityTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for equations identified by an object.
  SUBROUTINE CMISSEquations_SparsityTypeSetObj(equations,sparsityType,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(INOUT) :: equations !<The equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type of the equations to set \see OPENCMISS_EquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquations_SparsityTypeSetObj",err,error,*999)

    CALL EQUATIONS_SPARSITY_TYPE_SET(equations%EQUATIONS,sparsityType,err,error,*999)

    CALL EXITS("CMISSEquations_SparsityTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSEquations_SparsityTypeSetObj",err,error)
    CALL EXITS("CMISSEquations_SparsityTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_SparsityTypeSetObj

  !
  !================================================================================================================================
  !

  !>Gets the time dependence type for equations identified by a user number.
  SUBROUTINE CMISSEquations_TimeDependenceTypeGetNumber(regionUserNumber,equationsSetUserNumber,timeDependenceType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations to get the time dependence type for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the time dependence type of the equations \see OPENCMISS_EquationsTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquations_TimeDependenceTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_GET(EQUATIONS_SET,EQUATIONS,ERR,error,*999)
        CALL EQUATIONS_TIME_DEPENDENCE_TYPE_GET(EQUATIONS,timeDependenceType,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquations_TimeDependenceTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquations_TimeDependenceTypeGetNumber",err,error)
    CALL EXITS("CMISSEquations_TimeDependenceTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_TimeDependenceTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the time dependence type for equations identified by an object.
  SUBROUTINE CMISSEquations_TimeDependenceTypeGetObj(equations,timeDependenceType,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the time dependence type for.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceType !<On return, the time dependence type of the equations \see OPENCMISS_EquationsTimeDependenceTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquations_TimeDependenceTypeGetObj",err,error,*999)

    CALL EQUATIONS_TIME_DEPENDENCE_TYPE_GET(equations%EQUATIONS,timeDependenceType,err,error,*999)

    CALL EXITS("CMISSEquations_TimeDependenceTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSEquations_TimeDependenceTypeGetObj",err,error)
    CALL EXITS("CMISSEquations_TimeDependenceTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_TimeDependenceTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get the number of linear matrices in the equations
  SUBROUTINE CMISSEquations_NumberOfLinearMatricesGet(equations,numberOfMatrices,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the number of linear matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of linear matrices
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSEquations_NumberOfLinearMatricesGet",err,error,*999)

    CALL Equations_NumberOfLinearMatricesGet(equations%equations,numberOfMatrices,err,error,*999)

    CALL Exits("CMISSEquations_NumberOfLinearMatricesGet")
    RETURN
999 CALL Errors("CMISSEquations_NumberOfLinearMatricesGet",err,error)
    CALL Exits("CMISSEquations_NumberOfLinearMatricesGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_NumberOfLinearMatricesGet

  !
  !================================================================================================================================
  !

  !>Get the number of Jacobian matrices in the equations
  SUBROUTINE CMISSEquations_NumberOfJacobianMatricesGet(equations,numberOfMatrices,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the number of Jacobian matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of Jacobian matrices
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSEquations_NumberOfLinearMatricesGet",err,error,*999)

    CALL Equations_NumberOfJacobianMatricesGet(equations%equations,numberOfMatrices,err,error,*999)

    CALL Exits("CMISSEquations_NumberOfJacobianMatricesGet")
    RETURN
999 CALL Errors("CMISSEquations_NumberOfJacobianMatricesGet",err,error)
    CALL Exits("CMISSEquations_NumberOfJacobianMatricesGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_NumberOfJacobianMatricesGet

  !
  !================================================================================================================================
  !

  !>Get the number of dynamic matrices in the equations
  SUBROUTINE CMISSEquations_NumberOfDynamicMatricesGet(equations,numberOfMatrices,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the number of dynamic matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of dynamic matrices
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSEquations_NumberOfDynamicMatricesGet",err,error,*999)

    CALL Equations_NumberOfDynamicMatricesGet(equations%equations,numberOfMatrices,err,error,*999)

    CALL Exits("CMISSEquations_NumberOfDynamicMatricesGet")
    RETURN
999 CALL Errors("CMISSEquations_NumberOfDynamicMatricesGet",err,error)
    CALL Exits("CMISSEquations_NumberOfDynamicMatricesGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_NumberOfDynamicMatricesGet

  !
  !================================================================================================================================
  !

  !>Get a linear equations matrix from the equations
  SUBROUTINE CMISSEquations_LinearMatrixGet(equations,matrixIndex,matrix,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the linear matrix for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The number of the linear matrix to get
    TYPE(CMISSDistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested linear matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSEquations_LinearMatrixGet",err,error,*999)

    CALL Equations_LinearMatrixGet(equations%equations,matrixIndex,matrix%distributedMatrix,err,error,*999)

    CALL Exits("CMISSEquations_LinearMatrixGet")
    RETURN
999 CALL Errors("CMISSEquations_LinearMatrixGet",err,error)
    CALL Exits("CMISSEquations_LinearMatrixGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_LinearMatrixGet

  !
  !================================================================================================================================
  !

  !>Get a Jacobian matrix from the equations
  SUBROUTINE CMISSEquations_JacobianMatrixGet(equations,residualIndex,variableType,matrix,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the Jacobian matrix for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get the Jacobian matrix for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type that the residual is differentiated with respect to for this Jacobian. \see OPENCMISS_FieldVariableTypes
    TYPE(CMISSDistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested Jacobian matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSEquations_JacobianMatrixGet",err,error,*999)

    CALL Equations_JacobianMatrixGet(equations%equations, &
      & residualIndex,variableType,matrix%distributedMatrix,err,error,*999)

    CALL Exits("CMISSEquations_JacobianMatrixGet")
    RETURN
999 CALL Errors("CMISSEquations_JacobianMatrixGet",err,error)
    CALL Exits("CMISSEquations_JacobianMatrixGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_JacobianMatrixGet

  !
  !================================================================================================================================
  !

  !>Get a dynamic equations matrix from equations using the dynamic matrix index
  SUBROUTINE CMISSEquations_DynamicMatrixGet(equations,matrixIndex,matrix,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the dynamic matrix for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The number of the dynamic matrix to get
    TYPE(CMISSDistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested dynamic matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSEquations_DynamicMatrixGet",err,error,*999)

    CALL Equations_DynamicMatrixGet(equations%equations,matrixIndex,matrix%distributedMatrix,err,error,*999)

    CALL Exits("CMISSEquations_DynamicMatrixGet")
    RETURN
999 CALL Errors("CMISSEquations_DynamicMatrixGet",err,error)
    CALL Exits("CMISSEquations_DynamicMatrixGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_DynamicMatrixGet

  !
  !================================================================================================================================
  !

  !>Get a dynamic equations matrix from equations using the dynamic matrix type
  SUBROUTINE CMISSEquations_DynamicMatrixGetByType(equations,matrixType,matrix,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the dynamic matrix for
    INTEGER(INTG), INTENT(IN) :: matrixType !<The type of the dynamic matrix to get. \see OPENCMISS_EquationsSetDynamicMatrixTypes
    TYPE(CMISSDistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested dynamic matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSEquations_DynamicMatrixGetByType",err,error,*999)

    CALL Equations_DynamicMatrixGetByType(equations%equations,matrixType,matrix%distributedMatrix,err,error,*999)

    CALL Exits("CMISSEquations_DynamicMatrixGetByType")
    RETURN
999 CALL Errors("CMISSEquations_DynamicMatrixGetByType",err,error)
    CALL Exits("CMISSEquations_DynamicMatrixGetByType")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_DynamicMatrixGetByType

  !
  !================================================================================================================================
  !

  !>Get the type of a dynamic matrix from equations set equations
  SUBROUTINE CMISSEquations_DynamicMatrixTypeGet(equations,matrixIndex,matrixType,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the dynamic matrix type from
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The number of the dynamic matrix to get the type of
    INTEGER(INTG), INTENT(OUT) :: matrixType !<On return, the dynamic matrix type. \see OPENCMISS_EquationsSetDynamicMatrixTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSEquations_DynamicMatrixTypeGet",err,error,*999)

    CALL Equations_DynamicMatrixTypeGet(equations%equations,matrixIndex,matrixType,err,error,*999)

    CALL Exits("CMISSEquations_DynamicMatrixTypeGet")
    RETURN
999 CALL Errors("CMISSEquations_DynamicMatrixTypeGet",err,error)
    CALL Exits("CMISSEquations_DynamicMatrixTypeGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_DynamicMatrixTypeGet

  !
  !================================================================================================================================
  !

  !>Get the right hand side vector for equations
  SUBROUTINE CMISSEquations_RhsVectorGet(equations,rhsVector,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the right hand side vector for
    TYPE(CMISSDistributedVectorType), INTENT(INOUT) :: rhsVector !<On return, the right hand side vector for the equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSEquations_RhsVectorGet",err,error,*999)

    CALL Equations_RhsVectorGet(equations%equations,rhsVector%distributedVector,err,error,*999)

    CALL Exits("CMISSEquations_RhsVectorGet")
    RETURN
999 CALL Errors("CMISSEquations_RhsVectorGet",err,error)
    CALL Exits("CMISSEquations_RhsVectorGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_RhsVectorGet

  !
  !================================================================================================================================
  !

  !>Get the source vector for equations
  SUBROUTINE CMISSEquations_SourceVectorGet(equations,sourceVector,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the source vector for
    TYPE(CMISSDistributedVectorType), INTENT(INOUT) :: sourceVector !<On return, the source vector for the equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSEquations_SourceVectorGet",err,error,*999)

    CALL Equations_SourceVectorGet(equations%equations,sourceVector%distributedVector,err,error,*999)

    CALL Exits("CMISSEquations_SourceVectorGet")
    RETURN
999 CALL Errors("CMISSEquations_SourceVectorGet",err,error)
    CALL Exits("CMISSEquations_SourceVectorGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_SourceVectorGet

  !
  !================================================================================================================================
  !

  !>Get a residual vector for equations
  SUBROUTINE CMISSEquations_ResidualVectorGet(equations,residualIndex,residualVector,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the residual vector for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get
    TYPE(CMISSDistributedVectorType), INTENT(INOUT) :: residualVector !<On return, the residual vector for the equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSEquations_ResidualVectorGet",err,error,*999)

    CALL Equations_ResidualVectorGet(equations%equations,residualIndex,residualVector%distributedVector,err,error,*999)

    CALL Exits("CMISSEquations_ResidualVectorGet")
    RETURN
999 CALL Errors("CMISSEquations_ResidualVectorGet",err,error)
    CALL Exits("CMISSEquations_ResidualVectorGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_ResidualVectorGet

  !
  !================================================================================================================================
  !

  !>Get the number of field variables that contribute to the residual vector
  SUBROUTINE CMISSEquations_ResidualNumberOfVariablesGet(equations,residualIndex,numberOfVariables,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the residual vector number of variables for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get the number of variables for
    INTEGER(INTG), INTENT(OUT) :: numberOfVariables !<On return, the number of variables that contribute to the residual vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSEquations_ResidualNumberOfVariablesGet",err,error,*999)

    CALL Equations_ResidualNumberOfVariablesGet(equations%equations,residualIndex,numberOfVariables,err,error,*999)

    CALL Exits("CMISSEquations_ResidualNumberOfVariablesGet")
    RETURN
999 CALL Errors("CMISSEquations_ResidualNumberOfVariablesGet",err,error)
    CALL Exits("CMISSEquations_ResidualNumberOfVariablesGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_ResidualNumberOfVariablesGet

  !
  !================================================================================================================================
  !

  !>Get the field variables that contribute to the residual vector
  SUBROUTINE CMISSEquations_ResidualVariablesGet(equations,residualIndex,residualVariables,err)

    !Argument variables
    TYPE(CMISSEquationsType), INTENT(IN) :: equations !<The equations to get the residual vector variables for
    INTEGER(INTG), INTENT(IN) :: residualIndex !<The index of the residual vector to get the variables for
    INTEGER(INTG), INTENT(OUT) :: residualVariables(:) !<residualVariables(varIdx). On return, the field variable type for the varIdx'th residual variable. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSEquations_ResidualVariablesGet",err,error,*999)

    CALL Equations_ResidualVariablesGet(equations%equations,residualIndex,residualVariables,err,error,*999)

    CALL Exits("CMISSEquations_ResidualVariablesGet")
    RETURN
999 CALL Errors("CMISSEquations_ResidualVariablesGet",err,error)
    CALL Exits("CMISSEquations_ResidualVariablesGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSEquations_ResidualVariablesGet

!!==================================================================================================================================
!!
!! EQUATIONS_SET_ROUTINES
!!
!!==================================================================================================================================

  !>Finish the creation of a analytic solution for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_AnalyticCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_AnalyticCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_ANALYTIC_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_AnalyticCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_AnalyticCreateFinishNumber",err,error)
    CALL EXITS("CMISSEquationsSet_AnalyticCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_AnalyticCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of a analytic solution for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_AnalyticCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_AnalyticCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_CREATE_FINISH(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSet_AnalyticCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_AnalyticCreateFinishObj",err,error)
    CALL EXITS("CMISSEquationsSet_AnalyticCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_AnalyticCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of a analytic solution for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_AnalyticCreateStartNumber(regionUserNumber,equationsSetUserNumber,analyticFunctionType, &
    & analyticFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: analyticFunctionType !<The analytic function type to use. \see OPENCMISS_EquationsSetAnalyticFunctionTypes
    INTEGER(INTG), INTENT(IN) :: analyticFieldUserNumber !<The user number of the field for the analytic function
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: ANALYTIC_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_AnalyticCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(ANALYTIC_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(analyticFieldUserNumber,REGION,ANALYTIC_FIELD,ERR,error,*999)
        CALL EQUATIONS_SET_ANALYTIC_CREATE_START(EQUATIONS_SET,analyticFunctionType,analyticFieldUserNumber,ANALYTIC_FIELD, &
          & err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_AnalyticCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_AnalyticCreateStartNumber",err,error)
    CALL EXITS("CMISSEquationsSet_AnalyticCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_AnalyticCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of an analytic solution for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_AnalyticCreateStartObj(equationsSet,analyticFunctionType,analyticFieldUserNumber,analyticField,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the analytic creation on.
    INTEGER(INTG), INTENT(IN) :: analyticFunctionType !<The analytic function type to use. \see OPENCMISS_EquationsSetAnalyticFunctionTypes
    INTEGER(INTG), INTENT(IN) :: analyticFieldUserNumber !<The user number of the field for the analytic function
    TYPE(CMISSFieldType), INTENT(INOUT) :: analyticField !<If associated on entry, the user created analytic field which has the same user number as the specified analytic field user number. If not associated on entry, on return, the created analytic field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_AnalyticCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_CREATE_START(equationsSet%EQUATIONS_SET,analyticFunctionType,analyticFieldUserNumber, &
      & analyticField%FIELD,err,error,*999)

    CALL EXITS("CMISSEquationsSet_AnalyticCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_AnalyticCreateStartObj",err,error)
    CALL EXITS("CMISSEquationsSet_AnalyticCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_AnalyticCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the analytic solution for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_AnalyticDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
     TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_AnalyticDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_ANALYTIC_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_AnalyticDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_AnalyticDestroyNumber",err,error)
    CALL EXITS("CMISSEquationsSet_AnalyticDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_AnalyticDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the analytic solution for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_AnalyticDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the analytic for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_AnalyticDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_DESTROY(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSet_AnalyticDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_AnalyticDestroyObj",err,error)
    CALL EXITS("CMISSEquationsSet_AnalyticDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_AnalyticDestroyObj


  !
  !================================================================================================================================
  !

  !>Evaluates the current analytic solution for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_AnalyticEvaluateNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to evaluate.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to evaluate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
     TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_AnalyticEvaluateNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_ANALYTIC_EVALUATE(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_AnalyticEvaluateNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_AnalyticEvaluateNumber",err,error)
    CALL EXITS("CMISSEquationsSet_AnalyticEvaluateNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_AnalyticEvaluateNumber

  !
  !================================================================================================================================
  !

  !>Evaluates the current analytic solution for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_AnalyticEvaluateObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to evaluate the current analytic solution for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_AnalyticEvaluateObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_EVALUATE(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSet_AnalyticEvaluateObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_AnalyticEvaluateObj",err,error)
    CALL EXITS("CMISSEquationsSet_AnalyticEvaluateObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_AnalyticEvaluateObj

  !
  !================================================================================================================================
  !

  !>Returns the analytic time for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_AnalyticTimeGetNumber(regionUserNumber,equationsSetUserNumber,time,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set get the analytic time for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the analytic time get.
    REAL(DP), INTENT(OUT) :: time !<On return, the analytic time for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_AnalyticTimeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_ANALYTIC_TIME_GET(EQUATIONS_SET,time,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_AnalyticTimeGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_AnalyticTimeGetNumber",err,error)
    CALL EXITS("CMISSEquationsSet_AnalyticTimeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_AnalyticTimeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the analytic time for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_AnalyticTimeGetObj(equationsSet,time,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to get the analytic time for.
    REAL(DP), INTENT(OUT) :: time !<On return, the analytic time for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_AnalyticTimeGetObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_TIME_GET(equationsSet%EQUATIONS_SET,time,err,error,*999)

    CALL EXITS("CMISSEquationsSet_AnalyticTimeGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_AnalyticTimeGetObj",err,error)
    CALL EXITS("CMISSEquationsSet_AnalyticTimeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_AnalyticTimeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the analytic time for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_AnalyticTimeSetNumber(regionUserNumber,equationsSetUserNumber,time,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set get the analytic time for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the analytic time get.
    REAL(DP), INTENT(IN) :: time !<The analytic time to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_AnalyticTimeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_ANALYTIC_TIME_SET(EQUATIONS_SET,time,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_AnalyticTimeSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_AnalyticTimeSetNumber",err,error)
    CALL EXITS("CMISSEquationsSet_AnalyticTimeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_AnalyticTimeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the analytic time for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_AnalyticTimeSetObj(equationsSet,time,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the analytic time for.
    REAL(DP), INTENT(IN) :: time !<The analytic time to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_AnalyticTimeSetObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_TIME_SET(equationsSet%EQUATIONS_SET,time,err,error,*999)

    CALL EXITS("CMISSEquationsSet_AnalyticTimeSetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_AnalyticTimeSetObj",err,error)
    CALL EXITS("CMISSEquationsSet_AnalyticTimeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_AnalyticTimeSetObj


  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE CMISSEquationsSet_AnalyticUserParamSetNumber(regionUserNumber,equationsSetUserNumber,paramIdx,param,err)
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(IN) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_AnalyticUserParamSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        IF(ASSOCIATED(EQUATIONS_SET%ANALYTIC)) THEN
          CALL EQUATIONS_SET_ANALYTIC_USER_PARAM_SET(EQUATIONS_SET,paramIdx,param,err,error,*999)
        ELSE
          LOCAL_ERROR="Equations set analytic is not associated for equations set with a user number of " &
            & //TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_AnalyticUserParamSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_AnalyticUserParamSetNumber",err,error)
    CALL EXITS("CMISSEquationsSet_AnalyticUserParamSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_AnalyticUserParamSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE CMISSEquationsSet_AnalyticUserParamSetObj(equationsSet,paramIdx,param,err)
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the analytic user parameter.
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(IN) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_AnalyticUserParamSetObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_USER_PARAM_SET(equationsSet%EQUATIONS_SET,paramIdx,param,err,error,*999)

    CALL EXITS("CMISSEquationsSet_AnalyticUserParamSetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_AnalyticUserParamSetObj",err,error)
    CALL EXITS("CMISSEquationsSet_AnalyticUserParamSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_AnalyticUserParamSetObj

  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE CMISSEquationsSet_AnalyticUserParamGetNumber(regionUserNumber,equationsSetUserNumber,paramIdx,param,err)
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(OUT) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_AnalyticUserParamGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        IF(ASSOCIATED(EQUATIONS_SET%ANALYTIC)) THEN
          CALL EQUATIONS_SET_ANALYTIC_USER_PARAM_GET(EQUATIONS_SET,paramIdx,param,err,error,*999)
        ELSE
          LOCAL_ERROR="Equations set analytic is not associated for equations set with a user number of " &
            & //TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_AnalyticUserParamGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_AnalyticUserParamGetNumber",err,error)
    CALL EXITS("CMISSEquationsSet_AnalyticUserParamGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_AnalyticUserParamGetNumber

  !
  !================================================================================================================================
  !

  !>Sets the analytic problem user parameter
  SUBROUTINE CMISSEquationsSet_AnalyticUserParamGetObj(equationsSet,paramIdx,param,err)
    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the analytic user parameter.
    INTEGER(INTG), INTENT(IN) :: paramIdx !<The index of the analytic user parameter to set
    REAL(DP), INTENT(OUT) :: param !<Value of the parameter to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_AnalyticUserParamGetObj",err,error,*999)

    CALL EQUATIONS_SET_ANALYTIC_USER_PARAM_GET(equationsSet%EQUATIONS_SET,paramIdx,param,err,error,*999)

    CALL EXITS("CMISSEquationsSet_AnalyticUserParamGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_AnalyticUserParamGetObj",err,error)
    CALL EXITS("CMISSEquationsSet_AnalyticUserParamGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_AnalyticUserParamGetObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_CreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Equations Set Create')
#endif

    CALL EXITS("CMISSEquationsSet_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_CreateFinishNumber",err,error)
    CALL EXITS("CMISSEquationsSetreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_CreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_CreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_CREATE_FINISH(equationsSet%EQUATIONS_SET,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Equations Set Create')
#endif

    CALL EXITS("CMISSEquationsSet_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_CreateFinishObj",err,error)
    CALL EXITS("CMISSEquationsSet_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_CreateStartNumber(equationsSetUserNumber,regionUserNumber,geomFibreFieldUserNumber,&
               & equationsSetClass,equationsSetType,equationsSetSubtype,equationsSetFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to be created.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to start the creation of an equations set on.
    INTEGER(INTG), INTENT(IN) :: geomFibreFieldUserNumber !<The user number of the Geometric/Fibre field for the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetFieldUserNumber !<The user number of the equations set field
    INTEGER(INTG), INTENT(IN) :: equationsSetClass !<The equations set class to set. \see OPENCMISS_EquationsSetClasses
    INTEGER(INTG), INTENT(IN) :: equationsSetType !<The equations set type to set. \see OPENCMISS_EquationsSetTypes
    INTEGER(INTG), INTENT(IN) :: equationsSetSubtype !<The equations set subtype to set. \see OPENCMISS_EquationsSetSubtypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: EQUATIONS_SET_FIELD_FIELD
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: GEOM_FIBRE_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Equations Set Create')
#endif

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(GEOM_FIBRE_FIELD)
    NULLIFY(EQUATIONS_SET_FIELD_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(geomFibreFieldUserNumber,REGION,GEOM_FIBRE_FIELD,err,error,*999)

!!!!!!!!!!!!ALSO A FIELD USER NUMBER FIND FOR EQUATIONS SET FIELD?
      CALL FIELD_USER_NUMBER_FIND(equationsSetFieldUserNumber,REGION,EQUATIONS_SET_FIELD_FIELD,err,error,*999)

      IF(ASSOCIATED(GEOM_FIBRE_FIELD)) THEN
        CALL EQUATIONS_SET_CREATE_START(equationsSetUserNumber,REGION,GEOM_FIBRE_FIELD,&
          & equationsSetClass,equationsSetType,equationsSetSubtype,equationsSetFieldUserNumber,&
          & EQUATIONS_SET_FIELD_FIELD,EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(geomFibreFieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_CreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_CreateStartNumber",err,error)
    CALL EXITS("CMISSEquationsSet_CreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_CreateStartObj(equationsSetUserNumber,region,geomFibreField,&
              & equationsSetClass,equationsSetType,equationsSetSubtype,equationsSetFieldUserNumber,&
              & equationsSetFieldField,equationsSet,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to be created.
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to create the equations set on.
    TYPE(CMISSFieldType), INTENT(IN) :: geomFibreField !<The Geometric/Fibre field for the creation of the equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetFieldUserNumber !<The user number of the equations set field
    TYPE(CMISSFieldType), INTENT(INOUT) :: equationsSetFieldField !<On return, a pointer to the equations set field
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<On return, the created equations set.
    INTEGER(INTG), INTENT(IN) :: equationsSetClass !<The equations set class to set. \see OPENCMISS_EquationsSetClasses
    INTEGER(INTG), INTENT(IN) :: equationsSetType !<The equations set type to set. \see OPENCMISS_EquationsSetTypes
    INTEGER(INTG), INTENT(IN) :: equationsSetSubtype !<The equations set subtype to set. \see OPENCMISS_EquationsSetSubtypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Equations Set Create')
#endif

    CALL EQUATIONS_SET_CREATE_START(equationsSetUserNumber,region%REGION,geomFibreField%FIELD, &
      & equationsSetClass,equationsSetType,equationsSetSubtype,&
      & equationsSetFieldUserNumber, equationsSetFieldField%FIELD, equationsSet%EQUATIONS_SET, &
      & err,error,*999)

    CALL EXITS("CMISSEquationsSet_CreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_CreateStartObj",err,error)
    CALL EXITS("CMISSEquationsSet_CreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_DestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destory.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
     TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_DestroyNumber",err,error)
    CALL EXITS("CMISSEquationsSet_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_DestroyObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_DestroyObj",err,error,*999)

    CALL EQUATIONS_SET_DESTROY(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSet_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_DestroyObj",err,error)
    CALL EXITS("CMISSEquationsSet_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_DestroyObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of dependent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_DependentCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_DependentCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_DEPENDENT_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_DependentCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_DependentCreateFinishNumber",err,error)
    CALL EXITS("CMISSEquationsSet_DependentCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_DependentCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of dependent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_DependentCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_DependentCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_DEPENDENT_CREATE_FINISH(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSet_DependentCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_DependentCreateFinishObj",err,error)
    CALL EXITS("CMISSEquationsSet_DependentCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_DependentCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of dependent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_DependentCreateStartNumber(regionUserNumber,equationsSetUserNumber,dependentFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of dependent variables for.
    INTEGER(INTG), INTENT(IN) :: dependentFieldUserNumber !<The user number of the dependent field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: DEPENDENT_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_DependentCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(DEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(dependentFieldUserNumber,REGION,DEPENDENT_FIELD,ERR,error,*999)
        CALL EQUATIONS_SET_DEPENDENT_CREATE_START(EQUATIONS_SET,dependentFieldUserNumber,DEPENDENT_FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_DependentCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_DependentCreateStartNumber",err,error)
    CALL EXITS("CMISSEquationsSet_DependentCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_DependentCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of dependent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_DependentCreateStartObj(equationsSet,dependentFieldUserNumber,dependentField,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of dependent variables on.
    INTEGER(INTG), INTENT(IN) :: dependentFieldUserNumber !<The user number of the dependent field.
    TYPE(CMISSFieldType), INTENT(INOUT) :: dependentField !<If associated on entry, the user created dependent field which has the same user number as the specified dependent field user number. If not associated on entry, on return, the created dependent field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_DependentCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_DEPENDENT_CREATE_START(equationsSet%EQUATIONS_SET,dependentFieldUserNumber,dependentField%FIELD, &
      & err,error,*999)

    CALL EXITS("CMISSEquationsSet_DependentCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_DependentCreateStartObj",err,error)
    CALL EXITS("CMISSEquationsSet_DependentCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_DependentCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the dependent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_DependentDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_DependentDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_DEPENDENT_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_DependentDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_DependentDestroyNumber",err,error)
    CALL EXITS("CMISSEquationsSet_DependentDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_DependentDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the dependent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_DependentDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the dependent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_DependentDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_DEPENDENT_DESTROY(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSet_DependentDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_DependentDestroyObj",err,error)
    CALL EXITS("CMISSEquationsSet_DependentDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_DependentDestroyObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of equations for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_EquationsCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_EquationsCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_EquationsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_EquationsCreateFinishNumber",err,error)
    CALL EXITS("CMISSEquationsSet_EquationsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_EquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of equations for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_EquationsCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_EquationsCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_EQUATIONS_CREATE_FINISH(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSet_EquationsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_EquationsCreateFinishObj",err,error)
    CALL EXITS("CMISSEquationsSet_EquationsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_EquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of equations for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_EquationsCreateStartNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of equations for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_TYPE), POINTER :: EQUATIONS
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_EquationsCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_CREATE_START(EQUATIONS_SET,EQUATIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_EquationsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_EquationsCreateStartNumber",err,error)
    CALL EXITS("CMISSEquationsSet_EquationsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_EquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of equations for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_EquationsCreateStartObj(equationsSet,equations,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of equations on.
    TYPE(CMISSEquationsType), INTENT(INOUT) :: equations !<On return, the created equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_EquationsCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_EQUATIONS_CREATE_START(equationsSet%EQUATIONS_SET,equations%EQUATIONS,err,error,*999)

    CALL EXITS("CMISSEquationsSet_EquationsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_EquationsCreateStartObj",err,error)
    CALL EXITS("CMISSEquationsSet_EquationsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_EquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the equations for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_EquationsDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_EquationsDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_EQUATIONS_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_EquationsDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_EquationsDestroyNumber",err,error)
    CALL EXITS("CMISSEquationsSet_EquationsDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_EquationsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the equations for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_EquationsDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_EquationsDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_EQUATIONS_DESTROY(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSet_EquationsDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_EquationsDestroyObj",err,error)
    CALL EXITS("CMISSEquationsSet_EquationsDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_EquationsDestroyObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of independent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_IndependentCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_IndependentCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_INDEPENDENT_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_IndependentCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_IndependentCreateFinishNumber",err,error)
    CALL EXITS("CMISSEquationsSet_IndependentCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_IndependentCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of independent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_IndependentCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_IndependentCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_INDEPENDENT_CREATE_FINISH(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSet_IndependentCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_IndependentCreateFinishObj",err,error)
    CALL EXITS("CMISSEquationsSet_IndependentCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_IndependentCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of independent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_IndependentCreateStartNumber(regionUserNumber,equationsSetUserNumber,independentFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of independent variables for.
    INTEGER(INTG), INTENT(IN) :: independentFieldUserNumber !<The user number of the independent field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: INDEPENDENT_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_DependentCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(INDEPENDENT_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(independentFieldUserNumber,REGION,INDEPENDENT_FIELD,ERR,error,*999)
        CALL EQUATIONS_SET_DEPENDENT_CREATE_START(EQUATIONS_SET,independentFieldUserNumber,INDEPENDENT_FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_IndependentCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_IndependentCreateStartNumber",err,error)
    CALL EXITS("CMISSEquationsSet_IndependentCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_IndependentCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of independent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_IndependentCreateStartObj(equationsSet,independentFieldUserNumber,independentField,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of independent variables on.
    INTEGER(INTG), INTENT(IN) :: independentFieldUserNumber !<The user number of the dependent field.
    TYPE(CMISSFieldType), INTENT(INOUT) :: independentField !<If associated on entry, the user created independent field which has the same user number as the specified independent field user number. If not associated on entry, on return, the created independent field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_IndependentCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_INDEPENDENT_CREATE_START(equationsSet%EQUATIONS_SET,independentFieldUserNumber,independentField%FIELD, &
      & err,error,*999)

    CALL EXITS("CMISSEquationsSet_IndependentCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_IndependentCreateStartObj",err,error)
    CALL EXITS("CMISSEquationsSet_IndependentCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_IndependentCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the independent variables for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_IndependentDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_IndependentDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_INDEPENDENT_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_IndependentDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_IndependentDestroyNumber",err,error)
    CALL EXITS("CMISSEquationsSet_IndependentDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_IndependentDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the independent variables for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_IndependentDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the independent variables for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_IndependentDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_INDEPENDENT_DESTROY(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSet_IndependentDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_IndependentDestroyObj",err,error)
    CALL EXITS("CMISSEquationsSet_IndependentDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_IndependentDestroyObj

  !
  !================================================================================================================================
  !

  !
  !================================================================================================================================
  !

  !>Finish the creation of materials for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_MaterialsCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_MaterialsCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_MATERIALS_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_MaterialsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_MaterialsCreateFinishNumber",err,error)
    CALL EXITS("CMISSEquationsSet_MaterialsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_MaterialsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of materials for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_MaterialsCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_MaterialsCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_MATERIALS_CREATE_FINISH(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSet_MaterialsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_MaterialsCreateFinishObj",err,error)
    CALL EXITS("CMISSEquationsSet_MaterialsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_MaterialsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of materials for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_MaterialsCreateStartNumber(regionUserNumber,equationsSetUserNumber,materialsFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of materials for.
    INTEGER(INTG), INTENT(IN) :: materialsFieldUserNumber !<The user number of the materials field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: MATERIALS_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_MaterialsCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(MATERIALS_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(materialsFieldUserNumber,REGION,MATERIALS_FIELD,ERR,error,*999)
        CALL EQUATIONS_SET_MATERIALS_CREATE_START(EQUATIONS_SET,materialsFieldUserNumber,MATERIALS_FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_MaterialsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_MaterialsCreateStartNumber",err,error)
    CALL EXITS("CMISSEquationsSet_MaterialsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_MaterialsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of materials for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_MaterialsCreateStartObj(equationsSet,materialsFieldUserNumber,materialsField,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of materials on.
    INTEGER(INTG), INTENT(IN) :: materialsFieldUserNumber !<The user number of the materials field.
    TYPE(CMISSFieldType), INTENT(INOUT) :: materialsField !<If associated on entry, the user created materials field which has the same user number as the specified materials field user number. If not associated on entry, on return, the created materials field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_MaterialsCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_MATERIALS_CREATE_START(equationsSet%EQUATIONS_SET,materialsFieldUserNumber,materialsField%FIELD, &
      & err,error,*999)

    CALL EXITS("CMISSEquationsSet_MaterialsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_MaterialsCreateStartObj",err,error)
    CALL EXITS("CMISSEquationsSet_MaterialsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_MaterialsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the materials for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_MaterialsDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the materials for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_MaterialsDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_MATERIALS_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_MaterialsDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_MaterialsDestroyNumber",err,error)
    CALL EXITS("CMISSEquationsSet_MaterialsDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_MaterialsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the materials for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_MaterialsDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the materials for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_MaterialsDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_MATERIALS_DESTROY(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSet_MaterialsDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_MaterialsDestroyObj",err,error)
    CALL EXITS("CMISSEquationsSet_MaterialsDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_MaterialsDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the solution method for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_SolutionMethodGetNumber(regionUserNumber,equationsSetUserNumber,solutionMethod,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to get the solution method for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the solution method for.
    INTEGER(INTG), INTENT(OUT) :: solutionMethod !<On return, the solution method. \see OPENCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_SolutionMethodGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SOLUTION_METHOD_GET(EQUATIONS_SET,solutionMethod,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_SolutionMethodGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_SolutionMethodGetNumber",err,error)
    CALL EXITS("CMISSEquationsSet_SolutionMethodGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_SolutionMethodGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the solution method for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_SolutionMethodGetObj(equationsSet,solutionMethod,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to get the solution method for.
    INTEGER(INTG), INTENT(OUT) :: solutionMethod !<On Return, the solution method. \see OPENCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_SolutionMethodGetObj",err,error,*999)

    CALL EQUATIONS_SET_SOLUTION_METHOD_GET(equationsSet%EQUATIONS_SET,solutionMethod,err,error,*999)

    CALL EXITS("CMISSEquationsSet_SolutionMethodGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_SolutionMethodGetObj",err,error)
    CALL EXITS("CMISSEquationsSet_SolutionMethodGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_SolutionMethodGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution method for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_SolutionMethodSetNumber(regionUserNumber,equationsSetUserNumber,solutionMethod,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: solutionMethod !<The solution method to set. \see OPENCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_SolutionMethodSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SOLUTION_METHOD_SET(EQUATIONS_SET,solutionMethod,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_SolutionMethodSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_SolutionMethodSetNumber",err,error)
    CALL EXITS("CMISSEquationsSet_SolutionMethodSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_SolutionMethodSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution method for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_SolutionMethodSetObj(equationsSet,solutionMethod,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the solution method for.
    INTEGER(INTG), INTENT(IN) :: solutionMethod !<The solution method to set. \see OPENCMISS_EquationsSetSolutionMethods
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_SolutionMethodSetObj",err,error,*999)

    CALL EQUATIONS_SET_SOLUTION_METHOD_SET(equationsSet%EQUATIONS_SET,solutionMethod,err,error,*999)

    CALL EXITS("CMISSEquationsSet_SolutionMethodSetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_SolutionMethodSetObj",err,error)
    CALL EXITS("CMISSEquationsSet_SolutionMethodSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_SolutionMethodSetObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of a source for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_SourceCreateFinishNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_SourceCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SOURCE_CREATE_FINISH(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_SourceCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_SourceCreateFinishNumber",err,error)
    CALL EXITS("CMISSEquationsSet_SourceCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_SourceCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finish the creation of a source for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_SourceCreateFinishObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to finish the creation of a source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_SourceCreateFinishObj",err,error,*999)

    CALL EQUATIONS_SET_SOURCE_CREATE_FINISH(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSet_SourceCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_SourceCreateFinishObj",err,error)
    CALL EXITS("CMISSEquationsSet_SourceCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_SourceCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of a source for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_SourceCreateStartNumber(regionUserNumber,equationsSetUserNumber,sourceFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to start the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to start the creation of a source for.
    INTEGER(INTG), INTENT(IN) :: sourceFieldUserNumber !<The user number of the source field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(FIELD_TYPE), POINTER :: SOURCE_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_SourceCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    NULLIFY(SOURCE_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL FIELD_USER_NUMBER_FIND(sourceFieldUserNumber,REGION,SOURCE_FIELD,ERR,error,*999)
        CALL EQUATIONS_SET_SOURCE_CREATE_START(EQUATIONS_SET,sourceFieldUserNumber,SOURCE_FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_SourceCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_SourceCreateStartNumber",err,error)
    CALL EXITS("CMISSEquationsSet_SourceCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_SourceCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Start the creation of a source for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_SourceCreateStartObj(equationsSet,sourceFieldUserNumber,sourceField,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to start the creation of a source on.
    INTEGER(INTG), INTENT(IN) :: sourceFieldUserNumber !<The user number of the source field.
    TYPE(CMISSFieldType), INTENT(INOUT) :: sourceField !<If associated on entry, the user created source field which has the same user number as the specified source field user number. If not associated on entry, on return, the created source field for the equations set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_SourceCreateStartObj",err,error,*999)

    CALL EQUATIONS_SET_SOURCE_CREATE_START(equationsSet%EQUATIONS_SET,sourceFieldUserNumber,sourceField%FIELD,err,error,*999)

    CALL EXITS("CMISSEquationsSet_SourceCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_SourceCreateStartObj",err,error)
    CALL EXITS("CMISSEquationsSet_SourceCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_SourceCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroy the source for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_SourceDestroyNumber(regionUserNumber,equationsSetUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to destroy the source for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to destroy the source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_SourceDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SOURCE_DESTROY(EQUATIONS_SET,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_SourceDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_SourceDestroyNumber",err,error)
    CALL EXITS("CMISSEquationsSet_SourceDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_SourceDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroy the source for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_SourceDestroyObj(equationsSet,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to destroy the source for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_SourceDestroyObj",err,error,*999)

    CALL EQUATIONS_SET_SOURCE_DESTROY(equationsSet%EQUATIONS_SET,err,error,*999)

    CALL EXITS("CMISSEquationsSet_SourceDestroyObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_SourceDestroyObj",err,error)
    CALL EXITS("CMISSEquationsSet_SourceDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_SourceDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the equations set specification i.e., equations set class, type and subtype for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_SpecificationGetNumber(regionUserNumber,equationsSetUserNumber,equationsSetClass, &
    & equationsSetType,equationsSetSubtype,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to get the specification for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to get the specification for.
    INTEGER(INTG), INTENT(OUT) :: equationsSetClass !<On return, the equations set class. \see OPENCMISS_EquationsSetClasses
    INTEGER(INTG), INTENT(OUT) :: equationsSetType !<On return, the equations set type. \see OPENCMISS_EquationsSetTypes
    INTEGER(INTG), INTENT(OUT) :: equationsSetSubtype !<On return, the equations set subtype. \see OPENCMISS_EquationsSetSubtypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_SpecificationGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SPECIFICATION_GET(EQUATIONS_SET,equationsSetClass,equationsSetType,equationsSetSubtype,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_SpecificationGetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_SpecificationGetNumber",err,error)
    CALL EXITS("CMISSEquationsSet_SpecificationGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_SpecificationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the equations set specification i.e., equations set class, type and subtype for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_SpecificationGetObj(equationsSet,equationsSetClass,equationsSetType,equationsSetSubtype,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(IN) :: equationsSet !<The equations set to get the specification for.
    INTEGER(INTG), INTENT(OUT) :: equationsSetClass !<On return, the equations set class. \see OPENCMISS_EquationsSetClasses
    INTEGER(INTG), INTENT(OUT) :: equationsSetType !<On return, the equations set type. \see OPENCMISS_EquationsSetTypes
    INTEGER(INTG), INTENT(OUT) :: equationsSetSubtype !<On return, the equations set subtype. \see OPENCMISS_EquationsSetSubtypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_SpecificationGetObj",err,error,*999)

    CALL EQUATIONS_SET_SPECIFICATION_GET(equationsSet%EQUATIONS_SET,equationsSetClass,equationsSetType,equationsSetSubtype, &
      & err,error,*999)

    CALL EXITS("CMISSEquationsSet_SpecificationGetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_SpecificationGetObj",err,error)
    CALL EXITS("CMISSEquationsSet_SpecificationGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_SpecificationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the equations set specification i.e., equations set class, type and subtype for an equations set identified by a user number.
  SUBROUTINE CMISSEquationsSet_SpecificationSetNumber(regionUserNumber,equationsSetUserNumber,equationsSetClass, &
    & equationsSetType,equationsSetSubtype,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to set the specification for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the specification for.
    INTEGER(INTG), INTENT(IN) :: equationsSetClass !<The equations set class to set. \see OPENCMISS_EquationsSetClasses
    INTEGER(INTG), INTENT(IN) :: equationsSetType !<The equations set type to set. \see OPENCMISS_EquationsSetTypes
    INTEGER(INTG), INTENT(IN) :: equationsSetSubtype !<The equations set subtype to set. \see OPENCMISS_EquationsSetSubtypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_SpecificationSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_SPECIFICATION_SET(EQUATIONS_SET,equationsSetClass,equationsSetType,equationsSetSubtype,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_SpecificationSetNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_SpecificationSetNumber",err,error)
    CALL EXITS("CMISSEquationsSet_SpecificationSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_SpecificationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the equations set specification i.e., equations set class, type and subtype for an equations set identified by an object.
  SUBROUTINE CMISSEquationsSet_SpecificationSetObj(equationsSet,equationsSetClass,equationsSetType,equationsSetSubtype,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(INOUT) :: equationsSet !<The equations set to set the specification for.
    INTEGER(INTG), INTENT(IN) :: equationsSetClass !<The equations set class to set. \see OPENCMISS_EquationsSetClasses
    INTEGER(INTG), INTENT(IN) :: equationsSetType !<The equations set type to set. \see OPENCMISS_EquationsSetTypes
    INTEGER(INTG), INTENT(IN) :: equationsSetSubtype !<The equations set subtype to set. \see OPENCMISS_EquationsSetSubtypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_SpecificationSetObj",err,error,*999)

    CALL EQUATIONS_SET_SPECIFICATION_SET(equationsSet%EQUATIONS_SET,equationsSetClass,equationsSetType,equationsSetSubtype, &
      & err,error,*999)

    CALL EXITS("CMISSEquationsSet_SpecificationSetObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_SpecificationSetObj",err,error)
    CALL EXITS("CMISSEquationsSet_SpecificationSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_SpecificationSetObj

  !
  !================================================================================================================================
  !

  SUBROUTINE CMISSEquationsSet_DeformationCalculateNumber(regionUserNumber,equationsSetUserNumber,userElementNumber,xi,C,invC,err)

    !>Calculate the deformation for a specified user element number and xi coordinates.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the Region containing the equations set to set the specification for.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to set the specification for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number.
    REAL(DP), INTENT(IN) :: xi(:) !<The xi coordinates to calculate the deformation at
    REAL(DP), INTENT(OUT) :: C(:) !<The independent values of the deformation tensor
    REAL(DP), INTENT(OUT) :: invC(:) !<The independent values of the inverse deformation tensor
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSEquationsSet_DeformationCalculateNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
      IF(ASSOCIATED(EQUATIONS_SET)) THEN
        CALL EQUATIONS_SET_DEFORMATION_CALCULATE(EQUATIONS_SET,userElementNumber,xi,C,invC,err,error,*999)
      ELSE
        LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSEquationsSet_DeformationCalculateNumber")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_DeformationCalculateNumber",err,error)
    CALL EXITS("CMISSEquationsSet_DeformationCalculateNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_DeformationCalculateNumber

  !
  !================================================================================================================================
  !

  !>Calculate the deformation for a specified user element number and xi coordinates.
  SUBROUTINE CMISSEquationsSet_DeformationCalculateObj(equationsSet,userElementNumber,xi,C,invC,err)

    !Argument variables
    TYPE(CMISSEquationsSetType), INTENT(IN) :: equationsSet !<The equations set to calculate the deformation for.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number.
    REAL(DP), INTENT(IN) :: xi(:) !<The xi coordinates to calculate the deformation at
    REAL(DP), INTENT(OUT) :: C(:) !<The independent values of the deformation tensor
    REAL(DP), INTENT(OUT) :: invC(:) !<The independent values of the inverse deformation tensor
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSEquationsSet_DeformationCalculateObj",err,error,*999)

    CALL EQUATIONS_SET_DEFORMATION_CALCULATE(equationsSet%EQUATIONS_SET,userElementNumber,xi,C,invC,err,error,*999)

    CALL EXITS("CMISSEquationsSet_DeformationCalculateObj")
    RETURN
999 CALL ERRORS("CMISSEquationsSet_DeformationCalculateObj",err,error)
    CALL EXITS("CMISSEquationsSet_DeformationCalculateObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSEquationsSet_DeformationCalculateObj

!!==================================================================================================================================
!!
!! FIELD_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the interpolation type for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ComponentInterpolationGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & interpolationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: interpolationType !<On return, the interpolation type. \see OPENCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ComponentInterpolationGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_INTERPOLATION_GET(FIELD,variableType,componentNumber,interpolationType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ComponentInterpolationGetNumber")
    RETURN
999 CALL ERRORS("CMISSField_ComponentInterpolationGetNumber",err,error)
    CALL EXITS("CMISSField_ComponentInterpolationGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentInterpolationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the interpolation type for a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ComponentInterpolationGetObj(field,variableType,componentNumber,interpolationType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the interpolation type for.
    INTEGER(INTG), INTENT(OUT) :: interpolationType !<On return, the interpolation type. \see OPENCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ComponentInterpolationGetObj",err,error,*999)

    CALL FIELD_COMPONENT_INTERPOLATION_GET(field%FIELD,variableType,componentNumber,interpolationType,err,error,*999)

    CALL EXITS("CMISSField_ComponentInterpolationGetObj")
    RETURN
999 CALL ERRORS("CMISSField_ComponentInterpolationGetObj",err,error)
    CALL EXITS("CMISSField_ComponentInterpolationGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentInterpolationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ComponentInterpolationSetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & interpolationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: interpolationType !<The interpolation type to set. \see OPENCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ComponentInterpolationSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_INTERPOLATION_SET(FIELD,variableType,componentNumber,interpolationType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ComponentInterpolationSetNumber")
    RETURN
999 CALL ERRORS("CMISSField_ComponentInterpolationSetNumber",err,error)
    CALL EXITS("CMISSField_ComponentInterpolationSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentInterpolationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the interpolation type for a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ComponentInterpolationSetObj(field,variableType,componentNumber,interpolationType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: interpolationType !<The interpolation type to set. \see OPENCMISS_FieldInterpolationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ComponentInterpolationSetObj",err,error,*999)

    CALL FIELD_COMPONENT_INTERPOLATION_SET(field%FIELD,variableType,componentNumber,interpolationType,err,error,*999)

    CALL EXITS("CMISSField_ComponentInterpolationSetObj")
    RETURN
999 CALL ERRORS("CMISSField_ComponentInterpolationSetObj",err,error)
    CALL EXITS("CMISSField_ComponentInterpolationSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentInterpolationSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ComponentLabelGetCNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ComponentLabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_LABEL_GET(FIELD,variableType,componentNumber,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ComponentLabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSField_ComponentLabelGetCNumber",err,error)
    CALL EXITS("CMISSField_ComponentLabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentLabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ComponentLabelGetCObj(field,variableType,componentNumber,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ComponentLabelGetCObj",err,error,*999)

    CALL FIELD_COMPONENT_LABEL_GET(field%FIELD,variableType,componentNumber,label,err,error,*999)

    CALL EXITS("CMISSField_ComponentLabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSField_ComponentLabelGetCObj",err,error)
    CALL EXITS("CMISSField_ComponentLabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentLabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ComponentLabelGetVSNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ComponentLabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_LABEL_GET(FIELD,variableType,componentNumber,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ComponentLabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSField_ComponentLabelGetVSNumber",err,error)
    CALL EXITS("CMISSField_ComponentLabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentLabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ComponentLabelGetVSObj(field,variableType,componentNumber,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable component label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ComponentLabelGetVSObj",err,error,*999)

    CALL FIELD_COMPONENT_LABEL_GET(field%FIELD,variableType,componentNumber,label,err,error,*999)

    CALL EXITS("CMISSField_ComponentLabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSField_ComponentLabelGetVSObj",err,error)
    CALL EXITS("CMISSField_ComponentLabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentLabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ComponentLabelSetCNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ComponentLabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_LABEL_SET(FIELD,variableType,componentNumber,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ComponentLabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSField_ComponentLabelSetCNumber",err,error)
    CALL EXITS("CMISSField_ComponentLabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentLabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ComponentLabelSetCObj(field,variableType,componentNumber,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ComponentLabelSetCObj",err,error,*999)

    CALL FIELD_COMPONENT_LABEL_SET(field%FIELD,variableType,componentNumber,label,err,error,*999)

    CALL EXITS("CMISSField_ComponentLabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSField_ComponentLabelSetCObj",err,error)
    CALL EXITS("CMISSField_ComponentLabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentLabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ComponentLabelSetVSNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ComponentLabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_LABEL_SET(FIELD,variableType,componentNumber,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ComponentLabelSetVSNumber")
    RETURN
999 CALL ERRORS("CMISSField_ComponentLabelSetVSNumber",err,error)
    CALL EXITS("CMISSField_ComponentLabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentLabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ComponentLabelSetVSObj(field,variableType,componentNumber,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the label for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable component label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ComponentLabelSetVSObj",err,error,*999)

    CALL FIELD_COMPONENT_LABEL_SET(field%FIELD,variableType,componentNumber,label,err,error,*999)

    CALL EXITS("CMISSField_ComponentLabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSField_ComponentLabelSetVSObj",err,error)
    CALL EXITS("CMISSField_ComponentLabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentLabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ComponentMeshComponentGetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & meshComponent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the mesh component number for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the mesh component number for.
    INTEGER(INTG), INTENT(OUT) :: meshComponent !<On return, the mesh component number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ComponentMeshComponentGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_MESH_COMPONENT_GET(FIELD,variableType,componentNumber,meshComponent,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ComponentMeshComponentGetNumber")
    RETURN
999 CALL ERRORS("CMISSField_ComponentMeshComponentGetNumber",err,error)
    CALL EXITS("CMISSField_ComponentMeshComponentGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentMeshComponentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number for a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ComponentMeshComponentGetObj(field,variableType,componentNumber,meshComponent,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the mesh component number for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the mesh component number for.
    INTEGER(INTG), INTENT(OUT) :: meshComponent !<On return, the mesh component number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ComponentMeshComponentGetObj",err,error,*999)

    CALL FIELD_COMPONENT_MESH_COMPONENT_GET(field%FIELD,variableType,componentNumber,meshComponent,err,error,*999)

    CALL EXITS("CMISSField_ComponentMeshComponentGetObj")
    RETURN
999 CALL ERRORS("CMISSField_ComponentMeshComponentGetObj",err,error)
    CALL EXITS("CMISSField_ComponentMeshComponentGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentMeshComponentGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ComponentMeshComponentSetNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & meshComponent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the mesh component number for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ComponentMeshComponentSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_MESH_COMPONENT_SET(FIELD,variableType,componentNumber,meshComponent,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ComponentMeshComponentSetNumber")
    RETURN
999 CALL ERRORS("CMISSField_ComponentMeshComponentSetNumber",err,error)
    CALL EXITS("CMISSField_ComponentMeshComponentSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentMeshComponentSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number for a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ComponentMeshComponentSetObj(field,variableType,componentNumber,meshComponent,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the mesh component number for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to set the mesh component number for.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ComponentMeshComponentSetObj",err,error,*999)

    CALL FIELD_COMPONENT_MESH_COMPONENT_SET(field%FIELD,variableType,componentNumber,meshComponent,err,error,*999)

    CALL EXITS("CMISSField_ComponentMeshComponentSetObj")
    RETURN
999 CALL ERRORS("CMISSField_ComponentMeshComponentSetObj",err,error)
    CALL EXITS("CMISSField_ComponentMeshComponentSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentMeshComponentSetObj

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to an integer constant value for a field identified by a user number.
  SUBROUTINE CMISSField_ComponentValuesInitialiseIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ComponentValuesInitialiseIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_VALUES_INITIALISE(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ComponentValuesInitialiseIntgNumber")
    RETURN
999 CALL ERRORS("CMISSField_ComponentValuesInitialiseIntgNumber",err,error)
    CALL EXITS("CMISSField_ComponentValuesInitialiseIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentValuesInitialiseIntgNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to an integer constant value for a field identified by an object.
  SUBROUTINE CMISSField_ComponentValuesInitialiseIntgObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ComponentValuesInitialiseIntgObj",err,error,*999)

    CALL FIELD_COMPONENT_VALUES_INITIALISE(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ComponentValuesInitialiseIntgObj")
    RETURN
999 CALL ERRORS("CMISSField_ComponentValuesInitialiseIntgObj",err,error)
    CALL EXITS("CMISSField_ComponentValuesInitialiseIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentValuesInitialiseIntgObj
  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a single precision constant value for a field identified by a user number.
  SUBROUTINE CMISSField_ComponentValuesInitialiseSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(SP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ComponentValuesInitialiseSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_VALUES_INITIALISE(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ComponentValuesInitialiseSPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ComponentValuesInitialiseSPNumber",err,error)
    CALL EXITS("CMISSField_ComponentValuesInitialiseSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentValuesInitialiseSPNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a single precision constant value for a field identified by an object.
  SUBROUTINE CMISSField_ComponentValuesInitialiseSPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(SP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ComponentValuesInitialiseSPObj",err,error,*999)

    CALL FIELD_COMPONENT_VALUES_INITIALISE(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ComponentValuesInitialiseSPObj")
    RETURN
999 CALL ERRORS("CMISSField_ComponentValuesInitialiseSPObj",err,error)
    CALL EXITS("CMISSField_ComponentValuesInitialiseSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentValuesInitialiseSPObj
  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a double precision constant value for a field identified by a user number.
  SUBROUTINE CMISSField_ComponentValuesInitialiseDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(DP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ComponentValuesInitialiseDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_VALUES_INITIALISE(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ComponentValuesInitialiseDPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ComponentValuesInitialiseDPNumber",err,error)
    CALL EXITS("CMISSField_ComponentValuesInitialiseDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentValuesInitialiseDPNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a double precision constant value for a field identified by an object.
  SUBROUTINE CMISSField_ComponentValuesInitialiseDPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    REAL(DP), INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ComponentValuesInitialiseDPObj",err,error,*999)

    CALL FIELD_COMPONENT_VALUES_INITIALISE(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ComponentValuesInitialiseDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ComponentValuesInitialiseDPObj",err,error)
    CALL EXITS("CMISSField_ComponentValuesInitialiseDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentValuesInitialiseDPObj
  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a logical constant value for a field identified by a user number.
  SUBROUTINE CMISSField_ComponentValuesInitialiseLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to initialise the field variable component for for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    LOGICAL, INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ComponentValuesInitialiseLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_COMPONENT_VALUES_INITIALISE(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ComponentValuesInitialiseLNumber")
    RETURN
999 CALL ERRORS("CMISSField_ComponentValuesInitialiseLNumber",err,error)
    CALL EXITS("CMISSField_ComponentValuesInitialiseLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentValuesInitialiseLNumber

  !
  !================================================================================================================================
  !

  !>Initialises the values of parameter set of a field variable component to a logical constant value for a field identified by an object.
  SUBROUTINE CMISSField_ComponentValuesInitialiseLObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to initialise the field variable component for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to initialise the field variable component for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to initialise the field variable component for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to initialise the field variable component for.
    LOGICAL, INTENT(IN) :: value !<The value to initialise the parameter set for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ComponentValuesInitialiseLObj",err,error,*999)

    CALL FIELD_COMPONENT_VALUES_INITIALISE(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ComponentValuesInitialiseLObj")
    RETURN
999 CALL ERRORS("CMISSField_ComponentValuesInitialiseLObj",err,error)
    CALL EXITS("CMISSField_ComponentValuesInitialiseLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ComponentValuesInitialiseLObj

  !
  !================================================================================================================================
  !

  !>Returns the data type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSField_DataTypeGetNumber(regionUserNumber,fieldUserNumber,variableType,dataType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the field variable data type. \see OPENCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_DataTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DATA_TYPE_GET(FIELD,variableType,dataType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_DataTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSField_DataTypeGetNumber",err,error)
    CALL EXITS("CMISSField_DataTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DataTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the data type for a field variable for a field identified by an object.
  SUBROUTINE CMISSField_DataTypeGetObj(field,variableType,dataType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the field variable data type. \see OPENCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_DataTypeGetObj",err,error,*999)

    CALL FIELD_DATA_TYPE_GET(field%FIELD,variableType,dataType,err,error,*999)

    CALL EXITS("CMISSField_DataTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSField_DataTypeGetObj",err,error)
    CALL EXITS("CMISSField_DataTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DataTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSField_DataTypeSetNumber(regionUserNumber,fieldUserNumber,variableType,dataType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the data type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: dataType !<The field variable data type to set. \see OPENCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_DataTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DATA_TYPE_SET(FIELD,variableType,dataType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_DataTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSField_DataTypeSetNumber",err,error)
    CALL EXITS("CMISSField_DataTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DataTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the data type for a field variable for a field identified by an object.
  SUBROUTINE CMISSField_DataTypeSetObj(field,variableType,dataType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the data type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the data type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: dataType !<The field variable data type to set. \see OPENCMISS_FieldDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_DataTypeSetObj",err,error,*999)

    CALL FIELD_DATA_TYPE_SET(field%FIELD,variableType,dataType,err,error,*999)

    CALL EXITS("CMISSField_DataTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSField_DataTypeSetObj",err,error)
    CALL EXITS("CMISSField_DataTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DataTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the DOF order type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSField_DOFOrderTypeGetNumber(regionUserNumber,fieldUserNumber,variableType,DOFOrderType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the DOF Order type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: DOFOrderType !<On return, the field variable DOF Order type. \see OPENCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_DOFOrderTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DOF_ORDER_TYPE_GET(FIELD,variableType,DOFOrderType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_DOFOrderTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSField_DOFOrderTypeGetNumber",err,error)
    CALL EXITS("CMISSField_DOFOrderTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DOFOrderTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the DOF Order type for a field variable for a field identified by an object.
  SUBROUTINE CMISSField_DOFOrderTypeGetObj(field,variableType,DOFOrderType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the DOF order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the DOF order type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: DOFOrderType !<On return, the field variable DOF order type. \see OPENCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_DOFOrderTypeGetObj",err,error,*999)

    CALL FIELD_DOF_ORDER_TYPE_GET(field%FIELD,variableType,DOFOrderType,err,error,*999)

    CALL EXITS("CMISSField_DOFOrderTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSField_DOFOrderTypeGetObj",err,error)
    CALL EXITS("CMISSField_DOFOrderTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DOFOrderTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF order type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSField_DOFOrderTypeSetNumber(regionUserNumber,fieldUserNumber,variableType,DOFOrderType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the DOF Order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the DOF Order type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: DOFOrderType !<The field variable DOF Order type to set. \see OPENCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_DOFOrderTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DOF_ORDER_TYPE_SET(FIELD,variableType,DOFOrderType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_DOFOrderTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSField_DOFOrderTypeSetNumber",err,error)
    CALL EXITS("CMISSField_DOFOrderTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DOFOrderTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the DOF Order type for a field variable for a field identified by an object.
  SUBROUTINE CMISSField_DOFOrderTypeSetObj(field,variableType,DOFOrderType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the DOF order type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the DOF order type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: DOFOrderType !<The field variable DOF order type to set. \see OPENCMISS_FieldDOFOrderTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_DOFOrderTypeSetObj",err,error,*999)

    CALL FIELD_DOF_ORDER_TYPE_SET(field%FIELD,variableType,DOFOrderType,err,error,*999)

    CALL EXITS("CMISSField_DOFOrderTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSField_DOFOrderTypeSetObj",err,error)
    CALL EXITS("CMISSField_DOFOrderTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DOFOrderTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a field identified by a user number.
  SUBROUTINE CMISSField_CreateFinishNumber(regionUserNumber,fieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_CREATE_FINISH(FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Field Create')
#endif

    CALL EXITS("CMISSField_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSField_CreateFinishNumber",err,error)
    CALL EXITS("CMISSField_CreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a field identified by an object.
  SUBROUTINE CMISSField_CreateFinishObj(field,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<The field to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_CreateFinishObj",err,error,*999)

    CALL FIELD_CREATE_FINISH(field%FIELD,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('field Create')
#endif

    CALL EXITS("CMISSField_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSField_CreateFinishObj",err,error)
    CALL EXITS("CMISSField_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field identified by a user number.
  SUBROUTINE CMISSField_CreateStartNumber(fieldUserNumber,regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the creation of.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Field Create')
#endif

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_CREATE_START(fieldUserNumber,REGION,FIELD,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_CreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSField_CreateStartNumber",err,error)
    CALL EXITS("CMISSField_CreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a field on an interface identified by an object.
  SUBROUTINE CMISSField_CreateStartInterfaceObj(fieldUserNumber,interface,field,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the creation of.
    TYPE(CMISSInterfaceType), INTENT(IN) :: Interface !<The interface to create the field on.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the created field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_CreateStartInterfaceObj",err,error,*999)

    CALL FIELD_CREATE_START(fieldUserNumber,interface%INTERFACE,field%FIELD,err,error,*999)

    CALL EXITS("CMISSField_CreateStartInterfaceObj")
    RETURN
999 CALL ERRORS("CMISSField_CreateStartInterfaceObj",err,error)
    CALL EXITS("CMISSField_CreateStartInterfaceObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_CreateStartInterfaceObj

  !
  !================================================================================================================================
  !

   !>Starts the creation of a field on a region identified by an object.
  SUBROUTINE CMISSField_CreateStartRegionObj(fieldUserNumber,region,field,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the creation of.
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to create the field on.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<On return, the created field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_CreateStartRegionObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('field Create')
#endif

    CALL FIELD_CREATE_START(fieldUserNumber,region%REGION,field%FIELD,err,error,*999)

    CALL EXITS("CMISSField_CreateStartRegionObj")
    RETURN
999 CALL ERRORS("CMISSField_CreateStartRegionObj",err,error)
    CALL EXITS("CMISSField_CreateStartRegionObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_CreateStartRegionObj

  !
  !================================================================================================================================
  !

  !>Returns the dependent type for a field identified by a user number.
  SUBROUTINE CMISSField_DependentTypeGetNumber(regionUserNumber,fieldUserNumber,dependentType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the dependent type for.
    INTEGER(INTG), INTENT(OUT) :: dependentType !<On return, the field dependent type. \see OPENCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_DependentTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DEPENDENT_TYPE_GET(FIELD,dependentType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_DependentTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSField_DependentTypeGetNumber",err,error)
    CALL EXITS("CMISSField_DependentTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DependentTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the dependent type for a field identified by an object.
  SUBROUTINE CMISSField_DependentTypeGetObj(field,dependentType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the dependent type for.
    INTEGER(INTG), INTENT(OUT) :: dependentType !<On return, the field dependent type. \see OPENCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_DependentTypeGetObj",err,error,*999)

    CALL FIELD_DEPENDENT_TYPE_GET(field%FIELD,dependentType,err,error,*999)

    CALL EXITS("CMISSField_DependentTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSField_DependentTypeGetObj",err,error)
    CALL EXITS("CMISSField_DependentTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DependentTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field identified by a user number.
  SUBROUTINE CMISSField_DependentTypeSetNumber(regionUserNumber,fieldUserNumber,dependentType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the dependent type for.
    INTEGER(INTG), INTENT(IN) :: dependentType !<The field dependent type to set. \see OPENCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_DependentTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DEPENDENT_TYPE_SET(FIELD,dependentType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_DependentTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSField_DependentTypeSetNumber",err,error)
    CALL EXITS("CMISSField_DependentTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DependentTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the dependent type for a field identified by an object.
  SUBROUTINE CMISSField_DependentTypeSetObj(field,dependentType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the dependent type for.
    INTEGER(INTG), INTENT(IN) :: dependentType !<The field dependent type to set. \see OPENCMISS_FieldDependentTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_DependentTypeSetObj",err,error,*999)

    CALL FIELD_DEPENDENT_TYPE_SET(field%FIELD,dependentType,err,error,*999)

    CALL EXITS("CMISSField_DependentTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSField_DependentTypeSetObj",err,error)
    CALL EXITS("CMISSField_DependentTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DependentTypeSetObj

  !
  !================================================================================================================================
  !

  !>Destroys a field identified by a user number.
  SUBROUTINE CMISSField_DestroyNumber(regionUserNumber,fieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to destroy.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DESTROY(FIELD,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSField_DestroyNumber",err,error)
    CALL EXITS("CMISSField_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a field identified by an object.
  SUBROUTINE CMISSField_DestroyObj(field,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_DestroyObj",err,error,*999)

    CALL FIELD_DESTROY(field%FIELD,err,error,*999)

    CALL EXITS("CMISSField_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSField_DestroyObj",err,error)
    CALL EXITS("CMISSField_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the dimension for a field identified by a user number.
  SUBROUTINE CMISSField_DimensionGetNumber(regionUserNumber,fieldUserNumber,variableType,dimension,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: dimension !<On return, the field dimension. \see OPENCMISS_FieldDimensionTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_DimensionGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DIMENSION_GET(FIELD,variableType,dimension,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_DimensionGetNumber")
    RETURN
999 CALL ERRORS("CMISSField_DimensionGetNumber",err,error)
    CALL EXITS("CMISSField_DimensionGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DimensionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the dimension for a field identified by an object.
  SUBROUTINE CMISSField_DimensionGetObj(field,variableType,dimension,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: Dimension !<On return, the field dimension. \see OPENCMISS_FieldDimension
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_DimensionGetObj",err,error,*999)

    CALL FIELD_DIMENSION_GET(field%FIELD,variableType,dimension,err,error,*999)

    CALL EXITS("CMISSField_DimensionGetObj")
    RETURN
999 CALL ERRORS("CMISSField_DimensionGetObj",err,error)
    CALL EXITS("CMISSField_DimensionGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DimensionGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension for a field identified by a user number.
  SUBROUTINE CMISSField_DimensionSetNumber(regionUserNumber,fieldUserNumber,variableType,dimension,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: Dimension !<The field dimension to set. \see OPENCMISS_FieldDimensionTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_DimensionSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_DIMENSION_SET(FIELD,variableType,dimension,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_DimensionSetNumber")
    RETURN
999 CALL ERRORS("CMISSField_DimensionSetNumber",err,error)
    CALL EXITS("CMISSField_DimensionSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DimensionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the dimension for a field identified by an object.
  SUBROUTINE CMISSField_DimensionSetObj(field,variableType,dimension,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the dimension for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the dimension for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: dimension !<The field dimension to set. \see OPENCMISS_FieldDimension
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_DimensionSetObj",err,error,*999)

    CALL FIELD_DIMENSION_SET(field%FIELD,variableType,DIMENSION,err,error,*999)

    CALL EXITS("CMISSField_DimensionSetObj")
    RETURN
999 CALL ERRORS("CMISSField_DimensionSetObj",err,error)
    CALL EXITS("CMISSField_DimensionSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DimensionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the geometric field for a field identified by a user number.
  SUBROUTINE CMISSField_GeometricFieldGetNumber(regionUserNumber,fieldUserNumber,geometricFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the geometric field for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the geometric field for.
    INTEGER(INTG), INTENT(OUT) :: geometricFieldUserNumber !<On return, the field geometric field user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD,GEOMETRIC_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_GeometricFieldGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(GEOMETRIC_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_GEOMETRIC_FIELD_GET(FIELD,GEOMETRIC_FIELD,err,error,*999)
        geometricFieldUserNumber=GEOMETRIC_FIELD%USER_NUMBER
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_GeometricFieldGetNumber")
    RETURN
999 CALL ERRORS("CMISSField_GeometricFieldGetNumber",err,error)
    CALL EXITS("CMISSField_GeometricFieldGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_GeometricFieldGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the geometric field for a field identified by an object.
  SUBROUTINE CMISSField_GeometricFieldGetObj(field,geometricField,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the geometric field for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: geometricField !<On return, the geometric field for the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_GeometricFieldGetObj",err,error,*999)

    CALL FIELD_GEOMETRIC_FIELD_GET(field%FIELD,geometricField%FIELD,err,error,*999)

    CALL EXITS("CMISSField_GeometricFieldGetObj")
    RETURN
999 CALL ERRORS("CMISSField_GeometricFieldGetObj",err,error)
    CALL EXITS("CMISSField_GeometricFieldGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_GeometricFieldGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field identified by a user number.
  SUBROUTINE CMISSField_GeometricFieldSetNumber(regionUserNumber,fieldUserNumber,geometricFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the geometric field for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the geometric field for.
    INTEGER(INTG), INTENT(OUT) :: geometricFieldUserNumber !<The field geometric field user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD,GEOMETRIC_FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_GeometricFieldSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(GEOMETRIC_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_USER_NUMBER_FIND(geometricFieldUserNumber,REGION,GEOMETRIC_FIELD,err,error,*999)
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          CALL FIELD_GEOMETRIC_FIELD_SET(FIELD,GEOMETRIC_FIELD,err,error,*999)
        ELSE
          LOCAL_ERROR="A geometric field with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(geometricFieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_GeometricFieldSetNumber")
    RETURN
999 CALL ERRORS("CMISSField_GeometricFieldSetNumber",err,error)
    CALL EXITS("CMISSField_GeometricFieldSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_GeometricFieldSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the geometric field for a field identified by an object.
  SUBROUTINE CMISSField_GeometricFieldSetObj(field,geometricField,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the geometric field for.
    TYPE(CMISSFieldType), INTENT(IN) :: geometricField !<The geometric field for the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_GeometricFieldSetObj",err,error,*999)

    CALL FIELD_GEOMETRIC_FIELD_SET(field%FIELD,geometricField%FIELD,err,error,*999)

    CALL EXITS("CMISSField_GeometricFieldSetObj")
    RETURN
999 CALL ERRORS("CMISSField_GeometricFieldSetObj",err,error)
    CALL EXITS("CMISSField_GeometricFieldSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_GeometricFieldSetObj

  !
  !================================================================================================================================
  !

  !>Gets the line length between nodes of a geometric field for a given element number and element basis line number by a user number.
  SUBROUTINE CMISSField_GeometricParametersElementLineLengthGetNumber(regionUserNumber,geometricFieldUserNumber,elementNumber, &
    & elementLineNumber,lineLength,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to obtain the line length from
    INTEGER(INTG), INTENT(IN) :: geometricFieldUserNumber !<The geometric field user number to obtain the line length from
    INTEGER(INTG),  INTENT(IN) :: elementNumber !<The element to get the line length for
    INTEGER(INTG), INTENT(IN) :: elementLineNumber !<The element basis line to get the length for
    REAL(DP), INTENT(OUT) :: lineLength !<The line length of the chosen element line number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: geometricField
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_GeometricParametersElementLineLengthGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(geometricField)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(geometricFieldUserNumber,region,geometricField,err,error,*999)
      IF(ASSOCIATED(geometricField)) THEN
        CALL Field_GeometricParametersElementLineLengthGet(geometricField,elementNumber,elementLineNumber,lineLength, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(geometricFieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_GeometricParametersElementLineLengthGetNumber")
    RETURN
999 CALL ERRORS("CMISSField_GeometricParametersElementLineLengthGetNumber",err,error)
    CALL EXITS("CMISSField_GeometricParametersElementLineLengthGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_GeometricParametersElementLineLengthGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the line length between nodes of a geometric field for a given element number and element basis line number by an object.
  SUBROUTINE CMISSField_GeometricParametersElementLineLengthGetObj(geometricField,elementNumber,elementLineNumber,lineLength,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: geometricField !<The geometric field to obtain the line length from
    INTEGER(INTG),  INTENT(IN) :: elementNumber !<The element to get the line length for
    INTEGER(INTG), INTENT(IN) :: elementLineNumber !<The element basis line to get the length for
    REAL(DP), INTENT(OUT) :: lineLength !<The line length of the chosen element line number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_GeometricParametersElementLineLengthGetObj",err,error,*999)

    CALL Field_GeometricParametersElementLineLengthGet(geometricField%FIELD,elementNumber,elementLineNumber,lineLength, &
      & err,error,*999)

    CALL EXITS("CMISSField_GeometricParametersElementLineLengthGetObj")
    RETURN
999 CALL ERRORS("CMISSField_GeometricParametersElementLineLengthGetObj",err,error)
    CALL EXITS("CMISSField_GeometricParametersElementLineLengthGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_GeometricParametersElementLineLengthGetObj

  !
  !================================================================================================================================
  !

  !>Gets the scale factor for a particular node identified by a user number.
  SUBROUTINE CMISSField_ParameterSetNodeScaleFactorGetNumber(regionUserNumber,fieldUserNumber,variableType, &
    & versionNumber,derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the scalefactor for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to get scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to get the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetNodeScaleFactorGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetNodeScaleFactorGet(field,variableType,versionNumber, &
          & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetNodeScaleFactorGetNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetNodeScaleFactorGetNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetNodeScaleFactorGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetNodeScaleFactorGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the scale factor for a particular node identified by an object.
  SUBROUTINE CMISSField_ParameterSetNodeScaleFactorGetObj(field,variableType, &
    & versionNumber,derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to get the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetNodeScaleFactorGetObj",err,error,*999)

    CALL Field_ParameterSetNodeScaleFactorGet(field%FIELD,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetNodeScaleFactorGetObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetNodeScaleFactorGetObj",err,error)
    CALL EXITS("CMISSField_ParameterSetNodeScaleFactorGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetNodeScaleFactorGetObj


  !
  !================================================================================================================================
  !

  !>Gets the scale factors for all nodes identified by a user number.
  SUBROUTINE CMISSField_ParameterSetNodeScaleFactorsGetNumber(regionUserNumber,fieldUserNumber,variableType, &
    & meshComponentNumber,scaleFactors,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the scalefactor for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to get scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh omponent number of the field to set the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactors(:) !<The scale factors
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetNodeScaleFactorsGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetNodeScaleFactorsGet(field,variableType,meshComponentNumber,scaleFactors,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetNodeScaleFactorsGetNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetNodeScaleFactorsGetNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetNodeScaleFactorsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetNodeScaleFactorsGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the scale factors for all nodes identified by an object.
  SUBROUTINE CMISSField_ParameterSetNodeScaleFactorsGetObj(field,variableType,meshComponentNumber,scaleFactors,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh omponent number of the field to set the scale factor for
    REAL(DP), INTENT(OUT) :: scaleFactors(:) !<The scale factors
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetNodeScaleFactorsGetObj",err,error,*999)

    CALL Field_ParameterSetNodeScaleFactorsGet(field%FIELD,variableType,meshComponentNumber,scaleFactors,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetNodeScaleFactorsGetObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetNodeScaleFactorsGetObj",err,error)
    CALL EXITS("CMISSField_ParameterSetNodeScaleFactorsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetNodeScaleFactorsGetObj
  !
  !================================================================================================================================
  !

  !>Gets the number of scale factor dofs, identified by a user number.
  SUBROUTINE CMISSField_ParameterSetNodeNumberOfScaleFactorDofsGetNumber(regionUserNumber,fieldUserNumber,variableType, &
    & meshComponentNumber,numberOfScaleFactorsDofs,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the number of scalefactors for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(OUT) :: numberOfScaleFactorsDofs !<The number of scale factor dofs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetNodeNumberOfScaleFactorDofsGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetNodeNumberOfScaleFactorDofsGet(field,variableType,meshComponentNumber,numberOfScaleFactorsDofs, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetNodeNumberOfScaleFactorDofsGetNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetNodeNumberOfScaleFactorDofsGetNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetNodeNumberOfScaleFactorDofsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetNodeNumberOfScaleFactorDofsGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the number of scale factor dofs, identified by an object.
  SUBROUTINE CMISSField_ParameterSetNodeNumberOfScaleFactorDofsGetObj(field,variableType,meshComponentNumber, &
    & numberOfScaleFactorsDofs,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the field to get the number of scale factor dofs for
    INTEGER(INTG), INTENT(OUT) :: numberOfScaleFactorsDofs !<The number of scale factor dofs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetNodeNumberOfScaleFactorDofsGetObj",err,error,*999)

    CALL Field_ParameterSetNodeNumberOfScaleFactorDofsGet(field%FIELD,variableType,meshComponentNumber,numberOfScaleFactorsDofs, &
      & err,error,*999)

    CALL EXITS("CMISSField_ParameterSetNodeNumberOfScaleFactorDofsGetObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetNodeNumberOfScaleFactorDofsGetObj",err,error)
    CALL EXITS("CMISSField_ParameterSetNodeNumberOfScaleFactorDofsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetNodeNumberOfScaleFactorDofsGetObj

  !
  !================================================================================================================================
  !

  !>Sets the scale factor for a particular node identified by a user number.
  SUBROUTINE CMISSField_ParameterSetNodeScaleFactorSetNumber(regionUserNumber,fieldUserNumber,variableType, &
    & versionNumber,derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the scalefactor for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to set scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetNodeScaleFactorSetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetNodeScaleFactorSet(field,variableType,versionNumber, &
          & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetNodeScaleFactorSetNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetNodeScaleFactorSetNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetNodeScaleFactorSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetNodeScaleFactorSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the scale factor for a particular node identified by an object.
  SUBROUTINE CMISSField_ParameterSetNodeScaleFactorSetObj(field,variableType, &
    & versionNumber,derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The user number of the node derivative version to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The user number of the node derivative to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactor !<The scale factor of the specified node
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetNodeScaleFactorSetObj",err,error,*999)

    CALL Field_ParameterSetNodeScaleFactorSet(field%FIELD,variableType,versionNumber, &
      & derivativeNumber,nodeUserNumber,componentNumber,scaleFactor,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetNodeScaleFactorSetObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetNodeScaleFactorSetObj",err,error)
    CALL EXITS("CMISSField_ParameterSetNodeScaleFactorSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetNodeScaleFactorSetObj

  !
  !================================================================================================================================
  !

  !>Sets the scale factors for all nodes identified by a user number.
  SUBROUTINE CMISSField_ParameterSetNodeScaleFactorsSetNumber(regionUserNumber,fieldUserNumber,variableType, &
    & meshComponentNumber,scaleFactors,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the scalefactor for
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field to set scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh omponent number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactors(:) !<The scale factors
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetNodeScaleFactorsSetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetNodeScaleFactorsSet(field,variableType,meshComponentNumber,scaleFactors,err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetNodeScaleFactorsSetNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetNodeScaleFactorsSetNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetNodeScaleFactorsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetNodeScaleFactorsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the scale factors for all nodes identified by an object.
  SUBROUTINE CMISSField_ParameterSetNodeScaleFactorsSetObj(field,variableType,meshComponentNumber,scaleFactors,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set scale factor for
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the scale factor for
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The component number of the field to set the scale factor for
    REAL(DP), INTENT(IN) :: scaleFactors(:) !<The scale factors
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetNodeScaleFactorsSetObj",err,error,*999)

    CALL Field_ParameterSetNodeScaleFactorsSet(field%FIELD,variableType,meshComponentNumber,scaleFactors,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetNodeScaleFactorsSetObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetNodeScaleFactorsSetObj",err,error)
    CALL EXITS("CMISSField_ParameterSetNodeScaleFactorsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetNodeScaleFactorsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field identified by a user number.
  SUBROUTINE CMISSField_LabelGetCNumber(regionUserNumber,fieldUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_LabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_LABEL_GET(FIELD,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_LabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSField_LabelGetCNumber",err,error)
    CALL EXITS("CMISSField_LabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field identified by an object.
  SUBROUTINE CMISSField_LabelGetCObj(field,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_LabelGetCObj",err,error,*999)

    CALL FIELD_LABEL_GET(field%FIELD,label,err,error,*999)

    CALL EXITS("CMISSField_LabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSField_LabelGetCObj",err,error)
    CALL EXITS("CMISSField_LabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field identified by a user number.
  SUBROUTINE CMISSField_LabelGetVSNumber(regionUserNumber,fieldUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_LabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_LABEL_GET(FIELD,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_LabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSField_LabelGetVSNumber",err,error)
    CALL EXITS("CMISSField_LabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field identified by an object.
  SUBROUTINE CMISSField_LabelGetVSObj(field,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_LabelGetVSObj",err,error,*999)

    CALL FIELD_LABEL_GET(field%FIELD,label,err,error,*999)

    CALL EXITS("CMISSField_LabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSField_LabelGetVSObj",err,error)
    CALL EXITS("CMISSField_LabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field identified by a user number.
  SUBROUTINE CMISSField_LabelSetCNumber(regionUserNumber,fieldUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_LabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_LABEL_SET(FIELD,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_LabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSField_LabelSetCNumber",err,error)
    CALL EXITS("CMISSField_LabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field identified by an object.
  SUBROUTINE CMISSField_LabelSetCObj(field,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_LabelSetCObj",err,error,*999)

    CALL FIELD_LABEL_SET(field%FIELD,label,err,error,*999)

    CALL EXITS("CMISSField_LabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSField_LabelSetCObj",err,error)
    CALL EXITS("CMISSField_LabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field identified by a user number.
  SUBROUTINE CMISSField_LabelSetVSNumber(regionUserNumber,fieldUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_LabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_LABEL_SET(FIELD,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_LabelSetVSNumber")
    RETURN
999 CALL ERRORS("CMISSField_LabelSetVSNumber",err,error)
    CALL EXITS("CMISSField_LabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field identified by an object.
  SUBROUTINE CMISSField_LabelSetVSObj(field,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field label to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_LabelSetVSObj",err,error,*999)

    CALL FIELD_LABEL_SET(field%FIELD,label,err,error,*999)

    CALL EXITS("CMISSField_LabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSField_LabelSetVSObj",err,error)
    CALL EXITS("CMISSField_LabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the interpolation type for a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_PositionNormalTangentCalculateNodeNumber(regionUserNumber,fieldUserNumber,variableType,componentNumber, &
    & localNodeNumber,position,normal,tangents,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number of the field variable to get the data type for.
    REAL(DP), INTENT(OUT) :: position(:),normal(:),tangents(:,:) !<Actual useful outputs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_PositionNormalTangentCalculateNodeNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_NODE(FIELD,variableType,componentNumber,localNodeNumber, &
          & position,normal,tangents,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_PositionNormalTangentCalculateNodeNumber")
    RETURN
999 CALL ERRORS("CMISSField_PositionNormalTangentCalculateNodeNumber",err,error)
    CALL EXITS("CMISSField_PositionNormalTangentCalculateNodeNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_PositionNormalTangentCalculateNodeNumber

  !
  !================================================================================================================================
  !

  !>Returns the position, normal and tangents for a field node for a field identified by an object.
  SUBROUTINE CMISSField_PositionNormalTangentCalculateNodeObj(field,variableType,componentNumber,localNodeNumber, &
    & position,normal,tangents,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the interpolation type for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the interpolation type for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data type for.
    INTEGER(INTG), INTENT(IN) :: localNodeNumber !<The local node number of the field variable to get the data type for.
    REAL(DP), INTENT(OUT) :: position(:),normal(:),tangents(:,:) !<Actual useful outputs
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_PositionNormalTangentCalculateNodeObj",err,error,*999)

    CALL FIELD_POSITION_NORMAL_TANGENTS_CALCULATE_NODE(field%FIELD,variableType,componentNumber,localNodeNumber, &
    & position,normal,tangents,err,error,*999)

    CALL EXITS("CMISSField_PositionNormalTangentCalculateNodeObj")
    RETURN
999 CALL ERRORS("CMISSField_PositionNormalTangentCalculateNodeObj",err,error)
    CALL EXITS("CMISSField_PositionNormalTangentCalculateNodeObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_PositionNormalTangentCalculateNodeObj



  !
  !================================================================================================================================
  !

  !>Returns the mesh decomposition for a field identified by a user number.
  SUBROUTINE CMISSField_MeshDecompositionGetNumber(regionUserNumber,fieldUserNumber,decompositionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the mesh decomposition for.
    INTEGER(INTG), INTENT(OUT) :: decompositionUserNumber !<On return, the field decomposition user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_MeshDecompositionGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_MESH_DECOMPOSITION_GET(FIELD,DECOMPOSITION,err,error,*999)
        decompositionUserNumber=DECOMPOSITION%USER_NUMBER
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_MeshDecompositionGetNumber")
    RETURN
999 CALL ERRORS("CMISSField_MeshDecompositionGetNumber",err,error)
    CALL EXITS("CMISSField_MeshDecompositionGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_MeshDecompositionGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the mesh decomposition for a field identified by an object.
  SUBROUTINE CMISSField_MeshDecompositionGetObj(field,meshDecomposition,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the mesh decomposition for.
    TYPE(CMISSDecompositionType), INTENT(INOUT) :: meshDecomposition !<On return, the mesh decomposition for the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_MeshDecompositionGetObj",err,error,*999)

    CALL FIELD_MESH_DECOMPOSITION_GET(field%FIELD,meshDecomposition%DECOMPOSITION,err,error,*999)

    CALL EXITS("CMISSField_MeshDecompositionGetObj")
    RETURN
999 CALL ERRORS("CMISSField_MeshDecompositionGetObj",err,error)
    CALL EXITS("CMISSField_MeshDecompositionGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_MeshDecompositionGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh decomposition for a field identified by a user number.
  SUBROUTINE CMISSField_MeshDecompositionSetNumber(regionUserNumber,fieldUserNumber,meshUserNumber,decompositionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The field mesh decomposition user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_MeshDecompositionSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(DECOMPOSITION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
        IF(ASSOCIATED(MESH)) THEN
          CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
          IF(ASSOCIATED(DECOMPOSITION)) THEN
            CALL FIELD_MESH_DECOMPOSITION_SET(FIELD,DECOMPOSITION,err,error,*999)
          ELSE
            LOCAL_ERROR="A decomposition with a user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
              & " does not exist on mesh number "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
          END IF
        ELSE
          LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_MeshDecompositionSetNumber")
    RETURN
999 CALL ERRORS("CMISSField_MeshDecompositionSetNumber",err,error)
    CALL EXITS("CMISSField_MeshDecompositionSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_MeshDecompositionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh decomposition for a field identified by an object.
  SUBROUTINE CMISSField_MeshDecompositionSetObj(field,meshDecomposition,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the mesh decomposition for.
    TYPE(CMISSDecompositionType), INTENT(IN) :: meshDecomposition !<The mesh decomposition for the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_MeshDecompositionSetObj",err,error,*999)

    CALL FIELD_MESH_DECOMPOSITION_SET(field%FIELD,meshDecomposition%DECOMPOSITION,err,error,*999)

    CALL EXITS("CMISSField_MeshDecompositionSetObj")
    RETURN
999 CALL ERRORS("CMISSField_MeshDecompositionSetObj",err,error)
    CALL EXITS("CMISSField_MeshDecompositionSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_MeshDecompositionSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the data projection for a field identified by a user number.
  SUBROUTINE CMISSField_DataProjectionSetNumber(regionUserNumber,fieldUserNumber,dataProjectionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the mesh decomposition for.
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The field data projection user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DATA_POINTS_TYPE), POINTER :: DATA_POINTS
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DATA_PROJECTION
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    INTEGER(INTG) :: DATA_PROJECTION_NUMBER
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_DataProjectionSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(DATA_POINTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL REGION_DATA_POINTS_GET(REGION,DATA_POINTS,err,error,*999)
        IF(ASSOCIATED(DATA_POINTS)) THEN
          CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(DATA_POINTS,dataProjectionUserNumber,DATA_PROJECTION_NUMBER,&
           & err,ERROR,*999)
          CALL DATA_POINTS_DATA_PROJECTION_GET(DATA_POINTS,DATA_PROJECTION_NUMBER,DATA_PROJECTION,Err,ERROR,*999)
          IF(ASSOCIATED(DATA_PROJECTION)) THEN
            CALL Field_DataProjectionSet(FIELD,DATA_PROJECTION,err,error,*999)
          ELSE
            localError="A data projection does not exist for the data points on region number "// &
             & TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
            CALL FLAG_ERROR(localError,err,error,*999)
          END IF
        ELSE
          localError="Data points do not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        END IF
      ELSE
        localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_DataProjectionSetNumber")
    RETURN
999 CALL ERRORS("CMISSField_DataProjectionSetNumber",err,error)
    CALL EXITS("CMISSField_DataProjectionSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DataProjectionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the data projection for a field identified by an object.
  SUBROUTINE CMISSField_DataProjectionSetObj(field,dataProjection,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the mesh decomposition for.
    TYPE(CMISSDataProjectionType), INTENT(IN) :: dataProjection !<The data projection for the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_DataProjectionSetObj",err,error,*999)

    CALL Field_DataProjectionSet(field%FIELD,dataProjection%DATA_PROJECTION,err,error,*999)

    CALL EXITS("CMISSField_DataProjectionSetObj")
    RETURN
999 CALL ERRORS("CMISSField_DataProjectionSetObj",err,error)
    CALL EXITS("CMISSField_DataProjectionSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_DataProjectionSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of componenets for a field variable for a field identified by a user number.
  SUBROUTINE CMISSField_NumberOfComponentsGetNumber(regionUserNumber,fieldUserNumber,variableType,numberOfComponents,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to get the number of components for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the field variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_NumberOfComponentsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_NUMBER_OF_COMPONENTS_GET(FIELD,variableType,numberOfComponents,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_NumberOfComponentsGetNumber")
    RETURN
999 CALL ERRORS("CMISSField_NumberOfComponentsGetNumber",err,error)
    CALL EXITS("CMISSField_NumberOfComponentsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_NumberOfComponentsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of components for a field variable for a field identified by an object.
  SUBROUTINE CMISSField_NumberOfComponentsGetObj(field,variableType,numberOfComponents,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to get the number of components for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the field variable.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_NumberOfComponentsGetObj",err,error,*999)

    CALL FIELD_NUMBER_OF_COMPONENTS_GET(field%FIELD,variableType,numberOfComponents,err,error,*999)

    CALL EXITS("CMISSField_NumberOfComponentsGetObj")
    RETURN
999 CALL ERRORS("CMISSField_NumberOfComponentsGetObj",err,error)
    CALL EXITS("CMISSField_NumberOfComponentsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_NumberOfComponentsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of componenets for a field variable for a field identified by a user number.
  SUBROUTINE CMISSField_NumberOfComponentsSetNumber(regionUserNumber,fieldUserNumber,variableType,numberOfComponents,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the number of components for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the field variable to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_NumberOfComponentsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_NUMBER_OF_COMPONENTS_SET(FIELD,variableType,numberOfComponents,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_NumberOfComponentsSetNumber")
    RETURN
999 CALL ERRORS("CMISSField_NumberOfComponentsSetNumber",err,error)
    CALL EXITS("CMISSField_NumberOfComponentsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_NumberOfComponentsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of components for a field variable for a field identified by an object.
  SUBROUTINE CMISSField_NumberOfComponentsSetObj(field,variableType,numberOfComponents,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent field to set the number of components for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the field variable to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_NumberOfComponentsSetObj",err,error,*999)

    CALL FIELD_NUMBER_OF_COMPONENTS_SET(field%FIELD,variableType,numberOfComponents,err,error,*999)

    CALL EXITS("CMISSField_NumberOfComponentsSetObj")
    RETURN
999 CALL ERRORS("CMISSField_NumberOfComponentsSetObj",err,error)
    CALL EXITS("CMISSField_NumberOfComponentsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_NumberOfComponentsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of variables for a field identified by a user number.
  SUBROUTINE CMISSField_NumberOfVariablesGetNumber(regionUserNumber,fieldUserNumber,numberOfVariables,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the number of variables for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the number of variables for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVariables !<On return, the number of variables in the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_NumberOfVariablesGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_NUMBER_OF_VARIABLES_GET(FIELD,numberOfVariables,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_NumberOfVariablesGetNumber")
    RETURN
999 CALL ERRORS("CMISSField_NumberOfVariablesGetNumber",err,error)
    CALL EXITS("CMISSField_NumberOfVariablesGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_NumberOfVariablesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of variables for a field identified by an object.
  SUBROUTINE CMISSField_NumberOfVariablesGetObj(field,numberOfVariables,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the number of variables for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVariables !<On return, the number of variables in the field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_NumberOfVariablesGetObj",err,error,*999)

    CALL FIELD_NUMBER_OF_VARIABLES_GET(field%FIELD,numberOfVariables,err,error,*999)

    CALL EXITS("CMISSField_NumberOfVariablesGetObj")
    RETURN
999 CALL ERRORS("CMISSField_NumberOfVariablesGetObj",err,error)
    CALL EXITS("CMISSField_NumberOfVariablesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_NumberOfVariablesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/chnages the number of variables for a field identified by a user number.
  SUBROUTINE CMISSField_NumberOfVariablesSetNumber(regionUserNumber,fieldUserNumber,numberOfVariables,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: numberOfVariables !<The number of variables in the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_NumberOfVariablesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_NUMBER_OF_VARIABLES_SET(FIELD,numberOfVariables,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_NumberOfVariablesSetNumber")
    RETURN
999 CALL ERRORS("CMISSField_NumberOfVariablesSetNumber",err,error)
    CALL EXITS("CMISSField_NumberOfVariablesSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_NumberOfVariablesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of variables for a field identified by an object.
  SUBROUTINE CMISSField_NumberOfVariablesSetObj(field,numberOfVariables,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the number of variables for.
    INTEGER(INTG), INTENT(IN) :: numberOfVariables !<The number of variables in the field to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_NumberOfVariablesSetObj",err,error,*999)

    CALL FIELD_NUMBER_OF_VARIABLES_SET(field%FIELD,numberOfVariables,err,error,*999)

    CALL EXITS("CMISSField_NumberOfVariablesSetObj")
    RETURN
999 CALL ERRORS("CMISSField_NumberOfVariablesSetObj",err,error)
    CALL EXITS("CMISSField_NumberOfVariablesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_NumberOfVariablesSetObj

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetAddConstantIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetAddConstantIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetAddConstantIntgNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddConstantIntgNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetAddConstantIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddConstantIntgNumber

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetAddConstantIntgObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the field parameter set.
     INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetAddConstantIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetAddConstantIntgObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddConstantIntgObj",err,error)
    CALL EXITS("CMISSField_ParameterSetAddConstantIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddConstantIntgObj

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetAddConstantSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(SP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetAddConstantSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetAddConstantSPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddConstantSPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetAddConstantSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddConstantSPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetAddConstantSPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(SP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetAddConstantSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetAddConstantSPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddConstantSPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetAddConstantSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddConstantSPObj

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetAddConstantDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(DP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetAddConstantDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetAddConstantDPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddConstantDPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetAddConstantDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddConstantDPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetAddConstantDPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    REAL(DP), INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetAddConstantDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetAddConstantDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddConstantDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetAddConstantDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddConstantDPObj

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetAddConstantLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    LOGICAL, INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetAddConstantLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetAddConstantLNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddConstantLNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetAddConstantLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddConstantLNumber

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to the given parameter set for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetAddConstantLObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the constant to the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the constant to the field parameter set for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the constant to the field parameter set for.
    LOGICAL, INTENT(IN) :: value !<The value to add to the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetAddConstantLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSFieldParameterSetAddConstantLbj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddConstantLObj",err,error)
    CALL EXITS("CMISSField_ParameterSetAddConstantLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddConstantLObj

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetAddElementIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetAddElementIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetAddElementIntgNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddElementIntgNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetAddElementIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddElementIntgNumber

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetAddElementIntgObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: UserElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetAddElementIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_ELEMENT(field%FIELD,variableType,fieldSetType,UserElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSField_ParameterSetAddElementIntgObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddElementIntgObj",err,error)
    CALL EXITS("CMISSField_ParameterSetAddElementIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddElementIntgObj

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetAddElementSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetAddElementSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetAddElementSPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddElementSPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetAddElementSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddElementSPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetAddElementSPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetAddElementSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSField_ParameterSetAddElementSPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddElementSPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetAddElementSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddElementSPObj

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetAddElementDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetAddElementDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetAddElementDPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddElementDPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetAddElementDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddElementDPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetAddElementDPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetAddElementDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSField_ParameterSetAddElementDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddElementDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetAddElementDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddElementDPObj

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an element in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetAddElementLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetAddElementLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetAddElementLNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddElementLNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetAddElementLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddElementLNumber

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an element in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetAddElementLObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the value to the element in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the element in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the element. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the element to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the element in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetAddElementLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSField_ParameterSetAddElementLObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddElementLObj",err,error)
    CALL EXITS("CMISSField_ParameterSetAddElementLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddElementLObj

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetAddNodeIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,versionNumber, &
    & derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetAddNodeIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetAddNodeIntgNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddNodeIntgNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetAddNodeIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddNodeIntgNumber

  !
  !================================================================================================================================
  !

  !>Adds the given integer value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetAddNodeIntgObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetAddNodeIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetAddNodeIntgObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddNodeIntgObj",err,error)
    CALL EXITS("CMISSField_ParameterSetAddNodeIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddNodeIntgObj

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetAddNodeSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,versionNumber, &
    & derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetAddNodeSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetAddNodeSPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddNodeSPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetAddNodeSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddNodeSPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given single precision value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetAddNodeSPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetAddNodeSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetAddNodeSPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddNodeSPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetAddNodeSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddNodeSPObj

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetAddNodeDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,versionNumber, &
    & derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetAddNodeDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetAddNodeDPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddNodeDPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetAddNodeDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddNodeDPNumber

  !
  !================================================================================================================================
  !

  !>Adds the given double precision value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetAddNodeDPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetAddNodeDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetAddNodeDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddNodeDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetAddNodeDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddNodeDPObj

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an node in the given parameter set for field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetAddNodeLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,versionNumber, &
    & derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetAddNodeLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_ADD_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetAddNodeLNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddNodeLNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetAddNodeLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddNodeLNumber

  !
  !================================================================================================================================
  !

  !>Adds the given logical value to an node in the given parameter set for field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetAddNodeLObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber, value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to add the value to the node in the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to add the value to the node in the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to add the value to the node. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The node derivative version number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The node derivative number of the node to add the value to.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to add the value to.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to add the value to the node to in the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to add to the node in the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetAddNodeLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_ADD_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber, value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetAddNodeLObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetAddNodeLObj",err,error)
    CALL EXITS("CMISSField_ParameterSetAddNodeLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetAddNodeLObj

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type set type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetCreateNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to create the parameter set on.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to create the parameter set on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to create the parameter set on. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to create. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetCreateNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_CREATE(FIELD,variableType,fieldSetType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetCreateNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetCreateNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetCreateNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetCreateNumber

  !
  !================================================================================================================================
  !

  !>Creates a new parameter set of type set type for a field variable for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetCreateObj(field,variableType,fieldSetType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to create the field parameter set on.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to create the parameter set on. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to create. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetCreateObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_CREATE(field%FIELD,variableType,fieldSetType,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetCreateObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetCreateObj",err,error)
    CALL EXITS("CMISSField_ParameterSetCreateObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetCreateObj

  !
  !================================================================================================================================
  !

  !>Destroys the specified parameter set type for a field variable for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetDestroyNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to destroy the parameter set for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to destroy the parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to destroy the parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to destroy. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DESTROY(FIELD,variableType,fieldSetType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDestroyNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the specified parameter set type for a field variable for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetDestroyObj(field,variableType,fieldSetType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to destroy the field parameter set for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to destroy the parameter set for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to destroy. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetDestroyObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DESTROY(field%FIELD,variableType,fieldSetType,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetDestroyObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDestroyObj",err,error)
    CALL EXITS("CMISSField_ParameterSetDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local integer data array for a field identified by an user number. The pointer must be restored with a call to OPENCMISS::CMISSField_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSField_ParameterSetDataGetIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetDataGetIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_GET(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetDataGetIntgNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDataGetIntgNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetDataGetIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDataGetIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local integer data array for a field identified by an object. The pointer must be restored with a call to OPENCMISS::CMISSField_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSField_ParameterSetDataGetIntgObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetDataGetIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_GET(field%FIELD,variableType,fieldSetType,parameters,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetDataGetIntgObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDataGetIntgObj",err,error)
    CALL EXITS("CMISSField_ParameterSetDataGetIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDataGetIntgObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local single precision data array for a field identified by an user number. The pointer must be restored with a call to OPENCMISS::CMISSField_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSField_ParameterSetDataGetSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetDataGetSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_GET(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetDataGetSPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDataGetSPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetDataGetSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDataGetSPNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local single precision data array for a field identified by an object. The pointer must be restored with a call to OPENCMISS::CMISSField_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSField_ParameterSetDataGetSPObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetDataGetSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_GET(field%FIELD,variableType,fieldSetType,parameters,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetDataGetSPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDataGetSPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetDataGetSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDataGetSPObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local double precision data array for a field identified by an user number. The pointer must be restored with a call to OPENCMISS::CMISSField_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSField_ParameterSetDataGetDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetDataGetDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_GET(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetDataGetDPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDataGetDPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetDataGetDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDataGetDPNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local double precision data array for a field identified by an object. The pointer must be restored with a call to OPENCMISS::CMISSField_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSField_ParameterSetDataGetDPObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetDataGetDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_GET(field%FIELD,variableType,fieldSetType,parameters,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetDataGetDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDataGetDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetDataGetDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDataGetDPObj

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local logical data array for a field identified by an user number. The pointer must be restored with a call to OPENCMISS::CMISSField_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSField_ParameterSetDataGetLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetDataGetLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_GET(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetDataGetLNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDataGetLNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetDataGetLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDataGetLNumber

  !
  !================================================================================================================================
  !

  !>Returns a pointer to the specified field parameter set local logical data array for a field identified by an object. The pointer must be restored with a call to OPENCMISS::CMISSField_ParameterSetDataRestore call. Note: the values can be used for read operations but a field parameter set update or add calls must be used to change any values.
  SUBROUTINE CMISSField_ParameterSetDataGetLObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to get. \see OPENCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(OUT), POINTER :: parameters(:) !<On return, a pointer to the parameter set data.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetDataGetLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_GET(field%FIELD,variableType,fieldSetType,parameters,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetDataGetLObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDataGetLObj",err,error)
    CALL EXITS("CMISSField_ParameterSetDataGetLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDataGetLObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local integer array that was obtained with an OPENCMISS::CMISSField_ParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE CMISSField_ParameterSetDataRestoreIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetDataRestoreIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetDataRestoreIntgNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDataRestoreIntgNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetDataRestoreIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDataRestoreIntgNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local integer array that was obtained with an OPENCMISS::CMISSField_ParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE CMISSField_ParameterSetDataRestoreIntgObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetDataRestoreIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_RESTORE(field%FIELD,variableType,fieldSetType,parameters,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetDataRestoreIntgObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDataRestoreIntgObj",err,error)
    CALL EXITS("CMISSField_ParameterSetDataRestoreIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDataRestoreIntgObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local single precision array that was obtained with an OPENCMISS::CMISSField_ParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE CMISSField_ParameterSetDataRestoreSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetDataRestoreSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetDataRestoreSPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDataRestoreSPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetDataRestoreSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDataRestoreSPNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local single precision array that was obtained with an OPENCMISS::CMISSField_ParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE CMISSField_ParameterSetDataRestoreSPObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    REAL(SP), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetDataRestoreSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_RESTORE(field%FIELD,variableType,fieldSetType,parameters,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetDataRestoreSPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDataRestoreSPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetDataRestoreSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDataRestoreSPObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local double precision array that was obtained with an OPENCMISS::CMISSField_ParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE CMISSField_ParameterSetDataRestoreDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetDataRestoreDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetDataRestoreDPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDataRestoreDPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetDataRestoreDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDataRestoreDPNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local double precision array that was obtained with an OPENCMISS::CMISSField_ParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE CMISSField_ParameterSetDataRestoreDPObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetDataRestoreDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_RESTORE(field%FIELD,variableType,fieldSetType,parameters,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetDataRestoreDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDataRestoreDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetDataRestoreDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDataRestoreDPObj

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local logical array that was obtained with an OPENCMISS::CMISSField_ParameterSetDataGet call for a field that is specified with an user number.
  SUBROUTINE CMISSField_ParameterSetDataRestoreLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,parameters,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to restore the parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetDataRestoreLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_DATA_RESTORE(FIELD,variableType,fieldSetType,parameters,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetDataRestoreLNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDataRestoreLNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetDataRestoreLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDataRestoreLNumber

  !
  !================================================================================================================================
  !

  !>Restores the specified field variable parameter set local logical array that was obtained with an OPENCMISS::CMISSField_ParameterSetDataGet call for a field that is specified with an object.
  SUBROUTINE CMISSField_ParameterSetDataRestoreLObj(field,variableType,fieldSetType,parameters,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to restore the field parameter set data for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to restore the parameter set data for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the parameter set data to restore. \see OPENCMISS_FieldParameterSetTypes
    LOGICAL, INTENT(INOUT), POINTER :: parameters(:) !<A pointer to the parameter set data to restore. On return this pointer is null.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetDataRestoreLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_DATA_RESTORE(field%FIELD,variableType,fieldSetType,parameters,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetDataRestoreLObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetDataRestoreLObj",err,error)
    CALL EXITS("CMISSField_ParameterSetDataRestoreLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetDataRestoreLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetConstantIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetGetConstantIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,Value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetConstantIntgNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetConstantIntgNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetGetConstantIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetConstantIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetGetConstantIntgObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetConstantIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetConstantIntgObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetConstantIntgObj",err,error)
    CALL EXITS("CMISSField_ParameterSetGetConstantIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetConstantIntgObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetConstantSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetGetConstantSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetConstantSPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetConstantSPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetGetConstantSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetConstantSPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetGetConstantSPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetConstantSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetConstantSPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetConstantSPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetGetConstantSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetConstantSPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetConstantDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetGetConstantDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetConstantDPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetConstantDPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetGetConstantDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetConstantDPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetGetConstantDPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetConstantDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetConstantDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetConstantDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetGetConstantDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetConstantDPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetConstantLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetGetConstantLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetConstantLNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetConstantLNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetGetConstantLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetConstantLNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetGetConstantLObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the constant value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the constant value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the constant value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the constant value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetConstantLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetConstantLObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetConstantLObj",err,error)
    CALL EXITS("CMISSField_ParameterSetGetConstantLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetConstantLObj
  
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a integer value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetDataPointIntgNumberI(parentRegionUserNumber,interfaceUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetGetDataPointIntgNumberI",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,Err,ERROR,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,error,*999)
        IF(ASSOCIATED(field)) THEN
          CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
            & err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetDataPointIntgNumberI")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetDataPointIntgNumberI",err,error)
    CALL EXITS("CMISSField_ParameterSetGetDataPointIntgNumberI")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetDataPointIntgNumberI
  
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a integer value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetDataPointIntgNumberR(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetGetDataPointIntgNumberR",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetDataPointIntgNumberR")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetDataPointIntgNumberR",err,error)
    CALL EXITS("CMISSField_ParameterSetGetDataPointIntgNumberR")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetDataPointIntgNumberR

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a integer value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetGetDataPointIntgObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetDataPointIntgObj",err,error,*999)

    CALL Field_ParameterSetGetDataPoint(field%FIELD,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetDataPointIntgObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetDataPointIntgObj",err,error)
    CALL EXITS("CMISSField_ParameterSetGetDataPointIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetDataPointIntgObj
  
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetDataPointSPNumberI(parentRegionUserNumber,interfaceUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetGetDataPointSPNumberI",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,Err,ERROR,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,error,*999)
        IF(ASSOCIATED(field)) THEN
          CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
            & err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetDataPointSPNumberI")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetDataPointSPNumberI",err,error)
    CALL EXITS("CMISSField_ParameterSetGetDataPointSPNumberI")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetDataPointSPNumberI
  
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetDataPointSPNumberR(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetGetDataPointSPNumberR",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetDataPointSPNumberR")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetDataPointSPNumberR",err,error)
    CALL EXITS("CMISSField_ParameterSetGetDataPointSPNumberR")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetDataPointSPNumberR

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetGetDataPointSPObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetDataPointSPObj",err,error,*999)

    CALL Field_ParameterSetGetDataPoint(field%FIELD,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetDataPointSPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetDataPointSPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetGetDataPointSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetDataPointSPObj
  
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetDataPointDPNumberI(parentRegionUserNumber,interfaceUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetGetDataPointDPNumberI",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,Err,ERROR,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,error,*999)
        IF(ASSOCIATED(field)) THEN
          CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
            & err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetDataPointDPNumberI")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetDataPointDPNumberI",err,error)
    CALL EXITS("CMISSField_ParameterSetGetDataPointDPNumberI")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetDataPointDPNumberI
  
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetDataPointDPNumberR(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetGetDataPointDPNumberR",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetDataPointDPNumberR")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetDataPointDPNumberR",err,error)
    CALL EXITS("CMISSField_ParameterSetGetDataPointDPNumberR")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetDataPointDPNumberR

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetGetDataPointDPObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetDataPointDPObj",err,error,*999)

    CALL Field_ParameterSetGetDataPoint(field%FIELD,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetDataPointDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetDataPointDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetGetDataPointDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetDataPointDPObj
  
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetDataPointLNumberI(parentRegionUserNumber,interfaceUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetGetDataPointLNumberI",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,Err,ERROR,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,error,*999)
        IF(ASSOCIATED(field)) THEN
          CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
            & err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetDataPointLNumberI")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetDataPointLNumberI",err,error)
    CALL EXITS("CMISSField_ParameterSetGetDataPointLNumberI")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetDataPointLNumberI
  
  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetDataPointLNumberR(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetGetDataPointLNumberR",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetGetDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetDataPointLNumberR")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetDataPointLNumberR",err,error)
    CALL EXITS("CMISSField_ParameterSetGetDataPointLNumberR")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetDataPointLNumberR

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetGetDataPointLObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to get the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the data point value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetDataPointLObj",err,error,*999)

    CALL Field_ParameterSetGetDataPoint(field%FIELD,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetDataPointLObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetDataPointLObj",err,error)
    CALL EXITS("CMISSField_ParameterSetGetDataPointLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetDataPointLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetElementIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetGetElementIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetElementIntgNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetElementIntgNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetGetElementIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetElementIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetGetElementIntgObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetElementIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetElementIntgObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetElementIntgObj",err,error)
    CALL EXITS("CMISSField_ParameterSetGetElementIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetElementIntgObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetElementSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetGetElementSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetElementSPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetElementSPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetGetElementSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetElementSPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetGetElementSPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetElementSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetElementSPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetElementSPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetGetElementSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetElementSPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetElementDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetGetElementDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetElementDPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetElementDPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetGetElementDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetElementDPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetGetElementDPObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetElementDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetElementDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetElementDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetGetElementDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetElementDPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified element of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetElementLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetGetElementLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetElementLNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetElementLNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetGetElementLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetElementLNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetGetElementLObj(field,variableType,fieldSetType,userElementNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetElementLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,VALUE, &
      & err,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetElementLObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetElementLObj",err,error)
    CALL EXITS("CMISSField_ParameterSetGetElementLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetElementLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetNodeIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetGetNodeIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetNodeIntgNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetNodeIntgNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetGetNodeIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetNodeIntgNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set an integer value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetGetNodeIntgObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetNodeIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetNodeIntgObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetNodeIntgObj",err,error)
    CALL EXITS("CMISSField_ParameterSetGetNodeIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetNodeIntgObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetNodeSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetGetNodeSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetNodeSPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetNodeSPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetGetNodeSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetNodeSPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a single precision value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetGetNodeSPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(SP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetNodeSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetNodeSPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetNodeSPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetGetNodeSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetNodeSPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetNodeDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetGetNodeDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetNodeDPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetNodeDPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetGetNodeDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetNodeDPNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetGetNodeDPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetNodeDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber, value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetNodeDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetNodeDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetGetNodeDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetNodeDPObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified node and derivative of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetGetNodeLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetGetNodeLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_GET_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber, value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetGetNodeLNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetNodeLNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetGetNodeLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetNodeLNumber

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a logical value for the specified node and derivative of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetGetNodeLObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the nodal value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the nodal value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the nodal value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the nodal value from the field parameter set.
    LOGICAL, INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetNodeLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
      & componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetNodeLObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetNodeLObj",err,error)
    CALL EXITS("CMISSField_ParameterSetGetNodeLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetNodeLObj

  !
  !================================================================================================================================
  !

  !>Returns from the given parameter set a double precision value for the specified element of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetGetGaussPointDPObj(field,variableType,fieldSetType,&
    & userElementNumber,gaussPointNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the element value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the element value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to get the element value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The gauss point number number to get the value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to get the element value from the field parameter set.
    REAL(DP), INTENT(OUT) :: value !<On return, the value from the field parameter set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetGaussPointDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_GAUSS_POINT(field%FIELD,variableType,fieldSetType,userElementNumber,gaussPointNumber,&
    & componentNumber,value, err,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetGaussPointDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetGetGaussPointDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetGetGaussPointDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetGetGaussPointDPObj
  !
  !================================================================================================================================
  !


  !>Updates the given parameter set with the given integer value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateConstantIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetUpdateConstantIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateConstantIntgNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateConstantIntgNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateConstantIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateConstantIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetUpdateConstantIntgObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateConstantIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateConstantIntgObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateConstantIntgObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateConstantIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateConstantIntgObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateConstantSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetUpdateConstantSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateConstantSPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateConstantSPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateConstantSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateConstantSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetUpdateConstantSPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateConstantSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,Value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateConstantSPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateConstantSPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateConstantSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateConstantSPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateConstantDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetUpdateConstantDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateConstantDPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateConstantDPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateConstantDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateConstantDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetUpdateConstantDPObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateConstantDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateConstantDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateConstantDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateConstantDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateConstantDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the constant of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateConstantLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetUpdateConstantLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateConstantLNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateConstantLNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateConstantLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateConstantLNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the constant of the field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetUpdateConstantLObj(field,variableType,fieldSetType,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateConstantLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_CONSTANT(field%FIELD,variableType,fieldSetType,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateConstantLObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateConstantLObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateConstantLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateConstantLObj
  
  !
  !================================================================================================================================
  !

  !>Update the given parameter set a integer value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateDataPointIntgNumberI(parentRegionUserNumber,interfaceUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetUpdateDataPointIntgNumberI",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,Err,ERROR,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,error,*999)
        IF(ASSOCIATED(field)) THEN
          CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
            & err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateDataPointIntgNumberI")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateDataPointIntgNumberI",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateDataPointIntgNumberI")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateDataPointIntgNumberI
  
  !
  !================================================================================================================================
  !

  !>Update the given parameter set a integer value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateDataPointIntgNumberR(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetUpdateDataPointIntgNumberR",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateDataPointIntgNumberR")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateDataPointIntgNumberR",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateDataPointIntgNumberR")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateDataPointIntgNumberR

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a integer value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetUpdateDataPointIntgObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateDataPointIntgObj",err,error,*999)

    CALL Field_ParameterSetUpdateDataPoint(field%FIELD,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateDataPointIntgObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateDataPointIntgObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateDataPointIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateDataPointIntgObj
  
  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateDataPointSPNumberI(parentRegionUserNumber,interfaceUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetUpdateDataPointSPNumberI",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,Err,ERROR,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,error,*999)
        IF(ASSOCIATED(field)) THEN
          CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
            & err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateDataPointSPNumberI")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateDataPointSPNumberI",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateDataPointSPNumberI")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateDataPointSPNumberI
  
  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateDataPointSPNumberR(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetUpdateDataPointSPNumberR",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateDataPointSPNumberR")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateDataPointSPNumberR",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateDataPointSPNumberR")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateDataPointSPNumberR

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a single precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetUpdateDataPointSPObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateDataPointSPObj",err,error,*999)

    CALL Field_ParameterSetUpdateDataPoint(field%FIELD,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateDataPointSPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateDataPointSPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateDataPointSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateDataPointSPObj
  
  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateDataPointDPNumberI(parentRegionUserNumber,interfaceUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetUpdateDataPointDPNumberI",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,Err,ERROR,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,error,*999)
        IF(ASSOCIATED(field)) THEN
          CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
            & err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateDataPointDPNumberI")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateDataPointDPNumberI",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateDataPointDPNumberI")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateDataPointDPNumberI
  
  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateDataPointDPNumberR(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetUpdateDataPointDPNumberR",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateDataPointDPNumberR")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateDataPointDPNumberR",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateDataPointDPNumberR")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateDataPointDPNumberR

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a double precision value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetUpdateDataPointDPObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateDataPointDPObj",err,error,*999)

    CALL Field_ParameterSetUpdateDataPoint(field%FIELD,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateDataPointDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateDataPointDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateDataPointDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateDataPointDPObj
  
  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateDataPointLNumberI(parentRegionUserNumber,interfaceUserNumber,fieldUserNumber, &
    & variableType,fieldSetType,userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region for the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetUpdateDataPointLNumberI",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,Err,ERROR,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,interface,field,err,error,*999)
        IF(ASSOCIATED(field)) THEN
          CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
            & err,error,*999)
        ELSE
          localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateDataPointLNumberI")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateDataPointLNumberI",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateDataPointLNumberI")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateDataPointLNumberI
  
  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified data point of a field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateDataPointLNumberR(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userDataPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSField_ParameterSetUpdateDataPointLNumberR",err,error,*999)

    NULLIFY(region)
    NULLIFY(field)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
      IF(ASSOCIATED(field)) THEN
        CALL Field_ParameterSetUpdateDataPoint(field,variableType,fieldSetType,userDataPointNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        localError="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateDataPointLNumberR")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateDataPointLNumberR",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateDataPointLNumberR")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateDataPointLNumberR

  !
  !================================================================================================================================
  !

  !>Update the given parameter set a logical value for the specified constant of a field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetUpdateDataPointLObj(field,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the data point value from the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the data point value from the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the data point value from. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userDataPointNumber  !<The user data point number to update the value for
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the data point value from the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateDataPointLObj",err,error,*999)

    CALL Field_ParameterSetUpdateDataPoint(field%FIELD,variableType,fieldSetType,userDataPointNumber,componentNumber, &
      & value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateDataPointLObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateDataPointLObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateDataPointLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateDataPointLObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateElementIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetUpdateElementIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateElementIntgNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateElementIntgNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateElementIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateElementIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the element of the field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetUpdateElementIntgObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateElementIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateElementIntgObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateElementIntgObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateElementIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateElementIntgObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateElementSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetUpdateElementSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateElementSPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateElementSPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateElementSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateElementSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the element of the field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetUpdateElementSPObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateElementSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateElementSPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateElementSPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateElementSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateElementSPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateElementDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    REAL(DP), INTENT(IN) :: Value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetUpdateElementDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,Value, &
          & err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateElementDPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateElementDPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateElementDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateElementDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element of the field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetUpdateElementDPObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: VALUE !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateElementDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateElementDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateElementDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateElementDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateElementDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the element of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateElementLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the element value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the element value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the element value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the element value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetUpdateElementLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
          & err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateElementLNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateElementLNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateElementLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateElementLNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the element of the field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetUpdateElementLObj(field,variableType,fieldSetType,userElementNumber,componentNumber, &
    & value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateElementLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_ELEMENT(field%FIELD,variableType,fieldSetType,userElementNumber,componentNumber,value, &
      & err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateElementLObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateElementLObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateElementLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateElementLObj

  !
  !================================================================================================================================
  !

  !>Finishes the parameter set update for a field variable for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateFinishNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to finish the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to finish the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to finish the parameter set update for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to finish the update for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetUpdateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_FINISH(FIELD,variableType,fieldSetType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateFinishNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the parameter set update for a field variable for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetUpdateFinishObj(field,variableType,fieldSetType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to finishe the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to finish the parameter set update for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to finish the update for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateFinishObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_FINISH(field%FIELD,variableType,fieldSetType,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateFinishObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateFinishObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateFinishObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateNodeIntgNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetUpdateNodeIntgNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateNodeIntgNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateNodeIntgNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateNodeIntgNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateNodeIntgNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given integer value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE CMISSField_ParameterSetUpdateNodeIntgObj(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber,componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateNodeIntgObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber, value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateNodeIntgObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateNodeIntgObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateNodeIntgObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateNodeIntgObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateNodeSPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetUpdateNodeSPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
          & componentNumber, value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateNodeSPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateNodeSPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateNodeSPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateNodeSPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given single precision value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE CMISSField_ParameterSetUpdateNodeSPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber, &
    & userNodeNumber, componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(SP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateNodeSPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber, value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateNodeSPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateNodeSPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateNodeSPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateNodeSPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateNodeDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetUpdateNodeDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber, &
          & userNodeNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateNodeDPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateNodeDPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateNodeDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateNodeDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE CMISSField_ParameterSetUpdateNodeDPObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateNodeDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateNodeDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateNodeDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateNodeDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateNodeDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the node and derivative of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateNodeLNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & versionNumber,derivativeNumber,userNodeNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetUpdateNodeLNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_NODE(FIELD,variableType,fieldSetType,versionNumber,derivativeNumber, &
          & userNodeNumber,componentNumber,value,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateNodeLNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateNodeLNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateNodeLNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateNodeLNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given logical value for the node and derivative of the field variable component for a field identified by an object.

  SUBROUTINE CMISSField_ParameterSetUpdateNodeLObj(field,variableType,fieldSetType,versionNumber,derivativeNumber,userNodeNumber, &
    & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the nodal value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the nodal value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the nodal value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The derivative version number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the nodal value for the field parameter set.
    LOGICAL, INTENT(IN) :: value !<The value to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateNodeLObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_NODE(field%FIELD,variableType,fieldSetType,versionNumber,derivativeNumber, &
      & userNodeNumber,componentNumber, value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateNodeLObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateNodeLObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateNodeLObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateNodeLObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given values for all local dofs of the field variable identified by an object..
  SUBROUTINE CMISSField_ParameterSetUpdateLocalDofsDPObj(field,variableType,fieldSetType,values,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the values for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update values for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update values for. \see OPENCMISS_FieldParameterSetTypes
    REAL(DP), INTENT(IN) :: values(:) !<The values to update the field parameter set to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateLocalDofsDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_LOCAL_DOFS(field%FIELD,variableType,fieldSetType,values,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateLocalDofsDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateLocalDofsDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateLocalDofsDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateLocalDofsDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element gauss point of the field variable component for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateGaussPointDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & userElementNumber,gaussPointNumber,componentNumber,value,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetUpdateGaussPointDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_GAUSS_POINT(FIELD,variableType,fieldSetType,userElementNumber,gaussPointNumber, &
      & componentNumber,value, err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateGaussPointDPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateGaussPointDPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateGaussPointDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateGaussPointDPNumber

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element data point of the field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetUpdateElementDataPointDPObj(field,variableType,fieldSetType,elementNumber,dataPointIndex, &
       & componentNumber,value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The user element number to update the data point for.
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The index of the data point for the data points projected on this element.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the constant value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateElementDataPointDPObj",err,error,*999)

    CALL Field_ParameterSetUpdateElementDataPoint(field%FIELD,variableType,fieldSetType,elementNumber,&
    & dataPointIndex,componentNumber,value,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateElementDataPointDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateElementDataPointDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateElementDataPointDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateElementDataPointDPObj

  !
  !================================================================================================================================
  !

  !>Updates the given parameter set with the given double precision value for the element gauss point of the field variable component for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetUpdateGaussPointDPObj(field,variableType,fieldSetType,userElementNumber,gaussPointNumber, &
    & componentNumber, value,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the Gauss point value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the Gauss point value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the Gauss point value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: gaussPointNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: componentNumber !<The component number of the field variable to update the Gauss point value for the field parameter set.
    REAL(DP), INTENT(IN) :: value !<The value for the field parameter set to update.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateGaussPointDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_GAUSS_POINT(field%FIELD,variableType,fieldSetType,userElementNumber,gaussPointNumber, &
      & componentNumber,value, err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateGaussPointDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateGaussPointDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateGaussPointDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateGaussPointDPObj

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative and returns double precision values for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetInterpolateSingleXiDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & derivativeNumber,userElementNumber,xi,values,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:) !<The element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<The interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetInterpolateSingleXiDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_XI(FIELD,variableType,fieldSetType,derivativeNumber,userElementNumber, &
          & xi,values,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetInterpolateSingleXiDPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetInterpolateSingleXiDPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetInterpolateSingleXiDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetInterpolateSingleXiDPNumber

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified xi location for the specified element and derviative and returns double precision values for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetInterpolateSingleXiDPObj(field,variableType,fieldSetType,derivativeNumber,userElementNumber, &
    & xi,values,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:) !<The element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<The interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetInterpolateSingleXiDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_XI(field%FIELD,variableType,fieldSetType,derivativeNumber,userElementNumber,xi, &
      & values,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetInterpolateSingleXiDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetInterpolateSingleXiDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetInterpolateSingleXiDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetInterpolateSingleXiDPObj

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of xi locations for the specified element and derviative and returns double precision values for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetInterpolateMultipleXiDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & derivativeNumber,userElementNumber,xi,values,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:,:) !<The sets of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<The interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetInterpolateMultipleXiDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_XI(FIELD,variableType,fieldSetType,derivativeNumber,userElementNumber, &
          & xi,values,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetInterpolateMultipleXiDPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetInterpolateMultipleXiDPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetInterpolateMultipleXiDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetInterpolateMultipleXiDPNumber

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of xi locations for the specified element and derviative and returns double precision values for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetInterpolateMultipleXiDPObj(field,variableType,fieldSetType,derivativeNumber,userElementNumber, &
    & xi,values,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    REAL(DP), INTENT(IN) :: xi(:,:) !<The sets of element xi to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<The interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetInterpolateMultipleXiDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_XI(field%FIELD,variableType,fieldSetType,derivativeNumber,userElementNumber,xi, &
      & values,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetInterpolateMultipleXiDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetInterpolateMultipleXiDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetInterpolateMultipleXiDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetInterpolateMultipleXiDPObj

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified Gauss point for the specified element and derviative and returns double precision values for a or a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetInterpolateSingleGaussDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & derivativeNumber,userElementNumber,quadratureScheme,GaussPoint,values,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for.
    INTEGER(INTG), INTENT(IN) :: GaussPoint !<The Gauss point to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<The interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetInterpolateSingleGaussDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_GAUSS(FIELD,variableType,fieldSetType,derivativeNumber,userElementNumber, &
          & quadratureScheme,GaussPoint,values,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetInterpolateSingleGaussDPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetInterpolateSingleGaussDPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetInterpolateSingleGaussDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetInterpolateSingleGaussDPNumber

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified Gauss point for the specified element and derviative and returns double precision values for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetInterpolateSingleGaussDPObj(field,variableType,fieldSetType,derivativeNumber, &
    & userElementNumber,quadratureScheme, GaussPoint,values,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for.
    INTEGER(INTG), INTENT(IN) :: GaussPoint !<The Gauss point to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:) !<The interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetInterpolateSingleGaussDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_INTERPOLATE_SINGLE_GAUSS(field%FIELD,variableType,fieldSetType,derivativeNumber,userElementNumber, &
      & quadratureScheme,GaussPoint,values,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetInterpolateSingleGaussDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetInterpolateSingleGaussDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetInterpolateSingleGaussDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetInterpolateSingleGaussDPObj

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of Gauss points for the specified element and derviative and returns double precision values for a or a field identified by a user number. If no Gauss points are specified then all Gauss points are interpolated.
  SUBROUTINE CMISSField_ParameterSetInterpolateMultipleGaussDPNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType, &
    & derivativeNumber,userElementNumber,quadratureScheme,GaussPoints,values,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field whose parameter set is to be interpolated.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to interpolate. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to interpolate. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for.
    INTEGER(INTG), INTENT(IN) :: GaussPoints(:) !<The Gauss points to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<The interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetInterpolateMultipleGaussDPNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_GAUSS(FIELD,variableType,fieldSetType,derivativeNumber,userElementNumber, &
          & quadratureScheme,GaussPoints,values,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetInterpolateMultipleGaussDPNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetInterpolateMultipleGaussDPNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetInterpolateMultipleGaussDPNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetInterpolateMultipleGaussDPNumber

  !
  !================================================================================================================================
  !

  !>Interpolates the given parameter set at a specified set of Gauss points for the specified element and derviative and returns double precision values for a field identified by an object. If no Gauss points are specified then all Gauss points are interpolated.
  SUBROUTINE CMISSField_ParameterSetInterpolateMultipleGaussDPObj(field,variableType,fieldSetType,derivativeNumber, &
    & userElementNumber,quadratureScheme, GaussPoints,values,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to update the constant value for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to update the constant value for the field parameter set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type of the field to update the constant value for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the field to interpolate.
    INTEGER(INTG), INTENT(IN) :: userElementNumber !<The user element number of the field variable component to update for the field parameter set.
    INTEGER(INTG), INTENT(IN) :: quadratureScheme !<The quadrature scheme to interpolate the field for.
    INTEGER(INTG), INTENT(IN) :: GaussPoints(:) !<The Gauss points to interpolate the field at.
    REAL(DP), INTENT(OUT) :: values(:,:) !<The interpolated values.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetInterpolateMultipleGaussDPObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_INTERPOLATE_MULTIPLE_GAUSS(field%FIELD,variableType,fieldSetType,derivativeNumber,userElementNumber, &
      & quadratureScheme,GaussPoints,values,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetInterpolateMultipleGaussDPObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetInterpolateMultipleGaussDPObj",err,error)
    CALL EXITS("CMISSField_ParameterSetInterpolateMultipleGaussDPObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetInterpolateMultipleGaussDPObj

  !
  !================================================================================================================================
  !

  !>Starts the parameter set update for a field variable for a field identified by a user number.
  SUBROUTINE CMISSField_ParameterSetUpdateStartNumber(regionUserNumber,fieldUserNumber,variableType,fieldSetType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to start the parameter set update for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to start the update for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParameterSetUpdateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_PARAMETER_SET_UPDATE_START(FIELD,variableType,fieldSetType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ParameterSetUpdateStartNumber")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateStartNumber",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the parameter set update for a field variable for a field identified by an object.
  SUBROUTINE CMISSField_ParameterSetUpdateStartObj(field,variableType,fieldSetType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to start the parameter set update for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to start the parameter set update for. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(IN) :: fieldSetType !<The parameter set type to start the update for. \see OPENCMISS_FieldParameterSetTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetUpdateStartObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_UPDATE_START(field%FIELD,variableType,fieldSetType,err,error,*999)

    CALL EXITS("CMISSField_ParameterSetUpdateStartObj")
    RETURN
999 CALL ERRORS("CMISSField_ParameterSetUpdateStartObj",err,error)
    CALL EXITS("CMISSField_ParameterSetUpdateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParameterSetUpdateStartObj

  !
  !================================================================================================================================
  !

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable, where both fields are identified by user numbers.
  SUBROUTINE CMISSField_ParametersToFieldParametersComponentCopyNumber(fromRegionUserNumber,fromFieldUserNumber,fromVariableType, &
      & fromParameterSetType, fromComponentNumber,toRegionUserNumber,toFieldUserNumber,toVariableType,toParameterSetType, &
      & toComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: fromRegionUserNumber !<The user number of the region containing the field to copy from
    INTEGER(INTG), INTENT(IN) :: fromFieldUserNumber !<The field to copy from
    INTEGER(INTG), INTENT(IN) :: fromVariableType !<The field variable type to copy from
    INTEGER(INTG), INTENT(IN) :: fromParameterSetType !<The field parameter set type to copy from
    INTEGER(INTG), INTENT(IN) :: fromComponentNumber !<The field variable component number to copy from
    INTEGER(INTG), INTENT(IN) :: toRegionUserNumber !<The user number of the region containing the field to copy to
    INTEGER(INTG), INTENT(IN) :: toFieldUserNumber !<The field to copy to
    INTEGER(INTG), INTENT(IN) :: toVariableType !<The field variable type to copy to
    INTEGER(INTG), INTENT(IN) :: toParameterSetType !<The parameter set type to copy to
    INTEGER(INTG), INTENT(IN) :: toComponentNumber !<The field variable component to copy to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables
    TYPE(REGION_TYPE), POINTER :: FROM_REGION
    TYPE(FIELD_TYPE), POINTER :: FROM_FIELD
    TYPE(REGION_TYPE), POINTER :: TO_REGION
    TYPE(FIELD_TYPE), POINTER :: TO_FIELD
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ParametersToFieldParametersComponentCopyNumber",err,error,*999)

    NULLIFY(FROM_REGION)
    NULLIFY(FROM_FIELD)
    NULLIFY(TO_REGION)
    NULLIFY(TO_FIELD)
    CALL REGION_USER_NUMBER_FIND(fromRegionUserNumber,FROM_REGION,err,error,*999)
    IF(ASSOCIATED(FROM_REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fromFieldUserNumber,FROM_REGION,FROM_FIELD,err,error,*999)
      IF(ASSOCIATED(FROM_FIELD)) THEN
        CALL REGION_USER_NUMBER_FIND(toRegionUserNumber,TO_REGION,err,error,*999)
        IF(ASSOCIATED(TO_REGION)) THEN
          CALL FIELD_USER_NUMBER_FIND(toFieldUserNumber,TO_REGION,TO_FIELD,err,error,*999)
          IF(ASSOCIATED(TO_FIELD)) THEN
            CALL FIELD_PARAMETERS_TO_FIELD_PARAMETERS_COMPONENT_COPY(FROM_FIELD,fromVariableType,fromParameterSetType, &
              & fromComponentNumber,TO_FIELD,toVariableType,toParameterSetType,toComponentNumber,err,error,*999)
          ELSE
            LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(toFieldUserNumber,"*",err,error))// &
              & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(toRegionUserNumber,"*",err,error))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
          END IF
        ELSE
          LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(toRegionUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fromFieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(fromRegionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(fromRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    RETURN
999 CALL ERRORS("CMISSField_ParametersToFieldParametersComponentCopyNumber",err,error)
    CALL EXITS("CMISSField_ParametersToFieldParametersComponentCopyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParametersToFieldParametersComponentCopyNumber

  !
  !================================================================================================================================
  !

  !>Copy the parameters from the parameter set of a component of a field variable to the paramters of a parameter set of
  !>a component of another field variable, where both fields are objects.
  SUBROUTINE CMISSField_ParametersToFieldParametersComponentCopyObj(fromField,fromVariableType,fromParameterSetType, &
    & fromComponentNumber,toField,toVariableType,toParameterSetType,toComponentNumber,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: fromField !<The field to copy from
    INTEGER(INTG), INTENT(IN) :: fromVariableType !<The field variable type to copy from
    INTEGER(INTG), INTENT(IN) :: fromParameterSetType !<The field parameter set type to copy from
    INTEGER(INTG), INTENT(IN) :: fromComponentNumber !<The field variable component number to copy from
    TYPE(CMISSFieldType), INTENT(IN) :: toField !<The field to copy to
    INTEGER(INTG), INTENT(IN) :: toVariableType !<The field variable type to copy to
    INTEGER(INTG), INTENT(IN) :: toParameterSetType !<The parameter set type to copy to
    INTEGER(INTG), INTENT(IN) :: toComponentNumber !<The field variable component to copy to
    INTEGER(INTG), INTENT(OUT) :: err !<The error code
    !Local variables

    CALL ENTERS("CMISSField_ParametersToFieldParametersComponentCopyObj",err,error,*999)

    CALL FIELD_PARAMETERS_TO_FIELD_PARAMETERS_COMPONENT_COPY(fromField%FIELD,fromVariableType,fromParameterSetType, &
      & fromComponentNumber,toField%FIELD,toVariableType,toParameterSetType,toComponentNumber,err,error,*999)

    RETURN
999 CALL ERRORS("CMISSField_ParametersToFieldParametersComponentCopyObj",err,error)
    CALL EXITS("CMISSField_ParametersToFieldParametersComponentCopyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ParametersToFieldParametersComponentCopyObj

  !
  !================================================================================================================================
  !

  !>Returns the scaling type for a field identified by a user number.
  SUBROUTINE CMISSField_ScalingTypeGetNumber(regionUserNumber,fieldUserNumber,scalingType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the scaling type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the scaling type for.
    INTEGER(INTG), INTENT(OUT) :: scalingType !<On return, the field scaling type. \see OPENCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ScalingTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_SCALING_TYPE_GET(FIELD,scalingType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ScalingTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSField_ScalingTypeGetNumber",err,error)
    CALL EXITS("CMISSField_ScalingTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ScalingTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the scaling type for a field identified by an object.
  SUBROUTINE CMISSField_ScalingTypeGetObj(field,scalingType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the scaling type for.
    INTEGER(INTG), INTENT(OUT) :: scalingType !<On return, the field scaling type. \see OPENCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ScalingTypeGetObj",err,error,*999)

    CALL FIELD_SCALING_TYPE_GET(field%FIELD,scalingType,err,error,*999)

    CALL EXITS("CMISSField_ScalingTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSField_ScalingTypeGetObj",err,error)
    CALL EXITS("CMISSField_ScalingTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ScalingTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field identified by a user number.
  SUBROUTINE CMISSField_ScalingTypeSetNumber(regionUserNumber,fieldUserNumber,scalingType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: scalingType !<The field scaling type to set. \see OPENCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_ScalingTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_SCALING_TYPE_SET(FIELD,scalingType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_ScalingTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSField_ScalingTypeSetNumber",err,error)
    CALL EXITS("CMISSField_ScalingTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ScalingTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the scaling type for a field identified by an object.
  SUBROUTINE CMISSField_ScalingTypeSetObj(field,scalingType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the scaling type for.
    INTEGER(INTG), INTENT(IN) :: scalingType !<The field scaling type to set. \see OPENCMISS_FieldScalingTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_ScalingTypeSetObj",err,error,*999)

    CALL FIELD_SCALING_TYPE_SET(field%FIELD,scalingType,err,error,*999)

    CALL EXITS("CMISSField_ScalingTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSField_ScalingTypeSetObj",err,error)
    CALL EXITS("CMISSField_ScalingTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_ScalingTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the field type for a field identified by a user number.
  SUBROUTINE CMISSField_TypeGetNumber(regionUserNumber,fieldUserNumber,fieldType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the field type for.
    INTEGER(INTG), INTENT(OUT) :: fieldType !<On return, the field type. \see OPENCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_TypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_TYPE_GET(FIELD,fieldType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_TypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSField_TypeGetNumber",err,error)
    CALL EXITS("CMISSField_TypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type for a field identified by an object.
  SUBROUTINE CMISSField_TypeGetObj(field,fieldType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the field type for.
    INTEGER(INTG), INTENT(OUT) :: fieldType !<On return, the field type. \see OPENCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_TypeGetObj",err,error,*999)

    CALL FIELD_TYPE_GET(field%FIELD,fieldType,err,error,*999)

    CALL EXITS("CMISSField_TypeGetObj")
    RETURN
999 CALL ERRORS("CMISSField_TypeGetObj",err,error)
    CALL EXITS("CMISSField_TypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the field type for a field identified by a user number.
  SUBROUTINE CMISSField_TypeSetNumber(regionUserNumber,fieldUserNumber,fieldType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldType !<The field type to set. \see OPENCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_TypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_TYPE_SET(FIELD,fieldType,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_TypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSField_TypeSetNumber",err,error)
    CALL EXITS("CMISSField_TypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for a field identified by an object.
  SUBROUTINE CMISSField_TypeSetObj(field,fieldType,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the field type for.
    INTEGER(INTG), INTENT(IN) :: fieldType !<The field type to set. \see OPENCMISS_FieldTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_TypeSetObj",err,error,*999)

    CALL FIELD_TYPE_SET(field%FIELD,fieldType,err,error,*999)

    CALL EXITS("CMISSField_TypeSetObj")
    RETURN
999 CALL ERRORS("CMISSField_TypeSetObj",err,error)
    CALL EXITS("CMISSField_TypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_TypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable for a field identified by a user number.
  SUBROUTINE CMISSField_VariableLabelGetCNumber(regionUserNumber,fieldUserNumber,variableType,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OPENCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_VariableLabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_LABEL_GET(FIELD,variableType,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_VariableLabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSField_VariableLabelGetCNumber",err,error)
    CALL EXITS("CMISSField_VariableLabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_VariableLabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a field variable for a field identified by an object.
  SUBROUTINE CMISSField_VariableLabelGetCObj(field,variableType,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OPENCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_VariableLabelGetCObj",err,error,*999)

    CALL FIELD_VARIABLE_LABEL_GET(field%FIELD,variableType,label,err,error,*999)

    CALL EXITS("CMISSField_VariableLabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSField_VariableLabelGetCObj",err,error)
    CALL EXITS("CMISSField_VariableLabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_VariableLabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable for a field identified by a user number.
  SUBROUTINE CMISSField_VariableLabelGetVSNumber(regionUserNumber,fieldUserNumber,variableType,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OPENCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_VariableLabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_LABEL_GET(FIELD,variableType,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_VariableLabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSField_VariableLabelGetVSNumber",err,error)
    CALL EXITS("CMISSField_VariableLabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_VariableLabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a field variable for a field identified by an object.
  SUBROUTINE CMISSField_VariableLabelGetVSObj(field,variableType,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to get the field variable label \see OPENCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the field variable label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_VariableLabelGetVSObj",err,error,*999)

    CALL FIELD_VARIABLE_LABEL_GET(field%FIELD,variableType,label,err,error,*999)

    CALL EXITS("CMISSField_VariableLabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSField_VariableLabelGetVSObj",err,error)
    CALL EXITS("CMISSField_VariableLabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_VariableLabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable for a field identified by a user number.
  SUBROUTINE CMISSField_VariableLabelSetCNumber(regionUserNumber,fieldUserNumber,variableType,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OPENCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_VariableLabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_LABEL_SET(FIELD,variableType,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_VariableLabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSField_VariableLabelSetCNumber",err,error)
    CALL EXITS("CMISSField_VariableLabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_VariableLabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a field variable for a field identified by an object.
  SUBROUTINE CMISSField_VariableLabelSetCObj(field,variableType,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OPENCMISS_FieldVariableTypes
    CHARACTER(LEN=*), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_VariableLabelSetCObj",err,error,*999)

    CALL FIELD_VARIABLE_LABEL_SET(field%FIELD,variableType,label,err,error,*999)

    CALL EXITS("CMISSField_VariableLabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSField_VariableLabelSetCObj",err,error)
    CALL EXITS("CMISSField_VariableLabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_VariableLabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable for a field identified by a user number.
  SUBROUTINE CMISSField_VariableLabelSetVSNumber(regionUserNumber,fieldUserNumber,variableType,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OPENCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_VariableLabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_LABEL_SET(FIELD,variableType,label,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_VariableLabelSetVSNumber")
    RETURN
999 CALL ERRORS("CMISSField_VariableLabelSetVSNumber",err,error)
    CALL EXITS("CMISSField_VariableLabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_VariableLabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a field variable for a field identified by an object.
  SUBROUTINE CMISSField_VariableLabelSetVSObj(field,variableType,label,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the label for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the field to set the field variable label \see OPENCMISS_FieldVariableTypes
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The field variable label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_VariableLabelSetVSObj",err,error,*999)

    CALL FIELD_VARIABLE_LABEL_SET(field%FIELD,variableType,label,err,error,*999)

    CALL EXITS("CMISSField_VariableLabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSField_VariableLabelSetVSObj",err,error)
    CALL EXITS("CMISSField_VariableLabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_VariableLabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the field variable types for a field identified by a user number.
  SUBROUTINE CMISSField_VariableTypesGetNumber(regionUserNumber,fieldUserNumber,variableTypes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to get the field variable types for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to get the field variable types for.
    INTEGER(INTG), INTENT(OUT) :: variableTypes(:) !<variableTypes(variable_idx). On return, the field variable types for the variable_idx'th field variable. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_VariableTypesGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_TYPES_GET(FIELD,variableTypes,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_VariableTypesGetNumber")
    RETURN
999 CALL ERRORS("CMISSField_VariableTypesGetNumber",err,error)
    CALL EXITS("CMISSField_VariableTypesGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_VariableTypesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the variable types for a field identified by an object.
  SUBROUTINE CMISSField_VariableTypesGetObj(field,variableTypes,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to get the field variable types for.
    INTEGER(INTG), INTENT(OUT) :: variableTypes(:) !<variableTypes(variable_idx). On return, the field variable types for the variable_idx'th field variable. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_VariableTypesGetObj",err,error,*999)

    CALL FIELD_VARIABLE_TYPES_GET(field%FIELD,variableTypes,err,error,*999)

    CALL EXITS("CMISSField_VariableTypesGetObj")
    RETURN
999 CALL ERRORS("CMISSField_VariableTypesGetObj",err,error)
    CALL EXITS("CMISSField_VariableTypesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_VariableTypesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the field variable types for a field identified by a user number.
  SUBROUTINE CMISSField_VariableTypesSetNumber(regionUserNumber,fieldUserNumber,variableTypes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: variableTypes(:) !<variableTypes(variable_idx). The field variable types for the variable_idx'th field variable to set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSField_VariableTypesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL FIELD_VARIABLE_TYPES_SET(FIELD,variableTypes,err,error,*999)
      ELSE
        LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSField_VariableTypesSetNumber")
    RETURN
999 CALL ERRORS("CMISSField_VariableTypesSetNumber",err,error)
    CALL EXITS("CMISSField_VariableTypesSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_VariableTypesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the variable types for a field identified by an object.
  SUBROUTINE CMISSField_VariableTypesSetObj(field,variableTypes,err)

    !Argument variables
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field to set the field variable types for.
    INTEGER(INTG), INTENT(IN) :: variableTypes(:) !<variableTypes(variable_idx). The field variable types for the variable_idx'th field variable to set. \see OPENCMISS_FieldVariableTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSField_VariableTypesSetObj",err,error,*999)

    CALL FIELD_VARIABLE_TYPES_SET(field%FIELD,variableTypes,err,error,*999)

    CALL EXITS("CMISSField_VariableTypesSetObj")
    RETURN
999 CALL ERRORS("CMISSField_VariableTypesSetObj",err,error)
    CALL EXITS("CMISSField_VariableTypesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSField_VariableTypesSetObj

!!==================================================================================================================================
!!
!! FIELD_IO_ROUTINES
!!
!!==================================================================================================================================

  !>Export element information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFields_ElementsExportCCObj(fields,fileName,method,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the elements to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: FileNameLength
    INTEGER(INTG) :: MethodLength

    CALL ENTERS("CMISSFields_ElementsExportCCObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%FIELDS,VFileName,VMethod,err,error,*999)

    CALL EXITS("CMISSFields_ElementsExportCCObj")
    RETURN
999 CALL ERRORS("CMISSFields_ElementsExportCCObj",err,error)
    CALL EXITS("CMISSFields_ElementsExportCCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFields_ElementsExportCCObj

  !
  !================================================================================================================================
  !


  !>Export element information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFields_ElementsExportVSCObj(fields,fileName,method,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the elements to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: MethodLength

    CALL ENTERS("CMISSFields_ElementsExportVSCObj",err,error,*999)

    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%FIELDS,fileName,VMethod,err,error,*999)

    CALL EXITS("CMISSFields_ElementsExportVSCObj")
    RETURN
999 CALL ERRORS("CMISSFields_ElementsExportVSCObj",err,error)
    CALL EXITS("CMISSFields_ElementsExportVSCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFields_ElementsExportVSCObj

  !
  !================================================================================================================================
  !


  !>Export element information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFields_ElementsExportCVSObj(fields,fileName,method,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the elements to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    INTEGER(INTG) :: FileNameLength

    CALL ENTERS("CMISSFields_ElementsExportCVSObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%FIELDS,VFileName,method,err,error,*999)

    CALL EXITS("CMISSFields_ElementsExportCVSObj")
    RETURN
999 CALL ERRORS("CMISSFields_ElementsExportCVSObj",err,error)
    CALL EXITS("CMISSFields_ElementsExportCVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFields_ElementsExportCVSObj

  !
  !================================================================================================================================
  !

  !>Export element information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFields_ElementsExportVSVSObj(fields,fileName,method,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<The fields to export the elements for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the elements to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFields_ElementsExportVSVSObj",err,error,*999)

    CALL FIELD_IO_ELEMENTS_EXPORT(fields%FIELDS,fileName,method,err,error,*999)

    CALL EXITS("CMISSFields_ElementsExportVSVSObj")
    RETURN
999 CALL ERRORS("CMISSFieldIOElementsExportVSObj",err,error)
    CALL EXITS("CMISSFieldIOElementsExportVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFields_ElementsExportVSVSObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFields_NodesExportCCObj(fields,fileName,method,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the nodes to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: FileNameLength
    INTEGER(INTG) :: MethodLength

    CALL ENTERS("CMISSFields_NodesExportCCObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)
    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_NODES_EXPORT(fields%FIELDS,VFileName,VMethod,err,error,*999)

    CALL EXITS("CMISSFields_NodesExportCCObj")
    RETURN
999 CALL ERRORS("CMISSFields_NodesExportCCObj",err,error)
    CALL EXITS("CMISSFields_NodesExportCCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFields_NodesExportCCObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFields_NodesExportVSCObj(fields,fileName,method,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the nodes to
    CHARACTER(LEN=*), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VMethod
    INTEGER(INTG) :: MethodLength

    CALL ENTERS("CMISSFields_NodesExportVSCObj",err,error,*999)

    MethodLength = LEN_TRIM(method)
    VMethod = method(1:MethodLength)

    CALL FIELD_IO_NODES_EXPORT(fields%FIELDS,fileName,VMethod,err,error,*999)

    CALL EXITS("CMISSFields_NodesExportVSCObj")
    RETURN
999 CALL ERRORS("CMISSFields_NodesExportVSCObj",err,error)
    CALL EXITS("CMISSFields_NodesExportVSCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFields_NodesExportVSCObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFields_NodesExportCVSObj(fields,fileName,method,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    CHARACTER(LEN=*), INTENT(IN) :: fileName !<The file name to export the nodes to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: VFileName
    INTEGER(INTG) :: FileNameLength

    CALL ENTERS("CMISSFields_NodesExportCVSObj",err,error,*999)

    FileNameLength = LEN_TRIM(fileName)
    VFileName = fileName(1:FileNameLength)

    CALL FIELD_IO_NODES_EXPORT(fields%FIELDS,VFileName,method,err,error,*999)

    CALL EXITS("CMISSFields_NodesExportCVSObj")
    RETURN
999 CALL ERRORS("CMISSFields_NodesExportCVSObj",err,error)
    CALL EXITS("CMISSFields_NodesExportCVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFields_NodesExportCVSObj

  !
  !================================================================================================================================
  !

  !>Export nodal information for fields set identified by an object. \todo number method
  SUBROUTINE CMISSFields_NodesExportVSVSObj(fields,fileName,method,err)

    !Argument variables
    TYPE(CMISSFieldsType), INTENT(INOUT) :: fields !<The fields to export the nodes for.
    TYPE(VARYING_STRING), INTENT(IN) :: fileName !<The file name to export the nodes to
    TYPE(VARYING_STRING), INTENT(IN):: method !<The export method to use.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSFields_NodesExportVSVSObj",err,error,*999)

    CALL FIELD_IO_NODES_EXPORT(fields%FIELDS,fileName,method,err,error,*999)

    CALL EXITS("CMISSFields_NodesExportVSVSObj")
    RETURN
999 CALL ERRORS("CMISSFields_NodesExportVSVSObj",err,error)
    CALL EXITS("CMISSFields_NodesExportVSVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFields_NodesExportVSVSObj

!!==================================================================================================================================
!!
!! GENERATED_MESH_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the basis for a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMesh_BasisGetNumber(regionUserNumber,generatedMeshUserNumber,basisUserNumbers,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the basis for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the basis for.
    INTEGER(INTG), INTENT(INOUT) :: basisUserNumbers(:) !<On return, the user numbers of the bases.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_PTR_TYPE), POINTER :: BASES(:)
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: basis_idx,NumBases

    CALL ENTERS("CMISSGeneratedMesh_BasisGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    NULLIFY(BASES)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_BASIS_GET(GENERATED_MESH,BASES,err,error,*999)
        IF(ASSOCIATED(BASES)) THEN
          NumBases=SIZE(BASES)
          IF(SIZE(basisUserNumbers)<NumBases) THEN
            LOCAL_ERROR="The basis user numbers array must have a size of at least "// &
                & TRIM(NUMBER_TO_VSTRING(NumBases,"*",err,error))// &
                & ". However, it has a size of " &
                & //TRIM(NUMBER_TO_VSTRING(SIZE(basisUserNumbers),"*",err,error))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
          END IF
          DO basis_idx=1,NumBases
            IF(ASSOCIATED(BASES(basis_idx)%PTR)) THEN
              basisUserNumbers(basis_idx)=BASES(basis_idx)%PTR%USER_NUMBER
            ELSE
              LOCAL_ERROR="The basis with index "//TRIM(NUMBER_TO_VSTRING(basis_idx,"*",err,error))// &
                & " is not associated for the generated mesh with a user number of "// &
                & TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            END IF
          END DO
        ELSE
          LOCAL_ERROR="The bases are not associated for the generated mesh with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_BasisGetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_BasisGetNumber",err,error)
    CALL EXITS("CMISSGeneratedMesh_BasisGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_BasisGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the basis for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_BasisGetObj(generatedMesh,bases,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the basis for.
    TYPE(CMISSBasisType), INTENT(INOUT) :: bases(:) !<On return, the array of bases.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_PTR_TYPE), POINTER :: BASIS_PTRS(:)
    INTEGER(INTG) :: basis_idx,NumBases
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_BasisGetObj",err,error,*999)

    NULLIFY(BASIS_PTRS)

    CALL GENERATED_MESH_BASIS_GET(generatedMesh%GENERATED_MESH,BASIS_PTRS,err,error,*999)
    IF(ASSOCIATED(BASIS_PTRS)) THEN
      NumBases=SIZE(BASIS_PTRS)
      IF(SIZE(bases)<NumBases) THEN
        LOCAL_ERROR="The bases array must have a size of at least "// &
            & TRIM(NUMBER_TO_VSTRING(NumBases,"*",err,error))// &
            & ". However, it has a size of " &
            & //TRIM(NUMBER_TO_VSTRING(SIZE(bases),"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
      DO basis_idx=1,NumBases
        bases(basis_idx)%BASIS=>BASIS_PTRS(basis_idx)%PTR
      END DO
    ELSE
      LOCAL_ERROR="The bases are not associated for the generated mesh."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_BasisGetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_BasisGetObj",err,error)
    CALL EXITS("CMISSGeneratedMesh_BasisGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_BasisGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMesh_BasisSetNumber0(regionUserNumber,generatedMeshUserNumber,basisUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_PTR_TYPE), POINTER :: BASES(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_BasisSetNumber0",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    NULLIFY(BASIS)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL BASIS_USER_NUMBER_FIND(basisUserNumber,BASIS,err,error,*999)
        IF(ASSOCIATED(BASIS)) THEN
          ALLOCATE(BASES(1),STAT=err)
          IF(err/=0) CALL FLAG_ERROR("Could not allocate bases.",err,error,*999)
          BASES(1)%PTR=>BASIS
          CALL GENERATED_MESH_BASIS_SET(GENERATED_MESH,BASES,err,error,*999)
        ELSE
          LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(basisUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_BasisSetNumber0")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_BasisSetNumber0",err,error)
    CALL EXITS("CMISSGeneratedMesh_BasisSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_BasisSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMesh_BasisSetNumber1(regionUserNumber,generatedMeshUserNumber,basisUserNumbers,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumbers(:) !<The user numbers of the bases to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_PTR_TYPE), POINTER :: BASES(:)
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: basis_idx,NumBases

    CALL ENTERS("CMISSGeneratedMesh_BasisSetNumber1",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    NULLIFY(BASES)

    NumBases=SIZE(basisUserNumbers)
    ALLOCATE(BASES(NumBases),STAT=err)
    IF(err/=0) CALL FLAG_ERROR("Could not allocate bases.",err,error,*999)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        DO basis_idx=1,NumBases
          NULLIFY(BASIS)
          CALL BASIS_USER_NUMBER_FIND(basisUserNumbers(basis_idx),BASIS,err,error,*999)
          IF(ASSOCIATED(BASIS)) THEN
            BASES(basis_idx)%PTR=>BASIS
          ELSE
            LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(basisUserNumbers(basis_idx),"*",err,error))// &
              & " does not exist."
            CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
          END IF
        END DO
        CALL GENERATED_MESH_BASIS_SET(GENERATED_MESH,BASES,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_BasisSetNumber1")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_BasisSetNumber1",err,error)
    CALL EXITS("CMISSGeneratedMesh_BasisSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_BasisSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_BasisSetObj0(generatedMesh,basis,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the basis for.
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMesh_BasisSetObj0",err,error,*999)

    CALL CMISSGeneratedMesh_BasisSetObj1(generatedMesh,[basis],err)

    CALL EXITS("CMISSGeneratedMesh_BasisSetObj0")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_BasisSetObj0",err,error)
    CALL EXITS("CMISSGeneratedMesh_BasisSetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_BasisSetObj0

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_BasisSetObj1(generatedMesh,bases,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the basis for.
    TYPE(CMISSBasisType), INTENT(IN) :: bases(:) !<The bases to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: basis_idx
    TYPE(BASIS_PTR_TYPE), ALLOCATABLE :: BASIS_PTRS(:)
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_BasisSetObj1",err,error,*999)

    ALLOCATE(BASIS_PTRS(SIZE(bases,1)),STAT=err)
    IF(err/=0) CALL FLAG_ERROR("Could not allocate bases.",err,error,*999)
    DO basis_idx=1,SIZE(bases,1)
      IF(ASSOCIATED(bases(basis_idx)%BASIS)) THEN
        BASIS_PTRS(basis_idx)%PTR=>bases(basis_idx)%BASIS
      ELSE
        LOCAL_ERROR="The basis for index "//TRIM(NUMBER_TO_VSTRING(basis_idx,"*",err,error))//" is not associated."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    END DO

    CALL GENERATED_MESH_BASIS_SET(generatedMesh%GENERATED_MESH,BASIS_PTRS,err,error,*999)

    CALL EXITS("CMISSGeneratedMesh_BasisSetObj1")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_BasisSetObj1",err,error)
    CALL EXITS("CMISSGeneratedMesh_BasisSetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_BasisSetObj1

  !
  !================================================================================================================================
  !

  !>Sets/changes the base vectors for a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMesh_BaseVectorsSetNumber(regionUserNumber,generatedMeshUserNumber,baseVectors,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the base vectors for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the base vectors for.
    REAL(DP), INTENT(IN) :: baseVectors(:,:) !<baseVectors(coordinate_idx,xi_idx). The base vectors to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_BaseVectorsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_BASE_VECTORS_SET(GENERATED_MESH,baseVectors,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_BaseVectorsSetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_BaseVectorsSetNumber",err,error)
    CALL EXITS("CMISSGeneratedMesh_BaseVectorsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_BaseVectorsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the base vectors for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_BaseVectorsSetObj(generatedMesh,baseVectors,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the base vectors for.
    REAL(DP), INTENT(IN) :: baseVectors(:,:) !<baseVectors(coordinate_idx,xi_idx). The base vectors to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMesh_BaseVectorsSetObj",err,error,*999)

    CALL GENERATED_MESH_BASE_VECTORS_SET(generatedMesh%GENERATED_MESH,baseVectors,err,error,*999)

    CALL EXITS("CMISSGeneratedMesh_BaseVectorsSetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_BaseVectorsSetObj",err,error)
    CALL EXITS("CMISSGeneratedMesh_BaseVectorsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_BaseVectorsSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMesh_CreateFinishNumber(regionUserNumber,generatedMeshUserNumber,meshUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to generate.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_CREATE_FINISH(GENERATED_MESH,meshUserNumber,MESH,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Generated Mesh Create')
#endif

    CALL EXITS("CMISSGeneratedMesh_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_CreateFinishNumber",err,error)
    CALL EXITS("CMISSGeneratedMesh_CreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_CreateFinishObj(generatedMesh,meshUserNumber,mesh,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to generate.
    TYPE(CMISSMeshType), INTENT(INOUT) :: mesh !<On return, the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMesh_CreateFinishObj",err,error,*999)

    CALL GENERATED_MESH_CREATE_FINISH(generatedMesh%GENERATED_MESH,meshUserNumber,mesh%MESH,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Generated Mesh Create')
#endif

    CALL EXITS("CMISSGeneratedMesh_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_CreateFinishObj",err,error)
    CALL EXITS("CMISSGeneratedMesh_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMesh_CreateStartNumber(generatedMeshUserNumber,regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to create.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to create the generated mesh in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Generated Mesh Create')
#endif

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_CREATE_START(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_CreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_CreateStartNumber",err,error)
    CALL EXITS("CMISSGeneratedMesh_CreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a generated mesh on an interface identified by an object.
  SUBROUTINE CMISSGeneratedMesh_CreateStartInterfaceObj(generatedMeshUserNumber,interface,generatedMesh,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to create.
    TYPE(CMISSInterfaceType), INTENT(INOUT) :: interface !<The interface to created generated mesh in.
    TYPE(CMISSGeneratedMeshType), INTENT(INOUT) :: generatedMesh !<On return, the created generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMesh_CreateStartInterfaceObj",err,error,*999)

    CALL GENERATED_MESH_CREATE_START(generatedMeshUserNumber,interface%interface,generatedMesh%GENERATED_MESH,err,error,*999)

    CALL EXITS("CMISSGeneratedMesh_CreateStartInterfaceObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_CreateStartInterfaceObj",err,error)
    CALL EXITS("CMISSGeneratedMesh_CreateStartInterfaceObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_CreateStartInterfaceObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a generated mesh on a region identified by an object.
  SUBROUTINE CMISSGeneratedMesh_CreateStartRegionObj(generatedMeshUserNumber,region,generatedMesh,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to create.
    TYPE(CMISSRegionType), INTENT(INOUT) :: region !<The region to created generated mesh in.
    TYPE(CMISSGeneratedMeshType), INTENT(INOUT) :: generatedMesh !<On return, the created generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMesh_CreateStartRegionObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Generated Mesh Create')
#endif

    CALL GENERATED_MESH_CREATE_START(generatedMeshUserNumber,REGION%region,generatedMesh%GENERATED_MESH,err,error,*999)

    CALL EXITS("CMISSGeneratedMesh_CreateStartRegionObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_CreateStartRegionObj",err,error)
    CALL EXITS("CMISSGeneratedMesh_CreateStartRegionObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_CreateStartRegionObj

  !
  !================================================================================================================================
  !

  !>Destroys a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMesh_DestroyNumber(regionUserNumber,generatedMeshUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to destroy.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_DESTROY(GENERATED_MESH,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_DestroyNumber",err,error)
    CALL EXITS("CMISSGeneratedMesh_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_DestroyObj(generatedMesh,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(INOUT) :: generatedMesh !<The generated mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMesh_DestroyObj",err,error,*999)

    CALL GENERATED_MESH_DESTROY(generatedMesh%GENERATED_MESH,err,error,*999)

    CALL EXITS("CMISSGeneratedMesh_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_DestroyObj",err,error)
    CALL EXITS("CMISSGeneratedMesh_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_DestroyObj
  !
  !================================================================================================================================
  !

  !>Returns the extent for a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMesh_ExtentGetNumber(regionUserNumber,generatedMeshUserNumber,extent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the extent for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the extent for.
    REAL(DP), INTENT(OUT) :: extent(:) !<extent(i). On return, the extent for the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_ExtentGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_EXTENT_GET(GENERATED_MESH,extent,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_ExtentGetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_ExtentGetNumber",err,error)
    CALL EXITS("CMISSGeneratedMesh_ExtentGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_ExtentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the extent for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_ExtentGetObj(generatedMesh,extent,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the extent for.
    REAL(DP), INTENT(OUT) :: extent(:) !<extent(i). On return, the extent for the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMesh_ExtentGetObj",err,error,*999)

    CALL GENERATED_MESH_EXTENT_GET(generatedMesh%GENERATED_MESH,extent,err,error,*999)

    CALL EXITS("CMISSGeneratedMesh_ExtentGetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_ExtentGetObj",err,error)
    CALL EXITS("CMISSGeneratedMesh_ExtentGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_ExtentGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the extent for a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMesh_ExtentSetNumber(regionUserNumber,generatedMeshUserNumber,extent,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the extent for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the extent for.
    REAL(DP), INTENT(IN) :: extent(:) !<extent(i). The extent for the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_ExtentSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_EXTENT_SET(GENERATED_MESH,extent,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_ExtentSetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_ExtentSetNumber",err,error)
    CALL EXITS("CMISSGeneratedMesh_ExtentSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_ExtentSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the extent for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_ExtentSetObj(generatedMesh,extent,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the extent for.
    REAL(DP), INTENT(IN) :: extent(:) !<extent(i). the extent for the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMesh_ExtentSetObj",err,error,*999)

    CALL GENERATED_MESH_EXTENT_SET(generatedMesh%GENERATED_MESH,extent,err,error,*999)

    CALL EXITS("CMISSGeneratedMesh_ExtentSetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_ExtentSetObj",err,error)
    CALL EXITS("CMISSGeneratedMesh_ExtentSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_ExtentSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of elements for a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMesh_NumberOfElementsGetNumber(regionUserNumber,generatedMeshUserNumber,numberOfElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the number of elements for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements(:) !<numberOfElements(i). On return, the number of elements in the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_NumberOfElementsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_NUMBER_OF_ELEMENTS_GET(GENERATED_MESH,numberOfElements,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_NumberOfElementsGetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_NumberOfElementsGetNumber",err,error)
    CALL EXITS("CMISSGeneratedMesh_NumberOfElementsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_NumberOfElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of elements for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_NumberOfElementsGetObj(generatedMesh,numberOfElements,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements(:) !<numberOfElements(i). On return, the number of elements in the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMesh_NumberOfElementsGetObj",err,error,*999)

    CALL GENERATED_MESH_NUMBER_OF_ELEMENTS_GET(generatedMesh%GENERATED_MESH,numberOfElements,err,error,*999)

    CALL EXITS("CMISSGeneratedMesh_NumberOfElementsGetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_NumberOfElementsGetObj",err,error)
    CALL EXITS("CMISSGeneratedMesh_NumberOfElementsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_NumberOfElementsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements for a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMesh_NumberOfElementsSetNumber(regionUserNumber,generatedMeshUserNumber,numberOfElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements(:) !<numberOfElements(i). The number of elements in the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_NumberOfElementsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_NUMBER_OF_ELEMENTS_SET(GENERATED_MESH,numberOfElements,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_NumberOfElementsSetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_NumberOfElementsSetNumber",err,error)
    CALL EXITS("CMISSGeneratedMesh_NumberOfElementsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_NumberOfElementsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_NumberOfElementsSetObj(generatedMesh,numberOfElements,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements(:) !<numberOfElements(i). The number of elements in the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMesh_NumberOfElementsSetObj",err,error,*999)

    CALL GENERATED_MESH_NUMBER_OF_ELEMENTS_SET(generatedMesh%GENERATED_MESH,numberOfElements,err,error,*999)

    CALL EXITS("CMISSGeneratedMesh_NumberOfElementsSetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_NumberOfElementsSetObj",err,error)
    CALL EXITS("CMISSGeneratedMesh_NumberOfElementsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_NumberOfElementsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the origin of a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMesh_OriginGetNumber(regionUserNumber,generatedMeshUserNumber,origin,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the origin for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<origin(i). On return, the origin of the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_OriginGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_ORIGIN_GET(GENERATED_MESH,origin,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_OriginGetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_OriginGetNumber",err,error)
    CALL EXITS("CMISSGeneratedMesh_OriginGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_OriginGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the origin of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_OriginGetObj(generatedMesh,origin,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the origin for.
    REAL(DP), INTENT(OUT) :: origin(:) !<origin(i). On return, the origin of the i'th dimension of the generated mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMesh_OriginGetObj",err,error,*999)

    CALL GENERATED_MESH_ORIGIN_GET(generatedMesh%GENERATED_MESH,origin,err,error,*999)

    CALL EXITS("CMISSGeneratedMesh_OriginGetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_OriginGetObj",err,error)
    CALL EXITS("CMISSGeneratedMesh_OriginGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_OriginGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMesh_OriginSetNumber(regionUserNumber,generatedMeshUserNumber,origin,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the origin for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<origin(i). The origin of the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_OriginSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_ORIGIN_SET(GENERATED_MESH,origin,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_OriginSetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_OriginSetNumber",err,error)
    CALL EXITS("CMISSGeneratedMesh_OriginSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_OriginSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the origin of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_OriginSetObj(generatedMesh,origin,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the origin for.
    REAL(DP), INTENT(IN) :: origin(:) !<origin(i). The origin of the i'th dimension of the generated mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMesh_OriginSetObj",err,error,*999)

    CALL GENERATED_MESH_ORIGIN_SET(generatedMesh%GENERATED_MESH,origin,err,error,*999)

    CALL EXITS("CMISSGeneratedMesh_OriginSetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_OriginSetObj",err,error)
    CALL EXITS("CMISSGeneratedMesh_OriginSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_OriginSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMesh_TypeGetNumber(regionUserNumber,generatedMeshUserNumber,generatedMeshType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to get the type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to get the type for.
    INTEGER(INTG), INTENT(OUT) :: generatedMeshType !<On return, the type of the generated mesh. \see OPENCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_TypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_TYPE_GET(GENERATED_MESH,generatedMeshType,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on the region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_TypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_TypeGetNumber",err,error)
    CALL EXITS("CMISSGeneratedMesh_TypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_TypeGetObj(generatedMesh,generatedMeshType,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to get the generated mesh type for.
    INTEGER(INTG), INTENT(OUT) :: generatedMeshType !<On return, the type of the generated mesh. \see OPENCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMesh_TypeGetObj",err,error,*999)

    CALL GENERATED_MESH_TYPE_GET(generatedMesh%GENERATED_MESH,generatedMeshType,err,error,*999)

    CALL EXITS("CMISSGeneratedMesh_TypeGetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_TypeGetObj",err,error)
    CALL EXITS("CMISSGeneratedMesh_TypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a generated mesh on a region identified by a user number.
  SUBROUTINE CMISSGeneratedMesh_TypeSetNumber(regionUserNumber,generatedMeshUserNumber,generatedMeshType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh to set the type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to set the type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshType !<The type of the generated mesh to set. \see OPENCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_TypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
        CALL GENERATED_MESH_TYPE_SET(GENERATED_MESH,generatedMeshType,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
          & " does not exist on a region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_TypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_TypeSetNumber",err,error)
    CALL EXITS("CMISSGeneratedMesh_TypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_TypeSetObj(generatedMesh,generatedMeshType,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to set the generated mesh type for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshType !<The type of the generated mesh to set. \see OPENCMISS_GeneratedMeshTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMesh_TypeSetObj",err,error,*999)

    CALL GENERATED_MESH_TYPE_SET(generatedMesh%GENERATED_MESH,generatedMeshType,err,error,*999)

    CALL EXITS("CMISSGeneratedMesh_TypeSetObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_TypeSetObj",err,error)
    CALL EXITS("CMISSGeneratedMesh_TypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_TypeSetObj

  !
  !================================================================================================================================
  !

  !>Calculates and sets the geometric field parameters for a generated mesh identified by a user number.
  SUBROUTINE CMISSGeneratedMesh_GeometricParametersCalculateNumber(regionUserNumber,generatedMeshUserNumber, &
      & fieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the field to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber !<The user number of the generated mesh to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The user number of the field to calculate the geometric parameters for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: FIELD
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_GeometricParametersCalculateNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(FIELD)
    NULLIFY(GENERATED_MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,REGION,FIELD,err,error,*999)
      IF(ASSOCIATED(FIELD)) THEN
        CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
        IF(ASSOCIATED(GENERATED_MESH)) THEN
          CALL GENERATED_MESH_GEOMETRIC_PARAMETERS_CALCULATE(FIELD,GENERATED_MESH,err,error,*999)
        ELSE
          LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An field with an user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_GeometricParametersCalculateNumber")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_GeometricParametersCalculateNumber",err,error)
    CALL EXITS("CMISSGeneratedMesh_GeometricParametersCalculateNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_GeometricParametersCalculateNumber

  !
  !================================================================================================================================
  !

  !>Calculates and sets the geometric field parameters for a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_GeometricParametersCalculateObj(generatedMesh,field,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh to calculate the geometric parameters for.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !<The field to calculate the geometric parameters for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSGeneratedMesh_GeometricParametersCalculateObj",err,error,*999)

    CALL GENERATED_MESH_GEOMETRIC_PARAMETERS_CALCULATE(field%FIELD,generatedMesh%GENERATED_MESH,err,error,*999)

    CALL EXITS("CMISSGeneratedMesh_GeometricParametersCalculateObj")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_GeometricParametersCalculateObj",err,error)
    CALL EXITS("CMISSGeneratedMesh_GeometricParametersCalculateObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSGeneratedMesh_GeometricParametersCalculateObj

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_SurfaceGetNumber0(regionUserNumber,generatedMeshUserNumber,surfaceType,surfaceNodes,normalXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh.
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber  !<Guess what this is.
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted.
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_SurfaceGetNumber0",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
          CALL GENERATED_MESH_SURFACE_GET(GENERATED_MESH,1,surfaceType,surfaceNodes,normalXi,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
            & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_SurfaceGetNumber0")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_SurfaceGetNumber0",err,error)
    CALL EXITS("CMISSGeneratedMesh_SurfaceGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN
  END SUBROUTINE CMISSGeneratedMesh_SurfaceGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_SurfaceGetNumber1(regionUserNumber,meshComponent,generatedMeshUserNumber,surfaceType, &
      & surfaceNodes,normalXi,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the generated mesh.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component/basis number to use
    INTEGER(INTG), INTENT(IN) :: generatedMeshUserNumber  !<Guess what this is.
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted.
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(GENERATED_MESH_TYPE), POINTER :: GENERATED_MESH
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSGeneratedMesh_SurfaceGetNumber1",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(GENERATED_MESH)

    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL GENERATED_MESH_USER_NUMBER_FIND(generatedMeshUserNumber,REGION,GENERATED_MESH,err,error,*999)
      IF(ASSOCIATED(GENERATED_MESH)) THEN
          CALL GENERATED_MESH_SURFACE_GET(GENERATED_MESH,meshComponent,surfaceType,surfaceNodes,normalXi,err,error,*999)
      ELSE
        LOCAL_ERROR="A generated mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(generatedMeshUserNumber,"*",err,error))// &
            & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSGeneratedMesh_SurfaceGetNumber1")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_SurfaceGetNumber1",err,error)
    CALL EXITS("CMISSGeneratedMesh_SurfaceGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN
  END SUBROUTINE CMISSGeneratedMesh_SurfaceGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_SurfaceGetObj0(generatedMesh,surfaceType,surfaceNodes,normalXi,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh from which to extract surface nodes.
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted .
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL ENTERS("CMISSGeneratedMesh_SurfaceGetObj0",err,error,*999)

    CALL GENERATED_MESH_SURFACE_GET(generatedMesh%GENERATED_MESH,1,surfaceType,surfaceNodes,normalXi,err,error,*999)

    CALL EXITS("CMISSGeneratedMesh_SurfaceGetObj0")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_SurfaceGetObj0",err,error)
    CALL EXITS("CMISSGeneratedMesh_SurfaceGetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN
  END SUBROUTINE CMISSGeneratedMesh_SurfaceGetObj0

  !
  !================================================================================================================================
  !

  !>Returns a list of the nodes belonging to a surface, and their normal xi direction, of a generated mesh identified by an object.
  SUBROUTINE CMISSGeneratedMesh_SurfaceGetObj1(generatedMesh,meshComponent,surfaceType,surfaceNodes,normalXi,err)

    !Argument variables
    TYPE(CMISSGeneratedMeshType), INTENT(IN) :: generatedMesh !<The generated mesh from which to extract surface nodes.
    INTEGER(INTG), INTENT(IN) :: meshComponent !<The mesh component/basis number to use
    INTEGER(INTG), INTENT(IN) :: surfaceType !<The type of surface to be extracted .
    INTEGER(INTG), INTENT(OUT), ALLOCATABLE :: surfaceNodes(:) !<The list of nodes on the surface to be returned.
    INTEGER(INTG), INTENT(OUT) :: normalXi !<index of the xi direction that is normal to the surface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL ENTERS("CMISSGeneratedMesh_SurfaceGetObj1",err,error,*999)

    CALL GENERATED_MESH_SURFACE_GET(generatedMesh%GENERATED_MESH,meshComponent,surfaceType,surfaceNodes,normalXi,err,error,*999)

    CALL EXITS("CMISSGeneratedMesh_SurfaceGetObj1")
    RETURN
999 CALL ERRORS("CMISSGeneratedMesh_SurfaceGetObj1",err,error)
    CALL EXITS("CMISSGeneratedMesh_SurfaceGetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN
  END SUBROUTINE CMISSGeneratedMesh_SurfaceGetObj1


!!==================================================================================================================================
!!
!! MESH EMBEDDING ROUTINES
!!
!!==================================================================================================================================
  !
  !================================================================================================================================
  !

  !>Initialises a EmbeddedMeshType object.
  SUBROUTINE CMISSMeshEmbedding_Initialise(meshEmbedding,err)
    !Argument variables
    TYPE(CMISSMeshEmbeddingType), INTENT(OUT) ::  meshEmbedding !<The  MeshEmbeddingType object to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshEmbedding_Initialise",err,error,*999)

    NULLIFY(meshEmbedding%MESH_EMBEDDING)

    CALL EXITS("CMISSMeshEmbedding_Initialise")
    RETURN
999 CALL ERRORS("CMISSMeshEmbedding_Initialise",err,error)
    CALL EXITS("CMISSMeshEmbedding_Initialise")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshEmbedding_Initialise

  !
  !================================================================================================================================
  !
!>Creates a mesh embedding
  SUBROUTINE CMISSMeshEmbedding_CreateNumber(regionOneUserNumber,regionTwoUserNumber,meshEmbedding,parentMeshUserNumber, &
    & childMeshUserNumber,err)

    TYPE(CMISSMeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(REGION_TYPE), POINTER :: REGION1, REGION2
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    TYPE(MESH_TYPE), POINTER :: PARENTMESH,CHILDMESH
    INTEGER(INTG), INTENT(IN) :: parentMeshUserNumber, childMeshUserNumber  !<The user number of the mesh.
    INTEGER(INTG), INTENT(IN) :: regionOneUserNumber, regionTwoUserNumber !<The user number of the region containing the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.


    CALL ENTERS("CMISSMeshEmbedding_CreateNumber",err,error,*999)

    NULLIFY(REGION1)
    NULLIFY(REGION2)
    NULLIFY(PARENTMESH)
    NULLIFY(CHILDMESH)

    CALL REGION_USER_NUMBER_FIND(regionOneUserNumber,REGION1,err,error,*999)
    CALL REGION_USER_NUMBER_FIND(regionTwoUserNumber,REGION2,err,error,*999)
    IF(ASSOCIATED(REGION1)) THEN
      CALL MESH_USER_NUMBER_FIND(parentMeshUserNumber,REGION1,PARENTMESH,err,error,*999)
      IF(ASSOCIATED(REGION2)) THEN
        CALL MESH_USER_NUMBER_FIND(childMeshUserNumber,REGION2,CHILDMESH,err,error,*999)
        IF(ASSOCIATED(PARENTMESH).AND.ASSOCIATED(CHILDMESH)) THEN
          CALL MESH_EMBEDDING_CREATE(meshEmbedding%MESH_EMBEDDING,PARENTMESH,CHILDMESH,err,error,*999)
        ELSE
          LOCAL_ERROR="Meshes with user number of "//TRIM(NUMBER_TO_VSTRING(parentMeshUserNumber,"*",err,error))// &
              & " and "//TRIM(NUMBER_TO_VSTRING(childMeshUserNumber,"*",err,error))//  " do not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionTwoUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionOneUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMeshEmbedding_CreateNumber")
    RETURN
999 CALL ERRORS("CMISSMeshEmbedding_CreateNumber",err,error)
    CALL EXITS("CMISSMeshEmbedding_CreateNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshEmbedding_CreateNumber

  !
  !================================================================================================================================
  !

  !>Creates a mesh embedding
  SUBROUTINE CMISSMeshEmbedding_CreateObj(meshEmbedding, parentMesh, childMesh, err)
    TYPE(CMISSMeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(CMISSMeshType), INTENT(IN) :: parentMesh, childMesh   !<The parent and child meshes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    CALL MESH_EMBEDDING_CREATE(meshEmbedding%MESH_EMBEDDING,parentMesh%MESH,childMesh%MESH,err,error,*999)
999 RETURN
  END SUBROUTINE CMISSMeshEmbedding_CreateObj

  !
  !================================================================================================================================
  !

  !>Sets the embedded nodes for one parent element
  SUBROUTINE CMISSMeshEmbedding_SetChildNodePositionObj(meshEmbedding, elementNumber, nodeNumbers, xiCoords, err)
    TYPE(CMISSMeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    INTEGER(INTG), INTENT(IN) :: elementNumber   !<Parent element number
    INTEGER(INTG), INTENT(IN) :: nodeNumbers(:)  !<Node numbers in child mesh
    REAL(DP), INTENT(IN)      :: xiCoords(:,:)   !<Xi coordinates of embedded nodes wrt parent element
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    CALL MESH_EMBEDDING_SET_CHILD_NODE_POSITION(meshEmbedding%MESH_EMBEDDING,elementNumber, nodeNumbers, xiCoords, err, error, *999)
999 RETURN
  END SUBROUTINE CMISSMeshEmbedding_SetChildNodePositionObj

  !
  !================================================================================================================================
  !

  !>Pushes data to embedded mesh. Will generally be used at library and not API level. /TODO: Parameter set etc, function name?
  SUBROUTINE CMISSMeshEmbedding_PushDataObj(meshEmbedding, parentField, parentComponent, childField, childComponent, err)
    TYPE(CMISSMeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(CMISSFieldType), INTENT(IN) :: parentField, childField  !<Fields associated with parent and child mesh to get/set data from
!    TYPE(CMISSFieldType), POINTER, INTENT(IN) :: parentField, childField  !<Fields associated with parent and child mesh to get/set data from

    INTEGER(INTG), INTENT(IN) :: parentComponent, childComponent  !<Component numbers in respective fields
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    CALL MESH_EMBEDDING_PUSH_DATA(meshEmbedding%MESH_EMBEDDING,parentField%FIELD, parentComponent, childField%FIELD, &
      & childComponent, err, error, *999)
999 RETURN
  END SUBROUTINE CMISSMeshEmbedding_PushDataObj

!
  !================================================================================================================================
  !
!   !>Sets the positions of a Gauss point of the parent mesh in terms of element/xi coordinated in the child mesh
    SUBROUTINE CMISSMeshEmbedding_SetGaussPointDataObj(meshEmbedding, parentElementNumber,gaussPointNumber, &
       & parentXiCoords,childElementNumber,childXiCoords, err)
     TYPE(CMISSMeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
     INTEGER(INTG), INTENT(IN) :: parentElementNumber   !<Parent element number
     INTEGER(INTG), INTENT(IN) :: childElementNumber   !<Child element number
     INTEGER(INTG), INTENT(IN) :: gaussPointNumber  !<Gauss point number in this element
     REAL(DP), INTENT(IN)      :: parentXiCoords(:)   !<Xi coordinates of embedded nodes wrt parent element
     REAL(DP), INTENT(IN)      :: childXiCoords(:)   !<Xi coordinates of embedded nodes wrt Child element
     INTEGER(INTG), INTENT(OUT) :: err           !<The error code
!
     CALL MESH_EMBEDDING_SET_GAUSS_POINT_DATA(meshEmbedding%MESH_EMBEDDING, parentElementNumber, gaussPointNumber,&
     & parentXiCoords, childElementNumber, childXiCoords,err,error,*999)
 999 RETURN
    END SUBROUTINE CMISSMeshEmbedding_SetGaussPointDataObj
! !
  !================================================================================================================================
  !
!   !>Sets the positions of a Gauss point of the parent mesh in terms of element/xi coordinated in the child mesh
    SUBROUTINE CMISSMeshEmbedding_PullGaussPointDataObj(meshEmbedding, parentField, parentComponent, childField, &
      & childComponent, err)
    TYPE(CMISSMeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    TYPE(CMISSFieldType), INTENT(IN) :: parentField, childField  !<Fields associated with parent and child mesh to get/set data from
    INTEGER(INTG), INTENT(IN) :: parentComponent, childComponent  !<Component numbers in respective fields
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL MESH_EMBEDDING_PULL_GAUSS_POINT_DATA(meshEmbedding%MESH_EMBEDDING,parentField%FIELD, parentComponent, &
      &  childField%FIELD,childComponent, err, error, *999)
999 RETURN
    END SUBROUTINE CMISSMeshEmbedding_PullGaussPointDataObj
! !
  !================================================================================================================================
  !
   SUBROUTINE CMISSField_ParameterSetGetGaussPointCoordObj(meshEmbedding,componentNumber,numberOfGaussPoints, &
     & coords,err)

    !Argument variables
    TYPE(CMISSMeshEmbeddingType), INTENT(INOUT) :: meshEmbedding !<The embedding
    INTEGER(INTG), INTENT(IN) :: componentNumber
    INTEGER(INTG), INTENT(OUT) :: numberOfGaussPoints
    REAL(DP), INTENT(OUT)      :: coords(:)   !<Xi coordinates of embedded nodes wrt Child element
    INTEGER(INTG), INTENT(OUT) :: err           !<The error code
    !Local variables

    CALL ENTERS("CMISSField_ParameterSetGetGaussPointCoordObj",err,error,*999)

    CALL FIELD_PARAMETER_SET_GET_GAUSS_POINT_COORD(meshEmbedding%MESH_EMBEDDING,componentNumber, &
      & NumberofGaussPoints,COORDS,ERR,error,*999)

    CALL EXITS("CMISSField_ParameterSetGetGaussPointCoordObj")

999 RETURN

  END SUBROUTINE CMISSField_ParameterSetGetGaussPointCoordObj
!!==================================================================================================================================
!!
!! INTERFACE_ROUTINES
!!
!!==================================================================================================================================

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface identified by a user number.
  SUBROUTINE CMISSInterface_CreateFinishNumber(regionUserNumber,interfaceUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterface_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CREATE_FINISH(INTERFACE,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterface_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSInterface_CreateFinishNumber",err,error)
    CALL EXITS("CMISSInterface_CreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface identified by an object.
  SUBROUTINE CMISSInterface_CreateFinishObj(interface,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: interface !<The interface to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterface_CreateFinishObj",err,error,*999)

    CALL INTERFACE_CREATE_FINISH(interface%INTERFACE,err,error,*999)

    CALL EXITS("CMISSInterface_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSInterface_CreateFinishObj",err,error)
    CALL EXITS("CMISSInterface_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface identified by a user number.
  SUBROUTINE CMISSInterface_CreateStartNumber(interfaceUserNumber,regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterface_CreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_CREATE_START(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterface_CreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSInterface_CreateStartNumber",err,error)
    CALL EXITS("CMISSInterface_CreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface identified by an object.
  SUBROUTINE CMISSInterface_CreateStartObj(interfaceUserNumber,region,interface,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the field to start the creation of.
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to create the interface on.
    TYPE(CMISSInterfaceType), INTENT(IN) :: interface !<On return, the created interface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterface_CreateStartObj",err,error,*999)

    CALL INTERFACE_CREATE_START(interfaceUserNumber,region%REGION,interface%INTERFACE,err,error,*999)

    CALL EXITS("CMISSInterface_CreateStartObj")
    RETURN
999 CALL ERRORS("CMISSInterface_CreateStartObj",err,error)
    CALL EXITS("CMISSInterface_CreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN
    
  END SUBROUTINE CMISSInterface_CreateStartObj
  
  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the coordinate system for an interface identified by an user number.
  SUBROUTINE CMISSInterface_CoordinateSystemSetNumber(parentRegionUserNumber,interfaceUserNumber,coordinateSystemUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region where interface was created.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to set the coordinate system for.    
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSInterface_CoordinateSystemSetNumber",err,error,*999)
 
    NULLIFY(INTERFACE)
    NULLIFY(REGION)
    NULLIFY(COORDINATE_SYSTEM)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,REGION,err,error,*999)
    CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
    
    IF(ASSOCIATED(INTERFACE)) THEN
      CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
      IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
        CALL INTERFACE_COORDINATE_SYSTEM_SET(INTERFACE,COORDINATE_SYSTEM,err,error,*999)
      ELSE
        LOCAL_ERROR="A coordinate system with an user number of "// &
          & TRIM(NUMBER_TO_VSTRING(CoordinateSystemUserNumber,"*",err,ERROR))//" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterface_CoordinateSystemSetNumber")
    RETURN
999 CALL ERRORS("CMISSInterface_CoordinateSystemSetNumber",err,ERROR)
    CALL EXITS("CMISSInterface_CoordinateSystemSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSInterface_CoordinateSystemSetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Sets/changes the coordinate system for an interface identified by an object.
  SUBROUTINE CMISSInterface_CoordinateSystemSetObj(interface,coordinateSystem,err)
  
    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: interface !<The interface to set the coordinate system for
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSInterface_CoordinateSystemSetObj",err,error,*999)
 
    CALL INTERFACE_COORDINATE_SYSTEM_SET(interface%INTERFACE,coordinateSystem%COORDINATE_SYSTEM,err,error,*999)

    CALL EXITS("CMISSInterface_CoordinateSystemSetObj")
    RETURN
999 CALL ERRORS("CMISSInterface_CoordinateSystemSetObj",err,ERROR)
    CALL EXITS("CMISSInterface_CoordinateSystemSetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
  END SUBROUTINE CMISSInterface_CoordinateSystemSetObj

  !
  !================================================================================================================================
  !   
  
  !>Returns the coordinate system for an interface identified by an user number.
  SUBROUTINE CMISSInterface_CoordinateSystemGetNumber(parentRegionUserNumber,interfaceUserNumber,coordinateSystemUserNumber,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the region to get the coordinate system for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to get the coordinate system for. 
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemUserNumber !<On return, the coordinate system user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSInterface_CoordinateSystemGetNumber",err,error,*999)
 
    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(COORDINATE_SYSTEM)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,REGION,err,error,*999)
    CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
    IF(ASSOCIATED(INTERFACE)) THEN
      CALL INTERFACE_COORDINATE_SYSTEM_GET(INTERFACE,COORDINATE_SYSTEM,err,error,*999)
      IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
        coordinateSystemUserNumber = COORDINATE_SYSTEM%USER_NUMBER
      ELSE
        LOCAL_ERROR="The coordinate system is not associated for interface number "// &
          & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,ERROR))//" does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(InterfaceUserNumber,"*",err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterface_CoordinateSystemGetNumber")
    RETURN
999 CALL ERRORS("CMISSInterface_CoordinateSystemGetNumber",err,ERROR)
    CALL EXITS("CMISSInterface_CoordinateSystemGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSInterface_CoordinateSystemGetNumber

  !  
  !================================================================================================================================
  !  
 
  !>Returns the coordinate system for an interface identified by an object. 
  SUBROUTINE CMISSInterface_CoordinateSystemGetObj(Interface,CoordinateSystem,Err)
  
    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: Interface !<The interface to get the coordinate system for.
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: CoordinateSystem !<On return, the interface coordinate system.
   INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSInterface_CoordinateSystemGetObj",err,error,*999)
 
    CALL INTERFACE_COORDINATE_SYSTEM_GET(Interface%INTERFACE,CoordinateSystem%COORDINATE_SYSTEM,err,error,*999)

    CALL EXITS("CMISSInterface_CoordinateSystemGetObj")
    RETURN
999 CALL ERRORS("CMISSInterface_CoordinateSystemGetObj",err,ERROR)
    CALL EXITS("CMISSInterface_CoordinateSystemGetObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSInterface_CoordinateSystemGetObj
  
  !  
  !================================================================================================================================
  !

  !>Destroys an interface identified by a user number.
  SUBROUTINE CMISSInterface_DestroyNumber(regionUserNumber,interfaceUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to destroy.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFInterfaceDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_DESTROY(INTERFACE,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterface_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSInterface_DestroyNumber",err,error)
    CALL EXITS("CMISSInterface_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface identified by an object.
  SUBROUTINE CMISSInterface_DestroyObj(interface,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: Interface !<The interface to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterface_DestroyObj",err,error,*999)

    CALL INTERFACE_DESTROY(interface%INTERFACE,err,error,*999)

    CALL EXITS("CMISSInterface_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSInterface_DestroyObj",err,error)
    CALL EXITS("CMISSInterface_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an interface identified by an user number.
  SUBROUTINE CMISSInterface_LabelGetCNumber(parentRegionUserNumber,interfaceUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterface_LabelGetCNumber",err,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_LABEL_GET(INTERFACE,label,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on a parent region with a user number of "// &
          & TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterface_LabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSInterface_LabelGetCNumber",err,error)
    CALL EXITS("CMISSInterface_LabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for an interface identified by an object.
  SUBROUTINE CMISSInterface_LabelGetCObj(interface,label,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: interface !<The interface to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterface_LabelGetCObj",err,error,*999)

    CALL INTERFACE_LABEL_GET(interface%INTERFACE,label,err,error,*999)

    CALL EXITS("CMISSInterface_LabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSInterface_LabelGetCObj",err,error)
    CALL EXITS("CMISSInterface_LabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an interface identified by an user number.
  SUBROUTINE CMISSInterface_LabelGetVSNumber(parentRegionUserNumber,interfaceUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to get the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterface_LabelGetVSNumber",err,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_LABEL_GET(INTERFACE,label,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on a parent region with a user number of "// &
          & TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterface_LabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSInterface_LabelGetVSNumber",err,error)
    CALL EXITS("CMISSInterface_LabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for an interface identified by an object.
  SUBROUTINE CMISSInterface_LabelGetVSObj(interface,label,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: Interface !<The interface to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the interface label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterface_LabelGetVSObj",err,error,*999)

    CALL INTERFACE_LABEL_GET(interface%INTERFACE,label,err,error,*999)

    CALL EXITS("CMISSInterface_LabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSInterface_LabelGetVSObj",err,error)
    CALL EXITS("CMISSInterface_LabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an interface identified by an user number.
  SUBROUTINE CMISSInterface_LabelSetCNumber(parentRegionUserNumber,interfaceUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterface_LabelSetCNumber",err,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_LABEL_SET(INTERFACE,label,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on a parent region with a user number of "// &
          & TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterface_LabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSInterface_LabelSetCNumber",err,error)
    CALL EXITS("CMISSInterface_LabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for an interface identified by an object.
  SUBROUTINE CMISSInterface_LabelSetCObj(interface,label,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: Interface !<The interface to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterface_LabelSetCObj",err,error,*999)

    CALL INTERFACE_LABEL_SET(interface%INTERFACE,label,err,error,*999)

    CALL EXITS("CMISSInterface_LabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSInterface_LabelSetCObj",err,error)
    CALL EXITS("CMISSInterface_LabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for an interface identified by an user number.
  SUBROUTINE CMISSInterface_LabelSetVSNumber(parentRegionUserNumber,interfaceUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region containing the interface to set the label for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterface_LabelSetVSNumber",err,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_LABEL_SET(INTERFACE,CHAR(label),err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on a parent region with a user number of "// &
          & TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceLabelStVSNumber")
    RETURN
999 CALL ERRORS("CMISSInterface_LabelSetVSNumber",err,error)
    CALL EXITS("CMISSInterface_LabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for an interface identified by an object.
  SUBROUTINE CMISSInterface_LabelSetVSObj(interface,label,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: Interface !<The interface to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The interface label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterface_LabelSetVSObj",err,error,*999)

    CALL INTERFACE_LABEL_SET(interface%INTERFACE,CHAR(label),err,error,*999)

    CALL EXITS("CMISSInterface_LabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSInterface_LabelSetVSObj",err,error)
    CALL EXITS("CMISSInterface_LabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the nodes for a interface identified by an object.
  SUBROUTINE CMISSInterface_NodesGetObj(interface,nodes,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: interface !<The interface to get the nodes for.
    TYPE(CMISSNodesType), INTENT(INOUT) :: nodes !<On return, the interfaces nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterface_NodesGetObj",err,error,*999)

    CALL INTERFACE_NODES_GET(interface%INTERFACE,nodes%NODES,err,error,*999)

    CALL EXITS("CMISSInterface_NodesGetObj")
    RETURN
999 CALL ERRORS("CMISSInterface_NodesGetObj",err,error)
    CALL EXITS("CMISSInterface_NodesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_NodesGetObj

  !
  !================================================================================================================================
  !

  !>Adds a mesh to be coupled in an interface identified by a user number.
  SUBROUTINE CMISSInterface_MeshAddNumber(interfaceRegionUserNumber,interfaceUserNumber,meshRegionUserNumber, &
    & meshUserNumber,meshIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the parent region containing the interface to add a coupled mesh to.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to add a coupled mesh to.
    INTEGER(INTG), INTENT(IN) :: meshRegionUserNumber !<The user number of the region containing the mesh to add to the interface.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to add to the interface.
    INTEGER(INTG), INTENT(OUT) :: meshIndex !<On return, the mesh index of the mesh in the list of coupled meshes in the interface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: MESH_REGION,PARENT_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterface_MeshAddNumber",err,error,*999)

    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(MESH_REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(interfaceRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL REGION_USER_NUMBER_FIND(meshRegionUserNumber,MESH_REGION,err,error,*999)
        IF(ASSOCIATED(MESH_REGION)) THEN
          CALL MESH_USER_NUMBER_FIND(meshUserNumber,MESH_REGION,MESH,err,error,*999)
          IF(ASSOCIATED(MESH)) THEN
            CALL INTERFACE_MESH_ADD(INTERFACE,MESH,meshIndex,err,error,*999)
          ELSE
            LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
              & " does not exist on the region with an user number of "// &
              & TRIM(NUMBER_TO_VSTRING(meshRegionUserNumber,"*",err,error))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
          END IF
        ELSE
          LOCAL_ERROR="The mesh region with an user number of "//TRIM(NUMBER_TO_VSTRING(meshRegionUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "// &
          & TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="The interface parent region with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterface_MeshAddNumber")
    RETURN
999 CALL ERRORS("CMISSInterface_MeshAddNumber",err,error)
    CALL EXITS("CMISSInterface_MeshAddNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_MeshAddNumber

  !
  !================================================================================================================================
  !

  !>Adds a mesh to be coupled in an interface identified by an object.
  SUBROUTINE CMISSInterface_MeshAddObj(interface,mesh,meshIndex,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: interface !<The interface to finish creating.
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to add to the interface.
    INTEGER(INTG), INTENT(OUT) :: meshIndex !<On return, the mesh index of the mesh in the list of coupled meshes in the interface.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterface_MeshAddObj",err,error,*999)

    CALL INTERFACE_MESH_ADD(interface%INTERFACE,mesh%MESH,meshIndex,err,error,*999)

    CALL EXITS("CMISSInterface_MeshAddObj")
    RETURN
999 CALL ERRORS("CMISSInterface_MeshAddObj",err,error)
    CALL EXITS("CMISSInterface_MeshAddObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterface_MeshAddObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface coupled mesh connectivity identified by a user number.
  SUBROUTINE CMISSInterfaceMeshConnectivity_CreateFinishNumber(regionUserNumber,interfaceUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to finish creating the meshes connectivity.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceMeshConnectivity_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_MESH_CONNECTIVITY_CREATE_FINISH(INTERFACE%MESH_CONNECTIVITY,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceMeshConnectivity_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivity_CreateFinishNumber",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivity_CreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivity_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface meshes connectivity identified by an object.
  SUBROUTINE CMISSInterfaceMeshConnectivity_CreateFinishObj(interfaceMeshConnectivity,err)

    !Argument variables
    TYPE(CMISSInterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface meshes connectivity to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceMeshConnectivity_CreateFinishObj",err,error,*999)

    CALL INTERFACE_MESH_CONNECTIVITY_CREATE_FINISH(interfaceMeshConnectivity%MESH_CONNECTIVITY,err,error,*999)

    CALL EXITS("CMISSInterfaceMeshConnectivity_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivity_CreateFinishObj",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivity_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivity_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface meshes connectivity identified by a user number.
  SUBROUTINE CMISSInterfaceMeshConnectivity_CreateStartNumber(regionUserNumber,interfaceUserNumber,meshNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the meshes connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: meshNumber !<The user number of the interface mesh
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: INTERFACE_MESH_CONNECTIVITY
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceMeshConnectivity_CreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_MESH_CONNECTIVITY)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL MESH_USER_NUMBER_FIND(meshNumber,INTERFACE,MESH,ERR,error,*999)
        IF(ASSOCIATED(MESH)) THEN
          CALL INTERFACE_MESH_CONNECTIVITY_CREATE_START(INTERFACE,MESH,INTERFACE_MESH_CONNECTIVITY,err,error,*999)
        ELSE
          LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
           & " does not exist on the interface with user number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceMeshConnectivity_CreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivity_CreateStartNumber",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivity_CreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivity_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface meshes connectivity identified by an object.
  SUBROUTINE CMISSInterfaceMeshConnectivity_CreateStartObj(interface,interfaceMesh,interfaceMeshConnectivity,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: interface !<The interface to start the creation of the meshes connectivity for
    TYPE(CMISSMeshType), INTENT(IN) :: interfaceMesh
    TYPE(CMISSInterfaceMeshConnectivityType), INTENT(INOUT) :: interfaceMeshConnectivity !<On return, the created meshes connectivity
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceMeshConnectivity_CreateStartObj",err,error,*999)

    CALL INTERFACE_MESH_CONNECTIVITY_CREATE_START(interface%INTERFACE,interfaceMesh%MESH, &
      & interfaceMeshConnectivity%MESH_CONNECTIVITY,err,error,*999)

    CALL EXITS("CMISSInterfaceMeshConnectivity_CreateStartObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivity_CreateStartObj",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivity_CreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivity_CreateStartObj


  !
  !================================================================================================================================
  !

  !>Sets the connectivity between an element in a coupled mesh to an element in the interface mesh
  SUBROUTINE CMISSInterfaceMeshConnectivity_ElementNumberSetNumber(regionUserNumber,interfaceUserNumber, &
     &  interfaceElementNumber,coupledMeshIndexNumber,coupledMeshElementNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface meshe connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledMeshElementNumber !<The coupled mesh element to be connected to the interface
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceMeshConnectivity_ElementNumberSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_MESH_CONNECTIVITY_ELEMENT_NUMBER_SET(INTERFACE%MESH_CONNECTIVITY,interfaceElementNumber, &
         & coupledMeshIndexNumber,coupledMeshElementNumber,err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceMeshConnectivity_ElementNumberSetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivity_ElementNumberSetNumber",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivity_ElementNumberSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivity_ElementNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the connectivity between an element in a coupled mesh to an element in the interface mesh
  SUBROUTINE CMISSInterfaceMeshConnectivity_ElementNumberSetObj(interfaceMeshConnectivity,interfaceElementNumber, &
     &  coupledMeshIndexNumber,coupledMeshElementNumber,err)

    !Argument variables
    TYPE(CMISSInterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface mesh connectivity for the interface mesh
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber  !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledMeshElementNumber !<The coupled mesh element to be connected to the interface
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceMeshConnectivity_ElementNumberSetObj",err,error,*999)

    CALL INTERFACE_MESH_CONNECTIVITY_ELEMENT_NUMBER_SET(interfaceMeshConnectivity%MESH_CONNECTIVITY, &
      & interfaceElementNumber,coupledMeshIndexNumber,coupledMeshElementNumber,err,error,*999)

    CALL EXITS("CMISSInterfaceMeshConnectivity_ElementNumberSetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivity_ElementNumberSetObj",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivity_ElementNumberSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivity_ElementNumberSetObj


  !
  !================================================================================================================================
  !

  !>Sets the connectivity between an element in a coupled mesh to an element in the interface mesh
  SUBROUTINE CMISSInterfaceMeshConnectivity_NodeNumberSetNumber(regionUserNumber,interfaceUserNumber, &
     &  interfaceElementNumber,coupledMeshIndexNumber,coupledMeshElementNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface meshe connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface.
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledMeshElementNumber !<The coupled mesh element to be connected to the interface
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceMeshConnectivity_ElementNumberSetNumber",err,error,*999)

    CALL FLAG_ERROR("Not implemented yet.",err,error,*999)

    CALL EXITS("CMISSInterfaceMeshConnectivity_ElementNumberSetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivity_ElementNumberSetNumber",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivity_ElementNumberSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivity_NodeNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the connectivity between nodes in coupled meshes to nodes in the interface mesh
  SUBROUTINE CMISSInterfaceMeshConnectivity_NodeNumberSetObj(interfaceMeshConnectivity,interfaceNodeNumbers, &
     &  firstCoupledMeshIndexNumber,firstCoupledMeshNodeNumbers,secondCoupledMeshIndexNumber,secondCoupledMeshNodeNumbers,err)

    !Argument variables
    TYPE(CMISSInterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface mesh connectivity for the interface mesh
    INTEGER(INTG), INTENT(IN) :: interfaceNodeNumbers(:)  !<The interface mesh node numbers to which the specified coupled mesh nodes would be connected
    INTEGER(INTG), INTENT(IN) :: firstCoupledMeshIndexNumber,secondCoupledMeshIndexNumber !<The index of the coupled meshes at the interface to set the node connectivity for
    INTEGER(INTG), INTENT(IN) :: firstCoupledMeshNodeNumbers(:),secondCoupledMeshNodeNumbers(:) !<The coupled meshes nodes to be connected to the interface
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceMeshConnectivity_NodeNumberSetObj",err,error,*999)
    
    IF(SIZE(interfaceNodeNumbers(:))==SIZE(firstCoupledMeshNodeNumbers(:)) &
      & .AND.SIZE(interfaceNodeNumbers(:))==SIZE(secondCoupledMeshNodeNumbers(:))) THEN
      !TODO Check pointers
      !Set interface mesh connectivity node connectivity
      CALL INTERFACE_MESH_CONNECTIVITY_NODE_NUMBER_SET(interfaceMeshConnectivity%MESH_CONNECTIVITY%INTERFACE%NODES, &
        & interfaceNodeNumbers,firstCoupledMeshIndexNumber,firstCoupledMeshNodeNumbers, &
        & secondCoupledMeshIndexNumber,secondCoupledMeshNodeNumbers,err,error,*999)
    ELSE
      LOCAL_ERROR="Interface number of nodes does not match coupled meshes number of nodes."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceMeshConnectivity_NodeNumberSetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivity_NodeNumberSetObj",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivity_NodeNumberSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivity_NodeNumberSetObj

  !
  !================================================================================================================================
  !

  !>Sets the mapping from an xi position of a coupled mesh element to a node of an interface mesh element
  SUBROUTINE CMISSInterfaceMeshConnectivity_ElementXiSetNumber(regionUserNumber,interfaceUserNumber,interfaceElementNumber, &
     &  coupledMeshIndexNumber,coupledMeshElementNumber,interfaceMeshLocalNodeNumber,interfaceMeshComponentNodeNumber,xi,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the meshes connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledMeshElementNumber !<The coupled mesh element to define the element xi connectivity from
    INTEGER(INTG), INTENT(IN) :: interfaceMeshLocalNodeNumber !<The interface mesh node to assign the coupled mesh element xi to
    INTEGER(INTG), INTENT(IN) :: interfaceMeshComponentNodeNumber !<The interface mesh node's component to assign the coupled mesh element xi to
    REAL(DP), INTENT(IN) :: xi(:) !<The xi value for the xi_idx'th xi direction in the coupled mesh element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceMeshConnectivity_ElementXiSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_MESH_CONNECTIVITY_ELEMENT_XI_SET(INTERFACE%MESH_CONNECTIVITY,interfaceElementNumber, &
         & coupledMeshIndexNumber,coupledMeshElementNumber,interfaceMeshLocalNodeNumber,interfaceMeshComponentNodeNumber,xi, &
         & err,error,*999)
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceMeshConnectivity_ElementXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivity_ElementXiSetNumber",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivity_ElementXiSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivity_ElementXiSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the mapping from an xi position of a coupled mesh element to a node of an interface mesh element
  SUBROUTINE CMISSInterfaceMeshConnectivity_ElementXiSetObj(interfaceMeshConnectivity,interfaceElementNumber, &
     &  coupledMeshIndexNumber,coupledMeshElementNumber,interfaceMeshLocalNodeNumber,interfaceMeshComponentNodeNumber,xi,err)

    !Argument variables
    TYPE(CMISSInterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface to start the creation of the meshes connectivity for
    INTEGER(INTG), INTENT(IN) :: interfaceElementNumber !<The interface mesh element number to which the specified coupled mesh element would be connected
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index of the coupled mesh at the interface to set the element connectivity for
    INTEGER(INTG), INTENT(IN) :: coupledMeshElementNumber !<The coupled mesh element to define the element xi connectivity from
    INTEGER(INTG), INTENT(IN) :: interfaceMeshLocalNodeNumber !<The interface mesh node to assign the coupled mesh element xi to
    INTEGER(INTG), INTENT(IN) :: interfaceMeshComponentNodeNumber !<The interface mesh node's component to assign the coupled mesh element xi to
    REAL(DP), INTENT(IN) :: xi(:) !<The xi value for the xi_idx'th xi direction in the coupled mesh element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceMeshConnectivity_ElementXiSetObj",err,error,*999)

    CALL INTERFACE_MESH_CONNECTIVITY_ELEMENT_XI_SET(interfaceMeshConnectivity%MESH_CONNECTIVITY,interfaceElementNumber, &
      & coupledMeshIndexNumber,coupledMeshElementNumber,interfaceMeshLocalNodeNumber,interfaceMeshComponentNodeNumber,xi, &
      & err,error,*999)

    CALL EXITS("CMISSInterfaceMeshConnectivity_ElementXiSetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivity_ElementXiSetObj",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivity_ElementXiSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivity_ElementXiSetObj

  !
  !================================================================================================================================
  !

  SUBROUTINE CMISSInterfaceMeshConnectivity_BasisSetNumber(regionUserNumber,interfaceUserNumber,interfaceBasisNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceBasisNumber !<The user number of the basis to denote the interface mesh connectivity basis
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceMeshConnectivity_BasisSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(BASIS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL BASIS_USER_NUMBER_FIND(interfaceBasisNumber,BASIS,err,error,*999)
        IF (ASSOCIATED(BASIS)) THEN
          CALL INTERFACE_MESH_CONNECTIVITY_BASIS_SET(INTERFACE%MESH_CONNECTIVITY,BASIS,err,error,*999)
        ELSE
          LOCAL_ERROR="A basis with the user number "//TRIM(NUMBER_TO_VSTRING(interfaceBasisNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
     ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceMeshConnectivity_BasisSetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivity_BasisSetNumber",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivity_BasisSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivity_BasisSetNumber

  !
  !================================================================================================================================
  !

  !>Sets the basis for the mesh connectivity
  SUBROUTINE CMISSInterfaceMeshConnectivity_BasisSetObj(interfaceMeshConnectivity,interfaceMappingBasis,err)

    !Argument variables
    TYPE(CMISSInterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface to start the creation of the meshes connectivity for
    TYPE(CMISSBasisType), INTENT(INOUT) :: interfaceMappingBasis !<The interface mesh connectivity basis
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceMeshConnectivity_BasisSetObj",err,error,*999)

    CALL INTERFACE_MESH_CONNECTIVITY_BASIS_SET(interfaceMeshConnectivity%MESH_CONNECTIVITY,interfaceMappingBasis%BASIS, &
      & err,error,*999)

    CALL EXITS("CMISSInterfaceMeshConnectivity_BasisSetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivity_BasisSetObj",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivity_BasisSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivity_BasisSetObj

  !
  !================================================================================================================================
  !

  !>Destroys an interface meshes connectivity identified by a user number.
  SUBROUTINE CMISSInterfaceMeshConnectivity_DestroyNumber(regionUserNumber,interfaceUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy the meshes connectivity for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFInterfaceMeshConnectivityDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_MESH_CONNECTIVITY_DESTROY(INTERFACE%MESH_CONNECTIVITY,err,error,*999)
     ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceMeshConnectivity_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivity_DestroyNumber",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivity_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivity_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface meshes connectivity identified by an object.
  SUBROUTINE CMISSInterfaceMeshConnectivity_DestroyObj(interfaceMeshConnectivity,err)

    !Argument variables
    TYPE(CMISSInterfaceMeshConnectivityType), INTENT(IN) :: interfaceMeshConnectivity !<The interface meshes connectivity to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceMeshConnectivity_DestroyObj",err,error,*999)

    IF(ASSOCIATED(interfaceMeshConnectivity%MESH_CONNECTIVITY)) &
      &  CALL INTERFACE_MESH_CONNECTIVITY_DESTROY(interfaceMeshConnectivity%MESH_CONNECTIVITY,err,error,*999)

    CALL EXITS("CMISSInterfaceMeshConnectivity_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceMeshConnectivity_DestroyObj",err,error)
    CALL EXITS("CMISSInterfaceMeshConnectivity_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceMeshConnectivity_DestroyObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface coupled mesh points connectivity identified by a user number.
  SUBROUTINE CMISSInterfacePointsConnectivity_CreateFinishNumber(regionUserNumber,interfaceUserNumber,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface points connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to finish creating the points connectivity.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError
    
    CALL ENTERS("CMISSInterfacePointsConnectivity_CreateFinishNumber",err,error,*999)
 
    NULLIFY(region)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL interface_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL InterfacePointsConnectivity_CreateFinish(interface%pointsConnectivity,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfacePointsConnectivity_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSInterfacePointsConnectivity_CreateFinishNumber",err,error)
    CALL EXITS("CMISSInterfacePointsConnectivity_CreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,error)
    RETURN
    
  END SUBROUTINE CMISSInterfacePointsConnectivity_CreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of an interface meshes connectivity identified by an object.
  SUBROUTINE CMISSInterfacePointsConnectivity_CreateFinishObj(interfacePointsConnectivity,Err)
  
    !Argument variables
    TYPE(CMISSInterfacePointsConnectivityType), INTENT(IN) :: interfacePointsConnectivity !<The interface points connectivity to finish creating.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSInterfacePointsConnectivity_CreateFinishObj",err,error,*999)
 
    CALL InterfacePointsConnectivity_CreateFinish(interfacePointsConnectivity%pointsConnectivity,err,error,*999)

    CALL EXITS("CMISSInterfacePointsConnectivity_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSInterfacePointsConnectivity_CreateFinishObj",err,error)
    CALL EXITS("CMISSInterfacePointsConnectivity_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,error)
    RETURN
    
  END SUBROUTINE CMISSInterfacePointsConnectivity_CreateFinishObj
  
  !  
  !================================================================================================================================
  !   
  
  !>Starts the creation of an interface points connectivity identified by a user number.
  SUBROUTINE CMISSInterfacePointsConnectivity_CreateStartNumber(regionUserNumber,interfaceUserNumber,MeshNumber,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the meshes connectivity.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to start the creation of the meshes connectivity for.
    INTEGER(INTG), INTENT(IN) :: MeshNumber !<The user number of the interface mesh
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(InterfacePointsConnectivityType), POINTER :: interfacePointsConnectivity
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError
    
    CALL ENTERS("CMISSInterfacePointsConnectivity_CreateStartNumber",err,error,*999)
 
    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfacePointsConnectivity)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL MESH_USER_NUMBER_FIND(MeshNumber,interface,mesh,ERR,error,*999)
        IF(ASSOCIATED(mesh)) THEN
          CALL InterfacePointsConnectivity_CreateStart(interface,mesh,interfacePointsConnectivity,err,error,*999)
        ELSE
          localError="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
           & " does not exist on the interface with user number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_error(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_error(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_error(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfacePointsConnectivity_CreateStartNumber")
    RETURN
999 CALL errorS("CMISSInterfacePointsConnectivity_CreateStartNumber",err,error)
    CALL EXITS("CMISSInterfacePointsConnectivity_CreateStartNumber")
    CALL CMISS_HANDLE_error(Err,error)
    RETURN
    
  END SUBROUTINE CMISSInterfacePointsConnectivity_CreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Starts the creation of an interface points connectivity identified by an object.
  SUBROUTINE CMISSInterfacePointsConnectivity_CreateStartObj(interface,interfaceMesh,interfacePointsConnectivity,err)
  
    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: interface !<The interface to start the creation of the meshes connectivity for
    TYPE(CMISSMeshType), INTENT(IN) :: interfaceMesh
    TYPE(CMISSInterfacePointsConnectivityType), INTENT(INOUT) :: interfacePointsConnectivity !<On return, the created meshes connectivity
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfacePointsConnectivity_CreateStartObj",err,error,*999)

    CALL InterfacePointsConnectivity_CreateStart(interface%INTERFACE,interfaceMesh%MESH, &
      & InterfacePointsConnectivity%pointsConnectivity,err,error,*999)

    CALL EXITS("CMISSInterfacePointsConnectivity_CreateStartObj")
    RETURN
999 CALL errorS("CMISSInterfacePointsConnectivity_CreateStartObj",err,error)
    CALL EXITS("CMISSInterfacePointsConnectivity_CreateStartObj")
    CALL CMISS_HANDLE_error(err,error)
    RETURN
    
  END SUBROUTINE CMISSInterfacePointsConnectivity_CreateStartObj
  
  !
  !================================================================================================================================
  !

  !>Destroys an interface points connectivity identified by a user number.
  SUBROUTINE CMISSInterfacePointsConnectivity_DestroyNumber(regionUserNumber,interfaceUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to destroy the points connectivity for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface to destroy the points connectivity for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSInterfacePointsConnectivity_DestroyNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL InterfacePointsConnectivity_Destroy(interface%pointsConnectivity,err,error,*999)
     ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfacePointsConnectivity_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSInterfacePointsConnectivity_DestroyNumber",err,error)
    CALL EXITS("CMISSInterfacePointsConnectivity_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfacePointsConnectivity_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface points connectivity identified by an object.
  SUBROUTINE CMISSInterfacePointsConnectivity_DestroyObj(interfacePointsConnectivity,err)

    !Argument variables
    TYPE(CMISSInterfacePointsConnectivityType), INTENT(IN) :: interfacePointsConnectivity !<The interface points connectivity to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfacePointsConnectivity_DestroyObj",err,error,*999)

    CALL InterfacePointsConnectivity_Destroy(interfacePointsConnectivity%pointsConnectivity,err,error,*999)

    CALL EXITS("CMISSInterfacePointsConnectivity_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSInterfacePointsConnectivity_DestroyObj",err,error)
    CALL EXITS("CMISSInterfacePointsConnectivity_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfacePointsConnectivity_DestroyObj
  
  !  
  !================================================================================================================================
  ! 

  !>Gets coupled mesh element number that the data point in the interface is connected to
  SUBROUTINE CMISSInterfacePointsConnectivity_ElementNumberGetNumber(regionUserNumber,interfaceUserNumber, &
     &  interfaceDataPointIndexNumber,coupledMeshIndexNumber,meshComponentNumber,coupledMeshElementNumber,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface 
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the interface mesh that points connectivity is associated to
    INTEGER(INTG), INTENT(OUT) :: coupledMeshElementNumber !<The element number where the data point is connected to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError
    
    CALL ENTERS("CMISSInterfacePointsConnectivity_ElementNumberGetNumber",err,error,*999)
 
    NULLIFY(region)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL InterfacePointsConnectivity_ElementNumberGet(interface%pointsConnectivity,interfaceDataPointIndexNumber, &
         & coupledMeshIndexNumber,meshComponentNumber,coupledMeshElementNumber,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfacePointsConnectivity_ElementNumberGetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfacePointsConnectivity_ElementNumberGetNumber",err,error)
    CALL EXITS("CMISSInterfacePointsConnectivity_ElementNumberGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,error)
    RETURN
    
  END SUBROUTINE CMISSInterfacePointsConnectivity_ElementNumberGetNumber
  
  !  
  !================================================================================================================================
  !   

  !>Gets coupled mesh element number that the data point in the interface is connected to
  SUBROUTINE CMISSInterfacePointsConnectivity_ElementNumberGetObj(interfacePointsConnectivity,interfaceDataPointIndexNumber, &
      & coupledMeshIndexNumber,meshComponentNumber,coupledMeshElementNumber,err)
  
    !Argument variables
    TYPE(CMISSInterfacePointsConnectivityType), INTENT(IN) :: InterfacePointsConnectivity !<The interface points connectivity to set the element number for
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the interface mesh that points connectivity is associated to
    INTEGER(INTG), INTENT(OUT) :: coupledMeshElementNumber !<The element number where the data point is projected to.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSInterfacePointsConnectivity_ElementNumberGetObj",err,error,*999)
 
    CALL InterfacePointsConnectivity_ElementNumberGet(InterfacePointsConnectivity%pointsConnectivity, &
      & interfaceDataPointIndexNumber,coupledMeshIndexNumber,meshComponentNumber,coupledMeshElementNumber,err,error,*999)

    CALL EXITS("CMISSInterfacePointsConnectivity_ElementNumberGetObj")
    RETURN
999 CALL ERRORS("CMISSInterfacePointsConnectivity_ElementNumberGetObj",err,error)
    CALL EXITS("CMISSInterfacePointsConnectivity_ElementNumberGetObj")
    CALL CMISS_HANDLE_ERROR(Err,error)
    RETURN
    
  END SUBROUTINE CMISSInterfacePointsConnectivity_ElementNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets coupled mesh element number that the data point in the interface is connected to
  SUBROUTINE CMISSInterfacePointsConnectivity_ElementNumberSetNumber(regionUserNumber,interfaceUserNumber, &
     &  interfaceDataPointIndexNumber,coupledMeshIndexNumber,coupledMeshElementNumber,meshComponentNumber,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface 
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(IN) :: coupledMeshElementNumber !<The element number where the data point is projected to.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the points connectivity element number for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError
    
    CALL ENTERS("CMISSInterfacePointsConnectivity_ElementNumberSetNumber",err,error,*999)
 
    NULLIFY(region)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL InterfacePointsConnectivity_ElementNumberSet(interface%pointsConnectivity,interfaceDataPointIndexNumber, &
         & coupledMeshIndexNumber,coupledMeshElementNumber,meshComponentNumber,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfacePointsConnectivity_ElementNumberSetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfacePointsConnectivity_ElementNumberSetNumber",err,error)
    CALL EXITS("CMISSInterfacePointsConnectivity_ElementNumberSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,error)
    RETURN
    
  END SUBROUTINE CMISSInterfacePointsConnectivity_ElementNumberSetNumber
  
  !  
  !================================================================================================================================
  !   

  !>Sets coupled mesh element number that the data point in the interface is connected to
  SUBROUTINE CMISSInterfacePointsConnectivity_ElementNumberSetObj(interfacePointsConnectivity,interfaceDataPointIndexNumber, &
      & coupledMeshIndexNumber,coupledMeshElementNumber,meshComponentNumber,err)
  
    !Argument variables
    TYPE(CMISSInterfacePointsConnectivityType), INTENT(IN) :: InterfacePointsConnectivity !<The interface points connectivity to set the element number for
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(IN) :: coupledMeshElementNumber !<The element number where the data point is projected to.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the points connectivity element number for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSInterfacePointsConnectivity_ElementNumberSetObj",err,error,*999)
 
    CALL InterfacePointsConnectivity_ElementNumberSet(InterfacePointsConnectivity%pointsConnectivity, &
      & interfaceDataPointIndexNumber,coupledMeshIndexNumber,coupledMeshElementNumber,meshComponentNumber,err,error,*999)

    CALL EXITS("CMISSInterfacePointsConnectivity_ElementNumberSetObj")
    RETURN
999 CALL ERRORS("CMISSInterfacePointsConnectivity_ElementNumberSetObj",err,error)
    CALL EXITS("CMISSInterfacePointsConnectivity_ElementNumberSetObj")
    CALL CMISS_HANDLE_ERROR(Err,error)
    RETURN
    
  END SUBROUTINE CMISSInterfacePointsConnectivity_ElementNumberSetObj
  
  !  
  !================================================================================================================================
  !  

  !
  !================================================================================================================================
  !

  !>Gets the xi coordinate mapping between the data points in interface and xi coordinates in a coupled region mesh
  SUBROUTINE CMISSInterfacePointsConnectivity_PointXiGetNumber(regionUserNumber,interfaceUserNumber, &
      & interfaceDataPointIndexNumber,coupledMeshIndexNumber,xi,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface 
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    REAL(DP), INTENT(OUT) :: xi(:) !<xi(xiIdx). The full xi location in the coupled mesh that the data point is connected to 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError
    
    CALL ENTERS("CMISSInterfacePointsConnectivity_PointXiGetNumber",err,error,*999)
 
    NULLIFY(region)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,INTERFACE,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL InterfacePointsConnectivity_PointXiGet(interface%pointsConnectivity,interfaceDataPointIndexNumber, &
         & coupledMeshIndexNumber,xi,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfacePointsConnectivity_PointXiGetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfacePointsConnectivity_PointXiGetNumber",err,error)
    CALL EXITS("CMISSInterfacePointsConnectivity_PointXiGetNumber")
    CALL CMISS_HANDLE_ERROR(Err,error)
    RETURN
    
  END SUBROUTINE CMISSInterfacePointsConnectivity_PointXiGetNumber

  !
  !================================================================================================================================
  !
 
  !>Gets the xi coordinate mapping between the interface data points and xi coordinates in a coupled region mesh
  SUBROUTINE CMISSInterfacePointsConnectivity_PointXiGetObj(interfacePointsConnectivity,interfaceDataPointIndexNumber, & 
     &  coupledMeshIndexNumber,xi,Err)
  
    !Argument variables
    TYPE(CMISSInterfacePointsConnectivityType), INTENT(IN) :: InterfacePointsConnectivity !<The interface to start the creation of the meshes connectivity for
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    REAL(DP), INTENT(OUT) :: xi(:) !<xi(xiIdx). The full xi location in the coupled mesh that the data point is connected to 
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSInterfacePointsConnectivity_PointXiGetObj",err,error,*999)
 
    CALL InterfacePointsConnectivity_PointXiGet(InterfacePointsConnectivity%pointsConnectivity, &
      & interfaceDataPointIndexNumber,coupledMeshIndexNumber,xi,err,error,*999)

    CALL EXITS("CMISSInterfacePointsConnectivity_PointXiGetObj")
    RETURN
999 CALL ERRORS("CMISSInterfacePointsConnectivity_PointXiGetObj",err,error)
    CALL EXITS("CMISSInterfacePointsConnectivity_PointXiGetObj")
    CALL CMISS_HANDLE_ERROR(Err,error)
    RETURN
    
  END SUBROUTINE CMISSInterfacePointsConnectivity_PointXiGetObj

  !
  !================================================================================================================================
  !

  !>Sets the xi coordinate mapping between the data points in interface and xi coordinates in a coupled region mesh
  SUBROUTINE CMISSInterfacePointsConnectivity_PointXiSetNumber(regionUserNumber,interfaceUserNumber, &
      & interfaceDataPointIndexNumber,coupledMeshIndexNumber,xi,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface 
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    REAL(DP), INTENT(IN) :: xi(:) !<xi(xiIdx). The full xi location in the coupled mesh that the data point is connected to 
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError
    
    CALL ENTERS("CMISSInterfacePointsConnectivity_PointXiSetNumber",err,error,*999)
 
    NULLIFY(region)
    NULLIFY(interface)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL InterfacePointsConnectivity_PointXiSet(interface%pointsConnectivity,interfaceDataPointIndexNumber, &
         & coupledMeshIndexNumber,xi,err,error,*999)
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfacePointsConnectivity_PointXiSetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfacePointsConnectivity_PointXiSetNumber",err,error)
    CALL EXITS("CMISSInterfacePointsConnectivity_PointXiSetNumber")
    CALL CMISS_HANDLE_ERROR(Err,error)
    RETURN
    
  END SUBROUTINE CMISSInterfacePointsConnectivity_PointXiSetNumber

  !
  !================================================================================================================================
  !
 
  !>Sets the xi coordinate mapping between the interface data points and xi coordinates in a coupled region mesh
  SUBROUTINE CMISSInterfacePointsConnectivity_PointXiSetObj(interfacePointsConnectivity,interfaceDataPointIndexNumber, & 
     &  coupledMeshIndexNumber,xi,Err)
  
    !Argument variables
    TYPE(CMISSInterfacePointsConnectivityType), INTENT(IN) :: InterfacePointsConnectivity !<The interface to start the creation of the meshes connectivity for
    INTEGER(INTG), INTENT(IN) :: interfaceDataPointIndexNumber !<The index of the interface data point, i.e.user defined global number
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndexNumber !<The index number of the coupled mesh
    REAL(DP), INTENT(IN) :: xi(:) !<xi(xiIdx). The full xi location in the coupled mesh that the data point is connected to 
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSInterfacePointsConnectivity_PointXiSetObj",err,error,*999)
 
    CALL InterfacePointsConnectivity_PointXiSet(InterfacePointsConnectivity%pointsConnectivity, &
      & interfaceDataPointIndexNumber,coupledMeshIndexNumber,xi,err,error,*999)

    CALL EXITS("CMISSInterfacePointsConnectivity_PointXiSetObj")
    RETURN
999 CALL ERRORS("CMISSInterfacePointsConnectivity_PointXiSetObj",err,error)
    CALL EXITS("CMISSInterfacePointsConnectivity_PointXiSetObj")
    CALL CMISS_HANDLE_ERROR(Err,error)
    RETURN
    
  END SUBROUTINE CMISSInterfacePointsConnectivity_PointXiSetObj
  
  !  
  !================================================================================================================================
  !  

  !>Update points connectivity with projection results, data projection identified by region user number
  SUBROUTINE CMISSInterfacePointsConnectivity_UpdateFromProjectionRNumber(regionUserNumber,interfaceUserNumber, &
      & dataPointsRegionUserNumber,dataProjectionUserNumber,coupledMeshIndex,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface 
    INTEGER(INTG), INTENT(IN) :: dataPointsRegionUserNumber !<The region number of the data points which the data projection is associated with
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to update points connectivity with
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndex !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataProjectionGlobalNumber
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(REGION_TYPE), POINTER :: ParentRegion,dataPointsRegion
    TYPE(DATA_POINTS_TYPE), POINTER :: dataPoints
    TYPE(DATA_PROJECTION_TYPE), POINTER :: dataProjection
    TYPE(VARYING_STRING) :: localError
    
    CALL ENTERS("CMISSInterfacePointsConnectivity_UpdateFromProjectionRNumber",err,error,*999)
 
    NULLIFY(ParentRegion)
    NULLIFY(dataPointsRegion)
    NULLIFY(interface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,ParentRegion,err,error,*999)
    IF(ASSOCIATED(ParentRegion)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,ParentRegion,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL REGION_USER_NUMBER_FIND(dataPointsRegionUserNumber,dataPointsRegion,err,error,*999)
        CALL REGION_DATA_POINTS_GET(dataPointsRegion,dataPoints,err,error,*999)
        CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(dataPoints,DataProjectionUserNumber,dataProjectionGlobalNumber, &
          & err,ERROR,*999)
        CALL DATA_POINTS_DATA_PROJECTION_GET(dataPoints,dataProjectionGlobalNumber,dataProjection,err,ERROR,*999)
        CALL InterfacePointsConnectivity_UpdateFromProjection(Interface%PointsConnectivity, &
          & dataProjection,coupledMeshIndex,err,error,*999) 
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfacePointsConnectivity_UpdateFromProjectionRNumber")
    RETURN
999 CALL ERRORS("CMISSInterfacePointsConnectivity_UpdateFromProjectionRNumber",err,error)
    CALL EXITS("CMISSInterfacePointsConnectivity_UpdateFromProjectionRNumber")
    CALL CMISS_HANDLE_ERROR(Err,error)
    RETURN
    
  END SUBROUTINE CMISSInterfacePointsConnectivity_UpdateFromProjectionRNumber
  
  !  
  !================================================================================================================================
  !  

  !>Update points connectivity with projection results, data projection identified by interface user number
  SUBROUTINE CMISSInterfacePointsConnectivity_UpdateFromProjectionINumber(regionUserNumber,interfaceUserNumber, &
      & dataPointsRegionUserNumber,dataPointsInterfaceUserNumber,dataProjectionUserNumber,coupledMeshIndex,err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface 
    INTEGER(INTG), INTENT(IN) :: dataPointsRegionUserNumber !<The parent region number of the interface for the data points which the data projection is associated with
    INTEGER(INTG), INTENT(IN) :: dataPointsInterfaceUserNumber !<The interface number of the data points which the data projection is associated with
    INTEGER(INTG), INTENT(IN) :: dataProjectionUserNumber !<The data projection user number of the data projection to update points connectivity with
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndex !<The index number of the coupled mesh
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: dataProjectionGlobalNumber
    TYPE(INTERFACE_TYPE), POINTER :: interface,dataPointsInterface
    TYPE(REGION_TYPE), POINTER :: ParentRegion,dataPointsRegion
    TYPE(DATA_POINTS_TYPE), POINTER :: dataPoints
    TYPE(DATA_PROJECTION_TYPE), POINTER :: dataProjection
    TYPE(VARYING_STRING) :: localError
    
    CALL ENTERS("CMISSInterfacePointsConnectivity_UpdateFromProjectionINumber",err,error,*999)
 
    NULLIFY(ParentRegion)
    NULLIFY(dataPointsRegion)
    NULLIFY(interface)
    NULLIFY(dataPointsInterface)
    NULLIFY(dataPoints)
    NULLIFY(dataProjection)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,ParentRegion,err,error,*999)
    IF(ASSOCIATED(ParentRegion)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,ParentRegion,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL REGION_USER_NUMBER_FIND(dataPointsRegionUserNumber,dataPointsRegion,err,error,*999)
        CALL INTERFACE_USER_NUMBER_FIND(dataPointsInterfaceUserNumber,dataPointsRegion,dataPointsInterface,err,error,*999)
        CALL INTERFACE_DATA_POINTS_GET(dataPointsInterface,dataPoints,err,error,*999)
        CALL DATA_POINTS_DATA_PROJECTION_GLOBAL_NUMBER_GET(dataPoints,DataProjectionUserNumber,dataProjectionGlobalNumber, &
          & err,ERROR,*999)
        CALL DATA_POINTS_DATA_PROJECTION_GET(dataPoints,dataProjectionGlobalNumber,dataProjection,err,ERROR,*999)
        CALL InterfacePointsConnectivity_UpdateFromProjection(Interface%PointsConnectivity, &
          & dataProjection,coupledMeshIndex,err,error,*999) 
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSInterfacePointsConnectivity_UpdateFromProjectionINumber")
    RETURN
999 CALL ERRORS("CMISSInterfacePointsConnectivity_UpdateFromProjectionINumber",err,error)
    CALL EXITS("CMISSInterfacePointsConnectivity_UpdateFromProjectionINumber")
    CALL CMISS_HANDLE_ERROR(Err,error)
    RETURN
    
  END SUBROUTINE CMISSInterfacePointsConnectivity_UpdateFromProjectionINumber
  
  !  
  !================================================================================================================================
  !  

  !>Update points connectivity with projection results, data projection identified by object
  SUBROUTINE CMISSInterfacePointsConnectivity_UpdateFromProjectionObj(pointsConnectivity,dataProjection, &
      & coupledMeshIndex,err)
  
    !Argument variables
    TYPE(CMISSInterfacePointsConnectivityType), INTENT(IN) :: pointsConnectivity !<A pointer to the interface points connectivity to finish creating
    TYPE(CMISSDataProjectionType), INTENT(IN) :: dataProjection !<The data projection to update points connectivity with
    INTEGER(INTG), INTENT(IN) :: coupledMeshIndex !<The mesh index of the the points connectivity to be updated
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    
    CALL ENTERS("CMISSInterfacePointsConnectivity_UpdateFromProjectionObj",err,error,*999)
 
    CALL InterfacePointsConnectivity_UpdateFromProjection(pointsConnectivity%pointsConnectivity, &
      & dataProjection%DATA_PROJECTION,coupledMeshIndex,err,error,*999) 

    CALL EXITS("CMISSInterfacePointsConnectivity_UpdateFromProjectionObj")
    RETURN
999 CALL ERRORS("CMISSInterfacePointsConnectivity_UpdateFromProjectionObj",err,error)
    CALL EXITS("CMISSInterfacePointsConnectivity_UpdateFromProjectionObj")
    CALL CMISS_HANDLE_ERROR(Err,error)
    RETURN
    
  END SUBROUTINE CMISSInterfacePointsConnectivity_UpdateFromProjectionObj

!!==================================================================================================================================
!!
!! INTERFACE_CONDITIONS_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the creation of an interface condition identified by an user number.
  SUBROUTINE CMISSInterfaceCondition_CreateFinishNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containg the interface condition to finish creating for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceCondition_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_CREATE_FINISH(INTERFACE_CONDITION,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceCondition_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_CreateFinishNumber",err,error)
    CALL EXITS("CMISSInterfaceCondition_CreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceCondition_CreateFinishObj(interfaceCondition,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCondition_CreateFinishObj",err,error,*999)

    CALL INTERFACE_CONDITION_CREATE_FINISH(interfaceCondition%INTERFACE_CONDITION,err,error,*999)

    CALL EXITS("CMISSInterfaceCondition_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_CreateFinishObj",err,error)
    CALL EXITS("CMISSInterfaceCondition_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceCondition_CreateStartNumber(interfaceConditionUserNumber,regionUserNumber,interfaceUserNumber, &
    & geometricFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to start the creation of.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to start the creation of the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of.
    INTEGER(INTG), INTENT(IN) :: geometricFieldUserNumber !<The user number of the geometric field on the interface for the interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: GEOMETRIC_FIELD
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceCondition_CreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(GEOMETRIC_FIELD)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL FIELD_USER_NUMBER_FIND(geometricFieldUserNumber,INTERFACE,GEOMETRIC_FIELD,err,error,*999)
        IF(ASSOCIATED(GEOMETRIC_FIELD)) THEN
          CALL INTERFACE_CONDITION_CREATE_START(interfaceConditionUserNumber,INTERFACE,GEOMETRIC_FIELD,INTERFACE_CONDITION, &
            & err,error,*999)
        ELSE
          LOCAL_ERROR="A field with an user number of "//TRIM(NUMBER_TO_VSTRING(geometricFieldUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " in the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceCondition_CreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_CreateStartNumber",err,error)
    CALL EXITS("CMISSInterfaceCondition_CreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceCondition_CreateStartObj(interfaceConditionUserNumber,interface,geometricField,interfaceCondition,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface conditon to start the creation of.
    TYPE(CMISSInterfaceType), INTENT(IN) :: interface !<The interface to create the interface on.
    TYPE(CMISSFieldType), INTENT(IN) :: geometricField !<The geometric field for the interface condition.
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<On return, the created interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCondition_CreateStartObj",err,error,*999)

    CALL INTERFACE_CONDITION_CREATE_START(interfaceConditionUserNumber,interface%INTERFACE,geometricField%FIELD, &
      & interfaceCondition%INTERFACE_CONDITION,err,error,*999)

    CALL EXITS("CMISSInterfaceCondition_CreateStartObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_CreateStartObj",err,error)
    CALL EXITS("CMISSInterfaceCondition_CreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Adds a dependent variable to an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceCondition_DependentVariableAddNumber(interfaceRegionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,meshIndex,equationsSetRegionUserNumber,equationsSetUserNumber,variableType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the region containing the interface containing the interface condition to add the dependent variable for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to add the dependent variable for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to add the dependent variable for.
    INTEGER(INTG), INTENT(IN) :: meshIndex !<The mesh index of the interface condition interface for which the dependent variable is added.
    INTEGER(INTG), INTENT(IN) :: equationsSetRegionUserNumber !<The user number of the region containing the equations set containing the dependent field varible to add.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set containing the dependent field to add the variable for.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent variable to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: EQUATIONS_SET_REGION,INTERFACE_REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceCondition_DependentVariableAddNumber",err,error,*999)

    NULLIFY(INTERFACE_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(EQUATIONS_SET_REGION)
    NULLIFY(EQUATIONS_SET)
    CALL REGION_USER_NUMBER_FIND(interfaceRegionUserNumber,INTERFACE_REGION,err,error,*999)
    IF(ASSOCIATED(INTERFACE_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,INTERFACE_REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL REGION_USER_NUMBER_FIND(EquationsSetRegionuserNumber,EQUATIONS_SET_REGION,err,error,*999)
          IF(ASSOCIATED(EQUATIONS_SET_REGION)) THEN
            CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,EQUATIONS_SET_REGION,EQUATIONS_SET,err,error,*999)
            IF(ASSOCIATED(EQUATIONS_SET)) THEN
              CALL INTERFACE_CONDITION_DEPENDENT_VARIABLE_ADD(INTERFACE_CONDITION,meshIndex,EQUATIONS_SET,variableType, &
                & err,error,*999)
            ELSE
              LOCAL_ERROR="An equations set with an user number of "// &
                & TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
                & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(equationsSetRegionUserNumber,"*",err,error))//"."
              CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
            END IF
          ELSE
            LOCAL_ERROR="The equations set region with an user number of "// &
              & TRIM(NUMBER_TO_VSTRING(equationsSetRegionUserNumber,"*",err,error))//" does not exist."
            CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
          END IF
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="The interface region with an user number of "// &
        & TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceCondition_DependentVariableAddNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_DependentVariableAddNumber",err,error)
    CALL EXITS("CMISSInterfaceCondition_DependentVariableAddNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_DependentVariableAddNumber

  !
  !================================================================================================================================
  !

  !>Adds a dependent field variable to an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceCondition_DependentVariableAddObj(interfaceCondition,meshIndex,equationsSet,variableType,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to add the dependent variable to.
    INTEGER(INTG), INTENT(IN) :: meshIndex !<The mesh index of the interface condition interface for which the dependent variable is added.
    TYPE(CMISSEquationsSetType), INTENT(IN) :: equationsSet !<The equations set containg the dependent variable to add.
    INTEGER(INTG), INTENT(IN) :: variableType !<The variable type of the dependent variable to add.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCondition_DependentVariableAddObj",err,error,*999)

    CALL INTERFACE_CONDITION_DEPENDENT_VARIABLE_ADD(interfaceCondition%INTERFACE_CONDITION,meshIndex,equationsSet%EQUATIONS_SET, &
      & variableType,err,error,*999)

    CALL EXITS("CMISSInterfaceCondition_DependentVariableAddObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_DependentVariableAddObj",err,error)
    CALL EXITS("CMISSInterfaceCondition_DependentVariableAddObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_DependentVariableAddObj

  !
  !================================================================================================================================
  !

  !>Destroys an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceCondition_DestroyNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to destroy.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFInterfaceConditionDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_DESTROY(INTERFACE_CONDITION,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceCondition_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_DestroyNumber",err,error)
    CALL EXITS("CMISSInterfaceCondition_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceCondition_DestroyObj(interfaceCondition,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCondition_DestroyObj",err,error,*999)

    CALL INTERFACE_CONDITION_DESTROY(interfaceCondition%INTERFACE_CONDITION,err,error,*999)

    CALL EXITS("CMISSInterfaceCondition_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_DestroyObj",err,error)
    CALL EXITS("CMISSInterfaceCondition_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_DestroyObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of equations for an interface condition identified by an user number.
  SUBROUTINE CMISSInterfaceCondition_EquationsCreateFinishNumber(regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface to finish the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containg the interface condition to finish the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to finish creating the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceCondition_EquationsCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_CREATE_FINISH(INTERFACE_CONDITION,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceCondition_EquationsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_EquationsCreateFinishNumber",err,error)
    CALL EXITS("CMISSInterfaceCondition_EquationsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_EquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of interface equations for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceCondition_EquationsCreateFinishObj(interfaceCondition,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to finish creating the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCondition_EquationsCreateFinishObj",err,error,*999)

    CALL INTERFACE_CONDITION_EQUATIONS_CREATE_FINISH(interfaceCondition%INTERFACE_CONDITION,err,error,*999)

    CALL EXITS("CMISSInterfaceCondition_EquationsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_EquationsCreateFinishObj",err,error)
    CALL EXITS("CMISSInterfaceCondition_EquationsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_EquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of interface equations for an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceCondition_EquationsCreateStartNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to start the creation of the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to start the creation of the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceCondition_EquationsCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(INTERFACE_EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_CREATE_START(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceCondition_EquationsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_EquationsCreateStartNumber",err,error)
    CALL EXITS("CMISSInterfaceCondition_EquationsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_EquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of interface equations for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceCondition_EquationsCreateStartObj(interfaceCondition,interfaceEquations,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to start the creation of interface equations for
    TYPE(CMISSInterfaceEquationsType), INTENT(IN) :: interfaceEquations !<On return, the created interface equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCondition_EquationsCreateStartObj",err,error,*999)

    CALL INTERFACE_CONDITION_EQUATIONS_CREATE_START(interfaceCondition%INTERFACE_CONDITION,interfaceEquations% &
      & INTERFACE_EQUATIONS,err,error,*999)

    CALL EXITS("CMISSInterfaceCondition_EquationsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_EquationsCreateStartObj",err,error)
    CALL EXITS("CMISSInterfaceCondition_EquationsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_EquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys interface equations for an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceCondition_EquationsDestroyNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSFInterfaceConditionEquationsDestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_DESTROY(INTERFACE_CONDITION,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceCondition_EquationsDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_EquationsDestroyNumber",err,error)
    CALL EXITS("CMISSInterfaceCondition_EquationsDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_EquationsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the interface equations for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceCondition_EquationsDestroyObj(interfaceCondition,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to destroy the interface equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCondition_EquationsDestroyObj",err,error,*999)

    CALL INTERFACE_CONDITION_EQUATIONS_DESTROY(interfaceCondition%INTERFACE_CONDITION,err,error,*999)

    CALL EXITS("CMISSInterfaceCondition_EquationsDestroyObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_EquationsDestroyObj",err,error)
    CALL EXITS("CMISSInterfaceCondition_EquationsDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_EquationsDestroyObj
  
  !
  !================================================================================================================================
  !

  !>Returns the integration type for an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceCondition_IntegrationTypeGetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & interfaceConditionIntegrationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIntegrationType !<On return, the interface condition integration type. \see OPENCMISS_InterfaceConditionIntegrationTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: interfaceCondition
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSInterfaceCondition_IntegrationTypeGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,interface,interfaceCondition,err,error,*999)
        IF(ASSOCIATED(interfaceCondition)) THEN
          CALL InterfaceCondition_IntegrationTypeGet(interfaceCondition,interfaceConditionIntegrationType,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceCondition_IntegrationTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_IntegrationTypeGetNumber",err,error)
    CALL EXITS("CMISSInterfaceCondition_IntegrationTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_IntegrationTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the integration type for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceCondition_IntegrationTypeGetObj(interfaceCondition,interfaceConditionIntegrationType,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIntegrationType !<On return, the interface condition integration type. \see OPENCMISS_InterfaceConditionIntegrationTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCondition_IntegrationTypeGetObj",err,error,*999)

    CALL InterfaceCondition_IntegrationTypeGet(interfaceCondition%INTERFACE_CONDITION,interfaceConditionIntegrationType, &
      & err,error,*999)

    CALL EXITS("CMISSInterfaceCondition_IntegrationTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_IntegrationTypeGetObj",err,error)
    CALL EXITS("CMISSInterfaceCondition_IntegrationTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_IntegrationTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the integration type for an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceCondition_IntegrationTypeSetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & interfaceConditionIntegrationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionIntegrationType !<On return, the interface condition integration type. \see OPENCMISS_InterfaceConditionIntegrationTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: interface
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: interfaceCondition
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSInterfaceCondition_IntegrationTypeSetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(interface)
    NULLIFY(interfaceCondition)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,region,interface,err,error,*999)
      IF(ASSOCIATED(interface)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,interface,interfaceCondition,err,error,*999)
        IF(ASSOCIATED(interfaceCondition)) THEN
          CALL InterfaceCondition_IntegrationTypeSet(interfaceCondition,interfaceConditionIntegrationType,err,error,*999)
        ELSE
          localError="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(localError,err,error,*999)
        END IF
      ELSE
        localError="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceCondition_IntegrationTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_IntegrationTypeSetNumber",err,error)
    CALL EXITS("CMISSInterfaceCondition_IntegrationTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_IntegrationTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the integration type for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceCondition_IntegrationTypeSetObj(interfaceCondition,interfaceConditionIntegrationType,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionIntegrationType !<On return, the interface condition integration type. \see OPENCMISS_InterfaceConditionIntegrationTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCondition_MethodSetObj",err,error,*999)

    CALL InterfaceCondition_IntegrationTypeSet(interfaceCondition%INTERFACE_CONDITION,interfaceConditionIntegrationType, &
      & err,error,*999)

    CALL EXITS("CMISSInterfaceCondition_IntegrationTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_IntegrationTypeSetObj",err,error)
    CALL EXITS("CMISSInterfaceCondition_IntegrationTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_IntegrationTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a Lagrange Multiplier Field for an interface condition identified by an user number.
  SUBROUTINE CMISSInterfaceCondition_LagrangeFieldCreateFinishNumber(regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to finish the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containg the interface condition to finish the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to finish creating the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceCondition_LagrangeFieldCreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_LAGRANGE_FIELD_CREATE_FINISH(INTERFACE_CONDITION,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceCondition_LagrangeFieldCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_LagrangeFieldCreateFinishNumber",err,error)
    CALL EXITS("CMISSInterfaceCondition_LagrangeFieldCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_LagrangeFieldCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a Lagrange multiplier field for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceCondition_LagrangeFieldCreateFinishObj(interfaceCondition,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to finish creating the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCondition_LagrangeFieldCreateFinishObj",err,error,*999)

    CALL INTERFACE_CONDITION_LAGRANGE_FIELD_CREATE_FINISH(interfaceCondition%INTERFACE_CONDITION,err,error,*999)

    CALL EXITS("CMISSInterfaceCondition_LagrangeFieldCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_LagrangeFieldCreateFinishObj",err,error)
    CALL EXITS("CMISSInterfaceCondition_LagrangeFieldCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_LagrangeFieldCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a Lagrange multiplier field for an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceCondition_LagrangeFieldCreateStartNumber(regionUserNumber,interfaceUserNumber, &
    & interfaceConditionUserNumber,lagrangeFieldUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface and interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: lagrangeFieldUserNumber !<The user number of the Lagrange field.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: LAGRANGE_FIELD
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceCondition_LagrangeFieldCreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(LAGRANGE_FIELD)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_LAGRANGE_FIELD_CREATE_START(INTERFACE_CONDITION,lagrangeFieldUserNumber,LAGRANGE_FIELD, &
            & err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceCondition_LagrangeFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_LagrangeFieldCreateStartNumber",err,error)
    CALL EXITS("CMISSInterfaceCondition_LagrangeFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_LagrangeFieldCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a Lagrange multiplier field for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceCondition_LagrangeFieldCreateStartObj(interfaceCondition,lagrangeFieldUserNumber,lagrangeField,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to start the creation of the Lagrange multiplier field for.
    INTEGER(INTG), INTENT(IN) :: lagrangeFieldUserNumber !<The user number of the Lagrange field.
    TYPE(CMISSFieldType), INTENT(INOUT) :: lagrangeField !<If associated on entry, the user created Lagrange field which has the same user number as the specified Lagrange field user number. If not associated on entry, on return, the created Lagrange field for the interface condition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCondition_LagrangeFieldCreateStartObj",err,error,*999)

    CALL INTERFACE_CONDITION_LAGRANGE_FIELD_CREATE_START(interfaceCondition%INTERFACE_CONDITION,lagrangeFieldUserNumber, &
      & lagrangeField%FIELD,err,error,*999)

    CALL EXITS("CMISSInterfaceCondition_LagrangeFieldCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_LagrangeFieldCreateStartObj",err,error)
    CALL EXITS("CMISSInterfaceCondition_LagrangeFieldCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_LagrangeFieldCreateStartObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a penalty Field for an interface condition identified by an user number.
  SUBROUTINE CMISSInterfaceCondition_PenaltyFieldCreateFinishNumber(RegionUserNumber,InterfaceUserNumber, &
    & InterfaceConditionUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the interface and interface condition to finish the penalty field for.
    INTEGER(INTG), INTENT(IN) :: InterfaceUserNumber !<The user number of the interface containg the interface condition to finish the penalty  field for.
    INTEGER(INTG), INTENT(IN) :: InterfaceConditionUserNumber !<The user number of the interface condition to finish creating the penalty field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSInterfaceCondition_PenaltyFieldCreateFinishNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(InterfaceUserNumber,REGION,INTERFACE,Err,ERROR,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(InterfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,Err,ERROR,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_PENALTY_FIELD_CREATE_FINISH(INTERFACE_CONDITION,Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(InterfaceConditionUserNumber,"*",Err,ERROR))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(InterfaceUserNumber,"*",Err,ERROR))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(InterfaceUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceCondition_PenaltyFieldCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_PenaltyFieldCreateFinishNumber",Err,ERROR)
    CALL EXITS("CMISSInterfaceCondition_PenaltyFieldCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSInterfaceCondition_PenaltyFieldCreateFinishNumber

  !  
  !================================================================================================================================
  !  
 
  !>Finishes the creation of a penalty field for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceCondition_PenaltyFieldCreateFinishObj(InterfaceCondition,Err)
  
    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: InterfaceCondition !<The interface condition to finish creating the penalty field for.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSInterfaceCondition_PenaltyFieldCreateFinishObj",Err,ERROR,*999)
 
    CALL INTERFACE_CONDITION_PENALTY_FIELD_CREATE_FINISH(InterfaceCondition%INTERFACE_CONDITION,Err,ERROR,*999)

    CALL EXITS("CMISSInterfaceCondition_PenaltyFieldCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_PenaltyFieldCreateFinishObj",Err,ERROR)
    CALL EXITS("CMISSInterfaceCondition_PenaltyFieldCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSInterfaceCondition_PenaltyFieldCreateFinishObj

  !  
  !================================================================================================================================
  !  
 
  !>Starts the creation of a penalty field for an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceCondition_PenaltyFieldCreateStartNumber(RegionUserNumber,InterfaceUserNumber, &
    & InterfaceConditionUserNumber,PenaltyFieldUserNumber,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: RegionUserNumber !<The user number of the region containing the interface and interface condition to start the creation of the penalty field for.
    INTEGER(INTG), INTENT(IN) :: InterfaceUserNumber !<The user number of the interface containing the interface condition to start the creation of the penalty field for.
    INTEGER(INTG), INTENT(IN) :: InterfaceConditionUserNumber !<The user number of the interface condition to start the creation of the penalty field for.
    INTEGER(INTG), INTENT(IN) :: PenaltyFieldUserNumber !<The user number of the penalty field.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(FIELD_TYPE), POINTER :: PENALTY_FIELD
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSInterfaceCondition_PenaltyFieldCreateStartNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(PENALTY_FIELD)
    CALL REGION_USER_NUMBER_FIND(RegionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(InterfaceUserNumber,REGION,INTERFACE,Err,ERROR,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(InterfaceUserNumber,INTERFACE,INTERFACE_CONDITION,Err,ERROR,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_PENALTY_FIELD_CREATE_START(INTERFACE_CONDITION,PenaltyFieldUserNumber,PENALTY_FIELD, &
            & Err,ERROR,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(InterfaceConditionUserNumber,"*",Err,ERROR))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(InterfaceUserNumber,"*",Err,ERROR))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(InterfaceUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(RegionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSInterfaceCondition_PenaltyFieldCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_PenaltyFieldCreateStartNumber",Err,ERROR)
    CALL EXITS("CMISSInterfaceCondition_PenaltyFieldCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSInterfaceCondition_PenaltyFieldCreateStartNumber

  !  
  !================================================================================================================================
  !  
 
  !>Starts the creation of a penalty field for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceCondition_PenaltyFieldCreateStartObj(InterfaceCondition,PenaltyFieldUserNumber,PenaltyField,Err)
  
    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: InterfaceCondition !<The interface condition to start the creation of the penalty field for.
    INTEGER(INTG), INTENT(IN) :: PenaltyFieldUserNumber !<The user number of the penalty field.
    TYPE(CMISSFieldType), INTENT(INOUT) :: PenaltyField !<If associated on entry, the user created penalty field which has the same user number as the specified penalty field user number. If not associated on entry, on return, the created penalty field for the interface condition.
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSInterfaceCondition_PenaltyFieldCreateStartObj",Err,ERROR,*999)
 
    CALL INTERFACE_CONDITION_PENALTY_FIELD_CREATE_START(InterfaceCondition%INTERFACE_CONDITION,PenaltyFieldUserNumber, &
      & PenaltyField%FIELD,Err,ERROR,*999)

    CALL EXITS("CMISSInterfaceCondition_PenaltyFieldCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_PenaltyFieldCreateStartObj",Err,ERROR)
    CALL EXITS("CMISSInterfaceCondition_PenaltyFieldCreateStartObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSInterfaceCondition_PenaltyFieldCreateStartObj

  !  
  !================================================================================================================================
  !   

  !>Returns the method for an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceCondition_MethodGetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & interfaceConditionMethod,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionMethod !<On return, the interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceCondition_MethodGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_METHOD_GET(INTERFACE_CONDITION,interfaceConditionMethod,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceCondition_MethodGetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_MethodGetNumber",err,error)
    CALL EXITS("CMISSInterfaceCondition_MethodGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_MethodGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the method for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceCondition_MethodGetObj(interfaceCondition,interfaceConditionMethod,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the method for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionMethod !<On return, the interface condition method. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCondition_MethodGetObj",err,error,*999)

    CALL INTERFACE_CONDITION_METHOD_GET(interfaceCondition%INTERFACE_CONDITION,interfaceConditionMethod,err,error,*999)

    CALL EXITS("CMISSInterfaceCondition_MethodGetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_MethodGetObj",err,error)
    CALL EXITS("CMISSInterfaceCondition_MethodGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_MethodGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the method for an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceCondition_MethodSetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & interfaceConditionMethod,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionMethod !<The interface condition method to set. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceCondition_MethodSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_METHOD_SET(INTERFACE_CONDITION,interfaceConditionMethod,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceCondition_MethodSetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_MethodSetNumber",err,error)
    CALL EXITS("CMISSInterfaceCondition_MethodSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_MethodSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the method for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceCondition_MethodSetObj(interfaceCondition,interfaceConditionMethod,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the method for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionMethod !<The interface condition method to set. \see OPENCMISS_InterfaceConditionMethods,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCondition_MethodSetObj",err,error,*999)

    CALL INTERFACE_CONDITION_METHOD_SET(interfaceCondition%INTERFACE_CONDITION,interfaceConditionMethod,err,error,*999)

    CALL EXITS("CMISSInterfaceCondition_MethodSetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_MethodSetObj",err,error)
    CALL EXITS("CMISSInterfaceCondition_MethodSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_MethodSetObj

  !
  !================================================================================================================================
  !

  !>Returns the operator for an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceCondition_OperatorGetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & interfaceConditionOperator,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to get the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to get the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to get the operator for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionOperator !<On return, the interface condition operator. \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceCondition_OperatorGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_OPERATOR_GET(INTERFACE_CONDITION,interfaceConditionOperator,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceCondition_OperatorGetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_OperatorGetNumber",err,error)
    CALL EXITS("CMISSInterfaceCondition_OperatorGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_OperatorGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the operator for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceCondition_OperatorGetObj(interfaceCondition,interfaceConditionOperator,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to get the operator for.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionOperator !<On return, the interface condition operator. \see OPENCMISS_InterfaceConditionOperator,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCondition_OperatorGetObj",err,error,*999)

    CALL INTERFACE_CONDITION_OPERATOR_GET(interfaceCondition%INTERFACE_CONDITION,interfaceConditionOperator, &
      & err,error,*999)

    CALL EXITS("CMISSInterfaceCondition_OperatorGetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_OperatorGetObj",err,error)
    CALL EXITS("CMISSInterfaceCondition_OperatorGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_OperatorGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the operator for an interface condition identified by a user number.
  SUBROUTINE CMISSInterfaceCondition_OperatorSetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & interfaceConditionOperator,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface containing the interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionOperator !<The interface condition operator to set. \see OPENCMISS_InterfaceConditionOperators,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceCondition_OperatorSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_OPERATOR_SET(INTERFACE_CONDITION,interfaceConditionOperator,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceCondition_OperatorSetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_OperatorSetNumber",err,error)
    CALL EXITS("CMISSInterfaceCondition_OperatorSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_OperatorSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the operator for an interface condition identified by an object.
  SUBROUTINE CMISSInterfaceCondition_OperatorSetObj(interfaceCondition,interfaceConditionOperator,err)

    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to set the operator for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionOperator !<The interface condition operator to set. \see OPENCMISS_InterfaceConditionOperator,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceCondition_OperatorSetObj",err,error,*999)

    CALL INTERFACE_CONDITION_OPERATOR_SET(interfaceCondition%INTERFACE_CONDITION,interfaceConditionOperator, &
      & err,error,*999)

    CALL EXITS("CMISSInterfaceCondition_OperatorSetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceCondition_OperatorSetObj",err,error)
    CALL EXITS("CMISSInterfaceCondition_OperatorSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceCondition_OperatorSetObj

  !
  !================================================================================================================================
  !

  !>Returns the output type for an interface equations identified by a user number.
  SUBROUTINE CMISSInterfaceEquations_OutputTypeGetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the ouput type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the interface equations output type. \see OPENCMISS_EquationsOutputType,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceEquations_OutputTypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(INTERFACE_EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_GET(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*999)
          CALL INTERFACE_EQUATIONS_OUTPUT_TYPE_GET(INTERFACE_EQUATIONS,outputType,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceEquations_OutputTypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquations_OutputTypeGetNumber",err,error)
    CALL EXITS("CMISSInterfaceEquations_OutputTypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquations_OutputTypeGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the output type for an interface equations identified by an object.
  SUBROUTINE CMISSInterfaceEquations_OutputTypeGetObj(interfaceEquations,outputType,err)

    !Argument variables
    TYPE(CMISSInterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the output type for.
    INTEGER(INTG), INTENT(OUT) :: outputType !<On return, the interface equations output type. \see OPENCMISS_EquationsOutputType,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceEquations_OutputTypeGetObj",err,error,*999)

    CALL INTERFACE_EQUATIONS_OUTPUT_TYPE_GET(interfaceEquations%INTERFACE_EQUATIONS,outputType,err,error,*999)

    CALL EXITS("CMISSInterfaceEquations_OutputTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquations_OutputTypeGetObj",err,error)
    CALL EXITS("CMISSInterfaceEquations_OutputTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquations_OutputTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an interface equations identified by a user number.
  SUBROUTINE CMISSInterfaceEquations_OutputTypeSetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The interface equations output type to set. \see OPENCMISS_EquationsOutputTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceEquations_OutputTypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(INTERFACE_EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_GET(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*999)
          CALL INTERFACE_EQUATIONS_OUTPUT_TYPE_SET(INTERFACE_EQUATIONS,outputType,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceEquations_OutputTypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquations_OutputTypeSetNumber",err,error)
    CALL EXITS("CMISSInterfaceEquations_OutputTypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquations_OutputTypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for an interface equations identified by an object.
  SUBROUTINE CMISSInterfaceEquations_OutputTypeSetObj(interfaceEquations,outputType,err)

    !Argument variables
    TYPE(CMISSInterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The interface equations output type to set. \see OPENCMISS_EquationsOutputTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceEquations_OutputTypeSetObj",err,error,*999)

    CALL INTERFACE_EQUATIONS_OUTPUT_TYPE_SET(interfaceEquations%INTERFACE_EQUATIONS,outputType,err,error,*999)

    CALL EXITS("CMISSInterfaceEquations_OutputTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquations_OutputTypeSetObj",err,error)
    CALL EXITS("CMISSInterfaceEquations_OutputTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquations_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the sparsity type for an interface equations identified by a user number.
  SUBROUTINE CMISSInterfaceEquations_SparsityGetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to get the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to get the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equation to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the interface equations sparsity type. \see OPENCMISS_EquationsSparsityType,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceEquations_SparsityGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(INTERFACE_EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_GET(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*999)
          CALL INTERFACE_EQUATIONS_SPARSITY_TYPE_GET(INTERFACE_EQUATIONS,sparsityType,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceEquations_SparsityGetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquations_SparsityGetNumber",err,error)
    CALL EXITS("CMISSInterfaceEquations_SparsityGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquations_SparsityGetNumber

  !
  !================================================================================================================================
  !

  !>Gets the sparsity type for an interface equations identified by an object.
  SUBROUTINE CMISSInterfaceEquations_SparsityGetObj(interfaceEquations,sparsityType,err)

    !Argument variables
    TYPE(CMISSInterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to get the sparsity type for.
    INTEGER(INTG), INTENT(OUT) :: sparsityType !<On return, the interface equations sparsity type. \see OPENCMISS_EquationsSparsityType,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceEquations_SparsityGetObj",err,error,*999)

    CALL INTERFACE_EQUATIONS_SPARSITY_TYPE_GET(interfaceEquations%INTERFACE_EQUATIONS,sparsityType,err,error,*999)

    CALL EXITS("CMISSInterfaceEquations_SparsityGetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquations_SparsityGetObj",err,error)
    CALL EXITS("CMISSInterfaceEquations_SparsityGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquations_SparsityGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for an interface equations identified by a user number.
  SUBROUTINE CMISSInterfaceEquations_SparsitySetNumber(regionUserNumber,interfaceUserNumber,interfaceConditionUserNumber, &
    & sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the interface, interface condition and interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface, interface condition and interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition and interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The interface equations sparsity type to set. \see OPENCMISS_EquationsSparsityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: INTERFACE_EQUATIONS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSInterfaceEquations_SparsitySetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    NULLIFY(INTERFACE_EQUATIONS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,REGION,INTERFACE,err,error,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
        IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
          CALL INTERFACE_CONDITION_EQUATIONS_GET(INTERFACE_CONDITION,INTERFACE_EQUATIONS,err,error,*999)
          CALL INTERFACE_EQUATIONS_SPARSITY_TYPE_SET(INTERFACE_EQUATIONS,sparsityType,err,error,*999)
        ELSE
          LOCAL_ERROR="An interface condition with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
            & " does not exist on the interface with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " defined on a region with a user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
          & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSInterfaceEquations_SparsitySetNumber")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquations_SparsitySetNumber",err,error)
    CALL EXITS("CMISSInterfaceEquations_SparsitySetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquations_SparsitySetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for an interface equations identified by an object.
  SUBROUTINE CMISSInterfaceEquations_SparsitySetObj(interfaceEquations,sparsityType,err)

    !Argument variables
    TYPE(CMISSInterfaceEquationsType), INTENT(IN) :: interfaceEquations !<The interface equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The interface equations sparsity type to set. \see OPENCMISS_EquationsSparsityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSInterfaceEquations_SparsitySetObj",err,error,*999)

    CALL INTERFACE_EQUATIONS_SPARSITY_TYPE_SET(interfaceEquations%INTERFACE_EQUATIONS,sparsityType,err,error,*999)

    CALL EXITS("CMISSInterfaceEquations_SparsitySetObj")
    RETURN
999 CALL ERRORS("CMISSInterfaceEquations_SparsitySetObj",err,error)
    CALL EXITS("CMISSInterfaceEquations_SparsitySetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSInterfaceEquations_SparsitySetObj

!!==================================================================================================================================
!!
!! MESH_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the creation of a domain decomposition for a decomposition identified by a user number.
  SUBROUTINE CMISSDecomposition_CreateFinishNumber(regionUserNumber,meshUserNumber,decompositionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to finish the decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to finish the decomposition for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to finish.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecomposition_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_CREATE_FINISH(DECOMPOSITION,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Decomposition Create')
#endif

    CALL EXITS("CMISSDecomposition_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSDecomposition_CreateFinishNumber",err,error)
    CALL EXITS("CMISSDecomposition_CreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a domain decomposition for a decomposition identified by an object.
  SUBROUTINE CMISSDecomposition_CreateFinishObj(decomposition,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_CreateFinishObj",err,error,*999)

    CALL DECOMPOSITION_CREATE_FINISH(decomposition%DECOMPOSITION,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('decomposition Create')
#endif

    CALL EXITS("CMISSDecomposition_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_CreateFinishObj",err,error)
    CALL EXITS("CMISSDecomposition_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_CreateFinishObj

  !
  !================================================================================================================================
  !

  !> Calculates the decomposition topology for data points
  SUBROUTINE CMISSDecomposition_TopologyDataProjectionCalculateObj(decomposition,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_TopologyDataProjectionCalculateObj",err,error,*999)

    CALL DecompositionTopologyDataProjectionCalculate(decomposition%DECOMPOSITION%TOPOLOGY,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('CMISSDecomposition_TopologyDataProjectionCalculateObj',err,error,*999)
#endif

    CALL EXITS("CMISSDecomposition_TopologyDataProjectionCalculateObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_TopologyDataProjectionCalculateObj",err,error)
    CALL EXITS("CMISSDecomposition_TopologyDataProjectionCalculateObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_TopologyDataProjectionCalculateObj

  !
  !================================================================================================================================
  !

  !>Gets the local data point number for data points projected on an element
  SUBROUTINE CMISSDecomposition_TopologyElementDataPointLocalNumberGetObj(decomposition,elementNumber,dataPointIndex, &
       & dataPointLocalNumber,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The element number to get the data point for
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The data point index to get the number for
    INTEGER(INTG), INTENT(OUT) :: dataPointLocalNumber !<The data point local number to retu
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_TopologyElementDataPointLocalNumberGetObj",err,error,*999)

    CALL DecompositionTopologyElementDataPointLocalNumberGet(decomposition%DECOMPOSITION%TOPOLOGY,elementNumber,dataPointIndex, &
     & dataPointLocalNumber,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('CMISSDecomposition_TopologyElementDataPointLocalNumberGetObj',err,error,*999)
#endif

    CALL EXITS("CMISSDecomposition_TopologyElementDataPointLocalNumberGetObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_TopologyElementDataPointLocalNumberGetObj",err,error)
    CALL EXITS("CMISSDecomposition_TopologyElementDataPointLocalNumberGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_TopologyElementDataPointLocalNumberGetObj

  !
  !================================================================================================================================
  !

  !>Gets the user data point number for data points projected on an element
  SUBROUTINE CMISSDecomposition_TopologyElementDataPointUserNumberGetObj(decomposition,elementNumber,dataPointIndex, &
       & dataPointUserNumber,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The element number to get the data point for
    INTEGER(INTG), INTENT(IN) :: dataPointIndex !<The data point index to get the number for
    INTEGER(INTG), INTENT(OUT) :: dataPointUserNumber !<The data point user number to retu
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_TopologyElementDataPointUserNumberGetObj",err,error,*999)

    CALL DecompositionTopologyElementDataPointUserNumberGet(decomposition%DECOMPOSITION%TOPOLOGY,elementNumber,dataPointIndex, &
     & dataPointUserNumber,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('CMISSDecomposition_TopologyElementDataPointUserNumberGetObj',err,error,*999)
#endif

    CALL EXITS("CMISSDecomposition_TopologyElementDataPointUserNumberGetObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_TopologyElementDataPointUserNumberGetObj",err,error)
    CALL EXITS("CMISSDecomposition_TopologyElementDataPointUserNumberGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_TopologyElementDataPointUserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Gets the number of data points projected on an element
  SUBROUTINE CMISSDecomposition_TopologyNumberOfElementDataPointsGetObj(decomposition,elementNumber,numberOfDataPoints,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to finish creating.
    INTEGER(INTG), INTENT(IN) :: elementNumber !<The element number to get the data point for
    INTEGER(INTG), INTENT(OUT) :: numberOfDataPoints !<The data point local number to return
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_TopologyNumberOfElementDataPointsGetObj",err,error,*999)

    CALL DecompositionTopologyNumberOfElementDataPointsGet(decomposition%DECOMPOSITION%TOPOLOGY,elementNumber, &
     & numberOfDataPoints,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('CMISSDecomposition_TopologyNumberOfElementDataPointsGetObj',err,error,*999)
#endif

    CALL EXITS("CMISSDecomposition_TopologyNumberOfElementDataPointsGetObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_TopologyNumberOfElementDataPointsGetObj",err,error)
    CALL EXITS("CMISSDecomposition_TopologyNumberOfElementDataPointsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_TopologyNumberOfElementDataPointsGetObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a domain decomposition for a decomposition identified by a user number.
  SUBROUTINE CMISSDecomposition_CreateStartNumber(decompositionUserNumber,regionUserNumber,meshUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to create.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to create the decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to create the decomposition for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecomposition_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Decomposition Create')
#endif

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_CREATE_START(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDecomposition_CreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSDecomposition_CreateStartNumber",err,error)
    CALL EXITS("CMISSDecomposition_CreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a domain decomposition for a decomposition identified by an object.
  SUBROUTINE CMISSDecomposition_CreateStartObj(decompositionUserNumber,mesh,decomposition,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to create.
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to create the decomposition for.
    TYPE(CMISSDecompositionType), INTENT(INOUT) :: decomposition !<On return, the created decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('decomposition Create')
#endif

    CALL DECOMPOSITION_CREATE_START(decompositionUserNumber,mesh%MESH,decomposition%DECOMPOSITION,err,error,*999)

    CALL EXITS("CMISSDecomposition_CreateStartObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_CreateStartObj",err,error)
    CALL EXITS("CMISSDecomposition_CreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a decomposition identified by a user number.
  SUBROUTINE CMISSDecomposition_DestroyNumber(regionUserNumber,meshUserNumber,decompositionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to destroy the decomposition for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to destroy the decomposition for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecomposition_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_DESTROY(DECOMPOSITION,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDecomposition_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSDecomposition_DestroyNumber",err,error)
    CALL EXITS("CMISSDecomposition_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a decomposition identified by an object.
  SUBROUTINE CMISSDecomposition_DestroyObj(decomposition,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_DestroyObj",err,error,*999)

    CALL DECOMPOSITION_DESTROY(decomposition%DECOMPOSITION,err,error,*999)

    CALL EXITS("CMISSDecomposition_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_DestroyObj",err,error)
    CALL EXITS("CMISSDecomposition_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_DestroyObj

  !
  !================================================================================================================================
  !

  !>Calculates the element domains for a decomposition identified by a user number.
  SUBROUTINE CMISSDecomposition_ElementDomainCalculateNumber(regionUserNumber,meshUserNumber,decompositionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to calculate the element domains for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to calculate the element domains for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to calculate the element domains for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecomposition_ElementDomainCalculateNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_ELEMENT_DOMAIN_CALCULATE(DECOMPOSITION,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDecomposition_ElementDomainCalculateNumber")
    RETURN
999 CALL ERRORS("CMISSDecomposition_ElementDomainCalculateNumber",err,error)
    CALL EXITS("CMISSDecomposition_ElementDomainCalculateNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_ElementDomainCalculateNumber

  !
  !================================================================================================================================
  !

  !>Calculates the element domains for a decomposition identified by an object.
  SUBROUTINE CMISSDecomposition_ElementDomainCalculateObj(decomposition,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to calcualte the element domains for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_ElementDomainCalculateObj",err,error,*999)

    CALL DECOMPOSITION_ELEMENT_DOMAIN_CALCULATE(decomposition%DECOMPOSITION,err,error,*999)

    CALL EXITS("CMISSDecomposition_ElementDomainCalculateObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_ElementDomainCalculateObj",err,error)
    CALL EXITS("CMISSDecomposition_ElementDomainCalculateObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_ElementDomainCalculateObj

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given element in a decomposition identified by a user number.
  SUBROUTINE CMISSDecomposition_ElementDomainGetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & elementUserNumber,domain,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the element domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computational domain of the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecomposition_ElementDomainGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_ELEMENT_DOMAIN_GET(DECOMPOSITION,elementUserNumber,domain,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDecomposition_ElementDomainGetNumber")
    RETURN
999 CALL ERRORS("CMISSDecomposition_ElementDomainGetNumber",err,error)
    CALL EXITS("CMISSDecomposition_ElementDomainGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_ElementDomainGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given element in a decomposition identified by an object.
  SUBROUTINE CMISSDecomposition_ElementDomainGetObj(decomposition,elementUserNumber,domain,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computational domain of the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_ElementDomainGetObj",err,error,*999)

    CALL DECOMPOSITION_ELEMENT_DOMAIN_GET(decomposition%DECOMPOSITION,elementUserNumber,domain,err,error,*999)

    CALL EXITS("CMISSDecomposition_ElementDomainGetObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_ElementDomainGetObj",err,error)
    CALL EXITS("CMISSDecomposition_ElementDomainGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_ElementDomainGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the domain for a given element in a decomposition identified by a user number.
  SUBROUTINE CMISSDecomposition_ElementDomainSetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & elementUserNumber,domain,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the domain for.
    INTEGER(INTG), INTENT(IN) :: domain !<The computational domain of the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecomposition_ElementDomainSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_ELEMENT_DOMAIN_SET(DECOMPOSITION,elementUserNumber,domain,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDecomposition_ElementDomainSetNumber")
    RETURN
999 CALL ERRORS("CMISSDecomposition_ElementDomainSetNumber",err,error)
    CALL EXITS("CMISSDecomposition_ElementDomainSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_ElementDomainSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the domain for a given element in a decomposition identified by an object.
  SUBROUTINE CMISSDecomposition_ElementDomainSetObj(decomposition,elementUserNumber,domain,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the element domain for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to set the domain for.
    INTEGER(INTG), INTENT(IN) :: domain !<The computational domain of the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_ElementDomainSetObj",err,error,*999)

    CALL DECOMPOSITION_ELEMENT_DOMAIN_SET(decomposition%DECOMPOSITION,elementUserNumber,domain,err,error,*999)

    CALL EXITS("CMISSDecomposition_ElementDomainSetObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_ElementDomainSetObj",err,error)
    CALL EXITS("CMISSDecomposition_ElementDomainSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_ElementDomainSetObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number used for the decomposition of a mesh for a decomposition identified by a user number.
  SUBROUTINE CMISSDecomposition_MeshComponentGetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the mesh component for.
    INTEGER(INTG), INTENT(OUT) :: meshComponentNumber !<On return, the mesh component number for the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecomposition_MeshComponentGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_MESH_COMPONENT_NUMBER_GET(DECOMPOSITION,meshComponentNumber,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDecomposition_MeshComponentGetNumber")
    RETURN
999 CALL ERRORS("CMISSDecomposition_MeshComponentGetNumber",err,error)
    CALL EXITS("CMISSDecomposition_MeshComponentGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_MeshComponentGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the mesh component number used for the decomposition of a mesh for a decomposition identified by an object.
  SUBROUTINE CMISSDecomposition_MeshComponentGetObj(decomposition,meshComponentNumber,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the mesh component for.
    INTEGER(INTG), INTENT(OUT) :: meshComponentNumber !<On return, the mesh component number for the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_MeshComponentGetObj",err,error,*999)

    CALL DECOMPOSITION_MESH_COMPONENT_NUMBER_GET(decomposition%DECOMPOSITION,meshComponentNumber,err,error,*999)

    CALL EXITS("CMISSDecomposition_MeshComponentGetObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_MeshComponentGetObj",err,error)
    CALL EXITS("CMISSDecomposition_MeshComponentGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_MeshComponentGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number used for the decomposition of a mesh for a decomposition identified by a user number.
  SUBROUTINE CMISSDecomposition_MeshComponentSetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & meshComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the decomposition mesh component for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number for the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecomposition_MeshComponentSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_MESH_COMPONENT_NUMBER_SET(DECOMPOSITION,meshComponentNumber,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDecomposition_MeshComponentSetNumber")
    RETURN
999 CALL ERRORS("CMISSDecomposition_MeshComponentSetNumber",err,error)
    CALL EXITS("CMISSDecomposition_MeshComponentSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_MeshComponentSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the mesh component number used for the decomposition of a mesh for a decomposition identified by an object.
  SUBROUTINE CMISSDecomposition_MeshComponentSetObj(decomposition,meshComponentNumber,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to Set the mesh component for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number for the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_MeshComponentSetObj",err,error,*999)

    CALL DECOMPOSITION_MESH_COMPONENT_NUMBER_SET(decomposition%DECOMPOSITION,meshComponentNumber,err,error,*999)

    CALL EXITS("CMISSDecomposition_MeshComponentSetObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_MeshComponentSetObj",err,error)
    CALL EXITS("CMISSDecomposition_MeshComponentSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_MeshComponentSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of domains for a decomposition identified by a user number.
  SUBROUTINE CMISSDecomposition_NumberOfDomainsGetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & numberOfDomains,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of domains for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of domains for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the number of domains for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDomains !<On return, the number of domains in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecomposition_NumberOfDomainsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_NUMBER_OF_DOMAINS_GET(DECOMPOSITION,numberOfDomains,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDecomposition_NumberOfDomainsGetNumber")
    RETURN
999 CALL ERRORS("CMISSDecomposition_NumberOfDomainsGetNumber",err,error)
    CALL EXITS("CMISSDecomposition_NumberOfDomainsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_NumberOfDomainsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of domains for a decomposition identified by an object.
  SUBROUTINE CMISSDecomposition_NumberOfDomainsGetObj(decomposition,numberOfDomains,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the number of domains for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDomains !<On return, the number of domains in the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_NumberOfDomainsGetObj",err,error,*999)

    CALL DECOMPOSITION_NUMBER_OF_DOMAINS_GET(decomposition%DECOMPOSITION,numberOfDomains,err,error,*999)

    CALL EXITS("CMISSDecomposition_NumberOfDomainsGetObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_NumberOfDomainsGetObj",err,error)
    CALL EXITS("CMISSDecomposition_NumberOfDomainsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_NumberOfDomainsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of domains for a decomposition identified by a user number.
  SUBROUTINE CMISSDecomposition_NumberOfDomainsSetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & numberOfDomains,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the number of domains for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the number of domains for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the number of domains for.
    INTEGER(INTG), INTENT(IN) :: numberOfDomains !<The number of domains in the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecomposition_NumberOfDomainsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_NUMBER_OF_DOMAINS_SET(DECOMPOSITION,numberOfDomains,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDecomposition_NumberOfDomainsSetNumber")
    RETURN
999 CALL ERRORS("CMISSDecomposition_NumberOfDomainsSetNumber",err,error)
    CALL EXITS("CMISSDecomposition_NumberOfDomainsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_NumberOfDomainsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of domains for a decomposition identified by an object.
  SUBROUTINE CMISSDecomposition_NumberOfDomainsSetObj(decomposition,numberOfDomains,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the number of domains for.
    INTEGER(INTG), INTENT(IN) :: numberOfDomains !<The number of domains in the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_NumberOfDomainsSetObj",err,error,*999)

    CALL DECOMPOSITION_NUMBER_OF_DOMAINS_SET(decomposition%DECOMPOSITION,numberOfDomains,err,error,*999)

    CALL EXITS("CMISSDecomposition_NumberOfDomainsSetObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_NumberOfDomainsSetObj",err,error)
    CALL EXITS("CMISSDecomposition_NumberOfDomainsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_NumberOfDomainsSetObj

  !
  !================================================================================================================================
  !

  !>Returns the type of a decomposition identified by a user number.
  SUBROUTINE CMISSDecomposition_TypeGetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber,decompositionType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the decomposition type for.
    INTEGER(INTG), INTENT(OUT) :: decompositionType !<On return, the type of the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecomposition_TypeGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_TYPE_GET(DECOMPOSITION,decompositionType,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDecomposition_TypeGetNumber")
    RETURN
999 CALL ERRORS("CMISSDecomposition_TypeGetNumber",err,error)
    CALL EXITS("CMISSDecomposition_TypeGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_TypeGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the type of a decomposition identified by an object.
  SUBROUTINE CMISSDecomposition_TypeGetObj(decomposition,decompositionType,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the type for.
    INTEGER(INTG), INTENT(OUT) :: decompositionType !<On return, the type of the decomposition.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_TypeGetObj",err,error,*999)

    CALL DECOMPOSITION_TYPE_GET(decomposition%DECOMPOSITION,decompositionType,err,error,*999)

    CALL EXITS("CMISSDecomposition_TypeGetObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_TypeGetObj",err,error)
    CALL EXITS("CMISSDecomposition_TypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_TypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a decomposition identified by a user number.
  SUBROUTINE CMISSDecomposition_TypeSetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber,decompositionType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the decomposition type for.
    INTEGER(INTG), INTENT(IN) :: decompositionType !<The type of the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecomposition_TypeSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_TYPE_SET(DECOMPOSITION,decompositionType,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDecomposition_TypeSetNumber")
    RETURN
999 CALL ERRORS("CMISSDecomposition_TypeSetNumber",err,error)
    CALL EXITS("CMISSDecomposition_TypeSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_TypeSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a decomposition identified by an object.
  SUBROUTINE CMISSDecomposition_TypeSetObj(decomposition,decompositionType,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to Set the type for.
    INTEGER(INTG), INTENT(IN) :: decompositionType !<The type of the decomposition to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_TypeSetObj",err,error,*999)

    CALL DECOMPOSITION_TYPE_SET(decomposition%DECOMPOSITION,decompositionType,err,error,*999)

    CALL EXITS("CMISSDecomposition_TypeSetObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_TypeSetObj",err,error)
    CALL EXITS("CMISSDecomposition_TypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_TypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets whether lines should be calculated
  SUBROUTINE CMISSDecomposition_CalculateLinesSetNumber(regionUserNumber,meshUserNumber,&
                                                     & decompositionUserNumber,calculateLinesFlag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the calculate lines flag for.
    LOGICAL, INTENT(IN) :: calculateLinesFlag !<Boolean to determine whether to set lines to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecomposition_CalculateLinesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_CALCULATE_LINES_SET(DECOMPOSITION,calculateLinesFlag,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDecomposition_CalculateLinesSetNumber")
    RETURN
999 CALL ERRORS("CMISSDecomposition_CalculateLinesSetNumber",err,error)
    CALL EXITS("CMISSDecomposition_CalculateLinesSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_CalculateLinesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets whether lines should be calculated
  SUBROUTINE CMISSDecomposition_CalculateLinesSetObj(decomposition,calculateLinesFlag,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the calculate lines flag for.
    LOGICAL, INTENT(IN) :: calculateLinesFlag !<Boolean to determine whether to set lines to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_CalculateLinesSetObj",err,error,*999)

    CALL DECOMPOSITION_CALCULATE_LINES_SET(decomposition%DECOMPOSITION,calculateLinesFlag,err,error,*999)

    CALL EXITS("CMISSDecomposition_CalculateLinesSetObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_CalculateLinesSetObj",err,error)
    CALL EXITS("CMISSDecomposition_CalculateLinesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_CalculateLinesSetObj

  !
  !================================================================================================================================
  !

  !>Sets whether faces should be calculated
  SUBROUTINE CMISSDecomposition_CalculateFacesSetNumber(regionUserNumber,meshUserNumber, &
                                                     & decompositionUserNumber,calculateFacesFlag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to set the decomposition type for.
    LOGICAL, INTENT(IN) :: calculateFacesFlag !<Boolean to determine whether to set faces to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecomposition_CalculateFacesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_CALCULATE_FACES_SET(DECOMPOSITION,calculateFacesFlag,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDecomposition_CalculateFacesSetNumber")
    RETURN
999 CALL ERRORS("CMISSDecomposition_CalculateFacesSetNumber",err,error)
    CALL EXITS("CMISSDecomposition_CalculateFacesSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_CalculateFacesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets whether faces should be calculated
  SUBROUTINE CMISSDecomposition_CalculateFacesSetObj(decomposition,calculateFacesFlag,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to set the calculate faces flag for.
    LOGICAL, INTENT(IN) :: calculateFacesFlag !<Boolean to determine whether to set faces to be calculated.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_CalculateFacesSetObj",err,error,*999)

    CALL DECOMPOSITION_CALCULATE_FACES_SET(decomposition%DECOMPOSITION,calculateFacesFlag,err,error,*999)

    CALL EXITS("CMISSDecomposition_CalculateFacesSetObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_CalculateFacesSetObj",err,error)
    CALL EXITS("CMISSDecomposition_CalculateFacesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_CalculateFacesSetObj

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given node in a decomposition identified by a user number.
  SUBROUTINE CMISSDecomposition_NodeDomainGetNumber(regionUserNumber,meshUserNumber,decompositionUserNumber, &
    & nodeUserNumber,meshComponentNumber,domain,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: decompositionUserNumber !<The user number of the decomposition to get the node domain for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the domain for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computational domain of the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(DECOMPOSITION_TYPE), POINTER :: DECOMPOSITION
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSDecomposition_NodeDomainGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(DECOMPOSITION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL DECOMPOSITION_USER_NUMBER_FIND(decompositionUserNumber,MESH,DECOMPOSITION,err,error,*999)
        IF(ASSOCIATED(DECOMPOSITION)) THEN
          CALL DECOMPOSITION_NODE_DOMAIN_GET(DECOMPOSITION,nodeUserNumber,meshComponentNumber,domain,err,error,*999)
        ELSE
          LOCAL_ERROR="A decomposition with an user number of "//TRIM(NUMBER_TO_VSTRING(decompositionUserNumber,"*",err,error))// &
            & " does not exist on the mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSDecomposition_NodeDomainGetNumber")
    RETURN
999 CALL ERRORS("CMISSDecomposition_NodeDomainGetNumber",err,error)
    CALL EXITS("CMISSDecomposition_NodeDomainGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_NodeDomainGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the domain for a given node in a decomposition identified by an object. \todo Maybe swap Node and MeshComponent?
  SUBROUTINE CMISSDecomposition_NodeDomainGetObj(decomposition,nodeUserNumber,meshComponentNumber,domain,err)

    !Argument variables
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !<The decomposition to get the domain for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to get the domain for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The user number of the mesh component to get the domain for.
    INTEGER(INTG), INTENT(OUT) :: domain !<On return, the computational domain of the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSDecomposition_NodeDomainGetObj",err,error,*999)

    CALL DECOMPOSITION_NODE_DOMAIN_GET(decomposition%DECOMPOSITION,nodeUserNumber,meshComponentNumber,domain,err,error,*999)

    CALL EXITS("CMISSDecomposition_NodeDomainGetObj")
    RETURN
999 CALL ERRORS("CMISSDecomposition_NodeDomainGetObj",err,error)
    CALL EXITS("CMISSDecomposition_NodeDomainGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSDecomposition_NodeDomainGetObj

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a mesh for a mesh identified by a user number.
  SUBROUTINE CMISSMesh_CreateFinishNumber(regionUserNumber,meshUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to finish the creation of.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMesh_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_CREATE_FINISH(MESH,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Mesh Create')
#endif

    CALL EXITS("CMISSMesh_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSMesh_CreateFinishNumber",err,error)
    CALL EXITS("CMISSMesh_CreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a mesh for a mesh identified by an object.
  SUBROUTINE CMISSMesh_CreateFinishObj(mesh,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMesh_CreateFinishObj",err,error,*999)

    CALL MESH_CREATE_FINISH(mesh%MESH,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('mesh Create')
#endif

    CALL EXITS("CMISSMesh_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSMesh_CreateFinishObj",err,error)
    CALL EXITS("CMISSMesh_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a mesh for a mesh identified by a user number.
  SUBROUTINE CMISSMesh_CreateStartNumber(meshUserNumber,regionUserNumber,numberOfDimensions,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions for the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMesh_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Mesh Create')
#endif

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_CREATE_START(meshUserNumber,REGION,numberOfDimensions,MESH,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMesh_CreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSMesh_CreateStartNumber",err,error)
    CALL EXITS("CMISSMesh_CreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a mesh for a mesh identified by an object.
  SUBROUTINE CMISSMesh_CreateStartObj(meshUserNumber,region,numberOfDimensions,mesh,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start the creation of.
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region containing the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions for the mesh.
    TYPE(CMISSMeshType), INTENT(INOUT) :: mesh !<On return, the created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMesh_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('mesh Create')
#endif

    CALL MESH_CREATE_START(meshUserNumber,region%REGION,numberOfDimensions,mesh%MESH,err,error,*999)

    CALL EXITS("CMISSMesh_CreateStartObj")
    RETURN
999 CALL ERRORS("CMISSMesh_CreateStartObj",err,error)
    CALL EXITS("CMISSMesh_CreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a mesh for a mesh identified by an object.
  SUBROUTINE CMISSMesh_CreateStartInterfaceObj(meshUserNumber,interface,numberOfDimensions,mesh,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start the creation of.
    TYPE(CMISSInterfaceType), INTENT(IN) :: interface !<The interface containing the mesh to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfDimensions !<The number of dimensions for the mesh.
    TYPE(CMISSMeshType), INTENT(INOUT) :: mesh !<On return, the created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMesh_CreateStartInterfaceObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('mesh Create')
#endif

    CALL MESH_CREATE_START(meshUserNumber,interface%INTERFACE,numberOfDimensions,mesh%MESH,err,error,*999)

    CALL EXITS("CMISSMesh_CreateStartInterfaceObj")
    RETURN
999 CALL ERRORS("CMISSMesh_CreateStartInterfaceObj",err,error)
    CALL EXITS("CMISSMesh_CreateStartInterfaceObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_CreateStartInterfaceObj

  !
  !================================================================================================================================
  !

  !>Destroys a mesh identified by a user number.
  SUBROUTINE CMISSMesh_DestroyNumber(regionUserNumber,meshUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to destroy.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMesh_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_DESTROY(MESH,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMesh_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSMesh_DestroyNumber",err,error)
    CALL EXITS("CMISSMesh_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a mesh identified by an object.
  SUBROUTINE CMISSMesh_DestroyObj(mesh,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMesh_DestroyObj",err,error,*999)

    CALL MESH_DESTROY(mesh%MESH,err,error,*999)

    CALL EXITS("CMISSMesh_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSMesh_DestroyObj",err,error)
    CALL EXITS("CMISSMesh_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the number of components in a mesh identified by a user number.
  SUBROUTINE CMISSMesh_NumberOfComponentsGetNumber(regionUserNumber,meshUserNumber,numberOfComponents,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of components for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of components for.
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMesh_NumberOfComponentsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_NUMBER_OF_COMPONENTS_GET(MESH,numberOfComponents,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMesh_NumberOfComponentsGetNumber")
    RETURN
999 CALL ERRORS("CMISSMesh_NumberOfComponentsGetNumber",err,error)
    CALL EXITS("CMISSMesh_NumberOfComponentsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_NumberOfComponentsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of components in a mesh identified by an object.
  SUBROUTINE CMISSMesh_NumberOfComponentsGetObj(mesh,numberOfComponents,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to get the number of components for.
    INTEGER(INTG), INTENT(OUT) :: numberOfComponents !<On return, the number of components in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMesh_NumberOfComponentsGetObj",err,error,*999)

    CALL MESH_NUMBER_OF_COMPONENTS_GET(mesh%MESH,numberOfComponents,err,error,*999)

    CALL EXITS("CMISSMesh_NumberOfComponentsGetObj")
    RETURN
999 CALL ERRORS("CMISSMesh_NumberOfComponentsGetObj",err,error)
    CALL EXITS("CMISSMesh_NumberOfComponentsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_NumberOfComponentsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of components in a mesh identified by a user number.
  SUBROUTINE CMISSMesh_NumberOfComponentsSetNumber(regionUserNumber,meshUserNumber,numberOfComponents,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMesh_NumberOfComponentsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_NUMBER_OF_COMPONENTS_SET(MESH,numberOfComponents,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMesh_NumberOfComponentsSetNumber")
    RETURN
999 CALL ERRORS("CMISSMesh_NumberOfComponentsSetNumber",err,error)
    CALL EXITS("CMISSMesh_NumberOfComponentsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_NumberOfComponentsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of components in a mesh identified by an object.
  SUBROUTINE CMISSMesh_NumberOfComponentsSetObj(mesh,numberOfComponents,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to set the number of components for.
    INTEGER(INTG), INTENT(IN) :: numberOfComponents !<The number of components in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMesh_NumberOfComponentsSetObj",err,error,*999)

    CALL MESH_NUMBER_OF_COMPONENTS_SET(mesh%MESH,numberOfComponents,err,error,*999)

    CALL EXITS("CMISSMesh_NumberOfComponentsSetObj")
    RETURN
999 CALL ERRORS("CMISSMesh_NumberOfComponentsSetObj",err,error)
    CALL EXITS("CMISSMesh_NumberOfComponentsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_NumberOfComponentsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the surrounding elements calculate flag.
  SUBROUTINE CMISSMesh_SurroundingElementsCalculateSetNumber(regionUserNumber,meshUserNumber,surroundingElementsCalculateFlag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the surrounding elements calculate flag for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the surrounding elements calculate flag for.
    LOGICAL, INTENT(IN) :: surroundingElementsCalculateFlag !<Boolean flag to determine whether to calculate surrounding elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMesh_SurroundingElementsCalculateSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_SURROUNDING_ELEMENTS_CALCULATE_SET(MESH,surroundingElementsCalculateFlag,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMesh_SurroundingElementsCalculateSetNumber")
    RETURN
999 CALL ERRORS("CMISSMesh_SurroundingElementsCalculateSetNumber",err,error)
    CALL EXITS("CMISSMesh_SurroundingElementsCalculateSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_SurroundingElementsCalculateSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the surrounding elements calculate flag.
  SUBROUTINE CMISSMesh_SurroundingElementsCalculateSetObj(mesh,surroundingElementsCalculateFlag,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to set the surrounding elements calculate flag for.
    LOGICAL, INTENT(IN) :: surroundingElementsCalculateFlag !<Boolean flag to determine whether to calculate surrounding elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMesh_SurroundingElementsCalculateSetObj",err,error,*999)

    CALL MESH_SURROUNDING_ELEMENTS_CALCULATE_SET(mesh%MESH,surroundingElementsCalculateFlag,err,error,*999)

    CALL EXITS("CMISSMesh_SurroundingElementsCalculateSetObj")
    RETURN
999 CALL ERRORS("CMISSMesh_SurroundingElementsCalculateSetObj",err,error)
    CALL EXITS("CMISSMesh_SurroundingElementsCalculateSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_SurroundingElementsCalculateSetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of elements in a mesh identified by a user number.
  SUBROUTINE CMISSMesh_NumberOfElementsGetNumber(regionUserNumber,meshUserNumber,numberOfElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements !<On return, the number of elements in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMesh_NumberOfElementsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_NUMBER_OF_ELEMENTS_GET(MESH,numberOfElements,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMesh_NumberOfElementsGetNumber")
    RETURN
999 CALL ERRORS("CMISSMesh_NumberOfElementsGetNumber",err,error)
    CALL EXITS("CMISSMesh_NumberOfElementsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_NumberOfElementsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of elements in a mesh identified by an object.
  SUBROUTINE CMISSMesh_NumberOfElementsGetObj(mesh,numberOfElements,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to get the number of elements for.
    INTEGER(INTG), INTENT(OUT) :: numberOfElements !<On return, the number of elements in the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMesh_NumberOfElementsGetObj",err,error,*999)

    CALL MESH_NUMBER_OF_ELEMENTS_GET(mesh%MESH,numberOfElements,err,error,*999)

    CALL EXITS("CMISSMesh_NumberOfElementsGetObj")
    RETURN
999 CALL ERRORS("CMISSMesh_NumberOfElementsGetObj",err,error)
    CALL EXITS("CMISSMesh_NumberOfElementsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_NumberOfElementsGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements in a mesh identified by a user number.
  SUBROUTINE CMISSMesh_NumberOfElementsSetNumber(regionUserNumber,meshUserNumber,numberOfElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements !<The number of elements in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMesh_NumberOfElementsSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_NUMBER_OF_ELEMENTS_SET(MESH,numberOfElements,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMesh_NumberOfElementsSetNumber")
    RETURN
999 CALL ERRORS("CMISSMesh_NumberOfElementsSetNumber",err,error)
    CALL EXITS("CMISSMesh_NumberOfElementsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_NumberOfElementsSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the number of elements in a mesh identified by an object.
  SUBROUTINE CMISSMesh_NumberOfElementsSetObj(mesh,numberOfElements,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to set the number of elements for.
    INTEGER(INTG), INTENT(IN) :: numberOfElements !<The number of elements in the mesh to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMesh_NumberOfElementsSetObj",err,error,*999)

    CALL MESH_NUMBER_OF_ELEMENTS_SET(mesh%MESH,numberOfElements,err,error,*999)

    CALL EXITS("CMISSMesh_NumberOfElementsSetObj")
    RETURN
999 CALL ERRORS("CMISSMesh_NumberOfElementsSetObj",err,error)
    CALL EXITS("CMISSMesh_NumberOfElementsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_NumberOfElementsSetObj
  
  !
  !================================================================================================================================
  !
  
  !>Calculate mesh data points topology in a region identified by a user number based on projection
  SUBROUTINE CMISSMesh_TopologyDataPointsCalculateProjectionRegionNumber(regionUserNumber,MeshUserNumber, &
      & DataProjection,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber
    TYPE(CMISSDataProjectionType), INTENT(IN) :: DataProjection !<The data projection
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSMesh_TopologyDataPointsCalculateProjectionRegionNumber",Err,ERROR,*999)
 
    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,Err,ERROR,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(MeshUserNumber,REGION,MESH,Err,ERROR,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MeshTopologyDataPointsCalculateProjection(MESH,DataProjection%DATA_PROJECTION,Err,ERROR,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",Err,ERROR))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSMesh_TopologyDataPointsCalculateProjectionRegionNumber")
    RETURN
999 CALL ERRORS("CMISSMesh_TopologyDataPointsCalculateProjectionRegionNumber",Err,ERROR)
    CALL EXITS("CMISSMesh_TopologyDataPointsCalculateProjectionRegionNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMesh_TopologyDataPointsCalculateProjectionRegionNumber
  
  !  
  !================================================================================================================================
  !  

  !>Calculate mesh data points topology in an interface identified by a user number based on projection
  SUBROUTINE CMISSMesh_TopologyDataPointsCalculateProjectionInterfaceNumber(parentRegionUserNumber,interfaceUserNumber, &
      & MeshUserNumber,DataProjection,Err)
  
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: parentregionUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the region.
    INTEGER(INTG), INTENT(IN) :: MeshUserNumber
    TYPE(CMISSDataProjectionType), INTENT(IN) :: DataProjection !<The data projection
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSMesh_TopologyDataPointsCalculateProjectionInterfaceNumber",Err,ERROR,*999)
 
    NULLIFY(PARENT_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(parentregionUserNumber,PARENT_REGION,Err,ERROR,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,PARENT_REGION,INTERFACE,Err,ERROR,*999)
      IF(ASSOCIATED(INTERFACE)) THEN
        CALL MESH_USER_NUMBER_FIND(MeshUserNumber,INTERFACE,MESH,Err,ERROR,*999)
        IF(ASSOCIATED(MESH)) THEN
          CALL MeshTopologyDataPointsCalculateProjection(MESH,DataProjection%DATA_PROJECTION,Err,ERROR,*999)        
        ELSE
          LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(MeshUserNumber,"*",Err,ERROR))// &
            & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentregionUserNumber, &
            & "*",Err,ERROR))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
        ENDIF
      ELSE
        LOCAL_ERROR="An interface with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",Err,ERROR))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
      ENDIF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentregionUserNumber,"*",Err,ERROR))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,Err,ERROR,*999)
    ENDIF

    CALL EXITS("CMISSMesh_TopologyDataPointsCalculateProjectionInterfaceNumber")
    RETURN
999 CALL ERRORS("CMISSMesh_TopologyDataPointsCalculateProjectionInterfaceNumber",Err,ERROR)
    CALL EXITS("CMISSMesh_TopologyDataPointsCalculateProjectionInterfaceNumber")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMesh_TopologyDataPointsCalculateProjectionInterfaceNumber
  
  !  
  !================================================================================================================================
  !  
  
  !>Calculate mesh data points topology identified by object based on projection
  SUBROUTINE CMISSMesh_TopologyDataPointsCalculateProjectionObj(Mesh,DataProjection,Err)
  
  !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: Mesh !<The mesh to calculate data points topology for
    TYPE(CMISSDataProjectionType), INTENT(IN) :: DataProjection !<The data projection
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code.
    !Local variables
  
    CALL ENTERS("CMISSMesh_TopologyDataPointsCalculateProjectionObj",Err,ERROR,*999)
    
    CALL MeshTopologyDataPointsCalculateProjection(Mesh%MESH,DataProjection%DATA_PROJECTION,Err,ERROR,*999)
 
    CALL EXITS("CMISSMesh_TopologyDataPointsCalculateProjectionObj")
    RETURN
999 CALL ERRORS("CMISSMesh_TopologyDataPointsCalculateProjectionObj",Err,ERROR)
    CALL EXITS("CMISSMesh_TopologyDataPointsCalculateProjectionObj")
    CALL CMISS_HANDLE_ERROR(Err,ERROR)
    RETURN
    
  END SUBROUTINE CMISSMesh_TopologyDataPointsCalculateProjectionObj

  !
  !================================================================================================================================
  !

  !>Finishes creating elements for a mesh component of a mesh identified by a user number.
  SUBROUTINE CMISSMeshElements_CreateFinishNumber(regionUserNumber,meshUserNumber,meshComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the mesh to finish creating the elements for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElements_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_CREATE_FINISH(MESH_ELEMENTS,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMeshElements_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElements_CreateFinishNumber",err,error)
    CALL EXITS("CMISSMeshElements_CreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes creating elements for a mesh component of a mesh identified by an object.
  SUBROUTINE CMISSMeshElements_CreateFinishObj(meshElements,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElements_CreateFinishObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_CREATE_FINISH(meshElements%MESH_ELEMENTS,err,error,*999)

    CALL EXITS("CMISSMeshElements_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSMeshElements_CreateFinishObj",err,error)
    CALL EXITS("CMISSMeshElements_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts creating elements for a mesh component of a mesh identified by a user number.
  SUBROUTINE CMISSMeshElements_CreateStartNumber(regionUserNumber,meshUserNumber,meshComponentNumber,basisUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the mesh to start creating the elements for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the default basis to use for the elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElements_CreateStartNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(BASIS)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL BASIS_USER_NUMBER_FIND(basisUserNumber,BASIS,err,error,*999)
        IF(ASSOCIATED(BASIS)) THEN
          CALL MESH_TOPOLOGY_ELEMENTS_CREATE_START(MESH,meshComponentNumber,BASIS,MESH_ELEMENTS,err,error,*999)
        ELSE
          LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(basisUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMeshElements_CreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElements_CreateStartNumber",err,error)
    CALL EXITS("CMISSMeshElements_CreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts creating elements for a mesh component of a mesh identified by an object.
  SUBROUTINE CMISSMeshElements_CreateStartObj(mesh,meshComponentNumber,basis,meshElements,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(INOUT) :: mesh !<The mesh to start the creation of elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number of the mesh to start creating the elements for.
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The default basis to use for the elements.
    TYPE(CMISSMeshElementsType), INTENT(INOUT) :: meshElements !<On return, the created mesh elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElements_CreateStartObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_CREATE_START(mesh%MESH,meshComponentNumber,basis%BASIS,meshElements%MESH_ELEMENTS,err,error,*999)

    CALL EXITS("CMISSMeshElements_CreateStartObj")
    RETURN
999 CALL ERRORS("CMISSMeshElements_CreateStartObj",err,error)
    CALL EXITS("CMISSMeshElements_CreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh elements for a mesh component on a mesh identified by an user number.
  SUBROUTINE CMISSMesh_ElementsGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,meshElements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the elements for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the elements for.
    TYPE(CMISSMeshElementsType), INTENT(INOUT) :: meshElements !<The mesh elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMesh_ElementsGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,meshElements%MESH_ELEMENTS,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMesh_ElementsGetNumber")
    RETURN
999 CALL ERRORS("CMISSMesh_ElementsGetNumber",err,error)
    CALL EXITS("CMISSMesh_ElementsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_ElementsGetNumber


  !
  !================================================================================================================================
  !

  !>Returns the mesh elements for a mesh component on a mesh identified by an
  !user number.
  SUBROUTINE CMISSMesh_ElementsGetObj(mesh,meshComponentNumber,meshElements,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to get the elements for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the elements for.
    TYPE(CMISSMeshElementsType), INTENT(INOUT) :: meshElements !<The mesh elements.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables

    CALL ENTERS("CMISSMesh_ElementsGetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_GET(mesh%MESH,meshComponentNumber,meshElements%MESH_ELEMENTS,err,error,*999)

    CALL EXITS("CMISSMesh_ElementsGetObj")
    RETURN
999 CALL ERRORS("CMISSMesh_ElementsGetObj",err,error)
    CALL EXITS("CMISSMesh_ElementsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_ElementsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the basis for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElements_BasisGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,globalElementNumber, &
    & basisUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the basis for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the basis for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the basis for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to get the basis for.
    INTEGER(INTG), INTENT(OUT) :: basisUserNumber !<On return, the user number of the basis for the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElements_BasisGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    NULLIFY(BASIS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_BASIS_GET(globalElementNumber,MESH_ELEMENTS,BASIS,err,error,*999)
        IF(ASSOCIATED(BASIS)) THEN
          basisUserNumber = BASIS%USER_NUMBER
        ELSE
          LOCAL_ERROR="The basis is not associated for global element number "// &
            & TRIM(NUMBER_TO_VSTRING(globalElementNumber,"*",err,error))//" of mesh component number "// &
            & TRIM(NUMBER_TO_VSTRING(meshComponentNumber,"*",err,error))//" from the mesh with a user number of "//&
            & TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))//" in the region with a user number of "// &
            & TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMeshElements_BasisGetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElements_BasisGetNumber",err,error)
    CALL EXITS("CMISSMeshElements_BasisGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_BasisGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the basis for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElements_BasisGetObj(meshElements,globalElementNumber,basis,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to get the basis for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to get the basis for.
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<On return, the basis for the element.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElements_BasisGetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_BASIS_GET(globalElementNumber,meshElements%MESH_ELEMENTS,basis%BASIS,err,error,*999)

    CALL EXITS("CMISSMeshElements_BasisGetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElements_BasisGetObj",err,error)
    CALL EXITS("CMISSMeshElements_BasisGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_BasisGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElements_BasisSetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,globalElementNumber, &
    & basisUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the basis for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the basis for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the basis for.
    INTEGER(INTG), INTENT(IN) :: basisUserNumber !<The user number of the basis for the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(BASIS_TYPE), POINTER :: BASIS
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElements_BasisSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    NULLIFY(BASIS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL BASIS_USER_NUMBER_FIND(basisUserNumber,BASIS,err,error,*999)
        IF(ASSOCIATED(BASIS)) THEN
          CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_BASIS_SET(globalElementNumber,MESH_ELEMENTS,BASIS,err,error,*999)
        ELSE
          LOCAL_ERROR="A basis with an user number of "//TRIM(NUMBER_TO_VSTRING(basisUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMeshElements_BasisSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElements_BasisSetNumber",err,error)
    CALL EXITS("CMISSMeshElements_BasisSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_BasisSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the basis for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElements_BasisSetObj(meshElements,globalElementNumber,basis,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the basis for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the basis for.
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis for the element to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElements_BasisSetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_BASIS_SET(globalElementNumber,meshElements%MESH_ELEMENTS,basis%BASIS,err,error,*999)

    CALL EXITS("CMISSMeshElements_BasisSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElements_BasisSetObj",err,error)
    CALL EXITS("CMISSMeshElements_BasisSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_BasisSetObj

  !
  !================================================================================================================================
  !

  !>Returns the adjacent element number of a mesh identified by a user number
  SUBROUTINE CMISSMeshElements_AdjacentElementGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,globalElementNumber, &
    & adjacentElementXi,adjacentElement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh from which to get the adjacent element from.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh from which to get the adjacent element from.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number from which to get adjacent element number from.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to get the adjacent element number for. !\todo this should be a user number
    INTEGER(INTG), INTENT(IN) :: adjacentElementXi !<The xi coordinate direction to get the adjacent element for. Note that -xiCoordinateDirection gives the adjacent element before the element in the xiCoordinateDirection'th direction and +xiCoordinateDirection gives the adjacent element after the element in the xiCoordinateDirection'th direction. The xiCoordinateDirection=0 index will give the information on the current element.
    INTEGER(INTG), INTENT(OUT) :: adjacentElement !<On return, the adjacent element number in the specified xi coordinate direction. Return 0 if the specified element has no adjacent elements in the specified xi coordinate direction.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElements_AdjacentElementGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ADJACENT_ELEMENT_GET(globalElementNumber,MESH_ELEMENTS,adjacentElementXi,adjacentElement, &
          & err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMeshElements_AdjacentElementGetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElements_AdjacentElementGetNumber",err,error)
    CALL EXITS("CMISSMeshElements_AdjacentElementGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_AdjacentElementGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the adjacent element number of a mesh identified by an object.
  SUBROUTINE CMISSMeshElements_AdjacentElementGetObj(meshElements,globalElementNumber,adjacentElementXi,adjacentElement,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements from which to get the adjacent element for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to get the adjacent element for !\todo this should be a user number
    INTEGER(INTG), INTENT(IN) :: adjacentElementXi !<The xi coordinate direction to get the adjacent element for  Note that -xiCoordinateDirection gives the adjacent element before the element in the xiCoordinateDirection'th direction and +xiCoordinateDirection gives the adjacent element after the element in the xiCoordinateDirection'th direction. The xiCoordinateDirection=0 index will give the information on the current element.
    INTEGER(INTG), INTENT(OUT) :: adjacentElement !<On return, the adjacent element number in the specified xi coordinate direction. Return 0 if the specified element has no adjacent elements in the specified xi coordinate direction.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElements_AdjacentElementGetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ADJACENT_ELEMENT_GET(globalElementNumber,meshElements%MESH_ELEMENTS,adjacentElementXi, &
      & adjacentElement,err,error,*999)

    CALL EXITS("CMISSMeshElements_AdjacentElementGetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElements_AdjacentElementGetObj",err,error)
    CALL EXITS("CMISSMeshElements_AdjacentElementGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_AdjacentElementGetObj

  !
  !================================================================================================================================
  !

  !>Returns the element nodes for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElements_NodesGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,globalElementNumber, &
    & elementUserNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to get the element nodes for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNodes(:) !<elementUserNodes(i). On return, the user node number number of the i'th element node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElements_NodesGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODES_GET(globalElementNumber,MESH_ELEMENTS,elementUserNodes,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMeshElements_NodesGetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElements_NodesGetNumber",err,error)
    CALL EXITS("CMISSMeshElements_NodesGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_NodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the element nodes for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElements_NodesGetObj(meshElements,globalElementNumber,elementUserNodes,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to get the element nodes for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNodes(:) !<elementUserNodes(i). On return, the user node number number of the i'th element node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElements_NodesGetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODES_GET(globalElementNumber,meshElements%MESH_ELEMENTS,elementUserNodes,err,error,*999)

    CALL EXITS("CMISSMeshElements_NodesGetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElements_NodesGetObj",err,error)
    CALL EXITS("CMISSMeshElements_NodesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_NodesGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElements_NodesSetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,globalElementNumber, &
    & elementUserNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementUserNodes(:) !<elementUserNodes(i). The user node number number of the i'th element node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElements_NodesSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODES_SET(globalElementNumber,MESH_ELEMENTS,elementUserNodes,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMeshElements_NodesSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElements_NodesSetNumber",err,error)
    CALL EXITS("CMISSMeshElements_NodesSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_NodesSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElements_NodesSetObj(meshElements,globalElementNumber,elementUserNodes,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementUserNodes(:) !<elementUserNodes(i). The user node number number of the i'th element node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElements_NodesSetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODES_SET(globalElementNumber,meshElements%MESH_ELEMENTS,elementUserNodes,err,error,*999)

    CALL EXITS("CMISSMeshElements_NodesSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElements_NodesSetObj",err,error)
    CALL EXITS("CMISSMeshElements_NodesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_NodesSetObj


  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElements_UserNodeVersionSetNumber(regionUserNumber,meshUserNumber,globalElementNumber,versionNumber, &
    & derivativeNumber,userNodeNumber,meshComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to set a version for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element nodes for.

    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: localelementnode
    LOGICAL :: FOUND

    CALL ENTERS("CMISSMeshElements_UserNodeVersionSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        FOUND=.FALSE.
        DO localelementnode=1,MESH_ELEMENTS%ELEMENTS(globalElementNumber)%BASIS%NUMBER_OF_NODES
          IF(MESH_ELEMENTS%ELEMENTS(globalElementNumber)%USER_ELEMENT_NODES(localelementnode)==userNodeNumber) THEN
            FOUND=.TRUE.
            EXIT
          END IF
        END DO !localelementnode
        IF(FOUND) THEN
          CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODE_VERSION_SET(globalElementNumber,MESH_ELEMENTS,versionNumber,derivativeNumber, &
            & localelementnode,err,error,*999)
        ELSE
          LOCAL_ERROR="User node number "//TRIM(NUMBER_TO_VSTRING(userNodeNumber,"*",err,error))// &
            & " does not exist in element number "//TRIM(NUMBER_TO_VSTRING(globalElementNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMeshElements_UserNodeVersionSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElements_UserNodeVersionSetNumber",err,error)
    CALL EXITS("CMISSMeshElements_UserNodeVersionSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_UserNodeVersionSetNumber

  !
  !================================================================================================================================
   !

  !>Sets/changes the element nodes for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElements_UserNodeVersionSetObj(meshElements,globalElementNumber,versionNumber,derivativeNumber, &
    & userNodeNumber,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to set a version for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    INTEGER(INTG) :: localelementnode
    LOGICAL :: FOUND

    CALL ENTERS("CMISSMeshElements_UserNodeVersionSetObj",err,error,*999)

    FOUND=.FALSE.
    DO localelementnode=1,meshElements%MESH_ELEMENTS%ELEMENTS(globalElementNumber)%BASIS%NUMBER_OF_NODES
      IF(meshElements%MESH_ELEMENTS%ELEMENTS(globalElementNumber)%USER_ELEMENT_NODES(localelementnode)==userNodeNumber) THEN
        FOUND=.TRUE.
        EXIT
      END IF
    END DO !localelementnode
    IF(FOUND) THEN
      CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODE_VERSION_SET(globalElementNumber,meshElements%MESH_ELEMENTS,versionNumber, &
         & derivativeNumber,localelementnode,err,error,*999)
    ELSE
      LOCAL_ERROR="User node number "//TRIM(NUMBER_TO_VSTRING(userNodeNumber,"*",err,error))// &
        & " does not exist in element number "//TRIM(NUMBER_TO_VSTRING(globalElementNumber,"*",err,error))//"."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMeshElements_UserNodeVersionSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElements_UserNodeVersionSetObj",err,error)
    CALL EXITS("CMISSMeshElements_UserNodeVersionSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_UserNodeVersionSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an user number. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElements_LocalElementNodeVersionSetNumber(regionUserNumber,meshUserNumber,globalElementNumber,versionNumber, &
    & derivativeNumber,localElementNodeNumber,meshComponentNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: localElementNodeNumber !<The local element node to set a version for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element nodes for.

    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElements_LocalElementNodeVersionSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODE_VERSION_SET(globalElementNumber,MESH_ELEMENTS,versionNumber,derivativeNumber, &
          & localElementNodeNumber,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMeshElements_LocalElementNodeVersionSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElements_LocalElementNodeVersionSetNumber",err,error)
    CALL EXITS("CMISSMeshElements_LocalElementNodeVersionSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_LocalElementNodeVersionSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element nodes for an element in a mesh identified by an object. \todo should the global element number be a user number?
  SUBROUTINE CMISSMeshElements_LocalElementNodeVersionSetObj(meshElements,globalElementNumber,versionNumber,derivativeNumber, &
    & localElementNodeNumber,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: globalElementNumber !<The global element number to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: versionNumber !<The version number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the specified element node to set.
    INTEGER(INTG), INTENT(IN) :: localElementNodeNumber !<The local element node to set a version for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElements_LocalElementNodeVersionSetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_NODE_VERSION_SET(globalElementNumber,meshElements%MESH_ELEMENTS,versionNumber, &
       & derivativeNumber,localElementNodeNumber,err,error,*999)

    CALL EXITS("CMISSMeshElements_LocalElementNodeVersionSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElements_LocalElementNodeVersionSetObj",err,error)
    CALL EXITS("CMISSMeshElements_LocalElementNodeVersionSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_LocalElementNodeVersionSetObj

  !
  !================================================================================================================================
  !

  !
  !================================================================================================================================
  !

  !>Returns the user number for an element in a mesh identified by an user number.
  SUBROUTINE CMISSMeshElements_UserNumberGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,elementGlobalNumber, &
    & elementUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to get the element user number for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNumber !<On return, the element user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElements_UserNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_USER_NUMBER_GET(elementGlobalNumber,elementUserNumber,MESH_ELEMENTS,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMeshElements_UserNumberGetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElements_UserNumberGetNumber",err,error)
    CALL EXITS("CMISSMeshElements_UserNumberGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_UserNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the element user number for an element in a mesh identified by an object.
  SUBROUTINE CMISSMeshElements_UserNumberGetObj(meshElements,elementGlobalNumber,elementUserNumber,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to get the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to get the element user number for.
    INTEGER(INTG), INTENT(OUT) :: elementUserNumber !<On return, the element user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElements_UserNumberGetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_USER_NUMBER_GET(elementGlobalNumber,elementUserNumber,meshElements%MESH_ELEMENTS, &
      & err,error,*999)

    CALL EXITS("CMISSMeshElements_UserNumberGetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElements_UserNumberGetObj",err,error)
    CALL EXITS("CMISSMeshElements_UserNumberGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_UserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for an element in a mesh identified by an user number.
  SUBROUTINE CMISSMeshElements_UserNumberSetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,elementGlobalNumber, &
    & elementUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The element user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElements_UserNumberSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_USER_NUMBER_SET(elementGlobalNumber,elementUserNumber,MESH_ELEMENTS,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMeshElements_UserNumberSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElements_UserNumberSetNumber",err,error)
    CALL EXITS("CMISSMeshElements_UserNumberSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_UserNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element user number for an element in a mesh identified by an object.
  SUBROUTINE CMISSMeshElements_UserNumberSetObj(meshElements,elementGlobalNumber,elementUserNumber,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element nodes for.
    INTEGER(INTG), INTENT(IN) :: elementGlobalNumber !<The global element number to set the element user number for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The element user number to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElements_UserNumberSetObj",err,error,*999)

    CALL MESH_TOPOLOGY_ELEMENTS_ELEMENT_USER_NUMBER_SET(elementGlobalNumber,elementUserNumber,meshElements%MESH_ELEMENTS, &
      & err,error,*999)

    CALL EXITS("CMISSMeshElements_UserNumberSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElements_UserNumberSetObj",err,error)
    CALL EXITS("CMISSMeshElements_UserNumberSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_UserNumberSetObj
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the user numbers for all elements in a mesh identified by an user number.
  SUBROUTINE CMISSMeshElements_UserNumbersAllSetNumber(regionUserNumber,meshUserNumber,meshComponentNumber, &
    & elementUserNumbers,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to set the element user numbers for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to set the element user numbers for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to set the element user numbers for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumbers(:) !<The element user numbers to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: MESH
    TYPE(MeshElementsType), POINTER :: MESH_ELEMENTS
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSMeshElements_UserNumbersAllSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(MESH)
    NULLIFY(MESH_ELEMENTS)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,REGION,MESH,err,error,*999)
      IF(ASSOCIATED(MESH)) THEN
        CALL MESH_TOPOLOGY_ELEMENTS_GET(MESH,meshComponentNumber,MESH_ELEMENTS,err,error,*999)
        CALL MeshTopologyElementsUserNumbersAllSet(MESH_ELEMENTS,elementUserNumbers,err,error,*999)
      ELSE
        LOCAL_ERROR="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSMeshElements_UserNumbersAllSetNumber")
    RETURN
999 CALL ERRORS("CMISSMeshElements_AllUserNumbersAllSetNumber",err,error)
    CALL EXITS("CMISSMeshElements_AllUserNumbersAllSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_UserNumbersAllSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the element user numbers for all elements in a mesh identified by an object.
  SUBROUTINE CMISSMeshElements_UserNumbersAllSetObj(meshElements,elementUserNumbers,err)

    !Argument variables
    TYPE(CMISSMeshElementsType), INTENT(IN) :: meshElements !<The mesh elements to set the element user numbers for
    INTEGER(INTG), INTENT(IN) :: elementUserNumbers(:) !<The element user numbers to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSMeshElements_UserNumbersAllSetObj",err,error,*999)

    CALL MeshTopologyElementsUserNumbersAllSet(meshElements%MESH_ELEMENTS,elementUserNumbers, &
      & err,error,*999)

    CALL EXITS("CMISSMeshElements_UserNumbersAllSetObj")
    RETURN
999 CALL ERRORS("CMISSMeshElements_UserNumbersAllSetObj",err,error)
    CALL EXITS("CMISSMeshElements_UserNumbersAllSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshElements_UserNumbersAllSetObj

  !
  !================================================================================================================================
  !


  !>Checks if the given node exists on the given mesh component.
  SUBROUTINE CMISSMesh_NodeExistsNumber( regionUserNumber, meshUserNumber, meshComponentNumber, nodeUserNumber, nodeExists, err )

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to check the node for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh tocheck the node for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the node for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to check.
    LOGICAL, INTENT(OUT) :: nodeExists !<True if the node exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(REGION_TYPE), POINTER :: region
    INTEGER(INTG) :: meshNodeNumber
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSMesh_NodeExistsNumber",err,error,*999)

    nodeExists = .FALSE.

    NULLIFY( region )
    NULLIFY( mesh )
    CALL REGION_USER_NUMBER_FIND( regionUserNumber, Region, err, error, *999 )
    IF(ASSOCIATED(region)) THEN
      CALL MESH_USER_NUMBER_FIND( meshUserNumber, Region, Mesh, err, error, *999 )
      IF( ASSOCIATED( mesh ) ) THEN
        CALL MeshTopologyNodeCheckExists(Mesh,meshComponentNumber,nodeUserNumber,nodeExists,meshNodeNumber,err,error,*999)
      ELSE
        LocalError="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LocalError,err,error,*999)
      END IF
    ELSE
      LocalError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LocalError,err,error,*999)
    END IF

    CALL EXITS("CMISSMesh_NodeExistsNumber")
    RETURN
999 CALL ERRORS("CMISSMesh_NodeExistsNumber",err,error)
    CALL EXITS("CMISSMesh_NodeExistsNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_NodeExistsNumber

  !
  !================================================================================================================================
  !

  !>Checks if the given node exists on the given mesh component.
  SUBROUTINE CMISSMesh_NodeExistsObj( mesh, meshComponentNumber, nodeUserNumber, nodeExists, err )

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to check the node for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the node for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number of the node to check.
    LOGICAL, INTENT(OUT) :: nodeExists !<True if the node exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    INTEGER(INTG) :: meshNodeNumber

    nodeExists = .FALSE.

    CALL ENTERS("CMISSMesh_NodeExistsObj",err,error,*999)

    CALL MeshTopologyNodeCheckExists(mesh%MESH,meshComponentNumber,nodeUserNumber,nodeExists,meshNodeNumber,err,error,*999)

    CALL EXITS("CMISSMesh_NodeExistsObj")
    RETURN
999 CALL ERRORS("CMISSMesh_NodeExistsObj",err,error)
    CALL EXITS("CMISSMesh_NodeExistsObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_NodeExistsObj

  !
  !================================================================================================================================
  !

  !>Checks if the given element exists on the given mesh component.
  SUBROUTINE CMISSMesh_ElementExistsNumber( regionUserNumber, meshUserNumber, meshComponentNumber, &
    & elementUserNumber, elementExists, err )

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to check the element for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to check the element for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the element for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to check.
    LOGICAL, INTENT(OUT) :: elementExists !<True if the element exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables
    TYPE(MESH_TYPE), POINTER :: Mesh
    TYPE(REGION_TYPE), POINTER :: Region
    INTEGER(INTG) :: meshElementNumber
    TYPE(VARYING_STRING) :: LocalError

    CALL ENTERS("CMISSMesh_ElementExistsNumber",err,error,*999)

    elementExists = .FALSE.

    NULLIFY( Region )
    NULLIFY( Mesh )
    CALL REGION_USER_NUMBER_FIND( regionUserNumber, Region, err, error, *999 )
    IF( ASSOCIATED( REGION ) ) THEN
      CALL MESH_USER_NUMBER_FIND( meshUserNumber, Region, Mesh, err, error, *999 )
      IF( ASSOCIATED( MESH ) ) THEN
        CALL MeshTopologyElementCheckExists(Mesh,meshComponentNumber,elementUserNumber,elementExists, &
          & meshElementNumber,err,error,*999)
      ELSE
        LocalError="A mesh with an user number of "//TRIM(NUMBER_TO_VSTRING(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LocalError,err,error,*999)
      END IF
    ELSE
      LocalError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LocalError,err,error,*999)
    END IF

    CALL EXITS("CMISSMesh_ElementExistsNumber")
    RETURN
999 CALL ERRORS("CMISSMesh_ElementExistsNumber",err,error)
    CALL EXITS("CMISSMesh_ElementExistsNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_ElementExistsNumber

  !
  !================================================================================================================================
  !

  !>Checks if the given element exists on the given mesh component.
  SUBROUTINE CMISSMesh_ElementExistsObj( mesh, meshComponentNumber, elementUserNumber, elementExists, err )

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to check the node for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to check the element for.
    INTEGER(INTG), INTENT(IN) :: elementUserNumber !<The user number of the element to check.
    LOGICAL, INTENT(OUT) :: elementExists !<True if the element exists, false otherwise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Local variables
    INTEGER(INTG) :: meshElementNumber

    CALL ENTERS("CMISSMesh_ElementExistsObj",err,error,*999)

    elementExists = .FALSE.

    CALL MeshTopologyElementCheckExists(mesh%MESH,meshComponentNumber,elementUserNumber,elementExists,meshElementNumber, &
      & err,error,*999)

    CALL EXITS("CMISSMesh_ElementExistsObj")
    RETURN
999 CALL ERRORS("CMISSMesh_ElementExistsObj",err,error)
    CALL EXITS("CMISSMesh_ElementExistsObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_ElementExistsObj

  !
  !================================================================================================================================
  !

  !>Returns the mesh nodes for a mesh component on a mesh identified by an user number.
  SUBROUTINE CMISSMesh_NodesGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,meshNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the nodes for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the nodes for.
    TYPE(CMISSMeshNodesType), INTENT(INOUT) :: meshNodes !<On return, the mesh nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL Enters("CMISSMesh_NodesGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(mesh)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,region,mesh,err,error,*999)
      IF(ASSOCIATED(mesh)) THEN
        CALL MeshTopologyNodesGet(mesh,meshComponentNumber,meshNodes%meshNodes,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    CALL Exits("CMISSMesh_NodesGetNumber")
    RETURN
999 CALL Errors("CMISSMesh_NodesGetNumber",err,error)
    CALL Exits("CMISSMesh_NodesGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_NodesGetNumber


  !
  !================================================================================================================================
  !

  !>Returns the mesh nodes for a mesh component on a mesh identified by an object.
  SUBROUTINE CMISSMesh_NodesGetObj(mesh,meshComponentNumber,meshNodes,err)

    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to get the nodes for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the nodes for.
    TYPE(CMISSMeshNodesType), INTENT(INOUT) :: meshNodes!<On return, the mesh nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL Enters("CMISSMesh_NodesGetObj",err,error,*999)

    CALL MeshTopologyNodesGet(mesh%mesh,meshComponentNumber,meshNodes%meshNodes,err,error,*999)

    CALL Exits("CMISSMesh_NodesGetObj")
    RETURN
999 CALL Errors("CMISSMesh_NodesGetObj",err,error)
    CALL Exits("CMISSMesh_NodesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMesh_NodesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of derivatives at a node in a mesh identified by an user number. 
  SUBROUTINE CMISSMeshNodes_NumberOfDerivativesGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,userNodeNumber, &
    & numberOfDerivatives,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of dervatives for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of derivatives for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the number of derivatives for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the number of derivatives for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDerivatives !<On return, the number of derivatives in the mesh for the user node number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL Enters("CMISSMeshNodes_NumberOfDerivativesGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshNodes)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,region,mesh,err,error,*999)
      IF(ASSOCIATED(mesh)) THEN
        CALL MeshTopologyNodesGet(mesh,meshComponentNumber,meshNodes,err,error,*999)
        CALL MeshTopologyNodeNumberOfDerivativesGet(meshNodes,userNodeNumber,numberOfDerivatives,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    CALL Exits("CMISSMeshNodes_NumberOfDerivativesGetNumber")
    RETURN
999 CALL Errors("CMISSMeshNodes_NumberOfDerivativesGetNumber",err,error)
    CALL Exits("CMISSMeshNodes_NumberOfDerivativesGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNodes_NumberOfDerivativesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of derivatives for a node in a mesh identified by an object.
  SUBROUTINE CMISSMeshNodes_NumberOfDerivativesGetObj(meshNodes,userNodeNumber,numberOfDerivatives,err)

    !Argument variables
    TYPE(CMISSMeshNodesType), INTENT(IN) :: meshNodes!<The mesh nodes to get the number of derivatives at a node for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the number of derivatives at a node for.
    INTEGER(INTG), INTENT(OUT) :: numberOfDerivatives!<On return, the number of derivatives at a node in a mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL Enters("CMISSMeshNodes_NumberOfDerivativesGetObj",err,error,*999)

    CALL MeshTopologyNodeNumberOfDerivativesGet(meshNodes%meshNodes,userNodeNumber,numberOfDerivatives,err,error,*999)

    CALL Exits("CMISSMeshNodes_NumberOfDerivativesGetObj")
    RETURN
999 CALL Errors("CMISSMeshNodes_NumberOfDerivativesGetObj",err,error)
    CALL Exits("CMISSMeshNodes_NumberOfDerivativesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNodes_NumberOfDerivativesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the derivatives at a node in a mesh identified by an user number. 
  SUBROUTINE CMISSMeshNodes_DerivativesGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,userNodeNumber, &
    & derivatives,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the derivatives for.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the derivatives for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the derivatives for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the derivatives for.
    INTEGER(INTG), INTENT(OUT) :: derivatives(:) !<On return, the derivatives in the mesh for the user node number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL Enters("CMISSMeshNodes_DerivativesGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshNodes)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,region,mesh,err,error,*999)
      IF(ASSOCIATED(mesh)) THEN
        CALL MeshTopologyNodesGet(mesh,meshComponentNumber,meshNodes,err,error,*999)
        CALL MeshTopologyNodeDerivativesGet(meshNodes,userNodeNumber,derivatives,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    CALL Exits("CMISSMeshNodes_DerivativesGetNumber")
    RETURN
999 CALL Errors("CMISSMeshNodes_DerivativesGetNumber",err,error)
    CALL Exits("CMISSMeshNodes_DerivativesGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNodes_DerivativesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the derivatives for a node in a mesh identified by an object.
  SUBROUTINE CMISSMeshNodes_DerivativesGetObj(meshNodes,userNodeNumber,derivatives,err)

    !Argument variables
    TYPE(CMISSMeshNodesType), INTENT(IN) :: meshNodes!<The mesh nodes to get the derivatives at a node for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the derivatives at a node for.
    INTEGER(INTG), INTENT(OUT) :: derivatives(:) !<On return, the derivatives at a node in a mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL Enters("CMISSMeshNodes_DerivativesGetObj",err,error,*999)

    CALL MeshTopologyNodeDerivativesGet(meshNodes%meshNodes,userNodeNumber,derivatives,err,error,*999)

    CALL Exits("CMISSMeshNodes_DerivativesGetObj")
    RETURN
999 CALL Errors("CMISSMeshNodes_DerivativesGetObj",err,error)
    CALL Exits("CMISSMeshNodes_DerivativesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNodes_DerivativesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the number of version at a derivative for a node in a mesh identified by an user number. 
  SUBROUTINE CMISSMeshNodes_NumberOfVersionsGetNumber(regionUserNumber,meshUserNumber,meshComponentNumber,derivativeNumber, &
    & userNodeNumber,numberOfVersions,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the mesh to get the number of versions.
    INTEGER(INTG), INTENT(IN) :: meshUserNumber !<The user number of the mesh to get the number of versions for.
    INTEGER(INTG), INTENT(IN) :: meshComponentNumber !<The mesh component number to get the number of versions for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of the node to get the number of versions for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the number of versions for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVersions !<On return, the number of versions in the mesh for the derivative index of the user node number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(MeshNodesType), POINTER :: meshNodes
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL Enters("CMISSMeshNodes_NumberOfVersionsGetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(mesh)
    NULLIFY(meshNodes)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL MESH_USER_NUMBER_FIND(meshUserNumber,region,mesh,err,error,*999)
      IF(ASSOCIATED(mesh)) THEN
        CALL MeshTopologyNodesGet(mesh,meshComponentNumber,meshNodes,err,error,*999)
        CALL MeshTopologyNodeNumberOfVersionsGet(meshnodes,derivativeNumber,userNodeNumber,numberOfVersions,err,error,*999)
      ELSE
        localError="A mesh with an user number of "//TRIM(NumberToVString(meshUserNumber,"*",err,error))// &
          & " does not exist on the region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))//"."
        CALL FlagError(localError,err,error,*999)
      END IF
    ELSE
      localError="A region with an user number of "//TRIM(NumberToVString(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FlagError(localError,err,error,*999)
    END IF

    CALL Exits("CMISSMeshNodes_NumberOfVersionsGetNumber")
    RETURN
999 CALL Errors("CMISSMeshNodes_NumberOfVersionsGetNumber",err,error)
    CALL Exits("CMISSMeshNodes_NumberOfVersionsGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNodes_NumberOfVersionsGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of versions for an node in a mesh identified by an object.
  SUBROUTINE CMISSMeshNodes_NumberOfVersionsGetObj(meshNodes,derivativeNumber,userNodeNumber,numberOfVersions,err)

    !Argument variables
    TYPE(CMISSMeshNodesType), INTENT(IN) :: meshNodes !<The mesh nodes to get the number of versions at a node for.
    INTEGER(INTG), INTENT(IN) :: derivativeNumber !<The derivative number of a node to get the number of versions for.
    INTEGER(INTG), INTENT(IN) :: userNodeNumber !<The user node number to get the number of versions at a node for.
    INTEGER(INTG), INTENT(OUT) :: numberOfVersions !<On return, the number of derivatives at the specified node and derivative in a mesh.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL Enters("CMISSMeshNodes_NumberOfVersionsGetObj",err,error,*999)

    CALL MeshTopologyNodeNumberOfVersionsGet(meshNodes%meshNodes,derivativeNumber,userNodeNumber, &
      & numberOfVersions,err,error,*999)

    CALL Exits("CMISSMeshNodes_NumberOfVersionsGetObj")
    RETURN
999 CALL Errors("CMISSMeshNodes_NumberOfVersionsGetObj",err,error)
    CALL Exits("CMISSMeshNodes_NumberOfVersionsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSMeshNodes_NumberOfVersionsGetObj

!!==================================================================================================================================
!!
!! DISTRIBUTED_MATRIX_VECTOR
!!
!!==================================================================================================================================

  !>Get the storage type for a distributed matrix
  SUBROUTINE CMISSDistributedMatrix_StorageTypeGetObj(matrix,storageType,err)

    !Argument variables
    TYPE(CMISSDistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the storage type for
    INTEGER(INTG), INTENT(OUT) :: storageType !<On return, the matrix storage type. \see OPENCMISS_MatrixStorageTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedMatrix_StorageTypeGetObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_STORAGE_TYPE_GET(matrix%distributedMatrix,storageType,err,error,*999)

    CALL exits("CMISSDistributedMatrix_StorageTypeGetObj")

    RETURN
999 CALL errors("CMISSDistributedMatrix_StorageTypeGetObj",err,error)
    CALL exits("CMISSDistributedMatrix_StorageTypeGetObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedMatrix_StorageTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get the data type of a distributed matrix
  SUBROUTINE CMISSDistributedMatrix_DataTypeGetObj(matrix,dataType,err)

    !Argument variables
    TYPE(CMISSDistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data type for
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the matrix data type. \see OPENCMISS_MatrixVectorDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedMatrix_DataTypeGetObj",err,error,*999)

    CALL DistributedMatrix_DataTypeGet(matrix%distributedMatrix,dataType,err,error,*999)

    CALL exits("CMISSDistributedMatrix_DataTypeGetObj")

    RETURN
999 CALL errors("CMISSDistributedMatrix_DataTypeGetObj",err,error)
    CALL exits("CMISSDistributedMatrix_DataTypeGetObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedMatrix_DataTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get the dimensions of a distributed matrix on this computational node
  SUBROUTINE CMISSDistributedMatrix_DimensionsGetObj(matrix,m,n,err)

    !Argument variables
    TYPE(CMISSDistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data type for
    INTEGER(INTG), INTENT(OUT) :: m !<On return, the number of rows for this computational node
    INTEGER(INTG), INTENT(OUT) :: n !<On return, the number of columns
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedMatrix_DimensionsGetObj",err,error,*999)

    CALL DistributedMatrix_DimensionsGet(matrix%distributedMatrix,m,n,err,error,*999)

    CALL exits("CMISSDistributedMatrix_DimensionsGetObj")

    RETURN
999 CALL errors("CMISSDistributedMatrix_DimensionsGetObj",err,error)
    CALL exits("CMISSDistributedMatrix_DimensionsGetObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedMatrix_DimensionsGetObj

  !
  !================================================================================================================================
  !

  !>Get the row indices and column indices for a sparse matrix
  SUBROUTINE CMISSDistributedMatrix_StorageLocationsGetObj(matrix,rowIndices,columnIndices,err)

    !Argument variables
    TYPE(CMISSDistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the storage locations for
    INTEGER(INTG), POINTER, INTENT(OUT) :: rowIndices(:) !<On return, the matrix storage row indices
    INTEGER(INTG), POINTER, INTENT(OUT) :: columnIndices(:) !<On return, the matrix storage column indices
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedMatrix_StorageLocationsGetObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_STORAGE_LOCATIONS_GET(matrix%distributedMatrix,rowIndices,columnIndices,err,error,*999)

    CALL exits("CMISSDistributedMatrix_StorageLocationsGetObj")

    RETURN
999 CALL errors("CMISSDistributedMatrix_StorageLocationsGetObj",err,error)
    CALL exits("CMISSDistributedMatrix_StorageLocationsGetObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedMatrix_StorageLocationsGetObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this matrix on this computational node
  SUBROUTINE CMISSDistributedMatrix_DataGetIntgObj(matrix,data,err)

    !Argument variables
    TYPE(CMISSDistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data for
    INTEGER(INTG), POINTER, INTENT(OUT) :: data(:) !<On return, the matrix data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedMatrix_DataGetIntgObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_DATA_GET(matrix%distributedMatrix,data,err,error,*999)

    CALL exits("CMISSDistributedMatrix_DataGetIntgObj")

    RETURN
999 CALL errors("CMISSDistributedMatrix_DataGetIntgObj",err,error)
    CALL exits("CMISSDistributedMatrix_DataGetIntgObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedMatrix_DataGetIntgObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this matrix once it has finished being used
  SUBROUTINE CMISSDistributedMatrix_DataRestoreIntgObj(matrix,data,err)

    !Argument variables
    TYPE(CMISSDistributedMatrixType), INTENT(IN) :: matrix !<The matrix to restore the data for
    INTEGER(INTG), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the matrix data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedMatrix_DataRestoreIntgObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_DATA_RESTORE(matrix%distributedMatrix,data,err,error,*999)

    CALL exits("CMISSDistributedMatrix_DataRestoreIntgObj")

    RETURN
999 CALL errors("CMISSDistributedMatrix_DataRestoreIntgObj",err,error)
    CALL exits("CMISSDistributedMatrix_DataRestoreIntgObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedMatrix_DataRestoreIntgObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this matrix on this computational node
  SUBROUTINE CMISSDistributedMatrix_DataGetDPObj(matrix,data,err)

    !Argument variables
    TYPE(CMISSDistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data for
    REAL(DP), POINTER, INTENT(OUT) :: data(:) !<On return, the matrix data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedMatrix_DataGetDPObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_DATA_GET(matrix%distributedMatrix,data,err,error,*999)

    CALL exits("CMISSDistributedMatrix_DataGetDPObj")

    RETURN
999 CALL errors("CMISSDistributedMatrix_DataGetDPObj",err,error)
    CALL exits("CMISSDistributedMatrix_DataGetDPObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedMatrix_DataGetDPObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this matrix once it has finished being used
  SUBROUTINE CMISSDistributedMatrix_DataRestoreDPObj(matrix,data,err)

    !Argument variables
    TYPE(CMISSDistributedMatrixType), INTENT(IN) :: matrix !<The matrix to restore the data for
    REAL(DP), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the matrix data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedMatrix_DataRestoreDPObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_DATA_RESTORE(matrix%distributedMatrix,data,err,error,*999)

    CALL exits("CMISSDistributedMatrix_DataRestoreDPObj")

    RETURN
999 CALL errors("CMISSDistributedMatrix_DataRestoreDPObj",err,error)
    CALL exits("CMISSDistributedMatrix_DataRestoreDPObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedMatrix_DataRestoreDPObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this matrix on this computational node
  SUBROUTINE CMISSDistributedMatrix_DataGetSPObj(matrix,data,err)

    !Argument variables
    TYPE(CMISSDistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data for
    REAL(SP), POINTER, INTENT(OUT) :: data(:) !<On return, the matrix data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedMatrix_DataGetSPObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_DATA_GET(matrix%distributedMatrix,data,err,error,*999)

    CALL exits("CMISSDistributedMatrix_DataGetSPObj")

    RETURN
999 CALL errors("CMISSDistributedMatrix_DataGetSPObj",err,error)
    CALL exits("CMISSDistributedMatrix_DataGetSPObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedMatrix_DataGetSPObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this matrix once it has finished being used
  SUBROUTINE CMISSDistributedMatrix_DataRestoreSPObj(matrix,data,err)

    !Argument variables
    TYPE(CMISSDistributedMatrixType), INTENT(IN) :: matrix !<The matrix to restore the data for
    REAL(SP), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the matrix data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedMatrix_DataRestoreSPObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_DATA_RESTORE(matrix%distributedMatrix,data,err,error,*999)

    CALL exits("CMISSDistributedMatrix_DataRestoreSPObj")

    RETURN
999 CALL errors("CMISSDistributedMatrix_DataRestoreSPObj",err,error)
    CALL exits("CMISSDistributedMatrix_DataRestoreSPObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedMatrix_DataRestoreSPObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this matrix on this computational node
  SUBROUTINE CMISSDistributedMatrix_DataGetLObj(matrix,data,err)

    !Argument variables
    TYPE(CMISSDistributedMatrixType), INTENT(IN) :: matrix !<The matrix to get the data for
    LOGICAL, POINTER, INTENT(OUT) :: data(:) !<On return, the matrix data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedMatrix_DataGetLObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_DATA_GET(matrix%distributedMatrix,data,err,error,*999)

    CALL exits("CMISSDistributedMatrix_DataGetLObj")

    RETURN
999 CALL errors("CMISSDistributedMatrix_DataGetLObj",err,error)
    CALL exits("CMISSDistributedMatrix_DataGetLObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedMatrix_DataGetLObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this matrix once it has finished being used
  SUBROUTINE CMISSDistributedMatrix_DataRestoreLObj(matrix,data,err)

    !Argument variables
    TYPE(CMISSDistributedMatrixType), INTENT(IN) :: matrix !<The matrix to restore the data for
    LOGICAL, POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the matrix data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedMatrix_DataRestoreLObj",err,error,*999)

    CALL DISTRIBUTED_MATRIX_DATA_RESTORE(matrix%distributedMatrix,data,err,error,*999)

    CALL exits("CMISSDistributedMatrix_DataRestoreLObj")

    RETURN
999 CALL errors("CMISSDistributedMatrix_DataRestoreLObj",err,error)
    CALL exits("CMISSDistributedMatrix_DataRestoreLObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedMatrix_DataRestoreLObj

  !
  !================================================================================================================================
  !

  !>Get the data type of a distributed vector
  SUBROUTINE CMISSDistributedVector_DataTypeGetObj(vector,dataType,err)

    !Argument variables
    TYPE(CMISSDistributedVectorType), INTENT(IN) :: vector !<The vector to get the data type for
    INTEGER(INTG), INTENT(OUT) :: dataType !<On return, the vector data type. \see OPENCMISS_MatrixVectorDataTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedVector_DataTypeGetObj",err,error,*999)

    CALL DistributedVector_DataTypeGet(vector%distributedVector,dataType,err,error,*999)

    CALL exits("CMISSDistributedVector_DataTypeGetObj")

    RETURN
999 CALL errors("CMISSDistributedVector_DataTypeGetObj",err,error)
    CALL exits("CMISSDistributedVector_DataTypeGetObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedVector_DataTypeGetObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this vector on this computational node
  SUBROUTINE CMISSDistributedVector_DataGetIntgObj(vector,data,err)

    !Argument variables
    TYPE(CMISSDistributedVectorType), INTENT(IN) :: vector !<The vector to get the data for
    INTEGER(INTG), POINTER, INTENT(OUT) :: data(:) !<On return, the vector data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedVector_DataGetIntgObj",err,error,*999)

    CALL DISTRIBUTED_VECTOR_DATA_GET(vector%distributedVector,data,err,error,*999)

    CALL exits("CMISSDistributedVector_DataGetIntgObj")

    RETURN
999 CALL errors("CMISSDistributedVector_DataGetIntgObj",err,error)
    CALL exits("CMISSDistributedVector_DataGetIntgObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedVector_DataGetIntgObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this vector once it has finished being used
  SUBROUTINE CMISSDistributedVector_DataRestoreIntgObj(vector,data,err)

    !Argument variables
    TYPE(CMISSDistributedVectorType), INTENT(IN) :: vector !<The vector to restore the data for
    INTEGER(INTG), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the vector data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedVector_DataRestoreIntgObj",err,error,*999)

    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(vector%distributedVector,data,err,error,*999)

    CALL exits("CMISSDistributedVector_DataRestoreIntgObj")

    RETURN
999 CALL errors("CMISSDistributedVector_DataRestoreIntgObj",err,error)
    CALL exits("CMISSDistributedVector_DataRestoreIntgObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedVector_DataRestoreIntgObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this vector on this computational node
  SUBROUTINE CMISSDistributedVector_DataGetDPObj(vector,data,err)

    !Argument variables
    TYPE(CMISSDistributedVectorType), INTENT(IN) :: vector !<The vector to get the data for
    REAL(DP), POINTER, INTENT(OUT) :: data(:) !<On return, the vector data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedVector_DataGetDPObj",err,error,*999)

    CALL DISTRIBUTED_VECTOR_DATA_GET(vector%distributedVector,data,err,error,*999)

    CALL exits("CMISSDistributedVector_DataGetDPObj")

    RETURN
999 CALL errors("CMISSDistributedVector_DataGetDPObj",err,error)
    CALL exits("CMISSDistributedVector_DataGetDPObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedVector_DataGetDPObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this vector once it has finished being used
  SUBROUTINE CMISSDistributedVector_DataRestoreDPObj(vector,data,err)

    !Argument variables
    TYPE(CMISSDistributedVectorType), INTENT(IN) :: vector !<The vector to restore the data for
    REAL(DP), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the vector data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedVector_DataRestoreDPObj",err,error,*999)

    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(vector%distributedVector,data,err,error,*999)

    CALL exits("CMISSDistributedVector_DataRestoreDPObj")

    RETURN
999 CALL errors("CMISSDistributedVector_DataRestoreDPObj",err,error)
    CALL exits("CMISSDistributedVector_DataRestoreDPObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedVector_DataRestoreDPObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this vector on this computational node
  SUBROUTINE CMISSDistributedVector_DataGetSPObj(vector,data,err)

    !Argument variables
    TYPE(CMISSDistributedVectorType), INTENT(IN) :: vector !<The vector to get the data for
    REAL(SP), POINTER, INTENT(OUT) :: data(:) !<On return, the vector data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedVector_DataGetSPObj",err,error,*999)

    CALL DISTRIBUTED_VECTOR_DATA_GET(vector%distributedVector,data,err,error,*999)

    CALL exits("CMISSDistributedVector_DataGetSPObj")

    RETURN
999 CALL errors("CMISSDistributedVector_DataGetSPObj",err,error)
    CALL exits("CMISSDistributedVector_DataGetSPObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedVector_DataGetSPObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this vector once it has finished being used
  SUBROUTINE CMISSDistributedVector_DataRestoreSPObj(vector,data,err)

    !Argument variables
    TYPE(CMISSDistributedVectorType), INTENT(IN) :: vector !<The vector to restore the data for
    REAL(SP), POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the vector data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedVector_DataRestoreSPObj",err,error,*999)

    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(vector%distributedVector,data,err,error,*999)

    CALL exits("CMISSDistributedVector_DataRestoreSPObj")

    RETURN
999 CALL errors("CMISSDistributedVector_DataRestoreSPObj",err,error)
    CALL exits("CMISSDistributedVector_DataRestoreSPObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedVector_DataRestoreSPObj

  !
  !================================================================================================================================
  !

  !>Get the data array for this vector on this computational node
  SUBROUTINE CMISSDistributedVector_DataGetLObj(vector,data,err)

    !Argument variables
    TYPE(CMISSDistributedVectorType), INTENT(IN) :: vector !<The vector to get the data for
    LOGICAL, POINTER, INTENT(OUT) :: data(:) !<On return, the vector data
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedVector_DataGetLObj",err,error,*999)

    CALL DISTRIBUTED_VECTOR_DATA_GET(vector%distributedVector,data,err,error,*999)

    CALL exits("CMISSDistributedVector_DataGetLObj")

    RETURN
999 CALL errors("CMISSDistributedVector_DataGetLObj",err,error)
    CALL exits("CMISSDistributedVector_DataGetLObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedVector_DataGetLObj

  !
  !================================================================================================================================
  !

  !>Restore the data array for this vector once it has finished being used
  SUBROUTINE CMISSDistributedVector_DataRestoreLObj(vector,data,err)

    !Argument variables
    TYPE(CMISSDistributedVectorType), INTENT(IN) :: vector !<The vector to restore the data for
    LOGICAL, POINTER, INTENT(INOUT) :: data(:) !<On entry, a pointer to the vector data. On return, a nullified pointer.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL enters("CMISSDistributedVector_DataRestoreLObj",err,error,*999)

    CALL DISTRIBUTED_VECTOR_DATA_RESTORE(vector%distributedVector,data,err,error,*999)

    CALL exits("CMISSDistributedVector_DataRestoreLObj")

    RETURN
999 CALL errors("CMISSDistributedVector_DataRestoreLObj",err,error)
    CALL exits("CMISSDistributedVector_DataRestoreLObj")
    CALL cmiss_handle_error(err,error)
    RETURN

  END SUBROUTINE CMISSDistributedVector_DataRestoreLObj

!!==================================================================================================================================
!!
!! NODE_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the process of creating nodes in a region for nodes identified by user number.
  SUBROUTINE CMISSNodes_CreateFinishNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodes_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_CREATE_FINISH(NODES,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Nodes Create')
#endif

    CALL EXITS("CMISSNodes_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSNodes_CreateFinishNumber",err,error)
    CALL EXITS("CMISSNodes_CreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a nodes in a region for nodes identified by an object.
  SUBROUTINE CMISSNodes_CreateFinishObj(nodes,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodes_CreateFinishObj",err,error,*999)

    CALL NODES_CREATE_FINISH(nodes%NODES,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('nodes Create')
#endif

    CALL EXITS("CMISSNodes_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSNodes_CreateFinishObj",err,error)
    CALL EXITS("CMISSNodes_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating nodes in a region for nodes identified by user number.
  SUBROUTINE CMISSNodes_CreateStartNumber(regionUserNumber,numberOfNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to start the creation of.
    INTEGER(INTG), INTENT(IN) :: numberOfNodes !<The number of nodes to create.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodes_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Nodes Create')
#endif

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL NODES_CREATE_START(REGION,numberOfNodes,NODES,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSNodes_CreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSNodes_CreateStartNumber",err,error)
    CALL EXITS("CMISSNodes_CreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a nodes in a region for nodes identified by an object.
  SUBROUTINE CMISSNodes_CreateStartObj(region,numberOfNodes,nodes,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to start the creation of nodes on.
    INTEGER(INTG), INTENT(IN) :: numberOfNodes !<The number of nodes to create.
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<On return, the created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodes_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('nodes Create')
#endif

    CALL NODES_CREATE_START(region%REGION,numberOfNodes,nodes%NODES,err,error,*999)

    CALL EXITS("CMISSNodes_CreateStartObj")
    RETURN
999 CALL ERRORS("CMISSNodes_CreateStartObj",err,error)
    CALL EXITS("CMISSNodes_CreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Starts the creation of a nodes in a region for nodes identified by an object.
  SUBROUTINE CMISSNodes_CreateStartInterfaceObj(interface,numberOfNodes,nodes,err)

    !Argument variables
    TYPE(CMISSInterfaceType), INTENT(IN) :: interface !<The interface to start the creation of nodes on.
    INTEGER(INTG), INTENT(IN) :: numberOfNodes !<The number of nodes to create.
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<On return, the created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodes_CreateStartInterfaceObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('nodes Create')
#endif

    CALL NODES_CREATE_START(interface%INTERFACE,numberOfNodes,nodes%NODES,err,error,*999)

    CALL EXITS("CMISSNodes_CreateStartInterfaceObj")
    RETURN
999 CALL ERRORS("CMISSNodes_CreateStartInterfaceObj",err,error)
    CALL EXITS("CMISSNodes_CreateStartInterfaceObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_CreateStartInterfaceObj

  !
  !================================================================================================================================
  !

  !>Destroys the nodes in a region for nodes identified by user number.
  SUBROUTINE CMISSNodes_DestroyNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodes_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_DESTROY(NODES,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSNodes_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSNodes_DestroyNumber",err,error)
    CALL EXITS("CMISSNodes_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the nodes in a region for nodes identified by an object.
  SUBROUTINE CMISSNodes_DestroyObj(nodes,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodeDestroyObj",err,error,*999)

    CALL NODES_DESTROY(nodes%NODES,err,error,*999)

    CALL EXITS("CMISSNodes_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSNodes_DestroyObj",err,error)
    CALL EXITS("CMISSNodes_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the number of nodes
  SUBROUTINE CMISSNodes_NumberOfNodesGetNumber(regionUserNumber,numberOfNodes,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get node count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<On return, the number of nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodes_NumberOfNodesGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_NUMBER_OF_NODES_GET(NODES,numberOfNodes,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSNodes_NumberOfNodesGetNumber")
    RETURN
999 CALL ERRORS("CMISSNodes_NumberOfNodesGetNumber",err,error)
    CALL EXITS("CMISSNodes_NumberOfNodesGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_NumberOfNodesGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the number of nodes
  SUBROUTINE CMISSNodes_NumberOfNodesGetObj(nodes,numberOfNodes,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes get node count for.
    INTEGER(INTG), INTENT(OUT) :: numberOfNodes !<The number of nodes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodes_NumberOfNodesGetObj",err,error,*999)

    CALL NODES_NUMBER_OF_NODES_GET(nodes%NODES,numberOfNodes,err,error,*999)

    CALL EXITS("CMISSNodes_NumberOfNodesGetObj")
    RETURN
999 CALL ERRORS("CMISSNodes_NumberOfNodesGetObj",err,error)
    CALL EXITS("CMISSNodes_NumberOfNodesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_NumberOfNodesGetObj

  !
  !================================================================================================================================
  !

  !>Returns the character label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE CMISSNodes_LabelGetCNumber(regionUserNumber,nodeGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodes_LabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_LABEL_GET(NODES,nodeGlobalNumber,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSNodes_LabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSNodes_LabelGetCNumber",err,error)
    CALL EXITS("CMISSNodes_LabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodes_LabelGetCObj(nodes,nodeGlobalNumber,label,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodes_LabelGetCObj",err,error,*999)

    CALL NODES_LABEL_GET(nodes%NODES,nodeGlobalNumber,label,err,error,*999)

    CALL EXITS("CMISSNodes_LabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSNodes_LabelGetCObj",err,error)
    CALL EXITS("CMISSNodes_LabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE CMISSNodes_LabelGetVSNumber(regionUserNumber,nodeGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodes_LabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_LABEL_GET(NODES,nodeGlobalNumber,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSNodes_LabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSNodes_LabelGetVSNumber",err,error)
    CALL EXITS("CMISSNodes_LabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodes_LabelGetVSObj(nodes,nodeGlobalNumber,label,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes to get the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the label for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodes_LabelGetVSObj",err,error,*999)

    CALL NODES_LABEL_GET(nodes%NODES,nodeGlobalNumber,label,err,error,*999)

    CALL EXITS("CMISSNodes_LabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSNodes_LabelGetVSObj",err,error)
    CALL EXITS("CMISSNodes_LabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE CMISSNodes_LabelSetCNumber(regionUserNumber,nodeGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodes_LabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_LABEL_SET(NODES,nodeGlobalNumber,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSNodes_LabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSNodes_LabelSetCNumber",err,error)
    CALL EXITS("CMISSNodes_LabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodes_LabelSetCObj(nodes,nodeGlobalNumber,label,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodes_LabelSetCObj",err,error,*999)

    CALL NODES_LABEL_SET(nodes%NODES,nodeGlobalNumber,label,err,error,*999)

    CALL EXITS("CMISSNodes_LabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSNodes_LabelSetCObj",err,error)
    CALL EXITS("CMISSNodes_LabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a node in a set of nodes identified by user number. \todo should this be user number??
  SUBROUTINE CMISSNodes_LabelSetVSNumber(regionUserNumber,nodeGlobalNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodes_LabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_LABEL_SET(NODES,nodeGlobalNumber,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSNodes_LabelSetVSNumber")
    RETURN
999 CALL ERRORS("CMISSNodes_LabelSetVSNumber",err,error)
    CALL EXITS("CMISSNodes_LabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodes_LabelSetVSObj(nodes,nodeGlobalNumber,label,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes to set the label for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The label for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodes_LabelSetVSObj",err,error,*999)

    CALL NODES_LABEL_SET(nodes%NODES,nodeGlobalNumber,label,err,error,*999)

    CALL EXITS("CMISSNodes_LabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSNodes_LabelSetVSObj",err,error)
    CALL EXITS("CMISSNodes_LabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the user number for a node in a set of nodes identified by user number.
  SUBROUTINE CMISSNodes_UserNumberGetNumber(regionUserNumber,nodeGlobalNumber,nodeUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to get the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the node user number for.
    INTEGER(INTG), INTENT(OUT) :: nodeUserNumber !<On return, the user number for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodes_UserNumberGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_USER_NUMBER_GET(NODES,nodeGlobalNumber,nodeUserNumber,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSNodes_UserNumberGetNumber")
    RETURN
999 CALL ERRORS("CMISSNodes_UserNumberGetNumber",err,error)
    CALL EXITS("CMISSNodes_UserNumberGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_UserNumberGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the user number for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodes_UserNumberGetObj(nodes,nodeGlobalNumber,nodeUserNumber,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes to get the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to get the node user number for.
    INTEGER(INTG), INTENT(OUT) :: nodeUserNumber !<On return, the user number for the node.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodes_UserNumberGetObj",err,error,*999)

    CALL NODES_USER_NUMBER_GET(nodes%NODES,nodeGlobalNumber,nodeUserNumber,err,error,*999)

    CALL EXITS("CMISSNodes_UserNumberGetObj")
    RETURN
999 CALL ERRORS("CMISSNodes_UserNumberGetObj",err,error)
    CALL EXITS("CMISSNodes_UserNumberGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_UserNumberGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a node in a set of nodes identified by user number.
  SUBROUTINE CMISSNodes_UserNumberSetNumber(regionUserNumber,nodeGlobalNumber,nodeUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: NODES
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSNodes_UserNumberSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(NODES)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_NODES_GET(REGION,NODES,err,error,*999)
      CALL NODES_USER_NUMBER_SET(NODES,nodeGlobalNumber,nodeUserNumber,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSNodes_UserNumberSetNumber")
    RETURN
999 CALL ERRORS("CMISSNodes_UserNumberSetNumber",err,error)
    CALL EXITS("CMISSNodes_UserNumberSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_UserNumberSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the user number for a node in a set of nodes identified by an object. \todo should this be user number??
  SUBROUTINE CMISSNodes_UserNumberSetObj(nodes,nodeGlobalNumber,nodeUserNumber,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeGlobalNumber !<The global number of the nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumber !<The user number for the node to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodes_UserNumberSetObj",err,error,*999)

    CALL NODES_USER_NUMBER_SET(nodes%NODES,nodeGlobalNumber,nodeUserNumber,err,error,*999)

    CALL EXITS("CMISSNodes_UserNumberSetObj")
    RETURN
999 CALL ERRORS("CMISSNodes_UserNumberSetObj",err,error)
    CALL EXITS("CMISSNodes_UserNumberSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_UserNumberSetObj
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the user numbers for a set of nodes identified by user number.
  SUBROUTINE CMISSNodes_UserNumbersAllSetNumber(regionUserNumber,nodeUserNumbers,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the nodes to set the node user numbers for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumbers(:) !<The user numbers for the nodes to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(NODES_TYPE), POINTER :: nodes
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSNodes_UserNumbersAllSetNumber",err,error,*999)

    NULLIFY(region)
    NULLIFY(nodes)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
    IF(ASSOCIATED(region)) THEN
      CALL REGION_NODES_GET(region,nodes,err,error,*999)
      CALL NodesUserNumbersAllSet(nodes,nodeUserNumbers,err,error,*999)
    ELSE
      localError="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSNodes_UserNumbersAllSetNumber")
    RETURN
999 CALL ERRORS("CMISSNodes_UserNumbersAllSetNumber",err,error)
    CALL EXITS("CMISSNodes_UserNumbersAllSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_UserNumbersAllSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the user numbers for a set of nodes identified by an object. 
  SUBROUTINE CMISSNodes_UserNumbersAllSetObj(nodes,nodeUserNumbers,err)

    !Argument variables
    TYPE(CMISSNodesType), INTENT(IN) :: nodes !<The nodes to set the node user number for.
    INTEGER(INTG), INTENT(IN) :: nodeUserNumbers(:) !<The user numbers for the nodes to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSNodes_UserNumbersAllSetObj",err,error,*999)

    CALL NodesUserNumbersAllSet(nodes%NODES,nodeUserNumbers,err,error,*999)

    CALL EXITS("CMISSNodes_UserNumbersAllSetObj")
    RETURN
999 CALL ERRORS("CMISSNodes_UserNumbersAllSetObj",err,error)
    CALL EXITS("CMISSNodes_UserNumbersAllSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSNodes_UserNumbersAllSetObj

!!==================================================================================================================================
!!
!! PROBLEM_ROUTINES
!!
!!==================================================================================================================================

  !>Finishes the process of creating CellML equations for a problem identified by user number.
  SUBROUTINE CMISSProblem_CellMLEquationsCreateFinishNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_CellMLEquationsCreateFinishNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CELLML_EQUATIONS_CREATE_FINISH(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('CellML Equations Create')
#endif

    CALL EXITS("CMISSProblem_CellMLEquationsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSProblem_CellMLEquationsCreateFinishNumber",err,error)
    CALL EXITS("CMISSProblem_CellMLEquationsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_CellMLEquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of CellML equations for problem identified by an object.
  SUBROUTINE CMISSProblem_CellMLEquationsCreateFinishObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to finish creating the CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_CellMLEquationsCreateFinishObj",err,error,*999)

    CALL PROBLEM_CELLML_EQUATIONS_CREATE_FINISH(problem%PROBLEM,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('CellML Equations Create')
#endif

    CALL EXITS("CMISSProblem_CellMLEquationsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSProblem_CellMLEquationsCreateFinishObj",err,error)
    CALL EXITS("CMISSProblem_CellMLEquationsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_CellMLEquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating CellML equations for a problem identified by user number.
  SUBROUTINE CMISSProblem_CellMLEquationsCreateStartNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_CellMLEquationsCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Equations Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CELLML_EQUATIONS_CREATE_START(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_CellMLEquationsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSProblem_CellMLEquationsCreateStartNumber",err,error)
    CALL EXITS("CMISSProblem_CellMLEquationsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_CellMLEquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of CellML equations for problem identified by an object.
  SUBROUTINE CMISSProblem_CellMLEquationsCreateStartObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to start creating the CellML equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_CellMLEquationsCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('CellML Equations Create')
#endif

    CALL PROBLEM_CELLML_EQUATIONS_CREATE_START(problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblem_CellMLEquationsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSProblem_CellMLEquationsCreateStartObj",err,error)
    CALL EXITS("CMISSProblem_CellMLEquationsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_CellMLEquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an user number.
  SUBROUTINE CMISSProblem_CellMLEquationsGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,CellMLEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSCellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_CellMLEquationsGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CELLML_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,CellMLEquations%CELLML_EQUATIONS,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_CellMLEquationsGetNumber0")
    RETURN
999 CALL ERRORS("CMISSProblem_CellMLEquationsGetNumber0",err,error)
    CALL EXITS("CMISSProblem_CellMLEquationsGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_CellMLEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an user number.
  SUBROUTINE CMISSProblem_CellMLEquationsGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,CellMLEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(CMISSCellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
     TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_CellMLEquationsGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CELLML_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,CellMLEquations%CELLML_EQUATIONS,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_CellMLEquationsGetNumber1")
    RETURN
999 CALL ERRORS("CMISSProblem_CellMLEquationsGetNumber1",err,error)
    CALL EXITS("CMISSProblem_CellMLEquationsGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_CellMLEquationsGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an object.
  SUBROUTINE CMISSProblem_CellMLEquationsGetObj0(problem,controlLoopIdentifier,solverIndex,CellMLEquations,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(CMISSCellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_CellMLEquationsGetObj0",err,error,*999)

    CALL PROBLEM_CELLML_EQUATIONS_GET(problem%PROBLEM,controlLoopIdentifier,solverIndex,CellMLEquations%CELLML_EQUATIONS, &
      & err,error,*999)

    CALL EXITS("CMISSProblem_CellMLEquationsGetObj0")
    RETURN
999 CALL ERRORS("CMISSProblem_CellMLEquationsGetObj0",err,error)
    CALL EXITS("CMISSProblem_CellMLEquationsGetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_CellMLEquationsGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations from a problem identified by an object.
  SUBROUTINE CMISSProblem_CellMLEquationsGetObj1(problem,controlLoopIdentifiers,solverIndex,CellMLEquations,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(CMISSCellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the specified CellML equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_CellMLEquationsGetObj1",err,error,*999)

    CALL PROBLEM_CELLML_EQUATIONS_GET(problem%PROBLEM,controlLoopIdentifiers,solverIndex,CellMLEquations%CELLML_EQUATIONS, &
      & err,error,*999)

    CALL EXITS("CMISSProblem_CellMLEquationsGetObj1")
    RETURN
999 CALL ERRORS("CMISSProblem_CellMLEquationsGetObj1",err,error)
    CALL EXITS("CMISSProblem_CellMLEquationsGetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_CellMLEquationsGetObj1

   !
  !================================================================================================================================
  !

  !>Finishes the process of a problem identified by user number.
  SUBROUTINE CMISSProblem_CreateFinishNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_CreateFinishNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CREATE_FINISH(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Create')
#endif

    CALL EXITS("CMISSProblem_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSProblem_CreateFinishNumber",err,error)
    CALL EXITS("CMISSProblem_CreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a problem identified by an object.
  SUBROUTINE CMISSProblem_CreateFinishObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_CreateFinishObj",err,error,*999)

    CALL PROBLEM_CREATE_FINISH(problem%PROBLEM,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Create')
#endif

    CALL EXITS("CMISSProblem_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSProblem_CreateFinishObj",err,error)
    CALL EXITS("CMISSProblem_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of a problem identified by user number.
  SUBROUTINE CMISSProblem_CreateStartNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM

    CALL ENTERS("CMISSProblem_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_CREATE_START(problemUserNumber,PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblem_CreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSProblem_CreateStartNumber",err,error)
    CALL EXITS("CMISSProblem_CreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a problem identified by an object.
  SUBROUTINE CMISSProblem_CreateStartObj(problemUserNumber,problem,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of.
    TYPE(CMISSProblemType), INTENT(INOUT) :: problem !<On return, the created problem.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Create')
#endif

    CALL PROBLEM_CREATE_START(problemUserNumber,problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblem_CreateStartObj")
    RETURN
999 CALL ERRORS("CMISSProblem_CreateStartObj",err,error)
    CALL EXITS("CMISSProblem_CreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a control loop for a problem identified by user number.
  SUBROUTINE CMISSProblem_ControlLoopCreateFinishNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_ControlLoopCreateFinishNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_CREATE_FINISH(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Control Loop Create')
#endif

    CALL EXITS("CMISSProblem_ControlLoopCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSProblem_ControlLoopCreateFinishNumber",err,error)
    CALL EXITS("CMISSProblem_ControlLoopCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_ControlLoopCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a control loop on a problem identified by an object.
  SUBROUTINE CMISSProblem_ControlLoopCreateFinishObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to finish creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_ControlLoopCreateFinishObj",err,error,*999)

    CALL PROBLEM_CONTROL_LOOP_CREATE_FINISH(problem%PROBLEM,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Control Loop Create')
#endif

    CALL EXITS("CMISSProblem_ControlLoopCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSProblem_ControlLoopCreateFinishObj",err,error)
    CALL EXITS("CMISSProblem_ControlLoopCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_ControlLoopCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating a control loop for a problem identified by user number.
  SUBROUTINE CMISSProblem_ControlLoopCreateStartNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_ControlLoopCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Control Loop Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_CREATE_START(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_ControlLoopCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSProblem_ControlLoopCreateStartNumber",err,error)
    CALL EXITS("CMISSProblem_ControlLoopCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_ControlLoopCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a control loop on a problem identified by an object.
  SUBROUTINE CMISSProblem_ControlLoopCreateStartObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to start creating the control loop for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_ControlLoopCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Control Loop Create')
#endif

    CALL PROBLEM_CONTROL_LOOP_CREATE_START(problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblem_ControlLoopCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSProblem_ControlLoopCreateStartObj",err,error)
    CALL EXITS("CMISSProblem_ControlLoopCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_ControlLoopCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys the control loops for a problem identified by user number.
  SUBROUTINE CMISSProblem_ControlLoopDestroyNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the control loops for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_ControlLoopDestroyNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_DESTROY(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_ControlLoopDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSProblem_ControlLoopDestroyNumber",err,error)
    CALL EXITS("CMISSProblem_ControlLoopDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_ControlLoopDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the control loops on a problem identified by an object.
  SUBROUTINE CMISSProblem_ControlLoopDestroyObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to destroy the control loops for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_ControlLoopDestroyObj",err,error,*999)

    CALL PROBLEM_CONTROL_LOOP_DESTROY(problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblem_ControlLoopDestroyObj")
    RETURN
999 CALL ERRORS("CMISSProblem_ControlLoopDestroyObj",err,error)
    CALL EXITS("CMISSProblem_ControlLoopDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_ControlLoopDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an user number.
  SUBROUTINE CMISSProblem_ControlLoopGetNumber0(problemUserNumber,controlLoopIdentifier,controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_ControlLoopGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifier,controlLoop%CONTROL_LOOP,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_ControlLoopGetNumber0")
    RETURN
999 CALL ERRORS("CMISSProblem_ControlLoopGetNumber0",err,error)
    CALL EXITS("CMISSProblem_ControlLoopGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_ControlLoopGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an user number.
  SUBROUTINE CMISSProblem_ControlLoopGetNumber1(problemUserNumber,controlLoopIdentifiers,controlLoop,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
     TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_ControlLoopGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_CONTROL_LOOP_GET(PROBLEM,controlLoopIdentifiers,controlLoop%CONTROL_LOOP,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_ControlLoopGetNumber1")
    RETURN
999 CALL ERRORS("CMISSProblem_ControlLoopGetNumber1",err,error)
    CALL EXITS("CMISSProblem_ControlLoopGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_ControlLoopGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an object.
  SUBROUTINE CMISSProblem_ControlLoopGetObj0(problem,controlLoopIdentifier,controlLoop,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_ControlLoopGetObj0",err,error,*999)

    CALL PROBLEM_CONTROL_LOOP_GET(problem%PROBLEM,controlLoopIdentifier,controlLoop%CONTROL_LOOP,err,error,*999)

    CALL EXITS("CMISSProblem_ControlLoopGetObj0")
    RETURN
999 CALL ERRORS("CMISSProblem_ControlLoopGetObj0",err,error)
    CALL EXITS("CMISSProblem_ControlLoopGetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_ControlLoopGetObj0

  !
  !================================================================================================================================
  !

  !>Returns a control loop from a problem identified by an object.
  SUBROUTINE CMISSProblem_ControlLoopGetObj1(problem,controlLoopIdentifiers,controlLoop,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the control loop for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the control loop for.
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<On return, the specified problem control loop.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_ControlLoopGetObj1",err,error,*999)

    CALL PROBLEM_CONTROL_LOOP_GET(problem%PROBLEM,controlLoopIdentifiers,controlLoop%CONTROL_LOOP,err,error,*999)

    CALL EXITS("CMISSProblem_ControlLoopGetObj1")
    RETURN
999 CALL ERRORS("CMISSProblem_ControlLoopGetObj1",err,error)
    CALL EXITS("CMISSProblem_ControlLoopGetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_ControlLoopGetObj1

  !
  !================================================================================================================================
  !

  !>Destroys a problem identified by an user number.
  SUBROUTINE CMISSProblem_DestroyNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_DestroyNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_DESTROY(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSProblem_DestroyNumber",err,error)
    CALL EXITS("CMISSProblem_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys a problem identified by an object.
  SUBROUTINE CMISSProblem_DestroyObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_DestroyObj",err,error,*999)

    CALL PROBLEM_DESTROY(problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblem_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSProblem_DestroyObj",err,error)
    CALL EXITS("CMISSProblem_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_DestroyObj

  !
  !================================================================================================================================
  !

  !>Solves a problem identified by an user number.
  SUBROUTINE CMISSProblem_SolveNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to solve.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_SolveNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Solve')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVE(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Solve')
#endif

    CALL EXITS("CMISSProblem_SolveNumber")
    RETURN
999 CALL ERRORS("CMISSProblem_SolveNumber",err,error)
    CALL EXITS("CMISSProblem_SolveNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolveNumber

  !
  !================================================================================================================================
  !

  !>Solves a problem identified by an object.
  SUBROUTINE CMISSProblem_SolveObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to solve.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_SolveObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Solve')
#endif

    CALL PROBLEM_SOLVE(problem%PROBLEM,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Solve')
#endif

    CALL EXITS("CMISSProblem_SolveObj")
    RETURN
999 CALL ERRORS("CMISSProblem_SolveObj",err,error)
    CALL EXITS("CMISSProblem_SolveObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolveObj

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an user number.
  SUBROUTINE CMISSProblem_SolverGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,solver,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_SolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,solver%SOLVER,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_SolverGetNumber0")
    RETURN
999 CALL ERRORS("CMISSProblem_SolverGetNumber0",err,error)
    CALL EXITS("CMISSProblem_SolverGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an user number.
  SUBROUTINE CMISSProblem_SolverGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,solver,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
     TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_SolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,solver%SOLVER,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_SolverGetNumber1")
    RETURN
999 CALL ERRORS("CMISSProblem_SolverGetNumber1",err,error)
    CALL EXITS("CMISSProblem_SolverGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an object.
  SUBROUTINE CMISSProblem_SolverGetObj0(problem,controlLoopIdentifier,solverIndex,solver,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_SolverGetObj0",err,error,*999)

    CALL PROBLEM_SOLVER_GET(problem%PROBLEM,controlLoopIdentifier,solverIndex,solver%SOLVER,err,error,*999)

    CALL EXITS("CMISSProblem_SolverGetObj0")
    RETURN
999 CALL ERRORS("CMISSProblem_SolverGetObj0",err,error)
    CALL EXITS("CMISSProblem_SolverGetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolverGetObj0

  !
  !================================================================================================================================
  !

  !>Returns a solver from a problem identified by an object.
  SUBROUTINE CMISSProblem_SolverGetObj1(problem,controlLoopIdentifiers,solverIndex,solver,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: solver !<On return, the specified solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_SolverGetObj1",err,error,*999)

    CALL PROBLEM_SOLVER_GET(problem%PROBLEM,controlLoopIdentifiers,solverIndex,solver%SOLVER,err,error,*999)

    CALL EXITS("CMISSProblem_SolverGetObj1")
    RETURN
999 CALL ERRORS("CMISSProblem_SolverGetObj1",err,error)
    CALL EXITS("CMISSProblem_SolverGetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolverGetObj1

  !
  !================================================================================================================================
  !

  !>Set boundary conditions for solver equations according to the analytic equations for solver equations identified by user numbers.
  SUBROUTINE CMISSSolverEquations_BoundaryConditionsAnalyticNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to calculate the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquations_BoundaryConditionsAnalyticNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_ANALYTIC(SOLVER_EQUATIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolverEquations_BoundaryConditionsAnalyticNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_BoundaryConditionsAnalyticNumber0",err,error)
    CALL EXITS("CMISSSolverEquations_BoundaryConditionsAnalyticNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_BoundaryConditionsAnalyticNumber0

  !
  !================================================================================================================================
  !

  !>Set boundary conditions for solver equations according to the analytic equations for solver equations identified by user numbers.
  SUBROUTINE CMISSSolverEquations_BoundaryConditionsAnalyticNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to calculate the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to calculate the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquations_BoundaryConditionsAnalyticNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL PROBLEM_SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_ANALYTIC(SOLVER_EQUATIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with a user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolverEquations_BoundaryConditionsAnalyticNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_BoundaryConditionsAnalyticNumber1",err,error)
    CALL EXITS("CMISSSolverEquations_BoundaryConditionsAnalyticNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_BoundaryConditionsAnalyticNumber1

  !
  !================================================================================================================================
  !

  !>Set boundary conditions for solver equations according to the analytic equations.
  SUBROUTINE CMISSSolverEquations_BoundaryConditionsAnalyticObj(solverEquations,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL ENTERS("CMISSSolverEquations_BoundaryConditionsAnalyticObj",err,error,*999)

    CALL PROBLEM_SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_ANALYTIC(solverEquations%SOLVER_EQUATIONS,err,error,*999)

    CALL EXITS("CMISSSolverEquations_BoundaryConditionsAnalyticObj")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_BoundaryConditionsAnalyticObj",err,error)
    CALL EXITS("CMISSSolverEquations_BoundaryConditionsAnalyticObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_BoundaryConditionsAnalyticObj

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating solver equations for a problem identified by user number.
  SUBROUTINE CMISSProblem_SolverEquationsCreateFinishNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_SolverEquationsCreateFinishNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_CREATE_FINISH(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Solver Equations Create')
#endif

    CALL EXITS("CMISSProblem_SolverEquationsCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSProblem_SolverEquationsCreateFinishNumber",err,error)
    CALL EXITS("CMISSProblem_SolverEquationsCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolverEquationsCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of solver equations for problem identified by an object.
  SUBROUTINE CMISSProblem_SolverEquationsCreateFinishObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to finish creating the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_SolverEquationsCreateFinishObj",err,error,*999)

    CALL PROBLEM_SOLVER_EQUATIONS_CREATE_FINISH(problem%PROBLEM,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Solver Equations Create')
#endif

    CALL EXITS("CMISSProblem_SolverEquationsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSProblem_SolverEquationsCreateFinishObj",err,error)
    CALL EXITS("CMISSProblem_SolverEquationsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolverEquationsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating solver equations for a problem identified by user number.
  SUBROUTINE CMISSProblem_SolverEquationsCreateStartNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_SolverEquationsCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Solver Equations Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_CREATE_START(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_SolverEquationsCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSProblem_SolverEquationsCreateStartNumber",err,error)
    CALL EXITS("CMISSProblem_SolverEquationsCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolverEquationsCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of solver equations for problem identified by an object.
  SUBROUTINE CMISSProblem_SolverEquationsCreateStartObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to start creating the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_SolverEquationsCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Solver Equations Create')
#endif

    CALL PROBLEM_SOLVER_EQUATIONS_CREATE_START(problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblem_SolverEquationsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSProblem_SolverEquationsCreateStartObj",err,error)
    CALL EXITS("CMISSProblem_SolverEquationsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolverEquationsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys the solver equations for a problem identified by an user number.
  SUBROUTINE CMISSProblem_SolverEquationsDestroyNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_SolverEquationsDestroyNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_DESTROY(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_SolverEquationsDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSProblem_SolverEquationsDestroyNumber",err,error)
    CALL EXITS("CMISSProblem_SolverEquationsDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolverEquationsDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the solver equations for problem identified by an object.
  SUBROUTINE CMISSProblem_SolverEquationsDestroyObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to destroy the solver equations for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_SolverEquationsDestroyObj",err,error,*999)

    CALL PROBLEM_SOLVER_EQUATIONS_DESTROY(problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblem_SolverEquationsDestroyObj")
    RETURN
999 CALL ERRORS("CMISSProblem_SolverEquationsDestroyObj",err,error)
    CALL EXITS("CMISSProblem_SolverEquationsDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolverEquationsDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an user number.
  SUBROUTINE CMISSProblem_SolverEquationsGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,solverEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_SolverEquationsGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,solverEquations%SOLVER_EQUATIONS,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_SolverEquationsGetNumber0")
    RETURN
999 CALL ERRORS("CMISSProblem_SolverEquationsGetNumber0",err,error)
    CALL EXITS("CMISSProblem_SolverEquationsGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolverEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an user number.
  SUBROUTINE CMISSProblem_SolverEquationsGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,solverEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
     TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_SolverEquationsGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,solverEquations%SOLVER_EQUATIONS,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_SolverEquationsGetNumber1")
    RETURN
999 CALL ERRORS("CMISSProblem_SolverEquationsGetNumber1",err,error)
    CALL EXITS("CMISSProblem_SolverEquationsGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolverEquationsGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an object.
  SUBROUTINE CMISSProblem_SolverEquationsGetObj0(problem,controlLoopIdentifier,solverIndex,solverEquations,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_SolverEquationsGetObj0",err,error,*999)

    CALL PROBLEM_SOLVER_EQUATIONS_GET(problem%PROBLEM,controlLoopIdentifier,solverIndex,solverEquations%SOLVER_EQUATIONS, &
      & err,error,*999)

    CALL EXITS("CMISSProblem_SolverEquationsGetObj0")
    RETURN
999 CALL ERRORS("CMISSProblem_SolverEquationsGetObj0",err,error)
    CALL EXITS("CMISSProblem_SolverEquationsGetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolverEquationsGetObj0

  !
  !================================================================================================================================
  !

  !>Returns the solver equations from a problem identified by an object.
  SUBROUTINE CMISSProblem_SolverEquationsGetObj1(problem,controlLoopIdentifiers,solverIndex,solverEquations,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_SolverEquationsGetObj1",err,error,*999)

    CALL PROBLEM_SOLVER_EQUATIONS_GET(problem%PROBLEM,controlLoopIdentifiers,solverIndex,solverEquations%SOLVER_EQUATIONS, &
      & err,error,*999)

    CALL EXITS("CMISSProblem_SolverEquationsGetObj1")
    RETURN
999 CALL ERRORS("CMISSProblem_SolverEquationsGetObj1",err,error)
    CALL EXITS("CMISSProblem_SolverEquationsGetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolverEquationsGetObj1

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating solvers for a problem identified by user number.
  SUBROUTINE CMISSProblem_SolversCreateFinishNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to finish the creation of solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_SolversCreateFinishNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVERS_CREATE_FINISH(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Problem Solvers Create')
#endif

    CALL EXITS("CMISSProblem_SolversCreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSProblem_SolversCreateFinishNumber",err,error)
    CALL EXITS("CMISSProblem_SolversCreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolversCreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of solvers for problem identified by an object.
  SUBROUTINE CMISSProblem_SolversCreateFinishObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to finish creating the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_SolversCreateFinishObj",err,error,*999)

    CALL PROBLEM_SOLVERS_CREATE_FINISH(problem%PROBLEM,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('problem Solvers Create')
#endif

    CALL EXITS("CMISSProblem_SolversCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSProblem_SolversCreateFinishObj",err,error)
    CALL EXITS("CMISSProblem_SolversCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolversCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process of creating solvers for a problem identified by user number.
  SUBROUTINE CMISSProblem_SolversCreateStartNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to start the creation of solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_SolversCreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Problem Solvers Create')
#endif

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVERS_CREATE_START(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_SolversCreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSProblem_SolversCreateStartNumber",err,error)
    CALL EXITS("CMISSProblem_SolversCreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolversCreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of solvers for problem identified by an object.
  SUBROUTINE CMISSProblem_SolversCreateStartObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to start creating the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_SolversCreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('problem Solvers Create')
#endif

    CALL PROBLEM_SOLVERS_CREATE_START(problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblem_SolversCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSProblem_SolversCreateStartObj",err,error)
    CALL EXITS("CMISSProblem_SolversCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolversCreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys the solvers for a problem identified by an user number.
  SUBROUTINE CMISSProblem_SolversDestroyNumber(problemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to destroy the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_SolversDestroyNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVERS_DESTROY(PROBLEM,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_SolversDestroyNumber")
    RETURN
999 CALL ERRORS("CMISSProblem_SolversDestroyNumber",err,error)
    CALL EXITS("CMISSProblem_SolversDestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolversDestroyNumber

  !
  !================================================================================================================================
  !

  !>Destroys the solvers for problem identified by an object.
  SUBROUTINE CMISSProblem_SolversDestroyObj(problem,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to destroy the solvers for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_SolversDestroyObj",err,error,*999)

    CALL PROBLEM_SOLVERS_DESTROY(problem%PROBLEM,err,error,*999)

    CALL EXITS("CMISSProblem_SolversDestroyObj")
    RETURN
999 CALL ERRORS("CMISSProblem_SolversDestroyObj",err,error)
    CALL EXITS("CMISSProblem_SolversDestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SolversDestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the specification i.e., problem class, type and subtype for a problem identified by an user number.
  SUBROUTINE CMISSProblem_SpecificationGetNumber(problemUserNumber,problemClass,problemType,problemSubtype,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to get the specification for.
    INTEGER(INTG), INTENT(OUT) :: problemClass !<On return, the problem class. \see OPENCMISS_ProblemClasses
    INTEGER(INTG), INTENT(OUT) :: problemType !<On return, the problem type. \see OPENCMISS_ProblemTypes
    INTEGER(INTG), INTENT(OUT) :: problemSubtype !<On return, the problem subtype. \see OPENCMISS_ProblemSubTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_SpecificationGetNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SPECIFICATION_GET(PROBLEM,problemClass,problemType,problemSubtype,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_SpecificationGetNumber")
    RETURN
999 CALL ERRORS("CMISSProblem_SpecificationGetNumber",err,error)
    CALL EXITS("CMISSProblem_SpecificationGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SpecificationGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the specification i.e., problem class, type and subtype for a problem identified by an object.
  SUBROUTINE CMISSProblem_SpecificationGetObj(problem,problemClass,problemType,problemSubtype,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the specification for.
    INTEGER(INTG), INTENT(OUT) :: problemClass !<On return, the problem class. \see OPENCMISS_ProblemClasses
    INTEGER(INTG), INTENT(OUT) :: problemType !<On return, the problem type. \see OPENCMISS_ProblemTypes
    INTEGER(INTG), INTENT(OUT) :: problemSubtype !<On return, the problem subtype. \see OPENCMISS_ProblemSubTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_SpecificationGetObj",err,error,*999)

    CALL PROBLEM_SPECIFICATION_GET(problem%PROBLEM,problemClass,problemType,problemSubtype,err,error,*999)

    CALL EXITS("CMISSProblem_SpecificationGetObj")
    RETURN
999 CALL ERRORS("CMISSProblem_SpecificationGetObj",err,error)
    CALL EXITS("CMISSProblem_SpecificationGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SpecificationGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the specification i.e., problem class, type and subtype for a problem identified by an user number.
  SUBROUTINE CMISSProblem_SpecificationSetNumber(problemUserNumber,problemClass,problemType,problemSubtype,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the specification for.
    INTEGER(INTG), INTENT(IN) :: problemClass !<The problem class to set. \see OPENCMISS_ProblemClasses
    INTEGER(INTG), INTENT(IN) :: problemType !<The problem type to set. \see OPENCMISS_ProblemTypes
    INTEGER(INTG), INTENT(IN) :: problemSubtype !<The problem subtype to set. \see OPENCMISS_ProblemSubTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSProblem_SpecificationSetNumber",err,error,*999)

    NULLIFY(PROBLEM)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SPECIFICATION_SET(PROBLEM,problemClass,problemType,problemSubtype,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSProblem_SpecificationSetNumber")
    RETURN
999 CALL ERRORS("CMISSProblem_SpecificationSetNumber",err,error)
    CALL EXITS("CMISSProblem_SpecificationSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SpecificationSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the specification i.e., problem class, type and subtype for a problem identified by an object.
  SUBROUTINE CMISSProblem_SpecificationSetObj(problem,problemClass,problemType,problemSubtype,err)

    !Argument variables
    TYPE(CMISSProblemType), INTENT(IN) :: problem !<The problem to get the specification for.
    INTEGER(INTG), INTENT(IN) :: problemClass !<The problem class to set. \see OPENCMISS_ProblemClasses
    INTEGER(INTG), INTENT(IN) :: problemType !<The problem type to set. \see OPENCMISS_ProblemTypes
    INTEGER(INTG), INTENT(IN) :: problemSubtype !<The problem subtype to set. \see OPENCMISS_ProblemSubTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSProblem_SpecificationSetObj",err,error,*999)

    CALL PROBLEM_SPECIFICATION_SET(problem%PROBLEM,problemClass,problemType,problemSubtype,err,error,*999)

    CALL EXITS("CMISSProblem_SpecificationSetObj")
    RETURN
999 CALL ERRORS("CMISSProblem_SpecificationSetObj",err,error)
    CALL EXITS("CMISSProblem_SpecificationSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSProblem_SpecificationSetObj

!!==================================================================================================================================
!!
!! REGION_ROUTINES
!!
!!==================================================================================================================================

  !>Returns the coordinate system for a region identified by an user number.
  SUBROUTINE CMISSRegion_CoordinateSystemGetNumber(regionUserNumber,coordinateSystemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to get the coordinate system for.
    INTEGER(INTG), INTENT(OUT) :: coordinateSystemUserNumber !<On return, the coordinate system user number.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegion_CoordinateSystemGetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(COORDINATE_SYSTEM)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_COORDINATE_SYSTEM_GET(REGION,COORDINATE_SYSTEM,err,error,*999)
      IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
        coordinateSystemUserNumber = COORDINATE_SYSTEM%USER_NUMBER
      ELSE
        LOCAL_ERROR="The coordinate system is not associated for region number "// &
          & TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSRegion_CoordinateSystemGetNumber")
    RETURN
999 CALL ERRORS("CMISSRegion_CoordinateSystemGetNumber",err,error)
    CALL EXITS("CMISSRegion_CoordinateSystemGetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_CoordinateSystemGetNumber

  !
  !================================================================================================================================
  !

  !>Returns the coordinate system for a region identified by an object.
  SUBROUTINE CMISSRegion_CoordinateSystemGetObj(region,coordinateSystem,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to get the coordinate system for.
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !<On return, the regions coordinate system.
   INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegion_CoordinateSystemGetObj",err,error,*999)

    CALL REGION_COORDINATE_SYSTEM_GET(region%REGION,coordinateSystem%COORDINATE_SYSTEM,err,error,*999)

    CALL EXITS("CMISSRegion_CoordinateSystemGetObj")
    RETURN
999 CALL ERRORS("CMISSRegion_CoordinateSystemGetObj",err,error)
    CALL EXITS("CMISSRegion_CoordinateSystemGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_CoordinateSystemGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the coordinate system for a region identified by an user number.
  SUBROUTINE CMISSRegion_CoordinateSystemSetNumber(regionUserNumber,coordinateSystemUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to set the coordinate system for.
    INTEGER(INTG), INTENT(IN) :: coordinateSystemUserNumber !<The user number of the coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegion_CoordinateSystemSetNumber",err,error,*999)

    NULLIFY(REGION)
    NULLIFY(COORDINATE_SYSTEM)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL COORDINATE_SYSTEM_USER_NUMBER_FIND(coordinateSystemUserNumber,COORDINATE_SYSTEM,err,error,*999)
      IF(ASSOCIATED(COORDINATE_SYSTEM)) THEN
        CALL REGION_COORDINATE_SYSTEM_SET(REGION,COORDINATE_SYSTEM,err,error,*999)
      ELSE
        LOCAL_ERROR="A coordinate system with an user number of "// &
          & TRIM(NUMBER_TO_VSTRING(coordinateSystemUserNumber,"*",err,error))//"."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSRegion_CoordinateSystemSetNumber")
    RETURN
999 CALL ERRORS("CMISSRegion_CoordinateSystemSetNumber",err,error)
    CALL EXITS("CMISSRegion_CoordinateSystemSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_CoordinateSystemSetNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the coordinate system for a region identified by an object.
  SUBROUTINE CMISSRegion_CoordinateSystemSetObj(region,coordinateSystem,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to set the coordinate system for.
    TYPE(CMISSCoordinateSystemType), INTENT(IN) :: coordinateSystem !<The coordinate system to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegion_CoordinateSystemSetObj",err,error,*999)

    CALL REGION_COORDINATE_SYSTEM_SET(region%REGION,coordinateSystem%COORDINATE_SYSTEM,err,error,*999)

    CALL EXITS("CMISSRegion_CoordinateSystemSetObj")
    RETURN
999 CALL ERRORS("CMISSRegion_CoordinateSystemSetObj",err,error)
    CALL EXITS("CMISSRegion_CoordinateSystemSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_CoordinateSystemSetObj

  !
  !================================================================================================================================
  !

  !>Finishes the process of creating a region identified by user number.
  SUBROUTINE CMISSRegion_CreateFinishNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to finish the creation of.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegion_CreateFinishNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_CREATE_FINISH(REGION,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('Region Create')
#endif

    CALL EXITS("CMISSRegion_CreateFinishNumber")
    RETURN
999 CALL ERRORS("CMISSRegion_CreateFinishNumber",err,error)
    CALL EXITS("CMISSRegion_CreateFinishNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_CreateFinishNumber

  !
  !================================================================================================================================
  !

  !>Finishes the creation of a region identified by an object.
  SUBROUTINE CMISSRegion_CreateFinishObj(region,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to finish creating.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegion_CreateFinishObj",err,error,*999)

    CALL REGION_CREATE_FINISH(region%REGION,err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_STOP('region Create')
#endif

    CALL EXITS("CMISSRegion_CreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSRegion_CreateFinishObj",err,error)
    CALL EXITS("CMISSRegion_CreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_CreateFinishObj

  !
  !================================================================================================================================
  !

  !>Starts the process creating a region identified by user number.
  SUBROUTINE CMISSRegion_CreateStartNumber(regionUserNumber,parentRegionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to start the creation of.
    INTEGER(INTG), INTENT(IN) :: parentRegionUserNumber !<The user number of the parent region to start the creation of the region in.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: PARENT_REGION,REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegion_CreateStartNumber",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('Region Create')
#endif

    NULLIFY(PARENT_REGION)
    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(parentRegionUserNumber,PARENT_REGION,err,error,*999)
    IF(ASSOCIATED(PARENT_REGION)) THEN
      CALL REGION_CREATE_START(regionUserNumber,PARENT_REGION,REGION,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(parentRegionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSRegion_CreateStartNumber")
    RETURN
999 CALL ERRORS("CMISSRegion_CreateStartNumber",err,error)
    CALL EXITS("CMISSRegion_CreateStartNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_CreateStartNumber

  !
  !================================================================================================================================
  !

  !>Starts the creation of a region identified by an object.
  SUBROUTINE CMISSRegion_CreateStartObj(regionUserNumber,parentRegion,region,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to start the creation of.
    TYPE(CMISSRegionType), INTENT(IN) :: parentRegion !<The parent region to  to start the creation of the region in.
    TYPE(CMISSRegionType), INTENT(INOUT) :: region !<On return, the created region.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegion_CreateStartObj",err,error,*999)

#ifdef TAUPROF
    CALL TAU_STATIC_PHASE_START('region Create')
#endif

    CALL REGION_CREATE_START(regionUserNumber,parentRegion%REGION,region%REGION,err,error,*999)

    CALL EXITS("CMISSRegion_CreateStartObj")
    RETURN
999 CALL ERRORS("CMISSRegion_CreateStartObj",err,error)
    CALL EXITS("CMISSRegion_CreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_CreateStartObj

  !
  !================================================================================================================================
  !

  !>Destroys a region identified by an user number.
  SUBROUTINE CMISSRegion_DestroyNumber(regionUserNumber,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to destroy.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegion_DestroyNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_DESTROY(REGION,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSRegion_DestroyNumber")
    RETURN
999 CALL ERRORS("CMISSRegion_DestroyNumber",err,error)
    CALL EXITS("CMISSRegion_DestroyNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_DestroyNumber

  !
  !================================================================================================================================
  !

  !>Returns the data points for a region identified by an object.
  SUBROUTINE CMISSRegion_DataPointsGetObj(region,dataPoints,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to get the data points for.
    TYPE(CMISSDataPointsType), INTENT(INOUT) :: dataPoints !<On return, the regions data points.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegion_DataPointsGetObj",err,error,*999)

    CALL REGION_DATA_POINTS_GET(region%REGION,dataPoints%DATA_POINTS,err,error,*999)

    CALL EXITS("CMISSRegion_DataPointsGetObj")
    RETURN
999 CALL ERRORS("CMISSRegion_DataPointsGetObj",err,error)
    CALL EXITS("CMISSRegion_DataPointsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_DataPointsGetObj

  !
  !================================================================================================================================
  !

  !>Destroys a region identified by an object.
  SUBROUTINE CMISSRegion_DestroyObj(region,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(INOUT) :: region !<The region to destroy
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegion_DestroyObj",err,error,*999)

    CALL REGION_DESTROY(region%REGION,err,error,*999)

    CALL EXITS("CMISSRegion_DestroyObj")
    RETURN
999 CALL ERRORS("CMISSRegion_DestroyObj",err,error)
    CALL EXITS("CMISSRegion_DestroyObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_DestroyObj

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a region identified by an user number.
  SUBROUTINE CMISSRegion_LabelGetCNumber(regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegion_LabelGetCNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_LABEL_GET(REGION,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSRegion_LabelGetCNumber")
    RETURN
999 CALL ERRORS("CMISSRegion_LabelGetCNumber",err,error)
    CALL EXITS("CMISSRegion_LabelGetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_LabelGetCNumber

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a region identified by an object.
  SUBROUTINE CMISSRegion_LabelGetCObj(region,label,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegion_LabelGetCObj",err,error,*999)

    CALL REGION_LABEL_GET(region%REGION,label,err,error,*999)

    CALL EXITS("CMISSRegion_LabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSRegion_LabelGetCObj",err,error)
    CALL EXITS("CMISSRegion_LabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a region identified by an user number.
  SUBROUTINE CMISSRegion_LabelGetVSNumber(regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegion_LabelGetVSNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_LABEL_GET(REGION,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSRegion_LabelGetVSNumber")
    RETURN
999 CALL ERRORS("CMISSRegion_LabelGetVSNumber",err,error)
    CALL EXITS("CMISSRegion_LabelGetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_LabelGetVSNumber

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a region identified by an object.
  SUBROUTINE CMISSRegion_LabelGetVSObj(region,label,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the region label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegion_LabelGetVSObj",err,error,*999)

    CALL REGION_LABEL_GET(region%REGION,label,err,error,*999)

    CALL EXITS("CMISSRegion_LabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSRegion_LabelGetVSObj",err,error)
    CALL EXITS("CMISSRegion_LabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a region identified by an user number.
  SUBROUTINE CMISSRegion_LabelSetCNumber(regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegion_LabelSetCNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_LABEL_SET(REGION,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSRegion_LabelSetCNumber")
    RETURN
999 CALL ERRORS("CMISSRegion_LabelSetCNumber",err,error)
    CALL EXITS("CMISSRegion_LabelSetCNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_LabelSetCNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a region identified by an object.
  SUBROUTINE CMISSRegion_LabelSetCObj(region,label,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegion_LabelSetCObj",err,error,*999)

    CALL REGION_LABEL_SET(region%REGION,label,err,error,*999)

    CALL EXITS("CMISSRegion_LabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSRegion_LabelSetCObj",err,error)
    CALL EXITS("CMISSRegion_LabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a region identified by an user number.
  SUBROUTINE CMISSRegion_LabelSetVSNumber(regionUserNumber,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSRegion_LabelSetVSNumber",err,error,*999)

    NULLIFY(REGION)
    CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
    IF(ASSOCIATED(REGION)) THEN
      CALL REGION_LABEL_SET(REGION,CHAR(label),err,error,*999)
    ELSE
      LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSRegionLabelStVSNumber")
    RETURN
999 CALL ERRORS("CMISSRegion_LabelSetVSNumber",err,error)
    CALL EXITS("CMISSRegion_LabelSetVSNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_LabelSetVSNumber

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for a region identified by an object.
  SUBROUTINE CMISSRegion_LabelSetVSObj(region,label,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegion_LabelSetVSObj",err,error,*999)

    CALL REGION_LABEL_SET(region%REGION,CHAR(label),err,error,*999)

    CALL EXITS("CMISSRegion_LabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSRegion_LabelSetVSObj",err,error)
    CALL EXITS("CMISSRegion_LabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the nodes for a region identified by an object.
  SUBROUTINE CMISSRegion_NodesGetObj(region,nodes,err)

    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to get the nodes for.
    TYPE(CMISSNodesType), INTENT(INOUT) :: nodes !<On return, the regions nodes.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSRegion_NodesGetObj",err,error,*999)

    CALL REGION_NODES_GET(region%REGION,nodes%NODES,err,error,*999)

    CALL EXITS("CMISSRegion_NodesGetObj")
    RETURN
999 CALL ERRORS("CMISSRegion_NodesGetObj",err,error)
    CALL EXITS("CMISSRegion_NodesGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSRegion_NodesGetObj

!!==================================================================================================================================
!!
!! SOLVER_ROUTINES
!!
!!==================================================================================================================================

  !
  !================================================================================================================================
  !

  !>Adds a CellML environment to CellML equations identified by an user number.
  SUBROUTINE CMISSCellMLEquations_CellMLAddNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & regionUserNumber,CellMLUserNumber,CellMLIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to add.
    INTEGER(INTG), INTENT(OUT) :: CellMLIndex !<On return, the index of the added CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLEquations_CellMLAddNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(CELLML_EQUATIONS)
    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_CELLML_EQUATIONS_GET(SOLVER,CELLML_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
      IF(ASSOCIATED(REGION)) THEN
        CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
        IF(ASSOCIATED(CELLML)) THEN
          CALL CELLML_EQUATIONS_CELLML_ADD(CELLML_EQUATIONS,CELLML,CellMLIndex,err,error,*999)
        ELSE
          LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellMLEquations_CellMLAddNumber0")
    RETURN
999 CALL ERRORS("CMISSCellMLEquations_CellMLAddNumber0",err,error)
    CALL EXITS("CMISSCellMLEquations_CellMLAddNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLEquations_CellMLAddNumber0

  !
  !================================================================================================================================
  !

  !>Adds a CellML environment to CellML equations identified by an user number.
  SUBROUTINE CMISSCellMLEquations_CellMLAddNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,CellMLUserNumber,CellMLIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the CellML environment for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region containing the CellML environment.
    INTEGER(INTG), INTENT(IN) :: CellMLUserNumber !<The user number of the CellML environment to add.
    INTEGER(INTG), INTENT(OUT) :: CellMLIndex !<On return, the index of the added CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(CELLML_TYPE), POINTER :: CELLML
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: CELLML_EQUATIONS
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSCellMLEquations_CellMLAddNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(CELLML_EQUATIONS)
    NULLIFY(REGION)
    NULLIFY(CELLML)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_CELLML_EQUATIONS_GET(SOLVER,CELLML_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
      IF(ASSOCIATED(REGION)) THEN
        CALL CELLML_USER_NUMBER_FIND(CellMLUserNumber,REGION,CELLML,err,error,*999)
        IF(ASSOCIATED(CELLML)) THEN
          CALL CELLML_EQUATIONS_CELLML_ADD(CELLML_EQUATIONS,CELLML,CellMLIndex,err,error,*999)
        ELSE
          LOCAL_ERROR="A CellML environment with an user number of "//TRIM(NUMBER_TO_VSTRING(CellMLUserNumber,"*",err,error))// &
            & " does not exist in region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSCellMLEquations_CellMLAddNumber1")
    RETURN
999 CALL ERRORS("CMISSCellMLEquations_CellMLAddNumber1",err,error)
    CALL EXITS("CMISSCellmlEquationsCellMLAddNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLEquations_CellMLAddNumber1

  !
  !================================================================================================================================
  !

  !>Adds a CellML environment to CellML equations identified by an object.
  SUBROUTINE CMISSCellMLEquations_CellMLAddObj(CellMLEquations,CellML,CellMLIndex,err)

    !Argument variables
    TYPE(CMISSCellMLEquationsType), INTENT(IN) :: CellMLEquations !<The CellML equations to add the CellML environment for.
    TYPE(CMISSCellMLType), INTENT(IN) :: CellML !<The CellML environment to add.
    INTEGER(INTG), INTENT(OUT) :: CellMLIndex !<On return, the index of the added CellML environment.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSCellMLEquations_CellMLAddObj",err,error,*999)

    CALL CELLML_EQUATIONS_CELLML_ADD(CellMLEquations%CELLML_EQUATIONS,CellML%CELLML,CellMLIndex,err,error,*999)

    CALL EXITS("CMISSCellMLEquations_CellMLAddObj")
    RETURN
999 CALL ERRORS("CMISSCellMLEquations_CellMLAddObj",err,error)
    CALL EXITS("CMISSCellMLEquations_CellMLAddObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSCellMLEquations_CellMLAddObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations for a solver identified by an user number.
  SUBROUTINE CMISSSolver_CellMLEquationsGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,CellMLEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(CMISSCellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the CellML equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_CellMLEquationsGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_CELLML_EQUATIONS_GET(SOLVER,CellMLEquations%CELLML_EQUATIONS,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_CellMLEquationsGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_CellMLEquationsGetNumber0",err,error)
    CALL EXITS("CMISSSolver_CellMLEquationsGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_CellMLEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML equations for a solver identified by an user number.
  SUBROUTINE CMISSSolver_CellMLEquationsGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,CellMLEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the CellML equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the CellML equations for.
    TYPE(CMISSCellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the CelllML equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_CellMLEquationsGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_CELLML_EQUATIONS_GET(SOLVER,CellMLEquations%CELLML_EQUATIONS,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_CellMLEquationsGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_CellMLEquationsGetNumber1",err,error)
    CALL EXITS("CMISSSolver_CellMLEquationsGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_CellMLEquationsGetNumber1

  !================================================================================================================================
  !

  !>Returns the CellML equations for a solver identified by an object.
  SUBROUTINE CMISSSolver_CellMLEquationsGetObj(solver,CellMLEquations,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the CellML equations for.
    TYPE(CMISSCellMLEquationsType), INTENT(INOUT) :: CellMLEquations !<On return, the CellML equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_CellMLEquationsGetObj",err,error,*999)

    CALL SOLVER_CELLML_EQUATIONS_GET(solver%SOLVER,CellMLEquations%CELLML_EQUATIONS,err,error,*999)

    CALL EXITS("CMISSSolver_CellMLEquationsGetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_CellMLEquationsGetObj",err,error)
    CALL EXITS("CMISSSolver_CellMLEquationsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_CellMLEquationsGetObj

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolver_DAEEulerSolverTypeGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,DAEEulerSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(OUT) :: DAEEulerSolverType !<On return, the DAE Euler solver type. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DAEEulerSolverTypeGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_EULER_SOLVER_TYPE_GET(SOLVER,DAEEulerSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DAEEulerSolverTypeGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_DAEEulerSolverTypeGetNumber0",err,error)
    CALL EXITS("CMISSSolver_DAEEulerSolverTypeGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAEEulerSolverTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolver_DAEEulerSolverTypeGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,DAEEulerSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE Euler solver type for
    INTEGER(INTG), INTENT(OUT) :: DAEEulerSolverType !<On return, the DAE Euler solver type. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DAEEulerSolverTypeGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_EULER_SOLVER_TYPE_GET(SOLVER,DAEEulerSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DAEEulerSolverTypeGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_DAEEulerSolverTypeGetNumber1",err,error)
    CALL EXITS("CMISSSolver_DAEEulerSolverTypeGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAEEulerSolverTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an Euler differential-algebraic equation solver identified by an object.
  SUBROUTINE CMISSSolver_DAEEulerSolverTypeGetObj(solver,DAEEulerSolverType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the DAE Euler solver type for.
    INTEGER(INTG), INTENT(OUT) :: DAEEulerSolverType !<On return, the DAE Euler solver type. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_DAEEulerSolverTypeGetObj",err,error,*999)

    CALL SOLVER_DAE_EULER_SOLVER_TYPE_GET(solver%SOLVER,DAEEulerSolverType,err,error,*999)

    CALL EXITS("CMISSSolver_DAEEulerSolverTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_DAEEulerSolverTypeGetObj",err,error)
    CALL EXITS("CMISSSolver_DAEEulerSolverTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAEEulerSolverTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolver_DAEEulerSolverTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,DAEEulerSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: DAEEulerSolverType !<The DAE Euler solver type to set. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DAEEulerSolverTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_EULER_SOLVER_TYPE_SET(SOLVER,DAEEulerSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DAEEulerSolverTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_DAEEulerSolverTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_DAEEulerSolverTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAEEulerSolverTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolver_DAEEulerSolverTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,DAEEulerSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE Euler solver type for
    INTEGER(INTG), INTENT(IN) :: DAEEulerSolverType !<The DAE Euler solver type to set. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DAEEulerSolverTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_EULER_SOLVER_TYPE_SET(SOLVER,DAEEulerSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DAEEulerSolverTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_DAEEulerSolverTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_DAEEulerSolverTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAEEulerSolverTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an Euler differential-algebraic equation solver identified by an object.
  SUBROUTINE CMISSSolver_DAEEulerSolverTypeSetObj(solver,DAEEulerSolverType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the DAE Euler solver type for.
    INTEGER(INTG), INTENT(IN) :: DAEEulerSolverType !<The DAE Euler solver type to set. \see OPENCMISS_EulerDAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_DAEEulerSolverTypeSetObj",err,error,*999)

    CALL SOLVER_DAE_EULER_SOLVER_TYPE_SET(solver%SOLVER,DAEEulerSolverType,err,error,*999)

    CALL EXITS("CMISSSolver_DAEEulerSolverTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_DAEEulerSolverTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_DAEEulerSolverTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAEEulerSolverTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolver_DAESolverTypeGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,DAESolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE solver type for
    INTEGER(INTG), INTENT(OUT) :: DAESolverType !<On return, the DAE solver type. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DAESolverTypeGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_SOLVER_TYPE_GET(SOLVER,DAESolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DAESolverTypeGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_DAESolverTypeGetNumber0",err,error)
    CALL EXITS("CMISSSolver_DAESolverTypeGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAESolverTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolver_DAESolverTypeGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,DAESolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the DAE solver type for
    INTEGER(INTG), INTENT(OUT) :: DAESolverType !<On return, the DAE solver type. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DAESolverTypeGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_SOLVER_TYPE_GET(SOLVER,DAESolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DAESolverTypeGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_DAESolverTypeGetNumber1",err,error)
    CALL EXITS("CMISSSolver_DAESolverTypeGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAESolverTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the solve type for an differential-algebraic equation solver identified by an object.
  SUBROUTINE CMISSSolver_DAESolverTypeGetObj(solver,DAESolverType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the DAE solver type for.
    INTEGER(INTG), INTENT(OUT) :: DAESolverType !<On return, the DAE solver type. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_DAESolverTypeGetObj",err,error,*999)

    CALL SOLVER_DAE_SOLVER_TYPE_GET(solver%SOLVER,DAESolverType,err,error,*999)

    CALL EXITS("CMISSSolver_DAESolverTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_DAESolverTypeGetObj",err,error)
    CALL EXITS("CMISSSolver_DAESolverTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAESolverTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolver_DAESolverTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,DAESolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: DAESolverType !<The DAE solver type to set. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DAESolverTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_SOLVER_TYPE_SET(SOLVER,DAESolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DAESolverTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_DAESolverTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_DAESolverTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAESolverTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolver_DAESolverTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,DAESolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE solver type for
    INTEGER(INTG), INTENT(IN) :: DAESolverType !<The DAE solver type to set. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DAESolverTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_SOLVER_TYPE_SET(SOLVER,DAESolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DAESolverTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_DAESolverTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_DAESolverTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAESolverTypeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the solve type for an differential-algebraic equation solver identified by an object.
  SUBROUTINE CMISSSolver_DAESolverTypeSetObj(solver,DAESolverType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the DAE solver type for.
    INTEGER(INTG), INTENT(IN) :: DAESolverType !<The DAE solver type to set. \see OPENCMISS_DAESolverTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_DAESolverTypeSetObj",err,error,*999)

    CALL SOLVER_DAE_SOLVER_TYPE_SET(solver%SOLVER,DAESolverType,err,error,*999)

    CALL EXITS("CMISSSolver_DAESolverTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_DAESolverTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_DAESolverTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAESolverTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolver_DAETimesSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,startTime,endTime,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: endTime !<The end time for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DAETimesSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_TIMES_SET(SOLVER,startTime,endTime,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DAETimesSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_DAETimesSetNumber0",err,error)
    CALL EXITS("CMISSSolver_DAETimesSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAETimesSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolver_DAETimesSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,startTime,endTime,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: endTime !<The end time for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DAETimesSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_TIMES_SET(SOLVER,startTime,endTime,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DAETimesSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_DAETimesSetNumber1",err,error)
    CALL EXITS("CMISSSolver_DAETimesSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAETimesSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for an differential-algebraic equation solver identified by an object.
  SUBROUTINE CMISSSolver_DAETimesSetObj(solver,startTime,endTime,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the DAE times for.
    REAL(DP), INTENT(IN) :: startTime !<The start time for the differential-algebraic solver.
    REAL(DP), INTENT(IN) :: endTime !<The end time for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_DAETimesSetObj",err,error,*999)

    CALL SOLVER_DAE_TIMES_SET(solver%SOLVER,startTime,endTime,err,error,*999)

    CALL EXITS("CMISSSolver_DAETimesSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_DAETimesSetObj",err,error)
    CALL EXITS("CMISSSolver_DAETimesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAETimesSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the (initial) time step for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolver_DAETimeStepSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,timeStep,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: timeStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DAETimeStepSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_TIME_STEP_SET(SOLVER,timeStep,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DAETimeStepSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_DAETimeStepSetNumber0",err,error)
    CALL EXITS("CMISSSolver_DAETimeStepSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAETimeStepSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the (initial) time step for an differential-algebraic equation solver identified by an user number.
  SUBROUTINE CMISSSolver_DAETimeStepSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,timeStep,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the DAE times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the DAE times for.
    REAL(DP), INTENT(IN) :: timeStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DAETimeStepSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DAE_TIME_STEP_SET(SOLVER,timeStep,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DAETimeStepSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_DAETimeStepSetNumber1",err,error)
    CALL EXITS("CMISSSolver_DAETimeStepSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAETimeStepSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the (initial) time step for an differential-algebraic equation solver identified by an object.
  SUBROUTINE CMISSSolver_DAETimeStepSetObj(solver,timeStep,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the DAE times for.
    REAL(DP), INTENT(IN) :: timeStep !<The (initial) time step for the differential-algebraic solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_DAETimeStepSetObj",err,error,*999)

    CALL SOLVER_DAE_TIME_STEP_SET(solver%SOLVER,timeStep,err,error,*999)

    CALL EXITS("CMISSSolver_DAETimeStepSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_DAETimeStepSetObj",err,error)
    CALL EXITS("CMISSSolver_DAETimeStepSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DAETimeStepSetObj

  !
  !================================================================================================================================
  !

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicDegreeGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,degree,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic degree for.
    INTEGER(INTG), INTENT(OUT) :: degree !<On return, the dynamic degree. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DynamicDegreeGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_DEGREE_GET(SOLVER,degree,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicDegreeGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicDegreeGetNumber0",err,error)
    CALL EXITS("CMISSSolver_DynamicDegreeGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicDegreeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicDegreeGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,degree,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic degree for
    INTEGER(INTG), INTENT(OUT) :: degree !<On return, the dynamic degree. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DynamicDegreeGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_DEGREE_GET(SOLVER,degree,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicDegreeGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicDegreeGetNumber1",err,error)
    CALL EXITS("CMISSSolver_DynamicDegreeGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicDegreeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the degree of the polynomial used to interpolate time for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolver_DynamicDegreeGetObj(solver,degree,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the dynamic degree for.
    INTEGER(INTG), INTENT(OUT) :: degree !<On return, the dynamic degree. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_DynamicDegreeGetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_DEGREE_GET(solver%SOLVER,degree,err,error,*999)

    CALL EXITS("CMISSSolver_DynamicDegreeGetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicDegreeGetObj",err,error)
    CALL EXITS("CMISSSolver_DynamicDegreeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicDegreeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicDegreeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,degree,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: degree !<The dynamic degree to set. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DynamicDegreeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,degree,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicDegreeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicDegreeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_DynamicDegreeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicDegreeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicDegreeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,degree,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the dynamic degree for
    INTEGER(INTG), INTENT(IN) :: degree !<The dynamic degree to set. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DynamicDegreeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_DEGREE_SET(SOLVER,degree,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicDegreeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicDegreeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_DynamicDegreeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicDegreeSetNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the degree of the polynomial used to interpolate time for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolver_DynamicDegreeSetObj(solver,degree,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the dynamic degree for.
    INTEGER(INTG), INTENT(IN) :: degree !<The dynamic degree to set. \see OPENCMISS_DynamicDegreeTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_DynamicDegreeSetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_DEGREE_SET(solver%SOLVER,degree,err,error,*999)

    CALL EXITS("CMISSSolver_DynamicDegreeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicDegreeSetObj",err,error)
    CALL EXITS("CMISSSolver_DynamicDegreeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicDegreeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicLinearityTypeGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,linearityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the dynamic linearity type. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DynamicLinearityTypeGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_LINEARITY_TYPE_GET(SOLVER,linearityType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicLinearityTypeGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicLinearityTypeGetNumber0",err,error)
    CALL EXITS("CMISSSolver_DynamicLinearityTypeGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicLinearityTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicLinearityTypeGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,linearityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the dynamic linearity type. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DynamicLinearityTypeGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_LINEARITY_TYPE_GET(SOLVER,linearityType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicLinearityTypeGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicLinearityTypeGetNumber1",err,error)
    CALL EXITS("CMISSSolver_DynamicLinearityTypeGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicLinearityTypeGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the linearity type for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolver_DynamicLinearityTypeGetObj(solver,linearityType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the dynamic linearity type for.
    INTEGER(INTG), INTENT(OUT) :: linearityType !<On return, the dynamic linearity type. \see OPENCMISS_DynamicLinearityTypes,OPENCMISS
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_DynamicLinearityTypeGetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_LINEARITY_TYPE_GET(solver%SOLVER,linearityType,err,error,*999)

    CALL EXITS("CMISSSolver_DynamicLinearityTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicLinearityTypeGetObj",err,error)
    CALL EXITS("CMISSSolver_DynamicLinearityTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicLinearityTypeGetObj

  !
  !================================================================================================================================
  !

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicNonlinearSolverGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & nonlinearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(OUT) :: nonlinearSolverIndex !<On return, the solver index of the nonlinear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DynamicNonlinearSolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(NONLINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET(SOLVER,NONLINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from nonlinear solver
      nonlinearSolverIndex=NONLINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicNonlinearSolverGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicNonlinearSolverGetNumber0",err,error)
    CALL EXITS("CMISSSolver_DynamicNonlinearSolverGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicNonlinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicNonlinearSolverGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & nonlinearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic nonlinear solver for.
    INTEGER(INTG), INTENT(OUT) :: nonlinearSolverIndex !<On return, the dynamic nonlinear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,NONLINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DynamicNonlinearSolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(NONLINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET(SOLVER,NONLINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from nonlinear solver
      nonlinearSolverIndex=NONLINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicNonlinearSolverGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicNonlinearSolverGetNumber1",err,error)
    CALL EXITS("CMISSSolver_DynamicNonlinearSolverGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicNonlinearSolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the nonlinear solver associated with a nonlinear dynamic solver identified by an object.
  SUBROUTINE CMISSSolver_DynamicNonlinearSolverGetObj(solver,nonlinearSolver,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the dynamic nonlinear solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: nonlinearSolver  !<On return, the dynamic nonlinear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_DynamicNonlinearSolverGetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_NONLINEAR_SOLVER_GET(solver%SOLVER,nonlinearSolver%SOLVER,err,error,*999)

    CALL EXITS("CMISSSolver_DynamicNonlinearSolverGetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicNonlinearSolverGetObj",err,error)
    CALL EXITS("CMISSSolver_DynamicNonlinearSolverGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicNonlinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a linear dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicLinearSolverGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,linearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the solver index of the linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DynamicLinearSolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from linear solver
      linearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicLinearSolverGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicLinearSolverGetNumber0",err,error)
    CALL EXITS("CMISSSolver_DynamicLinearSolverGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicLinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a linear dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicLinearSolverGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,linearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the dynamic linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the dynamic linear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DynamicLinearSolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from linear solver
      linearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicLinearSolverGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicLinearSolverGetNumber1",err,error)
    CALL EXITS("CMISSSolver_DynamicLinearSolverGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicLinearSolverGetNumber1

  !================================================================================================================================
  !

  !>Returns the linear solver associated with a linear dynamic solver identified by an object.
  SUBROUTINE CMISSSolver_DynamicLinearSolverGetObj(solver,linearSolver,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the dynamic linear solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: linearSolver !<On return, the dynamic linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_DynamicLinearSolverGetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_LINEAR_SOLVER_GET(solver%SOLVER,linearSolver%SOLVER,err,error,*999)

    CALL EXITS("CMISSSolver_DynamicLinearSolverGetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicLinearSolverGetObj",err,error)
    CALL EXITS("CMISSSolver_DynamicLinearSolverGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicLinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the scheme for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicSchemeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,scheme,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: scheme !<The dynamic scheme to set. \see OPENCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DynamicSchemeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_SCHEME_SET(SOLVER,scheme,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicSchemeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicSchemeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_DynamicSchemeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicSchemeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the scheme for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicSchemeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,scheme,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: scheme !<The dynamic scheme to set. \see OPENCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DynamicSchemeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_SCHEME_SET(SOLVER,scheme,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicSchemeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicSchemeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_DynamicSchemeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicSchemeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the scheme for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolver_DynamicSchemeSetObj(solver,scheme,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the scheme for.
    INTEGER(INTG), INTENT(IN) :: scheme !<The dynamic scheme to set. \see OPENCMISS_DynamicSchemeTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_DynamicSchemeSetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_SCHEME_SET(solver%SOLVER,scheme,err,error,*999)

    CALL EXITS("CMISSSolver_DynamicSchemeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicSchemeSetObj",err,error)
    CALL EXITS("CMISSSolver_DynamicSchemeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicSchemeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta value for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicThetaSetNumber00(problemUserNumber,controlLoopIdentifier,solverIndex,theta,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: theta !<The dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DynamicThetaSetNumber00",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,theta,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicThetaSetNumber00")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicThetaSetNumber00",err,error)
    CALL EXITS("CMISSSolver_DynamicThetaSetNumber00")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicThetaSetNumber00

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta value for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicThetaSetNumber01(problemUserNumber,controlLoopIdentifier,solverIndex,thetas,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: thetas(:) !<thetas(i). The i'th dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DynamicThetaSetNumber01",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,thetas,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicThetaSetNumber01")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicThetaSetNumber01",err,error)
    CALL EXITS("CMISSSolver_DynamicThetaSetNumber01")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicThetaSetNumber01

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicThetaSetNumber10(problemUserNumber,controlLoopIdentifiers,solverIndex,theta,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: theta !<The dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DynamicThetaSetNumber10",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,theta,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicThetaSetNumber10")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicThetaSetNumber10",err,error)
    CALL EXITS("CMISSSolver_DynamicThetaSetNumber10")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicThetaSetNumber10

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicThetaSetNumber11(problemUserNumber,controlLoopIdentifiers,solverIndex,thetas,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the theta for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the theta for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the theta for.
    REAL(DP), INTENT(IN) :: thetas(:) !<thetas(i). The i'th dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DynamicThetaSetNumber11",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_THETA_SET(SOLVER,thetas,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicThetaSetNumber11")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicThetaSetNumber11",err,error)
    CALL EXITS("CMISSSolver_DynamicThetaSetNumber11")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicThetaSetNumber11

  !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolver_DynamicThetaSetObj0(solver,theta,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the theta for.
    REAL(DP), INTENT(IN) :: theta !<The dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_DynamicThetaSetObj0",err,error,*999)

    CALL SOLVER_DYNAMIC_THETA_SET(solver%SOLVER,theta,err,error,*999)

    CALL EXITS("CMISSSolver_DynamicThetaSetObj0")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicThetaSetObj0",err,error)
    CALL EXITS("CMISSSolver_DynamicThetaSetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicThetaSetObj0

   !
  !================================================================================================================================
  !

  !>Sets/changes the theta for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolver_DynamicThetaSetObj1(solver,thetas,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the theta for.
    REAL(DP), INTENT(IN) :: thetas(:) !<thetas(i). The i'th dynamic theta to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_DynamicThetaSetObj1",err,error,*999)

    CALL SOLVER_DYNAMIC_THETA_SET(solver%SOLVER,thetas,err,error,*999)

    CALL EXITS("CMISSSolver_DynamicThetaSetObj1")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicThetaSetObj1",err,error)
    CALL EXITS("CMISSSolver_DynamicThetaSetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicThetaSetObj1

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicTimesSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,currentTime,timeIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_DynamicTimesSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_TIMES_SET(SOLVER,currentTime,timeIncrement,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicTimesSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicTimesSetNumber0",err,error)
    CALL EXITS("CMISSSolver_DynamicTimesSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicTimesSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the times for a dynamic solver identified by an user number.
  SUBROUTINE CMISSSolver_DynamicTimesSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,currentTime,timeIncrement,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the times for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the times for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverDynamicTimeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_DYNAMIC_TIMES_SET(SOLVER,currentTime,timeIncrement,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_DynamicTimesSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicTimesSetNumber1",err,error)
    CALL EXITS("CMISSSolver_DynamicTimesSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicTimesSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the times for a dynamic solver identified by an object.
  SUBROUTINE CMISSSolver_DynamicTimesSetObj(solver,currentTime,timeIncrement,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the times for.
    REAL(DP), INTENT(IN) :: currentTime !<The current time to set.
    REAL(DP), INTENT(IN) :: timeIncrement !<The time increment to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_DynamicTimesSetObj",err,error,*999)

    CALL SOLVER_DYNAMIC_TIMES_SET(solver%SOLVER,currentTime,timeIncrement,err,error,*999)

    CALL EXITS("CMISSSolver_DynamicTimesSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_DynamicTimesSetObj",err,error)
    CALL EXITS("CMISSSolver_DynamicTimesSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_DynamicTimesSetObj
  
  !
  !================================================================================================================================
  !

  !>Sets the arbitrary path logical for a geometric transformation identified by an user number.
  SUBROUTINE CMISSSolver_GeometricTransformationArbitraryPathSetNumber(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & arbitraryPath,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the arbitrary path for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the arbitrary path for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index for the geometric transformation solver.
    LOGICAL, INTENT(IN) :: arbitraryPath !<.TRUE. if the the transformation has an arbitrary path, .FALSE. if the path is uni-directional
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSSolver_GeometricTransformationArbitraryPathSetNumber",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationArbitraryPathSet(solver,arbitraryPath,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NUMBER_TO_VSTRING(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolver_GeometricTransformationArbitraryPathSetNumber")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationArbitraryPathSetNumber",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationArbitraryPathSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationArbitraryPathSetNumber
  
  !
  !================================================================================================================================
  !

  !>Sets the arbitrary path logical for a geometric transformation solver identified by an object.
  SUBROUTINE CMISSSolver_GeometricTransformationArbitraryPathSetObj(solver,arbitraryPath,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the arbitrary path for.
    LOGICAL, INTENT(IN) :: arbitraryPath !<.TRUE. if the the transformation has an arbitrary path, .FALSE. if the path is uni-directional
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_GeometricTransformationArbitraryPathSetObj",err,error,*999)
    
    CALL Solver_GeometricTransformationArbitraryPathSet(solver%SOLVER,arbitraryPath,err,error,*999)

    CALL EXITS("CMISSSolver_GeometricTransformationArbitraryPathSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationArbitraryPathSetObj",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationArbitraryPathSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationArbitraryPathSetObj
  
  !
  !================================================================================================================================
  !

  !>Clear transformation a geometric transformation identified by an user number.
  SUBROUTINE CMISSSolver_GeometricTransformationClearNumber(problemUserNumber,controlLoopIdentifier,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to clear.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to clear.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index for the geometric transformation solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSSolver_GeometricTransformationClearNumber",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationClear(solver,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NUMBER_TO_VSTRING(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolver_GeometricTransformationClearNumber")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationClearNumber",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationClearNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationClearNumber
  
  !
  !================================================================================================================================
  !

  !>Clear transformation for a geometric transformation solver identified by an object.
  SUBROUTINE CMISSSolver_GeometricTransformationClearObj(solver,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The geometric transformation solver to clear
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_GeometricTransformationClearObj",err,error,*999)
    
    CALL Solver_GeometricTransformationClear(solver%SOLVER,err,error,*999)

    CALL EXITS("CMISSSolver_GeometricTransformationClearObj")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationClearObj",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationClearObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationClearObj
  
  !
  !================================================================================================================================
  !

  !>Sets the field for a geometric transformation identified by an user number.
  SUBROUTINE CMISSSolver_GeometricTransformationFieldSetNumber(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & regionUserNumber,fieldUserNumber,variableType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index for the geometric transformation solver.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The region user number for the field
    INTEGER(INTG), INTENT(IN) :: fieldUserNumber !<The field user number
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the transformation for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(FIELD_TYPE), POINTER :: field
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSSolver_GeometricTransformationFieldSetNumber",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    NULLIFY(field)
    NULLIFY(region)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL REGION_USER_NUMBER_FIND(regionUserNumber,region,err,error,*999)
        IF(ASSOCIATED(region)) THEN
          CALL FIELD_USER_NUMBER_FIND(fieldUserNumber,region,field,err,error,*999)
          IF(ASSOCIATED(field)) THEN
            CALL Solver_GeometricTransformationFieldSet(solver,field,variableType,err,error,*999)
          ELSE
            localError="A field with user number of "//TRIM(NUMBER_TO_VSTRING(fieldUserNumber,"*",err,error))// &
              & " does not exist."
            CALL FLAG_ERROR(localError,err,error,*999)
          ENDIF
        ELSE
          localError="A region with user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
            & " does not exist."
          CALL FLAG_ERROR(localError,err,error,*999)
        ENDIF
      ELSE
        localError="A solver with index of "//TRIM(NUMBER_TO_VSTRING(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolver_GeometricTransformationFieldSetNumber")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationFieldSetNumber",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationFieldSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationFieldSetNumber
  
  !
  !================================================================================================================================
  !

  !>Sets the field for a geometric transformation solver identified by an object.
  SUBROUTINE CMISSSolver_GeometricTransformationFieldSetObj(solver,field,variableType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the field for.
    TYPE(CMISSFieldType), INTENT(IN) :: field !<The field for the solver to set.
    INTEGER(INTG), INTENT(IN) :: variableType !<The field variable type to set the transformation for
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_GeometricTransformationFieldSetObj",err,error,*999)
    
    CALL Solver_GeometricTransformationFieldSet(solver%SOLVER,field%FIELD,variableType,err,error,*999)

    CALL EXITS("CMISSSolver_GeometricTransformationFieldSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationFieldSetObj",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationFieldSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationFieldSetObj
  
  !
  !================================================================================================================================
  !

  !>Sets the full transformation matrix for a geometric transformation identified by an user number, default to be the 1st load increment
  SUBROUTINE CMISSSolver_GeometricTransformationMatrixSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & matrix,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the matrix for.
    REAL(DP), INTENT(IN) :: matrix(:,:) !<The full transformation matrix to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSSolver_GeometricTransformationMatrixSetNumber0",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationMatrixSet(solver,matrix,1,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NUMBER_TO_VSTRING(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolver_GeometricTransformationMatrixSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationMatrixSetNumber0",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationMatrixSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationMatrixSetNumber0
  
  !
  !================================================================================================================================
  !

  !>Sets the full transformation matrix for a geometric transformation solver identified by an object, default to be the 1st load increment
  SUBROUTINE CMISSSolver_GeometricTransformationMatrixSetObj0(solver,matrix,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the matrix for.
    REAL(DP), INTENT(IN) :: matrix(:,:) !<The full transformation matrix to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_GeometricTransformationMatrixSetObj0",err,error,*999)
    
    CALL Solver_GeometricTransformationMatrixSet(solver%SOLVER,matrix,1,err,error,*999)

    CALL EXITS("CMISSSolver_GeometricTransformationMatrixSetObj0")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationMatrixSetObj0",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationMatrixSetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationMatrixSetObj0
  
  !
  !================================================================================================================================
  !

  !>Sets the full transformation matrix at a specific increment for a geometric transformation identified by an user number.
  SUBROUTINE CMISSSolver_GeometricTransformationMatrixSetNumber1(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & matrix,loadIncrementIdx,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the matrix for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the matrix for.
    REAL(DP), INTENT(IN) :: matrix(:,:) !<The full transformation matrix to set
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the matrix for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSSolver_GeometricTransformationMatrixSetNumber1",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationMatrixSet(solver,matrix,loadIncrementIdx,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NUMBER_TO_VSTRING(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolver_GeometricTransformationMatrixSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationMatrixSetNumber1",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationMatrixSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationMatrixSetNumber1
  
  !
  !================================================================================================================================
  !

  !>Sets the full transformation matrix vector at a specific load increment for a geometric transformation solver identified by an object.
  SUBROUTINE CMISSSolver_GeometricTransformationMatrixSetObj1(solver,matrix,loadIncrementIdx,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the matrix for.
    REAL(DP), INTENT(IN) :: matrix(:,:) !<The full transformation matrix to set
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the matrix for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_GeometricTransformationMatrixSetObj1",err,error,*999)
    
    CALL Solver_GeometricTransformationMatrixSet(solver%SOLVER,matrix,loadIncrementIdx,err,error,*999)

    CALL EXITS("CMISSSolver_GeometricTransformationMatrixSetObj1")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationMatrixSetObj1",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationMatrixSetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationMatrixSetObj1
  
  !
  !================================================================================================================================
  !

  !>Sets the arbitrary path logical for a geometric transformation identified by an user number.
  SUBROUTINE CMISSSolver_GeometricTransformationNoLoadIncrementsSetNumber(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,numberOfIncrements,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index for the geometric transformation solver.
    INTEGER(INTG), INTENT(IN) :: numberOfIncrements !<The number of load increments to apply the transformation
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSSolver_GeometricTransformationNumberOfLoadIncrementsSetNumber",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationNumberOfLoadIncrementsSet(solver,numberOfIncrements,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NUMBER_TO_VSTRING(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolver_GeometricTransformationNumberOfLoadIncrementsSetNumber")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationNumberOfLoadIncrementsSetNumber",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationNumberOfLoadIncrementsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationNoLoadIncrementsSetNumber
  
  !
  !================================================================================================================================
  !

  !>Sets the arbitrary path logical for a geometric transformation solver identified by an object.
  SUBROUTINE CMISSSolver_GeometricTransformationNoLoadIncrementsSetObj(solver,numberOfIncrements,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the field for.
    INTEGER(INTG), INTENT(IN) :: numberOfIncrements !<The number of load increments to apply the transformation
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_GeometricTransformationNumberOfLoadIncrementsSetObj",err,error,*999)
    
    CALL Solver_GeometricTransformationNumberOfLoadIncrementsSet(solver%SOLVER,numberOfIncrements,err,error,*999)

    CALL EXITS("CMISSSolver_GeometricTransformationNumberOfLoadIncrementsSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationNumberOfLoadIncrementsSetObj",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationNumberOfLoadIncrementsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationNoLoadIncrementsSetObj
  
  !
  !================================================================================================================================
  !

  !>Sets the rotation for a geometric transformation identified by an user number, default to be the 1st load increment
  SUBROUTINE CMISSSolver_GeometricTransformationRotationSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & pivotPoint,axis,angle,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the rotation for.
    REAL(DP), INTENT(IN) :: pivotPoint(:) !<The pivot point to rotate about
    REAL(DP), INTENT(IN) :: axis(:) !<The axis to  to rotate around
    REAL(DP), INTENT(IN) :: angle !<The angle to rotate
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSSolver_GeometricTransformationRotationSetNumber0",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationRotationSet(solver,pivotPoint,axis,angle,1,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NUMBER_TO_VSTRING(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolver_GeometricTransformationRotationSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationRotationSetNumber0",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationRotationSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationRotationSetNumber0
  
  !
  !================================================================================================================================
  !

  !>Sets the rotation for a geometric transformation solver identified by an object, default to be the 1st load increment
  SUBROUTINE CMISSSolver_GeometricTransformationRotationSetObj0(solver,pivotPoint,axis,angle,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the rotation for.
    REAL(DP), INTENT(IN) :: pivotPoint(:) !<The pivot point to rotate about
    REAL(DP), INTENT(IN) :: axis(:) !<The axis to  to rotate around
    REAL(DP), INTENT(IN) :: angle !<The angle to rotate
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_GeometricTransformationRotationSetObj0",err,error,*999)
    
    CALL Solver_GeometricTransformationRotationSet(solver%SOLVER,pivotPoint,axis,angle,1,err,error,*999)

    CALL EXITS("CMISSSolver_GeometricTransformationRotationSetObj0")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationRotationSetObj0",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationRotationSetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationRotationSetObj0
  
  !
  !================================================================================================================================
  !

  !>Sets the rotation at a specific increment for a geometric transformation identified by an user number.
  SUBROUTINE CMISSSolver_GeometricTransformationRotationSetNumber1(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & pivotPoint,axis,angle,loadIncrementIdx,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the rotation for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the rotation for.
    REAL(DP), INTENT(IN) :: pivotPoint(:) !<The pivot point to rotate about
    REAL(DP), INTENT(IN) :: axis(:) !<The axis to  to rotate around
    REAL(DP), INTENT(IN) :: angle !<The angle to rotate
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the rotation for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSSolver_GeometricTransformationRotationSetNumber1",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationRotationSet(solver,pivotPoint,axis,angle,loadIncrementIdx,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NUMBER_TO_VSTRING(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolver_GeometricTransformationRotationSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationRotationSetNumber1",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationRotationSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationRotationSetNumber1
  
  !
  !================================================================================================================================
  !

  !>Sets the rotation at a specific load increment for a geometric transformation solver identified by an object.
  SUBROUTINE CMISSSolver_GeometricTransformationRotationSetObj1(solver,pivotPoint,axis,angle,loadIncrementIdx,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the rotation for.
    REAL(DP), INTENT(IN) :: pivotPoint(:) !<The pivot point to rotate about
    REAL(DP), INTENT(IN) :: axis(:) !<The axis to  to rotate around
    REAL(DP), INTENT(IN) :: angle !<The angle to rotate
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the rotation for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_GeometricTransformationRotationSetObj1",err,error,*999)
    
    CALL Solver_GeometricTransformationRotationSet(solver%SOLVER,pivotPoint,axis,angle,loadIncrementIdx,err,error,*999)

    CALL EXITS("CMISSSolver_GeometricTransformationRotationSetObj1")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationRotationSetObj1",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationRotationSetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationRotationSetObj1
  
  !
  !================================================================================================================================
  !

  !>Sets the scalings for a geometric transformation identified by an user number.
  SUBROUTINE CMISSSolver_GeometricTransformationScalingsSetNumber(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & scalings,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the scalings for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the scalings for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the scalings for.
    REAL(DP), INTENT(IN) :: scalings(:) !<The scalings to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSSolver_GeometricTransformationScalingsSetNumber",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationScalingsSet(solver,scalings,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NUMBER_TO_VSTRING(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolver_GeometricTransformationScalingsSetNumber")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationScalingsSetNumber",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationScalingsSetNumber")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationScalingsSetNumber
  
  !
  !================================================================================================================================
  !

  !>Sets the scalings for a geometric transformation solver identified by an object.
  SUBROUTINE CMISSSolver_GeometricTransformationScalingsSetObj(solver,scalings,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the scalings for.
    REAL(DP), INTENT(IN) :: scalings(:) !<The scalings to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_GeometricTransformationScalingsSetObj",err,error,*999)
    
    CALL Solver_GeometricTransformationScalingsSet(solver%SOLVER,scalings,err,error,*999)

    CALL EXITS("CMISSSolver_GeometricTransformationScalingsSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationScalingsSetObj",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationScalingsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationScalingsSetObj
  
  !
  !================================================================================================================================
  !

  !>Sets the translation for a geometric transformation identified by an user number, default to be the 1st load increment
  SUBROUTINE CMISSSolver_GeometricTransformationTranslationSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & translation,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the translation for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the translation for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the translation for.
    REAL(DP), INTENT(IN) :: translation(:) !<The translation components to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSSolver_GeometricTransformationTranslationSetNumber0",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationTranslationSet(solver,translation,1,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NUMBER_TO_VSTRING(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolver_GeometricTransformationTranslationSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationTranslationSetNumber0",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationTranslationSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationTranslationSetNumber0
  
  !
  !================================================================================================================================
  !

  !>Sets the translation vector for a geometric transformation solver identified by an object, default to be the 1st load increment
  SUBROUTINE CMISSSolver_GeometricTransformationTranslationSetObj0(solver,translation,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the translation for.
    REAL(DP), INTENT(IN) :: translation(:) !<The translation components to set
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_GeometricTransformationTranslationSetObj0",err,error,*999)
    
    CALL Solver_GeometricTransformationTranslationSet(solver%SOLVER,translation,1,err,error,*999)

    CALL EXITS("CMISSSolver_GeometricTransformationTranslationSetObj0")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationTranslationSetObj0",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationTranslationSetObj0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationTranslationSetObj0
  
  !
  !================================================================================================================================
  !

  !>Sets the translation at a specific increment for a geometric transformation identified by an user number.
  SUBROUTINE CMISSSolver_GeometricTransformationTranslationSetNumber1(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & translation,loadIncrementIdx,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the translation for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the translation for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the translation for.
    REAL(DP), INTENT(IN) :: translation(:) !<The translation components to set
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the translation for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSSolver_GeometricTransformationTranslationSetNumber1",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      IF(ASSOCIATED(solver)) THEN
        CALL Solver_GeometricTransformationTranslationSet(solver,translation,loadIncrementIdx,err,error,*999)
      ELSE
        localError="A solver with index of "//TRIM(NUMBER_TO_VSTRING(solverIndex,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(localError,err,error,*999)
      ENDIF
    ELSE
      localError="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolver_GeometricTransformationTranslationSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationTranslationSetNumber1",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationTranslationSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationTranslationSetNumber1
  
  !
  !================================================================================================================================
  !

  !>Sets the translation vector at a specific load increment for a geometric transformation solver identified by an object.
  SUBROUTINE CMISSSolver_GeometricTransformationTranslationSetObj1(solver,translation,loadIncrementIdx,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The geometric transformation solver to set the translation for.
    REAL(DP), INTENT(IN) :: translation(:) !<The translation components to set
    INTEGER(INTG), INTENT(IN) :: loadIncrementIdx !<The load increment index to set the translation for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_GeometricTransformationTranslationSetObj1",err,error,*999)
    
    CALL Solver_GeometricTransformationTranslationSet(solver%SOLVER,translation,loadIncrementIdx,err,error,*999)

    CALL EXITS("CMISSSolver_GeometricTransformationTranslationSetObj1")
    RETURN
999 CALL ERRORS("CMISSSolver_GeometricTransformationTranslationSetObj1",err,error)
    CALL EXITS("CMISSSolver_GeometricTransformationTranslationSetObj1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_GeometricTransformationTranslationSetObj1

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a solver identified by an user number.
  SUBROUTINE CMISSSolver_LabelGetCNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LabelGetCNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_GET(SOLVER,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolver_LabelGetCNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_LabelGetCNumber0",err,error)
    CALL EXITS("CMISSSolver_LabelGetCNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LabelGetCNumber0

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a solver identified by an user number.
  SUBROUTINE CMISSSolver_LabelGetCNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifiers.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LabelGetCNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_GET(SOLVER,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF

    CALL EXITS("CMISSSolver_LabelGetCNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_LabelGetCNumber1",err,error)
    CALL EXITS("CMISSSolver_LabelGetCNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LabelGetCNumber1

  !
  !================================================================================================================================
  !

  !>Returns the character string label for a solver identified by an object.
  SUBROUTINE CMISSSolver_LabelGetCObj(solver,label,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the label for.
    CHARACTER(LEN=*), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_LabelGetCObj",err,error,*999)

    CALL SOLVER_LABEL_GET(solver%SOLVER,label,err,error,*999)

    CALL EXITS("CMISSSolver_LabelGetCObj")
    RETURN
999 CALL ERRORS("CMISSSolver_LabelGetCObj",err,error)
    CALL EXITS("CMISSSolver_LabelGetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LabelGetCObj

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a solver identified by an user number.
  SUBROUTINE CMISSSolver_LabelGetVSNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LabelGetVSNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_GET(SOLVER,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LabelGetVSNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_LabelGetVSNumber0",err,error)
    CALL EXITS("CMISSSolver_LabelGetVSNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LabelGetVSNumber0

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a solver identified by an user number.
  SUBROUTINE CMISSSolver_LabelGetVSNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The solver identifiers.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LabelGetVSNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_GET(SOLVER,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LabelGetVSNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_LabelGetVSNumber1",err,error)
    CALL EXITS("CMISSSolver_LabelGetVSNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LabelGetVSNumber1

  !
  !================================================================================================================================
  !

  !>Returns the varying string label for a solver identified by an object.
  SUBROUTINE CMISSSolver_LabelGetVSObj(solver,label,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the label for.
    TYPE(VARYING_STRING), INTENT(OUT) :: label !<On return, the solver label.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_LabelGetVSObj",err,error,*999)

    CALL SOLVER_LABEL_GET(solver%SOLVER,label,err,error,*999)

    CALL EXITS("CMISSSolver_LabelGetVSObj")
    RETURN
999 CALL ERRORS("CMISSSolver_LabelGetVSObj",err,error)
    CALL EXITS("CMISSSolver_LabelGetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LabelGetVSObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a solver identified by an user number.
  SUBROUTINE CMISSSolver_LabelSetCNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LabelSetCNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_SET(SOLVER,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LabelSetCNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_LabelSetCNumber0",err,error)
    CALL EXITS("CMISSSolver_LabelSetCNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LabelSetCNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a solver identified by an user number.
  SUBROUTINE CMISSSolver_LabelSetCNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The solver identifiers.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The region label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LabelSetCNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_SET(SOLVER,label,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LabelSetCNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_LabelSetCNumber1",err,error)
    CALL EXITS("CMISSSolver_LabelSetCNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LabelSetCNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes the character string label for a solver identified by an object.
  SUBROUTINE CMISSSolver_LabelSetCObj(solver,label,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the label for.
    CHARACTER(LEN=*), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_LabelSetCObj",err,error,*999)

    CALL SOLVER_LABEL_SET(solver%SOLVER,label,err,error,*999)

    CALL EXITS("CMISSSolver_LabelSetCObj")
    RETURN
999 CALL ERRORS("CMISSSolver_LabelSetCObj",err,error)
    CALL EXITS("CMISSSolver_LabelSetCObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LabelSetCObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a solver identified by an user number.
  SUBROUTINE CMISSSolver_LabelSetVSNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The solver identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LabelSetVSNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_SET(SOLVER,CHAR(label),err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolverLabelStVSNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_LabelSetVSNumber0",err,error)
    CALL EXITS("CMISSControlLabelSetVSNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LabelSetVSNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the varying string label for a solver identified by an user number.
  SUBROUTINE CMISSSolver_LabelSetVSNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,label,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem to set the label for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<The control loop identifier.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the times for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LabelSetVSNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LABEL_SET(SOLVER,CHAR(label),err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolverLabelStVSNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_LabelSetVSNumber1",err,error)
    CALL EXITS("CMISSControlLabelSetVSNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LabelSetVSNumber1

  !
  !================================================================================================================================
  !

  !>Sets/changes string label for a solver identified by an object.
  SUBROUTINE CMISSSolver_LabelSetVSObj(solver,label,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the label for.
    TYPE(VARYING_STRING), INTENT(IN) :: label !<The solver label to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_LabelSetVSObj",err,error,*999)

    CALL SOLVER_LABEL_SET(solver%SOLVER,CHAR(label),err,error,*999)

    CALL EXITS("CMISSSolver_LabelSetVSObj")
    RETURN
999 CALL ERRORS("CMISSSolver_LabelSetVSObj",err,error)
    CALL EXITS("CMISSSolver_LabelSetVSObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LabelSetVSObj

  !
  !================================================================================================================================
  !

  !>Returns the type of library for a solver identified by an user number.
  SUBROUTINE CMISSSolver_LibraryTypeGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,libraryType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: libraryType !<On return, the library type for the solver. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LibraryTypeGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LIBRARY_TYPE_GET(SOLVER,libraryType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LibraryTypeGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_LibraryTypeGetNumber0",err,error)
    CALL EXITS("CMISSSolver_LibraryTypeGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LibraryTypeGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the library type for a solver identified by an user number.
  SUBROUTINE CMISSSolver_LibraryTypeGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,libraryType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: libraryType !<On return, the library type for the solver. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LibraryTypeGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LIBRARY_TYPE_GET(SOLVER,libraryType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LibraryTypeGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_LibraryTypeGetNumber1",err,error)
    CALL EXITS("CMISSSolver_LibraryTypeGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LibraryTypeGetNumber1

  !================================================================================================================================
  !

  !>Returns the library type for a solver identified by an object.
  SUBROUTINE CMISSSolver_LibraryTypeGetObj(solver,libraryType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the library type for.
    INTEGER(INTG), INTENT(OUT) :: libraryType !<On return, the library type for the solver. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_LibraryTypeGetObj",err,error,*999)

    CALL SOLVER_LIBRARY_TYPE_GET(solver%SOLVER,libraryType,err,error,*999)

    CALL EXITS("CMISSSolver_LibraryTypeGetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_LibraryTypeGetObj",err,error)
    CALL EXITS("CMISSSolver_LibraryTypeGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LibraryTypeGetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of library for a solver identified by an user number.
  SUBROUTINE CMISSSolver_LibraryTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,libraryType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the library type for.
    INTEGER(INTG), INTENT(IN) :: libraryType !<The library type for the solver to set. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LibraryTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LIBRARY_TYPE_SET(SOLVER,libraryType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LibraryTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_LibraryTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_LibraryTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LibraryTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the library type for a solver identified by an user number.
  SUBROUTINE CMISSSolver_LibraryTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,libraryType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the library type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the library type for.
    INTEGER(INTG), INTENT(IN) :: libraryType !<The library type for the solver to set. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LibraryTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LIBRARY_TYPE_SET(SOLVER,libraryType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LibraryTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_LibraryTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_LibraryTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LibraryTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the library type for a solver identified by an object.
  SUBROUTINE CMISSSolver_LibraryTypeSetObj(solver,libraryType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: libraryType !<The library type for the solver to set. \see OPENCMISS_SolverLibraries
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_LibraryTypeSetObj",err,error,*999)

    CALL SOLVER_LIBRARY_TYPE_SET(solver%SOLVER,libraryType,err,error,*999)

    CALL EXITS("CMISSSolver_LibraryTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_LibraryTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_LibraryTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LibraryTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of direct linear solver for a solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearDirectTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,directSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: directSolverType !<The type of the direct linear solver to set. \see OPENCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearDirectTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_DIRECT_TYPE_SET(SOLVER,directSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearDirectTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearDirectTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_LinearDirectTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearDirectTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of direct linear solver for a solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearDirectTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,directSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the direct linear solver to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the direct type for.
    INTEGER(INTG), INTENT(IN) :: directSolverType !<The type of the direct linear solver to set. \see OPENCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearDirectTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_DIRECT_TYPE_SET(SOLVER,directSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearDirectTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearDirectTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_LinearDirectTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearDirectTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of direct linear solver for a solver identified by an object.
  SUBROUTINE CMISSSolver_LinearDirectTypeSetObj(solver,directSolverType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: directSolverType !<The type of the direct linear solver to set. \see OPENCMISS_DirectLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_LinearDirectTypeSetObj",err,error,*999)

    CALL SOLVER_LINEAR_DIRECT_TYPE_SET(solver%SOLVER,directSolverType,err,error,*999)

    CALL EXITS("CMISSSolver_LinearDirectTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearDirectTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_LinearDirectTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearDirectTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the MUMPS ICNTL(icntl)=ivalue integer control parameters through the PETSc-MUMPS interface
  SUBROUTINE CMISSSolver_MumpsSetIcntl(solver,icntl,ivalue,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: icntl !<The MUMPS ICNTL integer control parameter 
    INTEGER(INTG), INTENT(IN) :: ivalue !<The MUMPS ICNTL integer value to set: ICNTL(icntl)=ivalue
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_MumpsSetIcntl",err,error,*999)

    CALL Solver_MumpsSetIcntl(solver%SOLVER,icntl,ivalue,err,error,*999)

    CALL EXITS("CMISSSolver_MumpsSetIcntl")
    RETURN
999 CALL ERRORS("CMISSSolver_MumpsSetIcntl",err,error)
    CALL EXITS("CMISSSolver_MumpsSetIcntl")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_MumpsSetIcntl

  !
  !================================================================================================================================
  !

  !>Sets/changes the MUMPS CNTL(icntl)=val real/complex control parameters through the PETSc-MUMPS interface
  SUBROUTINE CMISSSolver_MumpsSetCntl(solver,icntl,val,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the library type for.
    INTEGER(INTG), INTENT(IN) :: icntl !<The MUMPS CNTL integer control parameter 
    REAL(DP), INTENT(IN) :: val !<The MUMPS CNTL real value to set: CNTL(icntl)=val
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_MumpsSetCntl",err,error,*999)

    CALL Solver_MumpsSetCntl(solver%SOLVER,icntl,val,err,error,*999)

    CALL EXITS("CMISSSolver_MumpsSetCntl")
    RETURN
999 CALL ERRORS("CMISSSolver_MumpsSetCntl",err,error)
    CALL EXITS("CMISSSolver_MumpsSetCntl")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_MumpsSetCntl

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearIterativeAbsoluteToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearIterativeAbsoluteToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_ABSOLUTE_TOLERANCE_SET(SOLVER,absoluteTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearIterativeAbsoluteToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeAbsoluteToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeAbsoluteToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeAbsoluteToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearIterativeAbsoluteToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearIterativeAbsoluteToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_ABSOLUTE_TOLERANCE_SET(SOLVER,absoluteTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearIterativeAbsoluteToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeAbsoluteToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeAbsoluteToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeAbsoluteToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum absolute tolerance for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolver_LinearIterativeAbsoluteToleranceSetObj(solver,absoluteTolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The iterative linear solver to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_LinearIterativeAbsoluteToleranceSetObj",err,error,*999)

    CALL SOLVER_LINEAR_ITERATIVE_ABSOLUTE_TOLERANCE_SET(solver%SOLVER,absoluteTolerance,err,error,*999)

    CALL EXITS("CMISSSolver_LinearIterativeAbsoluteToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeAbsoluteToleranceSetObj",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeAbsoluteToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeAbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearIterativeDivergenceToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & divergenceTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: divergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearIterativeDivergenceToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_DIVERGENCE_TOLERANCE_SET(SOLVER,divergenceTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearIterativeDivergenceToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeDivergenceToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeDivergenceToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeDivergenceToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearIterativeDivergenceToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & divergenceTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the divergence tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: divergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearIterativeDivergenceToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_DIVERGENCE_TOLERANCE_SET(SOLVER,divergenceTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearIterativeDivergenceToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeDivergenceToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeDivergenceToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeDivergenceToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum divergence tolerance for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolver_LinearIterativeDivergenceToleranceSetObj(solver,divergenceTolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The iterative linear solver to set the divergence tolerance for.
    REAL(DP), INTENT(IN) :: divergenceTolerance !<The divergence tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_LinearIterativeDivergenceToleranceSetObj",err,error,*999)

    CALL SOLVER_LINEAR_ITERATIVE_DIVERGENCE_TOLERANCE_SET(solver%SOLVER,divergenceTolerance,err,error,*999)

    CALL EXITS("CMISSSolver_LinearIterativeDivergenceToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeDivergenceToleranceSetObj",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeDivergenceToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeDivergenceToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearIterativeGMRESRestartSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & GMRESRestart,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the GMRES restart value for.
    INTEGER(INTG), INTENT(IN) :: GMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearIterativeGMRESRestartSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET(SOLVER,GMRESRestart,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearIterativeGMRESRestartSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeGMRESRestartSetNumber0",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeGMRESRestartSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeGMRESRestartSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearIterativeGMRESRestartSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & GMRESRestart,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: GMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearIterativeGMRESRestartSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET(SOLVER,GMRESRestart,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearIterativeGMRESRestartSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeGMRESRestartSetNumber1",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeGMRESRestartSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeGMRESRestartSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the GMRES restart value for a GMRES iterative linear solver identified by an object.
  SUBROUTINE CMISSSolver_LinearIterativeGMRESRestartSetObj(solver,GMRESRestart,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The GMRES iterative linear solver to set the restart value for.
    INTEGER(INTG), INTENT(IN) :: GMRESRestart !<The GMRES restart value to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_LinearIterativeGMRESRestartSetObj",err,error,*999)

    CALL SOLVER_LINEAR_ITERATIVE_GMRES_RESTART_SET(solver%SOLVER,GMRESRestart,err,error,*999)

    CALL EXITS("CMISSSolver_LinearIterativeGMRESRestartSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeGMRESRestartSetObj",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeGMRESRestartSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeGMRESRestartSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearIterativeMaximumIterationsSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearIterativeMaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_MAXIMUM_ITERATIONS_SET(SOLVER,maximumIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearIterativeMaximumIterationsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeMaximumIterationsSetNumber0",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeMaximumIterationsSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeMaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearIterativeMaximumIterationsSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearIterativeMaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_MAXIMUM_ITERATIONS_SET(SOLVER,maximumIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearIterativeMaximumIterationsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeMaximumIterationsSetNumber1",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeMaximumIterationsSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeMaximumIterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolver_LinearIterativeMaximumIterationsSetObj(solver,maximumIterations,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The iterative linear solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum iterations to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_LinearIterativeMaximumIterationsSetObj",err,error,*999)

    CALL SOLVER_LINEAR_ITERATIVE_MAXIMUM_ITERATIONS_SET(solver%SOLVER,maximumIterations,err,error,*999)

    CALL EXITS("CMISSSolver_LinearIterativeMaximumIterationsSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeMaximumIterationsSetObj",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeMaximumIterationsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeMaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the preconditioner type for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearIterativePreconditionerTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & preconditionerType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: preconditionerType !<The preconditioner type to set. \see OPENCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearIterativePreconditionerTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_PRECONDITIONER_TYPE_SET(SOLVER,preconditionerType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearIterativePreconditionerTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativePreconditionerTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_LinearIterativePreconditionerTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativePreconditionerTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the preconditioner type for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearIterativePreconditionerTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & preconditionerType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: preconditionerType !<The preconditioner type to set. \see OPENCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearIterativePreconditionerTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_PRECONDITIONER_TYPE_SET(SOLVER,preconditionerType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearIterativePreconditionerTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativePreconditionerTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_LinearIterativePreconditionerTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativePreconditionerTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the preconditioner type for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolver_LinearIterativePreconditionerTypeSetObj(solver,preconditionerType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The iterative linear solver to set the preconditioner type for.
    INTEGER(INTG), INTENT(IN) :: preconditionerType !<The preconditioner type to set. \see OPENCMISS_IterativePreconditionerTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_LinearIterativePreconditionerTypeSetObj",err,error,*999)

    CALL SOLVER_LINEAR_ITERATIVE_PRECONDITIONER_TYPE_SET(solver%SOLVER,preconditionerType,err,error,*999)

    CALL EXITS("CMISSSolver_LinearIterativePreconditionerTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativePreconditionerTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_LinearIterativePreconditionerTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativePreconditionerTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearIterativeRelativeToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearIterativeRelativeToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_RELATIVE_TOLERANCE_SET(SOLVER,relativeTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearIterativeRelativeToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeRelativeToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeRelativeToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeRelativeToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearIterativeRelativeToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearIterativeRelativeToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_RELATIVE_TOLERANCE_SET(SOLVER,relativeTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearIterativeRelativeToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeRelativeToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeRelativeToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeRelativeToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum relative tolerance for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolver_LinearIterativeRelativeToleranceSetObj(solver,relativeTolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The iterative linear solver to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the iterative linear solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_LinearIterativeRelativeToleranceSetObj",err,error,*999)

    CALL SOLVER_LINEAR_ITERATIVE_RELATIVE_TOLERANCE_SET(solver%SOLVER,relativeTolerance,err,error,*999)

    CALL EXITS("CMISSSolver_LinearIterativeRelativeToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeRelativeToleranceSetObj",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeRelativeToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeRelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearIterativeTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,iterativeSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: iterativeSolverType !<The iterative solver type to set. \see OPENCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearIterativeTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_TYPE_SET(SOLVER,iterativeSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearIterativeTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for an iterative linear solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearIterativeTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,iterativeSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: iterativeSolverType !<The iterative solver type to set. \see OPENCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearIterativeTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_ITERATIVE_TYPE_SET(SOLVER,iterativeSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearIterativeTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type for an iterative linear solver identified by an object.
  SUBROUTINE CMISSSolver_LinearIterativeTypeSetObj(solver,iterativeSolverType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The iterative linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: iterativeSolverType !<The iterative solver type to set. \see OPENCMISS_IterativeLinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_LinearIterativeTypeSetObj",err,error,*999)

    CALL SOLVER_LINEAR_ITERATIVE_TYPE_SET(solver%SOLVER,iterativeSolverType,err,error,*999)

    CALL EXITS("CMISSSolver_LinearIterativeTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearIterativeTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_LinearIterativeTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearIterativeTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for a linear solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,linearSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: linearSolverType !<The linear solver type to set. \see OPENCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_TYPE_SET(SOLVER,linearSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_LinearTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type for a linear solver identified by an user number.
  SUBROUTINE CMISSSolver_LinearTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,linearSolverType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: linearSolverType !<The linear solver type to set. \see OPENCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_LinearTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_LINEAR_TYPE_SET(SOLVER,linearSolverType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_LinearTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_LinearTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type for a linear solver identified by an object.
  SUBROUTINE CMISSSolver_LinearTypeSetObj(solver,linearSolverType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The linear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: linearSolverType !<The linear solver type to set. \see OPENCMISS_LinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_LinearTypeSetObj",err,error,*999)

    CALL SOLVER_LINEAR_TYPE_SET(solver%SOLVER,linearSolverType,err,error,*999)

    CALL EXITS("CMISSSolver_LinearTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_LinearTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_LinearTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_LinearTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonAbsoluteToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonAbsoluteToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET(SOLVER,absoluteTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonAbsoluteToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonAbsoluteToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolver_NewtonAbsoluteToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonAbsoluteToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonAbsoluteToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,absoluteTolerance, &
    & err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonAbsoluteToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET(SOLVER,absoluteTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonAbsoluteToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonAbsoluteToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolver_NewtonAbsoluteToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonAbsoluteToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Newton solver identified by an object.
  SUBROUTINE CMISSSolver_NewtonAbsoluteToleranceSetObj(solver,absoluteTolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton solver to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NewtonAbsoluteToleranceSetObj",err,error,*999)

    CALL SOLVER_NEWTON_ABSOLUTE_TOLERANCE_SET(solver%SOLVER,absoluteTolerance,err,error,*999)

    CALL EXITS("CMISSSolver_NewtonAbsoluteToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonAbsoluteToleranceSetObj",err,error)
    CALL EXITS("CMISSSolver_NewtonAbsoluteToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonAbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonLineSearchMonitorOutputSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & monitorLinesearchFlag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the linesearch monitoring for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonLineSearchMonitorOutputSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL Solver_NewtonLineSearchMonitorOutputSet(SOLVER,monitorLinesearchFlag,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonLineSearchMonitorOutputSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLineSearchMonitorOutputSetNumber0",err,error)
    CALL EXITS("CMISSSolver_NewtonLineSearchMonitorOutputSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLineSearchMonitorOutputSetNumber0

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonLineSearchMonitorOutputSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & monitorLinesearchFlag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonLineSearchMonitorOutputSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL Solver_NewtonLineSearchMonitorOutputSet(SOLVER,monitorLinesearchFlag,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonLineSearchMonitorOutputSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLineSearchMonitorOutputSetNumber1",err,error)
    CALL EXITS("CMISSSolver_NewtonLineSearchMonitorOutputSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLineSearchMonitorOutputSetNumber1

  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Newton line search solver identified by an object.
  SUBROUTINE CMISSSolver_NewtonLineSearchMonitorOutputSetObj(solver,monitorLinesearchFlag,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton solver to set the linesearch monitoring for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NewtonLineSearchMonitorOutputSetObj",err,error,*999)

    CALL Solver_NewtonLineSearchMonitorOutputSet(solver%SOLVER,monitorLinesearchFlag,err,error,*999)

    CALL EXITS("CMISSSolver_NewtonLineSearchMonitorOutputSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLineSearchMonitorOutputSetObj",err,error)
    CALL EXITS("CMISSSolver_NewtonLineSearchMonitorOutputSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLineSearchMonitorOutputSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonJacobianCalculationTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & jacobianCalculationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonJacobianCalculationTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET(SOLVER,jacobianCalculationType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonJacobianCalculationTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonJacobianCalculationTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_NewtonJacobianCalculationTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonJacobianCalculationTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonJacobianCalculationTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & jacobianCalculationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonJacobianCalculationTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET(SOLVER,jacobianCalculationType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonJacobianCalculationTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonJacobianCalculationTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_NewtonJacobianCalculationTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonJacobianCalculationTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Newton solver identified by an object.
  SUBROUTINE CMISSSolver_NewtonJacobianCalculationTypeSetObj(solver,jacobianCalculationType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NewtonJacobianCalculationTypeSetObj",err,error,*999)

    CALL SOLVER_NEWTON_JACOBIAN_CALCULATION_TYPE_SET(solver%SOLVER,jacobianCalculationType,err,error,*999)

    CALL EXITS("CMISSSolver_NewtonJacobianCalculationTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonJacobianCalculationTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_NewtonJacobianCalculationTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonJacobianCalculationTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonLinearSolverGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,linearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the solver index of the linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonLinearSolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from linear solver
      linearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonLinearSolverGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLinearSolverGetNumber0",err,error)
    CALL EXITS("CMISSSolver_NewtonLinearSolverGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonLinearSolverGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,linearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the Newton linear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonLinearSolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from linear solver
      linearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonLinearSolverGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLinearSolverGetNumber1",err,error)
    CALL EXITS("CMISSSolver_NewtonLinearSolverGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLinearSolverGetNumber1

  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Newton solver identified by an object.
  SUBROUTINE CMISSSolver_NewtonLinearSolverGetObj(solver,linearSolver,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the Newton linear solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: linearSolver !<On return, the Newton linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NewtonLinearSolverGetObj",err,error,*999)

    CALL SOLVER_NEWTON_LINEAR_SOLVER_GET(solver%SOLVER,linearSolver%SOLVER,err,error,*999)

    CALL EXITS("CMISSSolver_NewtonLinearSolverGetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLinearSolverGetObj",err,error)
    CALL EXITS("CMISSSolver_NewtonLinearSolverGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonCellMLSolverGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,CellMLSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: CellMLSolverIndex !<On return, the solver index of the CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,CELLML_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonCellMLSolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(CELLML_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_CELLML_SOLVER_GET(SOLVER,CELLML_SOLVER,err,error,*999)
      !todo: get the solver index from CellML solver
      CellMLSolverIndex=CELLML_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonCellMLSolverGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonCellMLSolverGetNumber0",err,error)
    CALL EXITS("CMISSSolver_NewtonCellMLSolverGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonCellMLSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonCellMLSolverGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,CellMLSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: CellMLSolverIndex !<On return, the Newton CellML solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,CELLML_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonCellMLSolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(CELLML_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_CELLML_SOLVER_GET(SOLVER,CELLML_SOLVER,err,error,*999)
      !todo: get the solver index from CellML solver
      CellMLSolverIndex=CELLML_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonCellMLSolverGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonCellMLSolverGetNumber1",err,error)
    CALL EXITS("CMISSSolver_NewtonCellMLSolverGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonCellMLSolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Newton solver identified by an object.
  SUBROUTINE CMISSSolver_NewtonCellMLSolverGetObj(solver,CellMLSolver,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the Newton CellML solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: CellMLSolver !<On return, the Newton CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NewtonCellMLSolverGetObj",err,error,*999)

    CALL SOLVER_NEWTON_CELLML_SOLVER_GET(solver%SOLVER,CellMLSolver%SOLVER,err,error,*999)

    CALL EXITS("CMISSSolver_NewtonCellMLSolverGetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonCellMLSolverGetObj",err,error)
    CALL EXITS("CMISSSolver_NewtonCellMLSolverGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonCellMLSolverGetObj
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for an Newton linesearch solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonConvergenceTestTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & convergenceTestType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the convergence test for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSSolver_NewtonConvergenceTestTypeSetNumber0",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      CALL Solver_NewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonConvergenceTestTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonConvergenceTestTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_NewtonConvergenceTestTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonConvergenceTestTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonConvergenceTestTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
      & convergenceTestType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSSolver_NewtonConvergenceTestTypeSetNumber1",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
      CALL Solver_NewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonConvergenceTestTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonConvergenceTestTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_NewtonConvergenceTestTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonConvergenceTestTypeSetNumber1
  
  ! 
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for a Newton solver identified by an object.
  SUBROUTINE CMISSSolver_NewtonConvergenceTestTypeSetObj(solver,convergenceTestType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NewtonConvergenceTestTypeSetObj",err,error,*999)

    CALL Solver_NewtonConvergenceTestTypeSet(solver%SOLVER,convergenceTestType,err,error,*999)

    CALL EXITS("CMISSSolver_NewtonConvergenceTestTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonConvergenceTestTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_NewtonConvergenceTestTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonConvergenceTestTypeSetObj

  !
  !================================================================================================================================
  !
  
  !>Sets/changes the line search alpha for an Newton linesearch solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonLineSearchAlphaSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,alpha,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search alpha for.
    REAL(DP), INTENT(IN) :: alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonLineSearchAlphaSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_ALPHA_SET(SOLVER,alpha,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonLineSearchAlphaSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLineSearchAlphaSetNumber0",err,error)
    CALL EXITS("CMISSSolver_NewtonLineSearchAlphaSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLineSearchAlphaSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search alpha for a Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonLineSearchAlphaSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,alpha,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the alpha for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the alpha for.
    REAL(DP), INTENT(IN) :: alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonLineSearchAlphaSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_ALPHA_SET(SOLVER,alpha,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonLineSearchAlphaSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLineSearchAlphaSetNumber1",err,error)
    CALL EXITS("CMISSSolver_NewtonLineSearchAlphaSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLineSearchAlphaSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search alpha for a Newton line search solver identified by an object.
  SUBROUTINE CMISSSolver_NewtonLineSearchAlphaSetObj(solver,alpha,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton line search solver to set the alpha for.
    REAL(DP), INTENT(IN) :: alpha !<The alpha for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NewtonLineSearchAlphaSetObj",err,error,*999)

    CALL SOLVER_NEWTON_LINESEARCH_ALPHA_SET(solver%SOLVER,alpha,err,error,*999)

    CALL EXITS("CMISSSolver_NewtonLineSearchAlphaSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLineSearchAlphaSetObj",err,error)
    CALL EXITS("CMISSSolver_NewtonLineSearchAlphaSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLineSearchAlphaSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for an Newton linesearch solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonLineSearchMaxStepSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,maxStep,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonLineSearchMaxStepSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET(SOLVER,maxStep,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonLineSearchMaxStepSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLineSearchMaxStepSetNumber0",err,error)
    CALL EXITS("CMISSSolver_NewtonLineSearchMaxStepSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLineSearchMaxStepSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonLineSearchMaxStepSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,maxStep,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonLineSearchMaxStepSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET(SOLVER,maxStep,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonLineSearchMaxStepSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLineSearchMaxStepSetNumber1",err,error)
    CALL EXITS("CMISSSolver_NewtonLineSearchMaxStepSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLineSearchMaxStepSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Newton line search solver identified by an object.
  SUBROUTINE CMISSSolver_NewtonLineSearchMaxStepSetObj(solver,maxStep,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton line search solver to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NewtonLineSearchMaxStepSetObj",err,error,*999)

    CALL SOLVER_NEWTON_LINESEARCH_MAXSTEP_SET(solver%SOLVER,maxStep,err,error,*999)

    CALL EXITS("CMISSSolver_NewtonLineSearchMaxStepSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLineSearchMaxStepSetObj",err,error)
    CALL EXITS("CMISSSolver_NewtonLineSearchMaxStepSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLineSearchMaxStepSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for an Newton linesearch solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonLineSearchStepTolSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,stepTol,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonLineSearchStepTolSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_STEPTOL_SET(SOLVER,stepTol,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonLineSearchStepTolSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLineSearchStepTolSetNumber0",err,error)
    CALL EXITS("CMISSSolver_NewtonLineSearchStepTolSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLineSearchStepTolSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonLineSearchStepTolSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,stepTol,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonLineSearchStepTolSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_STEPTOL_SET(SOLVER,stepTol,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonLineSearchStepTolSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLineSearchStepTolSetNumber1",err,error)
    CALL EXITS("CMISSSolver_NewtonLineSearchStepTolSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLineSearchStepTolSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Newton line search solver identified by an object.
  SUBROUTINE CMISSSolver_NewtonLineSearchStepTolSetObj(solver,stepTol,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton line search solver to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NewtonLineSearchStepTolSetObj",err,error,*999)

    CALL SOLVER_NEWTON_LINESEARCH_STEPTOL_SET(solver%SOLVER,stepTol,err,error,*999)

    CALL EXITS("CMISSSolver_NewtonLineSearchStepTolSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLineSearchStepTolSetObj",err,error)
    CALL EXITS("CMISSSolver_NewtonLineSearchStepTolSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLineSearchStepTolSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search type for an Newton linesearch solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonLineSearchTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,lineSearchType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Newton line search solver to set. \see OPENCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonLineSearchTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_TYPE_SET(SOLVER,lineSearchType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonLineSearchTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLineSearchTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_NewtonLineSearchTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLineSearchTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonLineSearchTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,lineSearchType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Newton line search solver to set. \see OPENCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonLineSearchTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_LINESEARCH_TYPE_SET(SOLVER,lineSearchType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonLineSearchTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLineSearchTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_NewtonLineSearchTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLineSearchTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Newton line search solver identified by an object.
  SUBROUTINE CMISSSolver_NewtonLineSearchTypeSetObj(solver,lineSearchType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Newton line search solver to set. \see OPENCMISS_NewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NewtonLineSearchTypeSetObj",err,error,*999)

    CALL SOLVER_NEWTON_LINESEARCH_TYPE_SET(solver%SOLVER,lineSearchType,err,error,*999)

    CALL EXITS("CMISSSolver_NewtonLineSearchTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonLineSearchTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_NewtonLineSearchTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonLineSearchTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonMaximumFunctionEvaluationsSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & maximumFunctionEvaluations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonMaximumFunctionEvaluationsSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_MAXIMUM_FUNCTION_EVALUATIONS_SET(SOLVER,maximumFunctionEvaluations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonMaximumFunctionEvaluationsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonMaximumFunctionEvaluationsSetNumber0",err,error)
    CALL EXITS("CMISSSolver_NewtonMaximumFunctionEvaluationsSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonMaximumFunctionEvaluationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonMaximumFunctionEvaluationsSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & maximumFunctionEvaluations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonMaximumFunctionEvaluationsSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_MAXIMUM_FUNCTION_EVALUATIONS_SET(SOLVER,maximumFunctionEvaluations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonMaximumFunctionEvaluationsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonMaximumFunctionEvaluationsSetNumber1",err,error)
    CALL EXITS("CMISSSolver_NewtonMaximumFunctionEvaluationsSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonMaximumFunctionEvaluationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Newton solver identified by an object.
  SUBROUTINE CMISSSolver_NewtonMaximumFunctionEvaluationsSetObj(solver,maximumFunctionEvaluations,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton solver to set the maximum number of function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NewtonMaximumFunctionEvaluationsSetObj",err,error,*999)

    CALL SOLVER_NEWTON_MAXIMUM_FUNCTION_EVALUATIONS_SET(solver%SOLVER,maximumFunctionEvaluations,err,error,*999)

    CALL EXITS("CMISSSolver_NewtonMaximumFunctionEvaluationsSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonMaximumFunctionEvaluationsSetObj",err,error)
    CALL EXITS("CMISSSolver_NewtonMaximumFunctionEvaluationsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonMaximumFunctionEvaluationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonMaximumIterationsSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonMaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET(SOLVER,maximumIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonMaximumIterationsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonMaximumIterationsSetNumber0",err,error)
    CALL EXITS("CMISSSolver_NewtonMaximumIterationsSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonMaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonMaximumIterationsSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,maximumIterations, &
    & err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonMaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET(SOLVER,maximumIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonMaximumIterationsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonMaximumIterationsSetNumber1",err,error)
    CALL EXITS("CMISSSolver_NewtonMaximumIterationsSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonMaximumIterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Newton solver identified by an object.
  SUBROUTINE CMISSSolver_NewtonMaximumIterationsSetObj(solver,maximumIterations,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton solver to set the maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NewtonMaximumIterationsSetObj",err,error,*999)

    CALL SOLVER_NEWTON_MAXIMUM_ITERATIONS_SET(solver%SOLVER,maximumIterations,err,error,*999)

    CALL EXITS("CMISSSolver_NewtonMaximumIterationsSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonMaximumIterationsSetObj",err,error)
    CALL EXITS("CMISSSolver_NewtonMaximumIterationsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonMaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonRelativeToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonRelativeToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_RELATIVE_TOLERANCE_SET(SOLVER,relativeTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonRelativeToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonRelativeToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolver_NewtonRelativeToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonRelativeToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonRelativeToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,relativeTolerance, &
    & err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonRelativeToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_RELATIVE_TOLERANCE_SET(SOLVER,relativeTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonRelativeToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonRelativeToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolver_NewtonRelativeToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonRelativeToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Newton solver identified by an object.
  SUBROUTINE CMISSSolver_NewtonRelativeToleranceSetObj(solver,relativeTolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton solver to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NewtonRelativeToleranceSetObj",err,error,*999)

    CALL SOLVER_NEWTON_RELATIVE_TOLERANCE_SET(solver%SOLVER,relativeTolerance,err,error,*999)

    CALL EXITS("CMISSSolver_NewtonRelativeToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonRelativeToleranceSetObj",err,error)
    CALL EXITS("CMISSSolver_NewtonRelativeToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonRelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for an Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonSolutionToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & solutionTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonSolutionToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_SOLUTION_TOLERANCE_SET(SOLVER,solutionTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonSolutionToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonSolutionToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolver_NewtonSolutionToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonSolutionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonSolutionToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,solutionTolerance, &
    & err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The absolulte tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonSolutionToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_SOLUTION_TOLERANCE_SET(SOLVER,solutionTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonSolutionToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonSolutionToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolver_NewtonSolutionToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonSolutionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Newton solver identified by an object.
  SUBROUTINE CMISSSolver_NewtonSolutionToleranceSetObj(solver,solutionTolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton solver to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NewtonSolutionToleranceSetObj",err,error,*999)

    CALL SOLVER_NEWTON_SOLUTION_TOLERANCE_SET(solver%SOLVER,solutionTolerance,err,error,*999)

    CALL EXITS("CMISSSolver_NewtonSolutionToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonSolutionToleranceSetObj",err,error)
    CALL EXITS("CMISSSolver_NewtonSolutionToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonSolutionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Newton trust region solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonTrustRegionDelta0SetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,delta0,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonTrustRegionDelta0SetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TRUSTREGION_DELTA0_SET(SOLVER,delta0,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonTrustRegionDelta0SetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonTrustRegionDelta0SetNumber0",err,error)
    CALL EXITS("CMISSSolver_NewtonTrustRegionDelta0SetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonTrustRegionDelta0SetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Newton trust region solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonTrustRegionDelta0SetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,delta0,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonTrustRegionDelta0SetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TRUSTREGION_DELTA0_SET(SOLVER,delta0,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonTrustRegionDelta0SetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonTrustRegionDelta0SetNumber1",err,error)
    CALL EXITS("CMISSSolver_NewtonTrustRegionDelta0SetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonTrustRegionDelta0SetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Newton trust region solver identified by an object.
  SUBROUTINE CMISSSolver_NewtonTrustRegionDelta0SetObj(solver,delta0,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton trust region solver to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NewtonTrustRegionDelta0SetObj",err,error,*999)

    CALL SOLVER_NEWTON_TRUSTREGION_DELTA0_SET(solver%SOLVER,delta0,err,error,*999)

    CALL EXITS("CMISSSolver_NewtonTrustRegionDelta0SetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonTrustRegionDelta0SetObj",err,error)
    CALL EXITS("CMISSSolver_NewtonTrustRegionDelta0SetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonTrustRegionDelta0SetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Newton trust region solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonTrustRegionToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,tolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonTrustRegionToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET(SOLVER,tolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonTrustRegionToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonTrustRegionToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolver_NewtonTrustRegionToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonTrustRegionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Newton trust region solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonTrustRegionToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,tolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonTrustRegionToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET(SOLVER,tolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonTrustRegionToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonTrustRegionToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolver_NewtonTrustRegionToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonTrustRegionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Newton trust region solver identified by an object.
  SUBROUTINE CMISSSolver_NewtonTrustRegionToleranceSetObj(solver,tolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton trust region solver to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NewtonTrustRegionToleranceSetObj",err,error,*999)

    CALL SOLVER_NEWTON_TRUSTREGION_TOLERANCE_SET(solver%SOLVER,tolerance,err,error,*999)

    CALL EXITS("CMISSSolver_NewtonTrustRegionToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonTrustRegionToleranceSetObj",err,error)
    CALL EXITS("CMISSSolver_NewtonTrustRegionToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonTrustRegionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,newtonSolveType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: newtonSolveType !<The type of the Newton solver to set. \see OPENCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TYPE_SET(SOLVER,newtonSolveType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_NewtonTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_NewtonTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,newtonSolveType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: newtonSolveType !<The type of the Newton solver to set. \see OPENCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NewtonTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NEWTON_TYPE_SET(SOLVER,newtonSolveType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NewtonTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_NewtonTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a Newton solver identified by an object.
  SUBROUTINE CMISSSolver_NewtonTypeSetObj(solver,newtonSolveType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: newtonSolveType !<The type of the Newton solver to set. \see OPENCMISS_NewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NewtonTypeSetObj",err,error,*999)

    CALL SOLVER_NEWTON_TYPE_SET(solver%SOLVER,newtonSolveType,err,error,*999)

    CALL EXITS("CMISSSolver_NewtonTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NewtonTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_NewtonTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NewtonTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for an Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonAbsoluteToleranceSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonAbsoluteToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_ABSOLUTE_TOLERANCE_SET(SOLVER,absoluteTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonAbsoluteToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonAbsoluteToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonAbsoluteToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonAbsoluteToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonAbsoluteToleranceSetNumber1(problemUserNumber, &
      & controlLoopIdentifiers,solverIndex,absoluteTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the absolute tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonAbsoluteToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_ABSOLUTE_TOLERANCE_SET(SOLVER,absoluteTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonAbsoluteToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonAbsoluteToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonAbsoluteToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonAbsoluteToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the absolute tolerance for a Quasi-Newton solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonAbsoluteToleranceSetObj(solver,absoluteTolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the absolute tolerance for.
    REAL(DP), INTENT(IN) :: absoluteTolerance !<The absolute tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonAbsoluteToleranceSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_ABSOLUTE_TOLERANCE_SET(solver%SOLVER,absoluteTolerance,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonAbsoluteToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonAbsoluteToleranceSetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonAbsoluteToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonAbsoluteToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Quasi-Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetNumber0(problemUserNumber, &
      & controlLoopIdentifier,solverIndex,monitorLinesearchFlag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the linesearch monitoring for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL Solver_QuasiNewtonLineSearchMonitorOutputSet(SOLVER,monitorLinesearchFlag,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetNumber0

  !
  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Quasi-Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
      & monitorLinesearchFlag,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the linesearch monitoring for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the absolute tolerance for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL Solver_QuasiNewtonLineSearchMonitorOutputSet(SOLVER,monitorLinesearchFlag,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetNumber1

  !================================================================================================================================
  !

  !>Enables/disables output monitoring for a nonlinear Quasi-Newton line search solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetObj(solver,monitorLinesearchFlag,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the linesearch monitoring for.
    LOGICAL, INTENT(IN) :: monitorLinesearchFlag !<Flag to determine whether to enable/disable linsearch monitor output.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetObj",err,error,*999)

    CALL Solver_QuasiNewtonLineSearchMonitorOutputSet(solver%SOLVER,monitorLinesearchFlag,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonLineSearchMonitorOutputSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for an Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonJacobianCalculationTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & jacobianCalculationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Quasi-Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonJacobianCalculationTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_JACOBIAN_CALCULATION_TYPE_SET(SOLVER,jacobianCalculationType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonJacobianCalculationTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonJacobianCalculationTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonJacobianCalculationTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonJacobianCalculationTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonJacobianCalculationTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
      & jacobianCalculationType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Quasi-Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonJacobianCalculationTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_JACOBIAN_CALCULATION_TYPE_SET(SOLVER,jacobianCalculationType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonJacobianCalculationTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonJacobianCalculationTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonJacobianCalculationTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonJacobianCalculationTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the Jacobian calculation type for a Quasi-Newton solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonJacobianCalculationTypeSetObj(solver,jacobianCalculationType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the Jacobian calculation type for.
    INTEGER(INTG), INTENT(IN) :: jacobianCalculationType !<The Jacobian calculation type for the Quasi-Newton solver to set. \see OPENCMISS_JacobianCalculationTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonJacobianCalculationTypeSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_JACOBIAN_CALCULATION_TYPE_SET(solver%SOLVER,jacobianCalculationType,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonJacobianCalculationTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonJacobianCalculationTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonJacobianCalculationTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonJacobianCalculationTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonLinearSolverGetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,linearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the solver index of the linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonLinearSolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from linear solver
      linearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonLinearSolverGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonLinearSolverGetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonLinearSolverGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonLinearSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonLinearSolverGetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,linearSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Quasi-Newton linear solver for.
    INTEGER(INTG), INTENT(OUT) :: linearSolverIndex !<On return, the Quasi-Newton linear solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,LINEAR_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonLinearSolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(LINEAR_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_LINEAR_SOLVER_GET(SOLVER,LINEAR_SOLVER,err,error,*999)
      !todo: get the solver index from linear solver
      linearSolverIndex=LINEAR_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonLinearSolverGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonLinearSolverGetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonLinearSolverGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonLinearSolverGetNumber1

  !================================================================================================================================
  !

  !>Returns the linear solver associated with a Quasi-Newton solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonLinearSolverGetObj(solver,linearSolver,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the Quasi-Newton linear solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: linearSolver !<On return, the Quasi-Newton linear solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonLinearSolverGetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_LINEAR_SOLVER_GET(solver%SOLVER,linearSolver%SOLVER,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonLinearSolverGetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonLinearSolverGetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonLinearSolverGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonLinearSolverGetObj

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonCellMLSolverGetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,CellMLSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: CellMLSolverIndex !<On return, the solver index of the CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,CELLML_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonCellMLSolverGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(CELLML_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_CELLML_SOLVER_GET(SOLVER,CELLML_SOLVER,err,error,*999)
      !todo: get the solver index from CellML solver
      CellMLSolverIndex=CELLML_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonCellMLSolverGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonCellMLSolverGetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonCellMLSolverGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonCellMLSolverGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonCellMLSolverGetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,CellMLSolverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the Quasi-Newton CellML solver for.
    INTEGER(INTG), INTENT(OUT) :: CellMLSolverIndex !<On return, the Quasi-Newton CellML solver index.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER,CELLML_SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonCellMLSolverGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(CELLML_SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_CELLML_SOLVER_GET(SOLVER,CELLML_SOLVER,err,error,*999)
      !todo: get the solver index from CellML solver
      CellMLSolverIndex=CELLML_SOLVER%GLOBAL_NUMBER
      CALL FLAG_ERROR("Not implemented.",err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonCellMLSolverGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonCellMLSolverGetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonCellMLSolverGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonCellMLSolverGetNumber1

  !
  !================================================================================================================================
  !

  !>Returns the CellML solver associated with a Quasi-Newton solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonCellMLSolverGetObj(solver,CellMLSolver,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the Quasi-Newton CellML solver for.
    TYPE(CMISSSolverType), INTENT(INOUT) :: CellMLSolver !<On return, the Quasi-Newton CellML solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonCellMLSolverGetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_CELLML_SOLVER_GET(solver%SOLVER,CellMLSolver%SOLVER,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonCellMLSolverGetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonCellMLSolverGetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonCellMLSolverGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonCellMLSolverGetObj
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for an Quasi-Newton linesearch solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonConvergenceTestTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & convergenceTestType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the convergence test for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSSolver_QuasiNewtonConvergenceTestTypeSetNumber0",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifier,solverIndex,solver,err,error,*999)
      CALL Solver_QuasiNewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonConvergenceTestTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonConvergenceTestTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonConvergenceTestTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonConvergenceTestTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonConvergenceTestTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
      & convergenceTestType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: problem
    TYPE(SOLVER_TYPE), POINTER :: solver
    TYPE(VARYING_STRING) :: localError

    CALL ENTERS("CMISSSolver_QuasiNewtonConvergenceTestTypeSetNumber1",err,error,*999)

    NULLIFY(problem)
    NULLIFY(solver)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,problem,err,error,*999)
    IF(ASSOCIATED(problem)) THEN
      CALL PROBLEM_SOLVER_GET(problem,controlLoopIdentifiers,solverIndex,solver,err,error,*999)
      CALL Solver_QuasiNewtonConvergenceTestTypeSet(solver,convergenceTestType,err,error,*999)
    ELSE
      localError="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(localError,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonConvergenceTestTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonConvergenceTestTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonConvergenceTestTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonConvergenceTestTypeSetNumber1
  
  ! 
  !================================================================================================================================
  !

  !>Sets/changes the convergence test type for a Quasi-Newton solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonConvergenceTestTypeSetObj(solver,convergenceTestType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the convergence test type for.
    INTEGER(INTG), INTENT(IN) :: convergenceTestType !<The convergence test type for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonConvergenceTestTypeSetObj",err,error,*999)

    CALL Solver_QuasiNewtonConvergenceTestTypeSet(solver%SOLVER,convergenceTestType,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonConvergenceTestTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonConvergenceTestTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonConvergenceTestTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonConvergenceTestTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for an Quasi-Newton linesearch solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonLineSearchMaxStepSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,maxStep,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonLineSearchMaxStepSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_LINESEARCH_MAXSTEP_SET(SOLVER,maxStep,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchMaxStepSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonLineSearchMaxStepSetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchMaxStepSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonLineSearchMaxStepSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Quasi-Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonLineSearchMaxStepSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,maxStep,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum step for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonLineSearchMaxStepSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_LINESEARCH_MAXSTEP_SET(SOLVER,maxStep,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchMaxStepSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonLineSearchMaxStepSetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchMaxStepSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonLineSearchMaxStepSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search maximum step for a Quasi-Newton line search solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonLineSearchMaxStepSetObj(solver,maxStep,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton line search solver to set the maximum step for.
    REAL(DP), INTENT(IN) :: maxStep !<The maximum step for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonLineSearchMaxStepSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_LINESEARCH_MAXSTEP_SET(solver%SOLVER,maxStep,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchMaxStepSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonLineSearchMaxStepSetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchMaxStepSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonLineSearchMaxStepSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for an Quasi-Newton linesearch solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonLineSearchStepTolSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,stepTol,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonLineSearchStepTolSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_LINESEARCH_STEPTOL_SET(SOLVER,stepTol,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchStepTolSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonLineSearchStepTolSetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchStepTolSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonLineSearchStepTolSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Quasi-Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonLineSearchStepTolSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,stepTol,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the step tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonLineSearchStepTolSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_LINESEARCH_STEPTOL_SET(SOLVER,stepTol,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchStepTolSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonLineSearchStepTolSetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchStepTolSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonLineSearchStepTolSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the line search step tolerance for a Quasi-Newton line search solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonLineSearchStepTolSetObj(solver,stepTol,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton line search solver to set the step tolerance for.
    REAL(DP), INTENT(IN) :: stepTol !<The step tolerance for the Quasi-Newton line search solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonLineSearchStepTolSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_LINESEARCH_STEPTOL_SET(solver%SOLVER,stepTol,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchStepTolSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonLineSearchStepTolSetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchStepTolSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonLineSearchStepTolSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the line search type for an Quasi-Newton linesearch solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonLineSearchTypeSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,lineSearchType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Quasi-Newton line search solver to set. \see OPENCMISS_QuasiNewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonLineSearchTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_LINESEARCH_TYPE_SET(SOLVER,lineSearchType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonLineSearchTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonLineSearchTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Quasi-Newton line search solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonLineSearchTypeSetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,lineSearchType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Quasi-Newton line search solver to set. \see OPENCMISS_QuasiNewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonLineSearchTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_LINESEARCH_TYPE_SET(SOLVER,lineSearchType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonLineSearchTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonLineSearchTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of line search for a Quasi-Newton line search solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonLineSearchTypeSetObj(solver,lineSearchType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton line search solver to set the line search type for.
    INTEGER(INTG), INTENT(IN) :: lineSearchType !<The type of line search for the Quasi-Newton line search solver to set. \see OPENCMISS_QuasiNewtonLineSearchTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonLineSearchTypeSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_LINESEARCH_TYPE_SET(solver%SOLVER,lineSearchType,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonLineSearchTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonLineSearchTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonLineSearchTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for an Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
      & maximumFunctionEvaluations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_MAXIMUM_FUNCTION_EVALUATIONS_SET(SOLVER,maximumFunctionEvaluations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
      & maximumFunctionEvaluations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_MAXIMUM_FUNCTION_EVALUATIONS_SET(SOLVER,maximumFunctionEvaluations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of function evaluations for a Quasi-Newton solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetObj(solver,maximumFunctionEvaluations,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the maximum number of function evaluations for.
    INTEGER(INTG), INTENT(IN) :: maximumFunctionEvaluations !<The maximum number of function evaluations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_MAXIMUM_FUNCTION_EVALUATIONS_SET(solver%SOLVER,maximumFunctionEvaluations,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonMaximumFunctionEvaluationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for an Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonMaximumIterationsSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonMaximumIterationsSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_MAXIMUM_ITERATIONS_SET(SOLVER,maximumIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonMaximumIterationsSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonMaximumIterationsSetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonMaximumIterationsSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonMaximumIterationsSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonMaximumIterationsSetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,maximumIterations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the maximum iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonMaximumIterationsSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_MAXIMUM_ITERATIONS_SET(SOLVER,maximumIterations,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonMaximumIterationsSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonMaximumIterationsSetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonMaximumIterationsSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonMaximumIterationsSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the maximum number of iterations for a Quasi-Newton solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonMaximumIterationsSetObj(solver,maximumIterations,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the maximum number of iterations for.
    INTEGER(INTG), INTENT(IN) :: maximumIterations !<The maximum number of iterations for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonMaximumIterationsSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_MAXIMUM_ITERATIONS_SET(solver%SOLVER,maximumIterations,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonMaximumIterationsSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonMaximumIterationsSetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonMaximumIterationsSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonMaximumIterationsSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for an Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonRelativeToleranceSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonRelativeToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_RELATIVE_TOLERANCE_SET(SOLVER,relativeTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonRelativeToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonRelativeToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonRelativeToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonRelativeToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonRelativeToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,relativeTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the relative tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonRelativeToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_RELATIVE_TOLERANCE_SET(SOLVER,relativeTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonRelativeToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonRelativeToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonRelativeToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonRelativeToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the relative tolerance for a Quasi-Newton solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonRelativeToleranceSetObj(solver,relativeTolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the relative tolerance for.
    REAL(DP), INTENT(IN) :: relativeTolerance !<The relative tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonRelativeToleranceSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_RELATIVE_TOLERANCE_SET(solver%SOLVER,relativeTolerance,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonRelativeToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonRelativeToleranceSetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonRelativeToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonRelativeToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for an Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonSolutionToleranceSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,solutionTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonSolutionToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_SOLUTION_TOLERANCE_SET(SOLVER,solutionTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonSolutionToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonSolutionToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonSolutionToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonSolutionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonSolutionToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers, &
    & solverIndex,solutionTolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the solution tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The absolulte tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonSolutionToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_SOLUTION_TOLERANCE_SET(SOLVER,solutionTolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonSolutionToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonSolutionToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonSolutionToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonSolutionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the solution tolerance for a Quasi-Newton solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonSolutionToleranceSetObj(solver,solutionTolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the solution tolerance for.
    REAL(DP), INTENT(IN) :: solutionTolerance !<The solution tolerance for the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonSolutionToleranceSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_SOLUTION_TOLERANCE_SET(solver%SOLVER,solutionTolerance,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonSolutionToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonSolutionToleranceSetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonSolutionToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonSolutionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Quasi-Newton trust region solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonTrustRegionDelta0SetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,delta0,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonTrustRegionDelta0SetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_TRUSTREGION_DELTA0_SET(SOLVER,delta0,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonTrustRegionDelta0SetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonTrustRegionDelta0SetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonTrustRegionDelta0SetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonTrustRegionDelta0SetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Quasi-Newton trust region solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonTrustRegionDelta0SetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,delta0,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton trust region solver to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the delta0 for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonTrustRegionDelta0SetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_TRUSTREGION_DELTA0_SET(SOLVER,delta0,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonTrustRegionDelta0SetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonTrustRegionDelta0SetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonTrustRegionDelta0SetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonTrustRegionDelta0SetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the delta0 for a Quasi-Newton trust region solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonTrustRegionDelta0SetObj(solver,delta0,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton trust region solver to set the delta0 for.
    REAL(DP), INTENT(IN) :: delta0 !<The delta0 for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonTrustRegionDelta0SetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_TRUSTREGION_DELTA0_SET(solver%SOLVER,delta0,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonTrustRegionDelta0SetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonTrustRegionDelta0SetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonTrustRegionDelta0SetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonTrustRegionDelta0SetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Quasi-Newton trust region solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonTrustRegionToleranceSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,tolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonTrustRegionToleranceSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_TRUSTREGION_TOLERANCE_SET(SOLVER,tolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonTrustRegionToleranceSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonTrustRegionToleranceSetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonTrustRegionToleranceSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonTrustRegionToleranceSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Quasi-Newton trust region solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonTrustRegionToleranceSetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,tolerance,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton trust region solver to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the tolerance for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonTrustRegionToleranceSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_TRUSTREGION_TOLERANCE_SET(SOLVER,tolerance,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonTrustRegionToleranceSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonTrustRegionToleranceSetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonTrustRegionToleranceSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonTrustRegionToleranceSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the tolerance for a Quasi-Newton trust region solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonTrustRegionToleranceSetObj(solver,tolerance,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton trust region solver to set the tolerance for.
    REAL(DP), INTENT(IN) :: tolerance !<The tolerance for the Quasi-Newton trust region solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonTrustRegionToleranceSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_TRUSTREGION_TOLERANCE_SET(solver%SOLVER,tolerance,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonTrustRegionToleranceSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonTrustRegionToleranceSetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonTrustRegionToleranceSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonTrustRegionToleranceSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the restart of a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonRestartSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,quasiNewtonRestart,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestart !<The restart of the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonRestartSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_RESTART_SET(SOLVER,quasiNewtonRestart,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonRestartSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonRestartSetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonRestartSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonRestartSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the restart of a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonRestartSetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,quasiNewtonRestart,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestart !<The restart of the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonRestartSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_RESTART_SET(SOLVER,quasiNewtonRestart,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonRestartSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonRestartSetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonRestartSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonRestartSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the restart of a Quasi-Newton solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonRestartSetObj(solver,quasiNewtonRestart,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestart !<The restart of the Quasi-Newton solver to set.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonRestartSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_RESTART_SET(solver%SOLVER,quasiNewtonRestart,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonRestartSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonRestartSetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonRestartSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonRestartSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the restart type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonRestartTypeSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,quasiNewtonRestartType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestartType !<The restart type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonRestartTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonRestartTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_RESTART_TYPE_SET(SOLVER,quasiNewtonRestartType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonRestartTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonRestartTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonRestartTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonRestartTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the restart type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonRestartTypeSetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,quasiNewtonRestartType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestartType !<The restart type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonRestartTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonRestartTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_RESTART_TYPE_SET(SOLVER,quasiNewtonRestartType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonRestartTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonRestartTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonRestartTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonRestartTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the restart type of a Quasi-Newton solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonRestartTypeSetObj(solver,quasiNewtonRestartType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonRestartType !<The restart type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonRestartTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonRestartTypeSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_RESTART_TYPE_SET(solver%SOLVER,quasiNewtonRestartType,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonRestartTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonRestartTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonRestartTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonRestartTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the scale type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonScaleTypeSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,quasiNewtonScaleType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonScaleType !<The scale type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonScaleTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonScaleTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_SCALE_TYPE_SET(SOLVER,quasiNewtonScaleType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonScaleTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonScaleTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonScaleTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonScaleTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the scale type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonScaleTypeSetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,quasiNewtonScaleType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonScaleType !<The scale type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonScaleTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonScaleTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_SCALE_TYPE_SET(SOLVER,quasiNewtonScaleType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonScaleTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonScaleTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonScaleTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonScaleTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the scale type of a Quasi-Newton solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonScaleTypeSetObj(solver,quasiNewtonScaleType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonScaleType !<The scale type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonScaleTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonScaleTypeSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_SCALE_TYPE_SET(solver%SOLVER,quasiNewtonScaleType,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonScaleTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonScaleTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonScaleTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonScaleTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonSolveTypeSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,quasiNewtonSolveType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonSolveType !<The type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonSolveTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_SOLVE_TYPE_SET(SOLVER,quasiNewtonSolveType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonSolveTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonSolveTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonSolveTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonSolveTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonSolveTypeSetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,quasiNewtonSolveType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonSolveType !<The type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonSolveTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_SOLVE_TYPE_SET(SOLVER,quasiNewtonSolveType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonSolveTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonSolveTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonSolveTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonSolveTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonSolveTypeSetObj(solver,quasiNewtonSolveType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonSolveType !<The type of the Quasi-Newton solver to set. \see OPENCMISS_QuasiNewtonSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonSolveTypeSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_SOLVE_TYPE_SET(solver%SOLVER,quasiNewtonSolveType,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonSolveTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonSolveTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonSolveTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonSolveTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonTypeSetNumber0(problemUserNumber,controlLoopIdentifier, &
      & solverIndex,quasiNewtonType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonType !<The Quasi-Newton type to set. \see OPENCMISS_QuasiNewtonTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_TYPE_SET(SOLVER,quasiNewtonType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an user number.
  SUBROUTINE CMISSSolver_QuasiNewtonTypeSetNumber1(problemUserNumber,controlLoopIdentifiers, &
      & solverIndex,quasiNewtonType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonType !<The Quasi-Newton type to set. \see OPENCMISS_QuasiNewtonTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_QuasiNewtonTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_QUASI_NEWTON_TYPE_SET(SOLVER,quasiNewtonType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_QuasiNewtonTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a Quasi-Newton solver identified by an object.
  SUBROUTINE CMISSSolver_QuasiNewtonTypeSetObj(solver,quasiNewtonType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The Quasi-Newton solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: quasiNewtonType !<The Quasi-Newton type to set. \see OPENCMISS_QuasiNewtonTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_QuasiNewtonTypeSetObj",err,error,*999)

    CALL SOLVER_QUASI_NEWTON_TYPE_SET(solver%SOLVER,quasiNewtonType,err,error,*999)

    CALL EXITS("CMISSSolver_QuasiNewtonTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_QuasiNewtonTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_QuasiNewtonTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_QuasiNewtonTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a nonlinear solver identified by an user number.
  SUBROUTINE CMISSSolver_NonlinearTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,nonlinearSolveType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: nonlinearSolveType !<The type of the nonlinear solver to set. \see OPENCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NonlinearTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NONLINEAR_TYPE_SET(SOLVER,nonlinearSolveType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NonlinearTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_NonlinearTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_NonlinearTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NonlinearTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of a nonlinear solver identified by an user number.
  SUBROUTINE CMISSSolver_NonlinearTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,nonlinearSolveType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the type for.
    INTEGER(INTG), INTENT(IN) :: nonlinearSolveType !<The type of the nonlinear solver to set. \see OPENCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_NonlinearTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_NONLINEAR_TYPE_SET(SOLVER,nonlinearSolveType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_NonlinearTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_NonlinearTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_NonlinearTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NonlinearTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the type of a nonlinear solver identified by an object.
  SUBROUTINE CMISSSolver_NonlinearTypeSetObj(solver,nonlinearSolveType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The nonlinear solver to set the type for.
    INTEGER(INTG), INTENT(IN) :: nonlinearSolveType !<The type of the nonlinear solver to set. \see OPENCMISS_NonlinearSolverTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_NonlinearTypeSetObj",err,error,*999)

    CALL SOLVER_NONLINEAR_TYPE_SET(solver%SOLVER,nonlinearSolveType,err,error,*999)

    CALL EXITS("CMISSSolver_NonlinearTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_NonlinearTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_NonlinearTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_NonlinearTypeSetObj

  !
  !================================================================================================================================
  !

  !>Sets/changes the output type for a solver identified by an user number.
  SUBROUTINE CMISSSolver_OutputTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The type of solver output to set. \see OPENCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_OutputTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_OUTPUT_TYPE_SET(SOLVER,outputType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_OutputTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_OutputTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolver_OutputTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_OutputTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the type of output for a solver identified by an user number.
  SUBROUTINE CMISSSolver_OutputTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,outputType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the output type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The type of solver output to set. \see OPENCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_OutputTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_OUTPUT_TYPE_SET(SOLVER,outputType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_OutputTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_OutputTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolver_OutputTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_OutputTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the output type for a solver identified by an object.
  SUBROUTINE CMISSSolver_OutputTypeSetObj(solver,outputType,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to set the output type for.
    INTEGER(INTG), INTENT(IN) :: outputType !<The type of solver output to set. \see OPENCMISS_SolverOutputTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_OutputTypeSetObj",err,error,*999)

    CALL SOLVER_OUTPUT_TYPE_SET(solver%SOLVER,outputType,err,error,*999)

    CALL EXITS("CMISSSolver_OutputTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_OutputTypeSetObj",err,error)
    CALL EXITS("CMISSSolver_OutputTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_OutputTypeSetObj

  !
  !================================================================================================================================
  !

  !>Returns the solver equations for a solver identified by an user number.
  SUBROUTINE CMISSSolver_SolverEquationsGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,solverEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_SolverEquationsGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,solverEquations%SOLVER_EQUATIONS,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_SolverEquationsGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolver_SolverEquationsGetNumber0",err,error)
    CALL EXITS("CMISSSolver_SolverEquationsGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_SolverEquationsGetNumber0

  !
  !================================================================================================================================
  !

  !>Returns the solver equations for a solver identified by an user number.
  SUBROUTINE CMISSSolver_SolverEquationsGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,solverEquations,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolver_SolverEquationsGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,solverEquations%SOLVER_EQUATIONS,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolver_SolverEquationsGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolver_SolverEquationsGetNumber1",err,error)
    CALL EXITS("CMISSSolver_SolverEquationsGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_SolverEquationsGetNumber1

  !================================================================================================================================
  !

  !>Returns the solver equations for a solver identified by an object.
  SUBROUTINE CMISSSolver_SolverEquationsGetObj(solver,solverEquations,err)

    !Argument variables
    TYPE(CMISSSolverType), INTENT(IN) :: solver !<The solver to get the solver equations for.
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: solverEquations !<On return, the solver equations for the solver.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolver_SolverEquationsGetObj",err,error,*999)

    CALL SOLVER_SOLVER_EQUATIONS_GET(solver%SOLVER,solverEquations%SOLVER_EQUATIONS,err,error,*999)

    CALL EXITS("CMISSSolver_SolverEquationsGetObj")
    RETURN
999 CALL ERRORS("CMISSSolver_SolverEquationsGetObj",err,error)
    CALL EXITS("CMISSSolver_SolverEquationsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolver_SolverEquationsGetObj

  !
  !================================================================================================================================
  !

  !>Adds equations sets to solver equations identified by an user number.
  SUBROUTINE CMISSSolverEquations_EquationsSetAddNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & regionUserNumber,equationsSetUserNumber,equationsSetIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region with the equations set to add.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to add.
    INTEGER(INTG), INTENT(OUT) :: equationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquations_EquationsSetAddNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
      IF(ASSOCIATED(REGION)) THEN
        CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
        IF(ASSOCIATED(EQUATIONS_SET)) THEN
          CALL SOLVER_EQUATIONS_EQUATIONS_SET_ADD(SOLVER_EQUATIONS,EQUATIONS_SET,equationsSetIndex,err,error,*999)
        ELSE
          LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolverEquations_EquationsSetAddNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_EquationsSetAddNumber0",err,error)
    CALL EXITS("CMISSSolverEquations_EquationsSetAddNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_EquationsSetAddNumber0

  !
  !================================================================================================================================
  !

  !>Adds equations sets to solver equations identified by an user number.
  SUBROUTINE CMISSSolverEquations_EquationsSetAddNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & regionUserNumber,equationsSetUserNumber,equationsSetIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the equations set for.
    INTEGER(INTG), INTENT(IN) :: regionUserNumber !<The user number of the region with the equations set to add.
    INTEGER(INTG), INTENT(IN) :: equationsSetUserNumber !<The user number of the equations set to add.
    INTEGER(INTG), INTENT(OUT) :: equationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(EQUATIONS_SET_TYPE), POINTER :: EQUATIONS_SET
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquations_EquationsSetAddNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(REGION)
    NULLIFY(EQUATIONS_SET)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(regionUserNumber,REGION,err,error,*999)
      IF(ASSOCIATED(REGION)) THEN
        CALL EQUATIONS_SET_USER_NUMBER_FIND(equationsSetUserNumber,REGION,EQUATIONS_SET,err,error,*999)
        IF(ASSOCIATED(EQUATIONS_SET)) THEN
          CALL SOLVER_EQUATIONS_EQUATIONS_SET_ADD(SOLVER_EQUATIONS,EQUATIONS_SET,equationsSetIndex,err,error,*999)
        ELSE
          LOCAL_ERROR="An equations set with an user number of "//TRIM(NUMBER_TO_VSTRING(equationsSetUserNumber,"*",err,error))// &
            & " does not exist on region number "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(regionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolverEquations_EquationsSetAddNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_EquationsSetAddNumber1",err,error)
    CALL EXITS("CMISSSolverEquations_EquationsSetAddNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_EquationsSetAddNumber1

  !================================================================================================================================
  !

  !>Adds equations sets to solver equations identified by an object.
  SUBROUTINE CMISSSolverEquations_EquationsSetAddObj(solverEquations,equationsSet,equationsSetIndex,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to add the equations set for.
    TYPE(CMISSEquationsSetType), INTENT(IN) :: equationsSet !<The equations set to add.
    INTEGER(INTG), INTENT(OUT) :: equationsSetIndex !<On return, the index of the added equations set in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverEquations_EquationsSetAddObj",err,error,*999)

    CALL SOLVER_EQUATIONS_EQUATIONS_SET_ADD(solverEquations%SOLVER_EQUATIONS,equationsSet%EQUATIONS_SET,equationsSetIndex, &
      & err,error,*999)

    CALL EXITS("CMISSSolverEquations_EquationsSetAddObj")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_EquationsSetAddObj",err,error)
    CALL EXITS("CMISSSolverEquations_EquationsSetAddObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_EquationsSetAddObj

  !
  !================================================================================================================================
  !

  !>Adds an interface condition to solver equations identified by an user number.
  SUBROUTINE CMISSSolverEquations_InterfaceConditionAddNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & interfaceRegionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,interfaceConditionIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem with the solver to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the region containing the interface and interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containing the interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface condition to add.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIndex !<On return, the index of the added interface condition in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: INTERFACE_REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquations_InterfaceConditionAddNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(INTERFACE_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(interfaceRegionUserNumber,INTERFACE_REGION,err,error,*999)
      IF(ASSOCIATED(INTERFACE_REGION)) THEN
        CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,INTERFACE_REGION,INTERFACE,err,error,*999)
        IF(ASSOCIATED(INTERFACE)) THEN
          CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
          IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
            CALL SOLVER_EQUATIONS_INTERFACE_CONDITION_ADD(SOLVER_EQUATIONS,INTERFACE_CONDITION,interfaceConditionIndex, &
              & err,error,*999)
          ELSE
            LOCAL_ERROR="An interface condition with an user number of "// &
              & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
              & " does not exist on interface number "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
              & " of parent region number "//TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
          END IF
        ELSE
          LOCAL_ERROR="An interface with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " does not exist on parent region number "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolverEquationsInterfaceConditionNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_InterfaceConditionAddNumber0",err,error)
    CALL EXITS("CMISSSolverEquations_InterfaceConditionAddNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_InterfaceConditionAddNumber0

  !
  !================================================================================================================================
  !

  !>Adds an interface condition to solver equations identified by an user number.
  SUBROUTINE CMISSSolverEquations_InterfaceConditionAddNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & interfaceRegionUserNumber,interfaceUserNumber,interfaceConditionUserNumber,interfaceConditionIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to add the interface condition for.
    INTEGER(INTG), INTENT(IN) :: interfaceRegionUserNumber !<The user number of the region containing the interface and interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceUserNumber !<The user number of the interface containting the interface condition to add.
    INTEGER(INTG), INTENT(IN) :: interfaceConditionUserNumber !<The user number of the interface conditions to add.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIndex !<On return, the index of the added interface condition in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(INTERFACE_TYPE), POINTER :: INTERFACE
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: INTERFACE_CONDITION
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(REGION_TYPE), POINTER :: INTERFACE_REGION
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquations_InterfaceConditionAddNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(INTERFACE_REGION)
    NULLIFY(INTERFACE)
    NULLIFY(INTERFACE_CONDITION)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL REGION_USER_NUMBER_FIND(interfaceRegionUserNumber,INTERFACE_REGION,err,error,*999)
      IF(ASSOCIATED(INTERFACE_REGION)) THEN
        CALL INTERFACE_USER_NUMBER_FIND(interfaceUserNumber,INTERFACE_REGION,INTERFACE,err,error,*999)
        IF(ASSOCIATED(INTERFACE)) THEN
          CALL INTERFACE_CONDITION_USER_NUMBER_FIND(interfaceConditionUserNumber,INTERFACE,INTERFACE_CONDITION,err,error,*999)
          IF(ASSOCIATED(INTERFACE_CONDITION)) THEN
            CALL SOLVER_EQUATIONS_INTERFACE_CONDITION_ADD(SOLVER_EQUATIONS,INTERFACE_CONDITION,interfaceConditionIndex, &
              & err,error,*999)
          ELSE
            LOCAL_ERROR="An interface condition with an user number of "// &
              & TRIM(NUMBER_TO_VSTRING(interfaceConditionUserNumber,"*",err,error))// &
              & " does not exist on interface number "//TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
              & " of parent region number "//TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//"."
            CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
          END IF
        ELSE
          LOCAL_ERROR="An interface with an user number of "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceUserNumber,"*",err,error))// &
            & " does not exist on parent region number "// &
            & TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))//"."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        END IF
      ELSE
        LOCAL_ERROR="A region with an user number of "//TRIM(NUMBER_TO_VSTRING(interfaceRegionUserNumber,"*",err,error))// &
          & " does not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolverEquations_InterfaceConditionAddNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_InterfaceConditionAddNumber1",err,error)
    CALL EXITS("CMISSSolverEquations_InterfaceConditionAddNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_InterfaceConditionAddNumber1

  !================================================================================================================================
  !

  !>Adds an interface condition to solver equations identified by an object.
  SUBROUTINE CMISSSolverEquations_InterfaceConditionAddObj(solverEquations,interfaceCondition,interfaceConditionIndex,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to add the equations set for.
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to add.
    INTEGER(INTG), INTENT(OUT) :: interfaceConditionIndex !<On return, the index of the added interface condition in the solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverEquations_InterfaceConditionAddObj",err,error,*999)

    CALL SOLVER_EQUATIONS_INTERFACE_CONDITION_ADD(solverEquations%SOLVER_EQUATIONS,interfaceCondition%INTERFACE_CONDITION, &
      & interfaceConditionIndex,err,error,*999)

    CALL EXITS("CMISSSolverEquations_InterfaceConditionAddObj")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_InterfaceConditionAddObj",err,error)
    CALL EXITS("CMISSSolverEquations_InterfaceConditionAddObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_InterfaceConditionAddObj

  !
  !================================================================================================================================
  !
  
  !>Set the time dependence type of interface matrices
  SUBROUTINE CMISSInterfaceMatrices_TimeDependenceTypeSet(interfaceCondition, &
    & interfaceMatrixIndex,hasTranspose,timeDependenceTypes,Err)
    
    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to add.
    INTEGER(INTG), INTENT(IN) :: timeDependenceTypes(:) !<Time dependence types for the given interface matrix and it's transpose (if any). \see INTERFACE_MATRICES_ROUTINES_InterfaceMatricesTimeDependenceTypes,INTERFACE_MATRICES_ROUTINES
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIndex
    LOGICAL, INTENT(IN) :: hasTranspose
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSInterfaceMatrices_TimeDependenceTypeSet",err,error,*999)
    
    IF(SIZE(timeDependenceTypes)/=2) CALL FLAG_ERROR("Invalid size of time dependence types array. Must be 2.",err,error,*999)
    IF(timeDependenceTypes(1)>0.AND.timeDependenceTypes(1)<=CMISS_NUMBER_OF_INTERFACE_MATRIX_TYPES) THEN
      CALL InterfaceMatrix_TimeDependenceTypeSet(interfaceCondition%INTERFACE_CONDITION, &
        & interfaceMatrixIndex,.FALSE.,timeDependenceTypes(1),err,error,*999)
      IF(hasTranspose.AND.(timeDependenceTypes(2)>0.AND.timeDependenceTypes(2)<=CMISS_NUMBER_OF_INTERFACE_MATRIX_TYPES)) THEN
        CALL InterfaceMatrix_TimeDependenceTypeSet(interfaceCondition%INTERFACE_CONDITION, &
          & interfaceMatrixIndex,.TRUE.,timeDependenceTypes(2),err,error,*999)
      ELSE
        IF(.NOT.hasTranspose) THEN
          !ok)
        ELSEIF(hasTranspose.AND. &
          & .NOT.(timeDependenceTypes(2)>0.AND.timeDependenceTypes(2)<=CMISS_NUMBER_OF_INTERFACE_MATRIX_TYPES)) THEN
          LOCAL_ERROR="Interface matrix number "//TRIM(NUMBER_TO_VSTRING(interfaceMatrixIndex,"*",err,error))// &
            & " has transpose but invalid time dependence type of "//TRIM(NUMBER_TO_VSTRING(timeDependenceTypes(1), &
            & "*",err,error))//" ."
          CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
        ENDIF
      ENDIF
    ELSE
      LOCAL_ERROR="Interface matrix time dependence type of "//TRIM(NUMBER_TO_VSTRING(timeDependenceTypes(1),"*",err,error))// &
        & " is invalid for interface matrix number "//TRIM(NUMBER_TO_VSTRING(interfaceMatrixIndex,"*",err,error))// &
        & " ."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    ENDIF
    
    CALL EXITS("CMISSInterfaceMatrices_TimeDependenceTypeSet")
    RETURN
999 CALL ERRORS("CMISSInterfaceMatrices_TimeDependenceTypeSet",err,error)
    CALL EXITS("CMISSInterfaceMatrices_TimeDependenceTypeSet")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN
    
  END SUBROUTINE CMISSInterfaceMatrices_TimeDependenceTypeSet

  !
  !================================================================================================================================
  !
  
  !>Get the time dependence type of interface matrices
  SUBROUTINE CMISSInterfaceMatrices_TimeDependenceTypeGet(interfaceCondition, &
    & interfaceMatrixIndex,hasTranspose,timeDependenceTypes,Err)
    
    !Argument variables
    TYPE(CMISSInterfaceConditionType), INTENT(IN) :: interfaceCondition !<The interface condition to add.
    INTEGER(INTG), INTENT(OUT) :: timeDependenceTypes(:) !<Time dependence types for the given interface matrix and it's transpose (if any). \see INTERFACE_MATRICES_ROUTINES_InterfaceMatricesTimeDependenceTypes,INTERFACE_MATRICES_ROUTINES
    INTEGER(INTG), INTENT(IN) :: interfaceMatrixIndex
    LOGICAL, INTENT(IN) :: hasTranspose
    INTEGER(INTG), INTENT(OUT) :: Err !<The error code
    !Local Variables
    TYPE(VARYING_STRING) :: LOCAL_ERROR
    
    CALL ENTERS("CMISSInterfaceMatrices_TimeDependenceTypeGet",err,error,*999)
    
    IF(SIZE(timeDependenceTypes)/=2) CALL FLAG_ERROR("Invalid size of time dependence types array. Must be 2.",err,error,*999)
    CALL InterfaceMatrix_TimeDependenceTypeGet(interfaceCondition%INTERFACE_CONDITION, &
      & interfaceMatrixIndex,.FALSE.,timeDependenceTypes(1),err,error,*999)
    IF(hasTranspose) THEN
      CALL InterfaceMatrix_TimeDependenceTypeGet(interfaceCondition%INTERFACE_CONDITION, &
        & interfaceMatrixIndex,.TRUE.,timeDependenceTypes(2),err,error,*999)
    ENDIF
    
    CALL EXITS("CMISSInterfaceMatrices_TimeDependenceTypeGet")
    RETURN
999 CALL ERRORS("CMISSInterfaceMatrices_TimeDependenceTypeGet",err,error)
    CALL EXITS("CMISSInterfaceMatrices_TimeDependenceTypeGet")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN
    
  END SUBROUTINE CMISSInterfaceMatrices_TimeDependenceTypeGet
  
  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for solver equations identified by an user number.
  SUBROUTINE CMISSSolverEquations_SparsityTypeSetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type to set. \see OPENCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquations_SparsityTypeSetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL SOLVER_EQUATIONS_SPARSITY_TYPE_SET(SOLVER_EQUATIONS,sparsityType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolverEquations_SparsityTypeSetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_SparsityTypeSetNumber0",err,error)
    CALL EXITS("CMISSSolverEquations_SparsityTypeSetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_SparsityTypeSetNumber0

  !
  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for solver equations identified by an user number.
  SUBROUTINE CMISSSolverEquations_SparsityTypeSetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,sparsityType,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem number with the solver to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type to set. \see OPENCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_TYPE), POINTER :: SOLVER
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquations_SparsityTypeSetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER)
    NULLIFY(SOLVER_EQUATIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER,err,error,*999)
      CALL SOLVER_SOLVER_EQUATIONS_GET(SOLVER,SOLVER_EQUATIONS,err,error,*999)
      CALL SOLVER_EQUATIONS_SPARSITY_TYPE_SET(SOLVER_EQUATIONS,sparsityType,err,error,*999)
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))// &
        & " does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolverEquations_SparsityTypeSetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_SparsityTypeSetNumber1",err,error)
    CALL EXITS("CMISSSolverEquations_SparsityTypeSetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_SparsityTypeSetNumber1

  !================================================================================================================================
  !

  !>Sets/changes the sparsity type for solver equations identified by an object.
  SUBROUTINE CMISSSolverEquations_SparsityTypeSetObj(solverEquations,sparsityType,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to set the sparsity type for.
    INTEGER(INTG), INTENT(IN) :: sparsityType !<The sparsity type to set. \see OPENCMISS_SolverEquationsSparsityTypes
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverEquations_SparsityTypeSetObj",err,error,*999)

    CALL SOLVER_EQUATIONS_SPARSITY_TYPE_SET(solverEquations%SOLVER_EQUATIONS,sparsityType,err,error,*999)

    CALL EXITS("CMISSSolverEquations_SparsityTypeSetObj")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_SparsityTypeSetObj",err,error)
    CALL EXITS("CMISSSolverEquations_SparsityTypeSetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_SparsityTypeSetObj

  !
  !================================================================================================================================
  !

  !>Finish the creation of the boundary conditions for the solver equations identified by the user numbers
  SUBROUTINE CMISSSolverEquations_BoundaryConditionsCreateFinishNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to finish the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquations_BoundaryConditionsCreateFinishNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_CREATE_FINISH(SOLVER_EQUATIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolverEquations_BoundaryConditionsCreateFinishNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_BoundaryConditionsCreateFinishNumber0",err,error)
    CALL EXITS("CMISSSolverEquations_BoundaryConditionsCreateFinishNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_BoundaryConditionsCreateFinishNumber0

  !
  !================================================================================================================================
  !

  !>Finish the creation of the boundary conditions for the solver equations identified by the user numbers
  SUBROUTINE CMISSSolverEquations_BoundaryConditionsCreateFinishNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to finish the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquations_BoundaryConditionsCreateFinishNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_CREATE_FINISH(SOLVER_EQUATIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolverEquations_BoundaryConditionsCreateFinishNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_BoundaryConditionsCreateFinishNumber1",err,error)
    CALL EXITS("CMISSSolverEquations_BoundaryConditionsCreateFinishNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_BoundaryConditionsCreateFinishNumber1

  !
  !================================================================================================================================
  !

  !>Finish the creation of the boundary conditions for the solver equations
  SUBROUTINE CMISSSolverEquations_BoundaryConditionsCreateFinishObj(solverEquations,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations containing the boundary conditions to finish.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverEquations_BoundaryConditionsCreateFinishObj",err,error,*999)

    CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_CREATE_FINISH(solverEquations%SOLVER_EQUATIONS,err,error,*999)

    CALL EXITS("CMISSSolverEquations_BoundaryConditionsCreateFinishObj")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_BoundaryConditionsCreateFinishObj",err,error)
    CALL EXITS("CMISSSolverEquations_BoundaryConditionsCreateFinishObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_BoundaryConditionsCreateFinishObj

  !
  !================================================================================================================================
  !

  !>Start the creation of boundary conditions for solver equations identified by user numbers
  SUBROUTINE CMISSSolverEquations_BoundaryConditionsCreateStartNumber0(problemUserNumber,controlLoopIdentifier,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to start the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquations_BoundaryConditionsCreateStartNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_CREATE_START(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolverEquations_BoundaryConditionsCreateStartNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_BoundaryConditionsCreateStartNumber0",err,error)
    CALL EXITS("CMISSSolverEquations_BoundaryConditionsCreateStartNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_BoundaryConditionsCreateStartNumber0

  !
  !================================================================================================================================
  !

  !>Start the creation of boundary conditions for solver equations identified by user numbers
  SUBROUTINE CMISSSolverEquations_BoundaryConditionsCreateStartNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to start the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: BOUNDARY_CONDITIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquations_BoundaryConditionsCreateStartNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    NULLIFY(BOUNDARY_CONDITIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_CREATE_START(SOLVER_EQUATIONS,BOUNDARY_CONDITIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolverEquations_BoundaryConditionsCreateStartNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_BoundaryConditionsCreateStartNumber1",err,error)
    CALL EXITS("CMISSSolverEquations_BoundaryConditionsCreateStartNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_BoundaryConditionsCreateStartNumber1

  !
  !================================================================================================================================
  !

  !>Start the creation of boundary conditions for solver equations
  SUBROUTINE CMISSSolverEquations_BoundaryConditionsCreateStartObj(solverEquations,boundaryConditions,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(INOUT) :: solverEquations !<The solver equations containing the boundary conditions to start.
    TYPE(CMISSBoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, the created boundary conditions.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables

    CALL ENTERS("CMISSSolverEquations_BoundaryConditionsCreateStartObj",err,error,*999)

    CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_CREATE_START(solverEquations%SOLVER_EQUATIONS, &
        & boundaryConditions%BOUNDARY_CONDITIONS,err,error,*999)

    CALL EXITS("CMISSSolverEquations_BoundaryConditionsCreateStartObj")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_BoundaryConditionsCreateStartObj",err,error)
    CALL EXITS("CMISSSolverEquations_BoundaryConditionsCreateStartObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_BoundaryConditionsCreateStartObj

  !
  !================================================================================================================================
  !

  !>Get the boundary conditions for solver equations identified by user numbers
  SUBROUTINE CMISSSolverEquations_BoundaryConditionsGetNumber0(problemUserNumber,controlLoopIdentifier,solverIndex, &
    & boundaryConditions,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to get the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifier !<The control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    TYPE(CMISSBoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, The boundary conditions for the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquations_BoundaryConditionsGetNumber0",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifier,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,boundaryConditions%BOUNDARY_CONDITIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolverEquations_BoundaryConditionsGetNumber0")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_BoundaryConditionsGetNumber0",err,error)
    CALL EXITS("CMISSSolverEquations_BoundaryConditionsGetNumber0")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_BoundaryConditionsGetNumber0

  !
  !================================================================================================================================
  !

  !>Get the boundary conditions for solver equations identified by user numbers
  SUBROUTINE CMISSSolverEquations_BoundaryConditionsGetNumber1(problemUserNumber,controlLoopIdentifiers,solverIndex, &
    & boundaryConditions,err)

    !Argument variables
    INTEGER(INTG), INTENT(IN) :: problemUserNumber !<The user number of the problem containing the solver equations to start the boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: controlLoopIdentifiers(:) !<controlLoopIdentifiers(i). The i'th control loop identifier to get the solver equations boundary conditions for.
    INTEGER(INTG), INTENT(IN) :: solverIndex !<The solver index to get the solver equations boundary conditions for.
    TYPE(CMISSBoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, The boundary conditions for the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.
    !Local variables
    TYPE(PROBLEM_TYPE), POINTER :: PROBLEM
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: SOLVER_EQUATIONS
    TYPE(VARYING_STRING) :: LOCAL_ERROR

    CALL ENTERS("CMISSSolverEquations_BoundaryConditionsGetNumber1",err,error,*999)

    NULLIFY(PROBLEM)
    NULLIFY(SOLVER_EQUATIONS)
    CALL PROBLEM_USER_NUMBER_FIND(problemUserNumber,PROBLEM,err,error,*999)
    IF(ASSOCIATED(PROBLEM)) THEN
      CALL PROBLEM_SOLVER_EQUATIONS_GET(PROBLEM,controlLoopIdentifiers,solverIndex,SOLVER_EQUATIONS,err,error,*999)
      IF(ASSOCIATED(SOLVER_EQUATIONS)) THEN
        CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(SOLVER_EQUATIONS,boundaryConditions%BOUNDARY_CONDITIONS,err,error,*999)
      ELSE
        LOCAL_ERROR="Solver equations with the given solver index and control loop identifier do not exist."
        CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
      END IF
    ELSE
      LOCAL_ERROR="A problem with an user number of "//TRIM(NUMBER_TO_VSTRING(problemUserNumber,"*",err,error))//" does not exist."
      CALL FLAG_ERROR(LOCAL_ERROR,err,error,*999)
    END IF

    CALL EXITS("CMISSSolverEquations_BoundaryConditionsGetNumber1")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_BoundaryConditionsGetNumber1",err,error)
    CALL EXITS("CMISSSolverEquations_BoundaryConditionsGetNumber1")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_BoundaryConditionsGetNumber1

  !
  !================================================================================================================================
  !

  !>Get the boundary conditions for solver equations
  SUBROUTINE CMISSSolverEquations_BoundaryConditionsGetObj(solverEquations,boundaryConditions,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the boundary conditions for.
    TYPE(CMISSBoundaryConditionsType), INTENT(INOUT) :: boundaryConditions !<On return, The boundary conditions for the specified solver equations.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL ENTERS("CMISSSolverEquations_BoundaryConditionsGetObj",err,error,*999)

    CALL SOLVER_EQUATIONS_BOUNDARY_CONDITIONS_GET(solverEquations%SOLVER_EQUATIONS,boundaryConditions%BOUNDARY_CONDITIONS, &
      & err,error,*999)

    CALL EXITS("CMISSSolverEquations_BoundaryConditionsGetObj")
    RETURN
999 CALL ERRORS("CMISSSolverEquations_BoundaryConditionsGetObj",err,error)
    CALL EXITS("CMISSSolverEquations_BoundaryConditionsGetObj")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_BoundaryConditionsGetObj

  !
  !================================================================================================================================
  !

  !>Get the number of solver matrices for the solver equations
  SUBROUTINE CMISSSolverEquations_NumberOfMatricesGet(solverEquations,numberOfMatrices,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the number of matrices for
    INTEGER(INTG), INTENT(OUT) :: numberOfMatrices !<On return, the number of matrices for the solver equations
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSSolverEquations_NumberOfMatricesGet",err,error,*999)

    CALL SolverEquations_NumberOfMatricesGet(solverEquations%solver_equations,numberOfMatrices,err,error,*999)

    CALL Exits("CMISSSolverEquations_NumberOfMatricesGet")
    RETURN
999 CALL Errors("CMISSSolverEquations_NumberOfMatricesGet",err,error)
    CALL Exits("CMISSSolverEquations_NumberOfMatricesGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_NumberOfMatricesGet

  !
  !================================================================================================================================
  !

  !>Get a solver matrix from the solver equations matrices
  SUBROUTINE CMISSSolverEquations_MatrixGet(solverEquations,matrixIndex,matrix,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the matrix for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The solver matrix index to get
    TYPE(CMISSDistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the requested solver matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSSolverEquations_MatrixGet",err,error,*999)

    CALL SolverEquations_MatrixGet(solverEquations%solver_equations,matrixIndex,matrix%distributedMatrix,err,error,*999)

    CALL Exits("CMISSSolverEquations_MatrixGet")
    RETURN
999 CALL Errors("CMISSSolverEquations_MatrixGet",err,error)
    CALL Exits("CMISSSolverEquations_MatrixGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_MatrixGet

  !
  !================================================================================================================================
  !

  !>Get the Jacobian matrix from the solver equations matrices for nonlinear solver equations
  SUBROUTINE CMISSSolverEquations_JacobianMatrixGet(solverEquations,matrix,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the Jacobian matrix for
    TYPE(CMISSDistributedMatrixType), INTENT(INOUT) :: matrix !<On return, the solver equations Jacobian matrix
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSSolverEquations_JacobianMatrixGet",err,error,*999)

    CALL SolverEquations_JacobianMatrixGet(solverEquations%solver_equations,matrix%distributedMatrix,err,error,*999)

    CALL Exits("CMISSSolverEquations_JacobianMatrixGet")
    RETURN
999 CALL Errors("CMISSSolverEquations_JacobianMatrixGet",err,error)
    CALL Exits("CMISSSolverEquations_JacobianMatrixGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_JacobianMatrixGet

  !
  !================================================================================================================================
  !

  !>Get the vector assiciated with a solver matrix from the solver equations matrices
  SUBROUTINE CMISSSolverEquations_VectorGet(solverEquations,matrixIndex,vector,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the vector for
    INTEGER(INTG), INTENT(IN) :: matrixIndex !<The solver matrix index to get the vector for
    TYPE(CMISSDistributedVectorType), INTENT(INOUT) :: vector !<On return, the requested solver matrix vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSSolverEquations_VectorGet",err,error,*999)

    CALL SolverEquations_VectorGet(solverEquations%solver_equations,matrixIndex,vector%distributedVector,err,error,*999)

    CALL Exits("CMISSSolverEquations_VectorGet")
    RETURN
999 CALL Errors("CMISSSolverEquations_VectorGet",err,error)
    CALL Exits("CMISSSolverEquations_VectorGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_VectorGet

  !
  !================================================================================================================================
  !

  !>Get the residual vector from the solver equations for nonlinear problems
  SUBROUTINE CMISSSolverEquations_ResidualVectorGet(solverEquations,residualVector,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the residual vector for
    TYPE(CMISSDistributedVectorType), INTENT(INOUT) :: residualVector !<On return, the solver residual vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSSolverEquations_ResidualVectorGet",err,error,*999)

    CALL SolverEquations_ResidualVectorGet(solverEquations%solver_equations,residualVector%distributedVector,err,error,*999)

    CALL Exits("CMISSSolverEquations_ResidualVectorGet")
    RETURN
999 CALL Errors("CMISSSolverEquations_ResidualVectorGet",err,error)
    CALL Exits("CMISSSolverEquations_ResidualVectorGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_ResidualVectorGet

  !
  !================================================================================================================================
  !

  !>Get the right hand side vector from the solver equations
  SUBROUTINE CMISSSolverEquations_RhsVectorGet(solverEquations,rhsVector,err)

    !Argument variables
    TYPE(CMISSSolverEquationsType), INTENT(IN) :: solverEquations !<The solver equations to get the right hand side vector for
    TYPE(CMISSDistributedVectorType), INTENT(INOUT) :: rhsVector !<On return, the solver right hand side vector
    INTEGER(INTG), INTENT(OUT) :: err !<The error code

    CALL Enters("CMISSSolverEquations_RhsVectorGet",err,error,*999)

    CALL SolverEquations_RhsVectorGet(solverEquations%solver_equations,rhsVector%distributedVector,err,error,*999)

    CALL Exits("CMISSSolverEquations_RhsVectorGet")
    RETURN
999 CALL Errors("CMISSSolverEquations_RhsVectorGet",err,error)
    CALL Exits("CMISSSolverEquations_RhsVectorGet")
    CALL CMISSHandleError(err,error)
    RETURN

  END SUBROUTINE CMISSSolverEquations_RhsVectorGet

  !
  !================================================================================================================================
  !

  !>Get the user number of the given region.
  SUBROUTINE CMISSUserNumberGetRegion( region, userNumber, err )
    !Argument variables
    TYPE(CMISSRegionType), INTENT(IN) :: region !<The region to get the user number for
    INTEGER(INTG), INTENT(OUT) :: userNumber !<The region's user number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    err = 0

    userNumber = region%REGION%USER_NUMBER

  END SUBROUTINE CMISSUserNumberGetRegion

  !
  !================================================================================================================================
  !

  !>Get the user number of the given mesh.
  SUBROUTINE CMISSUserNumberGetMesh( mesh, userNumber, err )
    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !<The mesh to get the user number for
    INTEGER(INTG), INTENT(OUT) :: userNumber !<The mesh's user number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    err = 0

    userNumber = mesh%MESH%USER_NUMBER

  END SUBROUTINE CMISSUserNumberGetMesh

  !
  !================================================================================================================================
  !

  !>Get the user number of the given basis.
  SUBROUTINE CMISSUserNumberGetBasis( basis, userNumber, err )
    !Argument variables
    TYPE(CMISSBasisType), INTENT(IN) :: basis !<The basis to get the user number for
    INTEGER(INTG), INTENT(OUT) :: userNumber !<The basis's user number
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    err = 0

    userNumber = basis%BASIS%USER_NUMBER

  END SUBROUTINE CMISSUserNumberGetBasis

  !
  !================================================================================================================================
  !

  !>Update the bioelectrics geometric field by interpolating the finite elasticity geometric field
  SUBROUTINE CMISSBioelectricsFiniteElasticity_UpdateGeometricField(controlLoop,calcClosestGaussPoint,err)
  
    !Argument variables
    TYPE(CMISSControlLoopType), INTENT(INOUT) :: controlLoop !<The bioelectrics control loop
    LOGICAL, INTENT(IN) :: calcClosestGaussPoint
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL ENTERS("CMISSBioelectricsFiniteElasticity_UpdateGeometricField",err,error,*999)

    CALL BIOELECTRIC_FINITE_ELASTICITY_UPDATE_GEOMETRIC_FIELD(controlLoop%CONTROL_LOOP,calcClosestGaussPoint,err,error,*999)

    CALL EXITS("CMISSBioelectricsFiniteElasticity_UpdateGeometricField")
    RETURN
999 CALL ERRORS("CMISSBioelectricsFiniteElasticity_UpdateGeometricField",err,error)
    CALL EXITS("CMISSBioelectricsFiniteElasticity_UpdateGeometricField")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSBioelectricsFiniteElasticity_UpdateGeometricField

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given FieldML XML file.
  SUBROUTINE CMISSFieldML_InputCreateFromFileVS( filename, fieldml, err )
    !Arguments
    TYPE(VARYING_STRING), INTENT(IN) :: filename !< The FieldML XML file to parse.
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_InputCreateFromFileVS",err,error,*999)

#ifdef USEFIELDML

    ALLOCATE( fieldml%fieldmlInfo, stat=err )
    CALL FIELDML_INPUT_INITIALISE_FROM_FILE( fieldml%fieldmlInfo, filename, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputCreateFromFileVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputCreateFromFileVS",err,error)
    CALL EXITS("CMISSFieldML_InputCreateFromFileVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputCreateFromFileVS

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given FieldML XML file.
  SUBROUTINE CMISSFieldML_InputCreateFromFileC( filename, fieldml, err )
    !Arguments
    CHARACTER(LEN=*), INTENT(IN) :: filename !< The FieldML XML file to parse.
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_InputCreateFromFileC",err,error,*999)

#ifdef USEFIELDML

    ALLOCATE( fieldml%fieldmlInfo, stat=err )
    CALL FIELDML_INPUT_INITIALISE_FROM_FILE( fieldml%fieldmlInfo, var_str(filename), err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputCreateFromFileC")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputCreateFromFileC",err,error)
    CALL EXITS("CMISSFieldML_InputCreateFromFileC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputCreateFromFileC

  !
  !================================================================================================================================
  !

  !> Creates a mesh using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputMeshCreateStartObjVS( fieldml, meshArgumentName, mesh, meshNumber, region, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: meshArgumentName !< The name of the argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    TYPE(CMISSRegionType), INTENT(IN) :: region !< The region in which to create the mesh.
    TYPE(CMISSMeshType), INTENT(INOUT) :: mesh !< On return, the newly created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_InputMeshCreateStartObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, meshArgumentName, mesh%MESH, meshNumber, region%REGION, &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputMeshCreateStartObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputMeshCreateStartObjVS",err,error)
    CALL EXITS("CMISSFieldML_InputMeshCreateStartObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputMeshCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Creates a mesh with the given user number using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputMeshCreateStartNumberVS( fieldml, meshArgumentName, meshNumber, regionNumber, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: meshArgumentName !< The name of the mesh argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    CALL ENTERS("CMISSFieldML_InputMeshCreateStartNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    NULLIFY( mesh )
    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, meshArgumentName, mesh, meshNumber, region, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputMeshCreateStartNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputMeshCreateStartNumberVS",err,error)
    CALL EXITS("CMISSFieldML_InputMeshCreateStartNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputMeshCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Creates a mesh using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputMeshCreateStartObjC( fieldml, meshArgumentName, mesh, meshNumber, region, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: meshArgumentName !< The name of the argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    TYPE(CMISSRegionType), INTENT(IN) :: region !< The region in which to create the mesh.
    TYPE(CMISSMeshType), INTENT(INOUT) :: mesh !< On return, the newly created mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_InputMeshCreateStartObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, var_str(meshArgumentName), mesh%MESH, meshNumber, region%REGION, &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputMeshCreateStartObjC")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputMeshCreateStartObjC",err,error)
    CALL EXITS("CMISSFieldML_InputMeshCreateStartObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputMeshCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Creates a mesh with the given user number using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputMeshCreateStartNumberC( fieldml, meshArgumentName, meshNumber, regionNumber, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: meshArgumentName !< The name of the mesh argument evaluator to create a mesh from.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number to assign to the new mesh.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the mesh.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    CALL ENTERS("CMISSFieldML_InputMeshCreateStartNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    NULLIFY( mesh )
    CALL FIELDML_INPUT_MESH_CREATE_START( fieldml%fieldmlInfo, var_str(meshArgumentName), mesh, meshNumber, region, &
      & err, error, *999)

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputMeshCreateStartNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputMeshCreateStartNumberC",err,error)
    CALL EXITS("CMISSFieldML_InputMeshCreateStartNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputMeshCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputCoordinateSystemCreateStartObjVS( fieldml, evaluatorName, coordinateSystem, userNumber, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !< On return, the newly created coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_InputCoordinateSystemCreateStartObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_COORDINATE_SYSTEM_CREATE_START( fieldml%fieldmlInfo, evaluatorName, coordinateSystem%COORDINATE_SYSTEM, &
      & userNumber, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputCoordinateSystemCreateStartObjVS")
   RETURN
999 CALL ERRORS("CMISSFieldML_InputCoordinateSystemCreateStartObjVS",err,error)
    CALL EXITS("CMISSFieldML_InputCoordinateSystemCreateStartObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

 END SUBROUTINE CMISSFieldML_InputCoordinateSystemCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputCoordinateSystemCreateStartNumberVS( fieldml, evaluatorName, userNumber, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM

    CALL ENTERS("CMISSFieldML_InputCoordinateSystemCreateStartNumberVS",err,error,*999)

#ifdef USEFIELDML

    NULLIFY( COORDINATE_SYSTEM )
    CALL FIELDML_INPUT_COORDINATE_SYSTEM_CREATE_START( fieldml%fieldmlInfo, evaluatorName, COORDINATE_SYSTEM, &
      & userNumber, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputCoordinateSystemCreateStartNumberVS")
   RETURN
999 CALL ERRORS("CMISSFieldML_InputCoordinateSystemCreateStartNumberVS",err,error)
    CALL EXITS("CMISSFieldML_InputCoordinateSystemCreateStartNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

 END SUBROUTINE CMISSFieldML_InputCoordinateSystemCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputCoordinateSystemCreateStartObjC( fieldml, evaluatorName, coordinateSystem, userNumber, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    TYPE(CMISSCoordinateSystemType), INTENT(INOUT) :: coordinateSystem !< On return, the newly created coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_InputCoordinateSystemCreateStartObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_COORDINATE_SYSTEM_CREATE_START( fieldml%fieldmlInfo, var_str(evaluatorName), &
      & coordinateSystem%COORDINATE_SYSTEM, userNumber, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputCoordinateSystemCreateStartObjC")
   RETURN
999 CALL ERRORS("CMISSFieldML_InputCoordinateSystemCreateStartObjC",err,error)
    CALL EXITS("CMISSFieldML_InputCoordinateSystemCreateStartObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

 END SUBROUTINE CMISSFieldML_InputCoordinateSystemCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Create a coordinate system using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputCoordinateSystemCreateStartNumberC( fieldml, evaluatorName, userNumber, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the coordinate system from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new coordinate system.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: COORDINATE_SYSTEM

    CALL ENTERS("CMISSFieldML_InputCoordinateSystemCreateStartNumberC",err,error,*999)

#ifdef USEFIELDML

    NULLIFY( COORDINATE_SYSTEM )
    CALL FIELDML_INPUT_COORDINATE_SYSTEM_CREATE_START( fieldml%fieldmlInfo, var_str(evaluatorName), COORDINATE_SYSTEM, &
      & userNumber, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputCoordinateSystemCreateStartNumberC")
   RETURN
999 CALL ERRORS("CMISSFieldML_InputCoordinateSystemCreateStartNumberC",err,error)
    CALL EXITS("CMISSFieldML_InputCoordinateSystemCreateStartNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

 END SUBROUTINE CMISSFieldML_InputCoordinateSystemCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputBasisCreateStartNumberVS( fieldml, evaluatorName, userNumber, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(BASIS_TYPE), POINTER :: basis

    CALL ENTERS("CMISSFieldML_InputBasisCreateStartNumberVS",err,error,*999)

#ifdef USEFIELDML

    NULLIFY( basis )
    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, evaluatorName, userNumber, basis, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputBasisCreateStartNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputBasisCreateStartNumberVS",err,error)
    CALL EXITS("CMISSFieldML_InputBasisCreateStartNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
   RETURN

  END SUBROUTINE CMISSFieldML_InputBasisCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputBasisCreateStartObjVS( fieldml, evaluatorName, userNumber, basis, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<On return, the newly created basis.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_InputBasisCreateStartObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, evaluatorName, userNumber, basis%BASIS, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputBasisCreateStartObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputBasisCreateStartObjVS",err,error)
    CALL EXITS("CMISSFieldML_InputBasisCreateStartObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
   RETURN

  END SUBROUTINE CMISSFieldML_InputBasisCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputBasisCreateStartNumberC( fieldml, evaluatorName, userNumber, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(BASIS_TYPE), POINTER :: basis

    CALL ENTERS("CMISSFieldML_InputBasisCreateStartNumberC",err,error,*999)

#ifdef USEFIELDML

    NULLIFY( basis )
    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, var_str(evaluatorName), userNumber, basis, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputBasisCreateStartNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputBasisCreateStartNumberC",err,error)
    CALL EXITS("CMISSFieldML_InputBasisCreateStartNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
   RETURN

  END SUBROUTINE CMISSFieldML_InputBasisCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Create a basis using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputBasisCreateStartObjC( fieldml, evaluatorName, userNumber, basis, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(IN) :: userNumber !< The user number to assign to the new basis.
    TYPE(CMISSBasisType), INTENT(INOUT) :: basis !<On return, the newly created basis.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_InputBasisCreateStartObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_BASIS_CREATE_START( fieldml%fieldmlInfo, var_str(evaluatorName), userNumber, basis%BASIS, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputBasisCreateStartObjC")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputBasisCreateStartObjC",err,error)
    CALL EXITS("CMISSFieldML_InputBasisCreateStartObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
   RETURN

  END SUBROUTINE CMISSFieldML_InputBasisCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputNodesCreateStartNumberVS( fieldml, nodesArgumentName, regionNumber, nodes, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the nodes from.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region to create to the nodes in.
    TYPE(CMISSNodesType), INTENT(INOUT) :: nodes !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region

    CALL ENTERS("CMISSFieldML_InputNodesCreateStartNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, nodesArgumentName, region, nodes%NODES, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputNodesCreateStartNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputNodesCreateStartNumberVS",err,error)
    CALL EXITS("CMISSFieldML_InputNodesCreateStartNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
   RETURN

  END SUBROUTINE CMISSFieldML_InputNodesCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputNodesCreateStartObjVS( fieldml, nodesArgumentName, region, nodes, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the basis from.
    TYPE(CMISSRegionType), INTENT(IN) :: region !< The user number of the region to create to the nodes in.
    TYPE(CMISSNodesType), INTENT(INOUT) :: nodes  !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_InputNodesCreateStartObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, nodesArgumentName, region%REGION, nodes%NODES, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputNodesCreateStartObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputNodesCreateStartObjVS",err,error)
    CALL EXITS("CMISSFieldML_InputNodesCreateStartObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
   RETURN

  END SUBROUTINE CMISSFieldML_InputNodesCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputNodesCreateStartNumberC( fieldml, nodesArgumentName, regionNumber, nodes, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the nodes from.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region to create to the nodes in.
    TYPE(CMISSNodesType), INTENT(INOUT) :: nodes !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region

    CALL ENTERS("CMISSFieldML_InputNodesCreateStartNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, var_str(nodesArgumentName), region, nodes%NODES, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputNodesCreateStartNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputNodesCreateStartNumberC",err,error)
    CALL EXITS("CMISSFieldML_InputNodesCreateStartNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
   RETURN

  END SUBROUTINE CMISSFieldML_InputNodesCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Creates a region's nodes using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputNodesCreateStartObjC( fieldml, nodesArgumentName, region, nodes, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(LEN=*), INTENT(IN) :: nodesArgumentName !< The name of the argument evaluator to create the basis from.
    TYPE(CMISSRegionType), INTENT(IN) :: region !< The user number of the region to create to the nodes in.
    TYPE(CMISSNodesType), INTENT(INOUT) :: nodes  !< On return, the newly created nodes.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_InputNodesCreateStartObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_NODES_CREATE_START( fieldml%fieldmlInfo, var_str(nodesArgumentName), region%REGION, nodes%NODES, &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputNodesCreateStartObjC")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputNodesCreateStartObjC",err,error)
    CALL EXITS("CMISSFieldML_InputNodesCreateStartObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
   RETURN

  END SUBROUTINE CMISSFieldML_InputNodesCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the given mesh.
  SUBROUTINE CMISSFieldML_InputCreateMeshComponentObjVS( fieldml, mesh, componentNumber, evaluatorName, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !< The mesh for which to create the mesh component.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the mesh from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_InputCreateMeshComponentObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh%MESH, componentNumber, evaluatorName, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputCreateMeshComponentObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputCreateMeshComponentObjVS",err,error)
    CALL EXITS("CMISSFieldML_InputCreateMeshComponentObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputCreateMeshComponentObjVS

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the mesh identified by the given user number.
  SUBROUTINE CMISSFieldML_InputCreateMeshComponentNumberVS( fieldml, regionNumber, meshNumber, componentNumber, evaluatorName, &
    & err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh for which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    CALL ENTERS( "CMISSFieldML_InputCreateMeshComponentNumberVS", err, error, *999 )

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh, componentNumber, evaluatorName, err, error, *999 )

    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputNodesCreateStartObjVS")
    CALL EXITS("CMISSFieldML_InputCreateMeshComponentNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputCreateMeshComponentNumberVS",err,error)
    CALL EXITS("CMISSFieldML_InputCreateMeshComponentNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputCreateMeshComponentNumberVS

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the given mesh.
  SUBROUTINE CMISSFieldML_InputCreateMeshComponentObjC( fieldml, mesh, componentNumber, evaluatorName, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !< The mesh for which to create the mesh component.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the mesh from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_InputCreateMeshComponentObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh%MESH, componentNumber, var_str(evaluatorName), &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputCreateMeshComponentObjC")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputCreateMeshComponentObjC",err,error)
    CALL EXITS("CMISSFieldML_InputCreateMeshComponentObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputCreateMeshComponentObjC

  !
  !================================================================================================================================
  !

  !> Use the given FieldML evaluator as a template to create a component on the mesh identified by the given user number.
  SUBROUTINE CMISSFieldML_InputCreateMeshComponentNumberC( fieldml, regionNumber, meshNumber, componentNumber, evaluatorName, &
    & err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh for which the mesh component is to be created.
    INTEGER(INTG), INTENT(IN) :: componentNumber !< The number of the mesh component to create.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the basis from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    CALL ENTERS( "CMISSFieldML_InputCreateMeshComponentNumberC", err, error, *999 )

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )

    CALL FIELDML_INPUT_CREATE_MESH_COMPONENT( fieldml%fieldmlInfo, mesh, componentNumber, var_str(evaluatorName), err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputNodesCreateStartObjVS")
    CALL EXITS("CMISSFieldML_InputCreateMeshComponentNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputCreateMeshComponentNumberC",err,error)
    CALL EXITS("CMISSFieldML_InputCreateMeshComponentNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputCreateMeshComponentNumberC

  !
  !================================================================================================================================
  !

  !> Create a field using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputFieldCreateStartObjVS( fieldml, region, decomposition, fieldNumber, field, variableType, &
    & evaluatorName, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(CMISSRegionType), INTENT(IN) :: region !< The region in which the field is to be created.
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !< The decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !< On return, the newly created field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_InputFieldCreateStartObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region%REGION, decomposition%DECOMPOSITION, fieldNumber, &
      & field%FIELD, variableType, evaluatorName, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputFieldCreateStartObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputFieldCreateStartObjVS",err,error)
    CALL EXITS("CMISSFieldML_InputFieldCreateStartObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputFieldCreateStartObjVS

  !
  !================================================================================================================================
  !

  !> Create a field with the given user number using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputFieldCreateStartNumberVS( fieldml, regionNumber, meshNumber, decompositionNumber, fieldNumber, &
    & variableType, evaluatorName, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the field.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: decompositionNumber !< The user number of the decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldML_InputFieldCreateStartNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )
    CALL DECOMPOSITION_USER_NUMBER_TO_DECOMPOSITION( decompositionNumber, mesh, decomposition, err, error, *999 )

    NULLIFY( field )
    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region, decomposition, fieldNumber, field, variableType, &
      & evaluatorName, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputFieldCreateStartNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputFieldCreateStartNumberVS",err,error)
    CALL EXITS("CMISSFieldML_InputFieldCreateStartNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputFieldCreateStartNumberVS

  !
  !================================================================================================================================
  !

  !> Create a field using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputFieldCreateStartObjC( fieldml, region, decomposition, fieldNumber, field, variableType, &
    & evaluatorName, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(CMISSRegionType), INTENT(IN) :: region !< The region in which the field is to be created.
    TYPE(CMISSDecompositionType), INTENT(IN) :: decomposition !< The decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !< On return, the newly created field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_InputFieldCreateStartObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region%REGION, decomposition%DECOMPOSITION, fieldNumber, &
      & field%FIELD, variableType, var_str(evaluatorName), err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputFieldCreateStartObjC")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputFieldCreateStartObjC",err,error)
    CALL EXITS("CMISSFieldML_InputFieldCreateStartObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputFieldCreateStartObjC

  !
  !================================================================================================================================
  !

  !> Create a field with the given user number using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputFieldCreateStartNumberC( fieldml, regionNumber, meshNumber, decompositionNumber, fieldNumber, &
    & variableType, evaluatorName, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region in which to create the field.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: decompositionNumber !< The user number of the decomposition to use when creating the field.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number to assign to the new field.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to create the field from.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh
    TYPE(DECOMPOSITION_TYPE), POINTER :: decomposition
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldML_InputFieldCreateStartNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )
    CALL DECOMPOSITION_USER_NUMBER_TO_DECOMPOSITION( decompositionNumber, mesh, decomposition, err, error, *999 )

    NULLIFY( field )
    CALL FIELDML_INPUT_FIELD_CREATE_START( fieldml%fieldmlInfo, region, decomposition, fieldNumber, field, variableType, &
      & var_str(evaluatorName), err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputFieldCreateStartNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputFieldCreateStartNumberC",err,error)
    CALL EXITS("CMISSFieldML_InputFieldCreateStartNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputFieldCreateStartNumberC

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of the given field, using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputFieldParametersUpdateObjVS( fieldml, field, evaluatorName, variableType, &
    & setType, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !< On return, the field object.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_InputFieldParametersUpdateObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, evaluatorName, field%FIELD, variableType, &
      &  setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputFieldParametersUpdateObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputFieldParametersUpdateObjVS",err,error)
    CALL EXITS("CMISSFieldML_InputFieldParametersUpdateObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputFieldParametersUpdateObjVS

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of field with the given user number, using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputFieldParametersUpdateNumberVS( fieldml, regionNumber, fieldNumber, &
    & evaluatorName, variableType, setType, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region of the field for which parameters are to be updated.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field for which parameters are to be updated.
    TYPE(VARYING_STRING), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldML_InputFieldParametersUpdateNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, evaluatorName, field, variableType, setType, &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputFieldParametersUpdateNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputFieldParametersUpdateNumberVS",err,error)
    CALL EXITS("CMISSFieldML_InputFieldParametersUpdateNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputFieldParametersUpdateNumberVS

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of the given field, using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputFieldParametersUpdateObjC( fieldml, field, evaluatorName, &
    & variableType, setType, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(CMISSFieldType), INTENT(INOUT) :: field !< On return, the field object.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_InputFieldParametersUpdateObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, var_str(evaluatorName), field%FIELD, variableType, &
      & setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputFieldParametersUpdateObjC")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputFieldParametersUpdateObjC",err,error)
    CALL EXITS("CMISSFieldML_InputFieldParametersUpdateObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputFieldParametersUpdateObjC

  !
  !================================================================================================================================
  !

  !> Update the DOF parameters of field with the given user number, using the given FieldML evaluator.
  SUBROUTINE CMISSFieldML_InputFieldParametersUpdateNumberC( fieldml, regionNumber, fieldNumber, &
    & evaluatorName, variableType, setType, err )
    !Arguments
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region of the field for which parameters are to be updated.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field for which parameters are to be updated.
    CHARACTER(LEN=*), INTENT(IN) :: evaluatorName !< The name of the argument evaluator to get the parameters from.
    INTEGER(INTG), INTENT(IN) :: variableType !<The OpenCMISS variable type.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Local variables
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldML_InputFieldParametersUpdateNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_INPUT_FIELD_PARAMETERS_UPDATE( fieldml%fieldmlInfo, var_str(evaluatorName), field, variableType, &
      & setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_InputFieldParametersUpdateNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldML_InputFieldParametersUpdateNumberC",err,error)
    CALL EXITS("CMISSFieldML_InputFieldParametersUpdateNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_InputFieldParametersUpdateNumberC

  !
  !================================================================================================================================
  !

  !> Write the FieldML document managed by the given context to a file with the given name.
  SUBROUTINE CMISSFieldML_OutputWriteVS( fieldml, filename, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: filename !< The name of the file to write the FieldML document to.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_OutputWriteVS",err,error,*999)

#ifdef USEFIELDML

    IF( .NOT. fieldml%fieldmlInfo%IS_OUT ) THEN
      CALL FLAG_ERROR( "Inbound FieldML handle used four an output-only operation.", ERR, error, *999 )
    END IF

    CALL FIELDML_OUTPUT_WRITE( fieldml%fieldmlInfo, filename, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputWriteVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputWriteVS",err,error)
    CALL EXITS("CMISSFieldML_OutputWriteVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputWriteVS

  !
  !================================================================================================================================
  !

  !> Write the FieldML document managed by the given context to a file with the given name.
  SUBROUTINE CMISSFieldML_OutputWriteC( fieldml, filename, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: filename !< The name of the file to write the FieldML document to.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_OutputWriteC",err,error,*999)

#ifdef USEFIELDML

    IF( .NOT. fieldml%fieldmlInfo%IS_OUT ) THEN
      CALL FLAG_ERROR( "Inbound FieldML handle used four an output-only operation.", ERR, error, *999 )
    END IF

    CALL FIELDML_OUTPUT_WRITE( fieldml%fieldmlInfo, var_str(filename), err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputWriteC")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputWriteC",err,error)
    CALL EXITS("CMISSFieldML_OutputWriteC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputWriteC

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE CMISSFieldML_OutputAddFieldNoTypeObjVS( fieldml, baseName, dofFormat, field, variableType, setType, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(CMISSFieldType), INTENT(IN) :: field !< The field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_OutputAddFieldNoTypeObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field%FIELD, variableType, setType, &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputAddFieldNoTypeObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputAddFieldNoTypeObjVS",err,error)
    CALL EXITS("CMISSFieldML_OutputAddFieldNoTypeObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputAddFieldNoTypeObjVS

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE CMISSFieldML_OutputAddFieldNoTypeNumberVS( fieldml, baseName, dofFormat, regionNumber, fieldNumber, &
    & variableType, setType, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region containing the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldML_OutputAddFieldNoTypeNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field, variableType, setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputAddFieldNoTypeNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputAddFieldNoTypeNumberVS",err,error)
    CALL EXITS("CMISSFieldML_OutputAddFieldNoTypeNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputAddFieldNoTypeNumberVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE CMISSFieldML_OutputAddFieldWithTypeObjVS( fieldml, baseName, dofFormat, field, variableType, setType, typeHandle, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(CMISSFieldType), INTENT(IN) :: field !< The field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_OutputAddFieldWithTypeObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field%FIELD, variableType, setType, typeHandle, &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputAddFieldWithTypeObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputAddFieldWithTypeObjVS",err,error)
    CALL EXITS("CMISSFieldML_OutputAddFieldWithTypeObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputAddFieldWithTypeObjVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE CMISSFieldML_OutputAddFieldWithTypeNumberVS( fieldml, baseName, dofFormat, regionNumber, fieldNumber, &
    & variableType, setType, typeHandle, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldML_OutputAddFieldWithTypeNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, baseName, dofFormat, field, variableType, setType, typeHandle, &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputAddFieldWithTypeNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputAddFieldWithTypeNumberVS",err,error)
    CALL EXITS("CMISSFieldML_OutputAddFieldWithTypeNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputAddFieldWithTypeNumberVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE CMISSFieldML_OutputAddFieldNoTypeObjC( fieldml, baseName, dofFormat, field, variableType, setType, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(CMISSFieldType), INTENT(IN) :: field !< The field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_OutputAddFieldNoTypeObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field%FIELD, variableType, &
      & setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputAddFieldNoTypeObjC")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputAddFieldNoTypeObjC",err,error)
    CALL EXITS("CMISSFieldML_OutputAddFieldNoTypeObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputAddFieldNoTypeObjC

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the given FieldML context. The FieldML type will be inferred.
  SUBROUTINE CMISSFieldML_OutputAddFieldNoTypeNumberC( fieldml, baseName, dofFormat, regionNumber, fieldNumber, &
    & variableType, setType, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region containing the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldML_OutputAddFieldNoTypeNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field, variableType, &
      & setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputAddFieldNoTypeNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputAddFieldNoTypeNumberC",err,error)
    CALL EXITS("CMISSFieldML_OutputAddFieldNoTypeNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputAddFieldNoTypeNumberC

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE CMISSFieldML_OutputAddFieldWithTypeObjC( fieldml, baseName, dofFormat, field, variableType, setType, typeHandle, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(CMISSFieldType), INTENT(IN) :: field !< The field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_OutputAddFieldWithTypeObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field%FIELD, variableType, &
      & typeHandle, setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputAddFieldWithTypeObjC")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputAddFieldWithTypeObjC",err,error)
    CALL EXITS("CMISSFieldML_OutputAddFieldWithTypeObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputAddFieldWithTypeObjC

  !
  !================================================================================================================================
  !

  !> Add the given field to the given FieldML context, using the given FieldML type.
  SUBROUTINE CMISSFieldML_OutputAddFieldWithTypeNumberC( fieldml, baseName, dofFormat, regionNumber, fieldNumber, &
    & variableType, setType, typeHandle, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldML_OutputAddFieldWithTypeNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD( fieldml%fieldmlInfo, var_str(baseName), var_str(dofFormat), field, variableType, &
      & setType, typeHandle, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputAddFieldWithTypeNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputAddFieldWithTypeNumberC",err,error)
    CALL EXITS("CMISSFieldML_OutputAddFieldWithTypeNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputAddFieldWithTypeNumberC

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given mesh.
  SUBROUTINE CMISSFieldML_OutputCreateObjVS( mesh, location, baseName, connectivityFormat, fieldml, err )
    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !< The mesh to use when initialising the FieldML context.
    TYPE(VARYING_STRING), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_OutputCreateObjVS",err,error,*999)

#ifdef USEFIELDML

    ALLOCATE( fieldml%fieldmlInfo, stat=err )
    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh%MESH, location, baseName, connectivityFormat, fieldml%fieldmlInfo, &
      & err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputCreateObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputCreateObjVS",err,error)
    CALL EXITS("CMISSFieldML_OutputCreateObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputCreateObjVS

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the mesh with the given user number.
  SUBROUTINE CMISSFieldML_OutputCreateNumberVS( regionNumber, meshNumber, location, baseName, connectivityFormat, fieldml, err )
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the mesh to use when initialising the FieldML context.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when initialising the FieldML context.
    TYPE(VARYING_STRING), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    CALL ENTERS("CMISSFieldML_OutputCreateNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )

    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh, location, baseName, connectivityFormat, fieldml%fieldmlInfo, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputCreateNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputCreateNumberVS",err,error)
    CALL EXITS("CMISSFieldML_OutputCreateNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputCreateNumberVS

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the given mesh.
  SUBROUTINE CMISSFieldML_OutputCreateObjC( mesh, location, baseName, connectivityFormat, fieldml, err )
    !Argument variables
    TYPE(CMISSMeshType), INTENT(IN) :: mesh !< The mesh to use when initialising the FieldML context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_OutputCreateObjC",err,error,*999)

#ifdef USEFIELDML

    ALLOCATE( fieldml%fieldmlInfo, stat=err )
    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh%MESH, var_str(location), var_str(baseName), var_str(connectivityFormat), &
      & fieldml%fieldmlInfo, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputCreateObjC")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputCreateObjC",err,error)
    CALL EXITS("CMISSFieldML_OutputCreateObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputCreateObjC

  !
  !================================================================================================================================
  !

  !> Initialise the given FieldML context using the mesh with the given user number.
  SUBROUTINE CMISSFieldML_OutputCreateNumberC( regionNumber, meshNumber, location, baseName, connectivityFormat, fieldml, err )
    !Argument variables
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the mesh to use when initialising the FieldML context.
    INTEGER(INTG), INTENT(IN) :: meshNumber !< The user number of the mesh to use when initialising the FieldML context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: location !< The root directory in which associated data files should be created.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: connectivityFormat !<The name of the format to use when writing connectivity data.
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(MESH_TYPE), POINTER :: mesh

    CALL ENTERS("CMISSFieldML_OutputCreateNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL MESH_USER_NUMBER_TO_MESH( meshNumber, region, mesh, err, error, *999 )

    CALL FIELDML_OUTPUT_INITIALISE_INFO( mesh, var_str(location), var_str(baseName), var_str(connectivityFormat), &
      & fieldml%fieldmlInfo, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputCreateNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputCreateNumberC",err,error)
    CALL EXITS("CMISSFieldML_OutputCreateNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputCreateNumberC

  !
  !================================================================================================================================
  !

  !> Add the given field to the current FieldML context, only including the given components.
  SUBROUTINE CMISSFieldML_OutputAddFieldComponentsObjVS( fieldml, typeHandle, baseName, dofFormat, field, fieldComponentNumbers, &
    & variableType, setType, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(CMISSFieldType), INTENT(IN) :: field !< The field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:)
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_OutputAddFieldComponentsObjVS",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, baseName, dofFormat, field%FIELD, &
      & fieldComponentNumbers, variableType, setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputAddFieldComponentsObjVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputAddFieldComponentsObjVS",err,error)
    CALL EXITS("CMISSFieldML_OutputAddFieldComponentsObjVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputAddFieldComponentsObjVS

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the current FieldML context, only including the given components.
  SUBROUTINE CMISSFieldML_OutputAddFieldComponentsNumberVS( fieldml, typeHandle, baseName, dofFormat, regionNumber, &
    & fieldNumber, fieldComponentNumbers, variableType, setType, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    TYPE(VARYING_STRING), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    TYPE(VARYING_STRING), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:) !< The component numbers to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldML_OutputAddFieldComponentsNumberVS",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, baseName, dofFormat, field, fieldComponentNumbers,&
      & variableType, setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputAddFieldComponentsNumberVS")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputAddFieldComponentsNumberVS",err,error)
    CALL EXITS("CMISSFieldML_OutputAddFieldComponentsNumberVS")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputAddFieldComponentsNumberVS

  !
  !================================================================================================================================
  !

  !> Add the given field to the current FieldML context, only including the given components.
  SUBROUTINE CMISSFieldML_OutputAddFieldComponentsObjC( fieldml, typeHandle, baseName, dofFormat, field, fieldComponentNumbers, &
    & variableType, setType, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    TYPE(CMISSFieldType), INTENT(IN) :: field !< The field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:)
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    CALL ENTERS("CMISSFieldML_OutputAddFieldComponentsObjC",err,error,*999)

#ifdef USEFIELDML

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, var_str(baseName), var_str(dofFormat), &
      & field%FIELD, fieldComponentNumbers, variableType, setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputAddFieldComponentsObjC")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputAddFieldComponentsObjC",err,error)
    CALL EXITS("CMISSFieldML_OutputAddFieldComponentsObjC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputAddFieldComponentsObjC

  !
  !================================================================================================================================
  !

  !> Add the field with the given user number to the current FieldML context, only including the given components.
  SUBROUTINE CMISSFieldML_OutputAddFieldComponentsNumberC( fieldml, typeHandle, baseName, dofFormat, regionNumber, &
    & fieldNumber, fieldComponentNumbers, variableType, setType, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    INTEGER(INTG), INTENT(IN) :: typeHandle !< The FieldML type to assign to the new FieldML field.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: baseName !< The prefix to use when naming automatically created FieldML objects in the context.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: dofFormat !<The name of the format to use when writing dof data.
    INTEGER(INTG), INTENT(IN) :: regionNumber !< The user number of the region owning the field to add.
    INTEGER(INTG), INTENT(IN) :: fieldNumber !< The user number of the field whose components are to be added.
    INTEGER(INTG), INTENT(IN) :: fieldComponentNumbers(:) !< The component numbers to add.
    INTEGER(INTG), INTENT(IN) :: variableType !< The variable type of the field to add to the FieldML context.
    INTEGER(INTG), INTENT(IN) :: setType !<The parameter set type.
    INTEGER(INTG), INTENT(OUT) :: err !< The error code.

    !Locals
    TYPE(REGION_TYPE), POINTER :: region
    TYPE(FIELD_TYPE), POINTER :: field

    CALL ENTERS("CMISSFieldML_OutputAddFieldComponentsNumberC",err,error,*999)

#ifdef USEFIELDML

    CALL REGION_USER_NUMBER_TO_REGION( regionNumber, region, err, error, *999 )
    CALL FIELD_USER_NUMBER_TO_FIELD( fieldNumber, region, field, err, error, *999 )

    CALL FIELDML_OUTPUT_ADD_FIELD_COMPONENTS( fieldml%fieldmlInfo, typeHandle, var_str(baseName), var_str(dofFormat), &
      & field, fieldComponentNumbers, variableType, setType, err, error, *999 )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputAddFieldComponentsNumberC")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputAddFieldComponentsNumberC",err,error)
    CALL EXITS("CMISSFieldML_OutputAddFieldComponentsNumberC")
    CALL CMISS_HANDLE_ERROR(err,error)
    RETURN

  END SUBROUTINE CMISSFieldML_OutputAddFieldComponentsNumberC

  !
  !================================================================================================================================
  !

  !>Import a FieldML object from the library into the current session.
  SUBROUTINE CMISSFieldML_OutputAddImport( fieldml, name, handle, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(IN) :: fieldml !< The FieldML context containing the evaluator to use.
    CHARACTER(KIND=C_CHAR,LEN=*), INTENT(IN) :: name !< The name of the object to import.
    INTEGER(INTG), INTENT(OUT) :: handle !< A handle to the newly imported FieldML object.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    !Locals
    TYPE(VARYING_STRING) :: stringName

    CALL ENTERS("CMISSFieldML_OutputAddImport",err,error,*999)

#ifdef USEFIELDML

    stringName = name

    handle = FIELDML_OUTPUT_IMPORT( fieldml%fieldmlInfo, stringName, err, error )
    IF(err/=0) GOTO 999

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldML_OutputAddImport")
    RETURN
999 CALL ERRORS("CMISSFieldML_OutputAddImport",err,error)
    CALL EXITS("CMISSFieldML_OutputAddImport")
    CALL CMISS_HANDLE_ERROR( err, error )
    RETURN

  END SUBROUTINE CMISSFieldML_OutputAddImport

  !
  !================================================================================================================================
  !

  !>Finalises a Fieldml context.
  SUBROUTINE CMISSFieldMLIO_Finalise( fieldml, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(OUT) :: fieldml !< The FieldML context to finalise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL ENTERS("CMISSFieldMLIO_Finalise", err, error, *999 )

#ifdef USEFIELDML

    CALL FIELDML_IO_FINALISE( fieldml%fieldmlInfo, err, error, *999  )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLIO_Finalise")
    RETURN
999 CALL ERRORS("CMISSFieldMLIO_Finalise",err,error)
    CALL EXITS("CMISSFieldMLIO_Finalise")
    CALL CMISS_HANDLE_ERROR( err, error )
    RETURN

  END SUBROUTINE CMISSFieldMLIO_Finalise

  !
  !================================================================================================================================
  !

  !>Initialises a Fieldml context.
  SUBROUTINE CMISSFieldMLIO_Initialise( fieldml, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(OUT) :: fieldml !< The FieldML context to initialise.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL ENTERS("CMISSFieldMLIO_Initialise", err, error, *999 )

#ifdef USEFIELDML

    NULLIFY( fieldml%fieldmlInfo )

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLIO_Initialise")
    RETURN
999 CALL ERRORS("CMISSFieldMLIO_Initialise",err,error)
    CALL EXITS("CMISSFieldMLIO_Initialise")
    CALL CMISS_HANDLE_ERROR( err, error )
    RETURN

  END SUBROUTINE CMISSFieldMLIO_Initialise

  !
  !================================================================================================================================
  !

  !>Get the session handle from a Fieldml context.
  SUBROUTINE CMISSFieldMLIO_GetSession( fieldml, sessionHandle, err )
    !Argument variables
    TYPE(CMISSFieldMLIOType), INTENT(INOUT) :: fieldml !< The FieldML context whose session handle is to be returned.
    INTEGER(INTG), INTENT(OUT) :: sessionHandle !<The session handle.
    INTEGER(INTG), INTENT(OUT) :: err !<The error code.

    CALL ENTERS("CMISSFieldMLIO_GetSession", err, error, *999 )

#ifdef USEFIELDML

    sessionHandle = fieldml%fieldmlInfo%FML_HANDLE

#else
    CALL FLAG_ERROR("Must compile with USEFIELDML=true to use FieldML functionality.",ERR,error,*999)
#endif

    CALL EXITS("CMISSFieldMLIO_GetSession")
    RETURN
999 CALL ERRORS("CMISSFieldMLIO_GetSession",err,error)
    CALL EXITS("CMISSFieldMLIO_GetSession")
    CALL CMISS_HANDLE_ERROR( err, error )
    RETURN

  END SUBROUTINE CMISSFieldMLIO_GetSession

  !
  !================================================================================================================================
  !


END MODULE OPENCMISS

